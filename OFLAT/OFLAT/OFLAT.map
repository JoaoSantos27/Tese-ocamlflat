{"version":3,"file":"OFLAT/OFLAT.js","sections":[{"offset":{"line":2,"column":0},"map":{"version":3,"file":"OFLAT/OFLAT.js","sources":["/builtin/blackbox.ml","/mnt/c/Users/Joao Bernardo/Documents/.Uni Stuff/Tese/oflat/OFLAT/GraphLibrary.js","/builtin/+array.js","/builtin/+mlBytes.js","/builtin/+sys.js","/builtin/+backtrace.js","/builtin/+stdlib.js","/builtin/+jslib.js","/builtin/+fail.js","/builtin/+int64.js","/builtin/+ieee_754.js","/builtin/+obj.js","/builtin/+bigarray.js","/builtin/+ints.js","/builtin/+hash.js","/builtin/+marshal.js","/builtin/+compare.js","/builtin/+format.js","/builtin/+fs_node.js","/builtin/+fs.js","/builtin/+unix.js","/builtin/+fs_fake.js","/builtin/+jslib_js_of_ocaml.js","/builtin/+md5.js","/builtin/+io.js","/usr/lib/ocaml/camlinternalFormatBasics.ml","/usr/lib/ocaml/camlinternalAtomic.ml","/usr/lib/ocaml/stdlib.ml","/usr/lib/ocaml/option.ml","/usr/lib/ocaml/bool.ml","/usr/lib/ocaml/char.ml","/usr/lib/ocaml/list.ml","/usr/lib/ocaml/int.ml","/usr/lib/ocaml/bytes.ml","/usr/lib/ocaml/string.ml","/usr/lib/ocaml/obj.ml","/usr/lib/ocaml/array.ml","/usr/lib/ocaml/set.ml","/usr/lib/ocaml/map.ml","/usr/lib/ocaml/stack.ml","/usr/lib/ocaml/queue.ml","/usr/lib/ocaml/camlinternalLazy.ml","/usr/lib/ocaml/buffer.ml","/usr/lib/ocaml/camlinternalFormat.ml","/usr/lib/ocaml/printf.ml","/usr/lib/ocaml/printexc.ml","/usr/lib/ocaml/digest.ml","/usr/lib/ocaml/random.ml","/usr/lib/ocaml/hashtbl.ml","/usr/lib/ocaml/format.ml","/usr/lib/ocaml/callback.ml","/usr/lib/ocaml/camlinternalOO.ml","/home/joaob/.opam/default/lib/js_of_ocaml-compiler/runtime/jsoo_runtime.ml","/home/joaob/.opam/default/lib/js_of_ocaml/js.ml","/home/joaob/.opam/default/lib/js_of_ocaml/dom.ml","/home/joaob/.opam/default/lib/js_of_ocaml/dom_html.ml","/home/joaob/.opam/default/lib/js_of_ocaml/console.ml","/home/joaob/.opam/default/lib/lwt/lwt_sequence.ml","/home/joaob/.opam/default/lib/lwt/lwt.ml","/home/joaob/.opam/default/lib/js_of_ocaml-lwt/lwt_js.ml","/home/joaob/.opam/default/lib/re/bit_vector.ml","/home/joaob/.opam/default/lib/re/category.ml","/home/joaob/.opam/default/lib/re/dense_map.ml","/home/joaob/.opam/default/lib/re/import.ml","/home/joaob/.opam/default/lib/re/cset.ml","/home/joaob/.opam/default/lib/re/hash_set.ml","/home/joaob/.opam/default/lib/re/mark_infos.ml","/home/joaob/.opam/default/lib/re/mutex.ml","/home/joaob/.opam/default/lib/re/pmark.ml","/home/joaob/.opam/default/lib/re/automata.ml","/home/joaob/.opam/default/lib/re/color_map.ml","/home/joaob/.opam/default/lib/re/ast.ml","/home/joaob/.opam/default/lib/re/group.ml","/home/joaob/.opam/default/lib/re/compile.ml","/home/joaob/.opam/default/lib/re/core.ml","/home/joaob/.opam/default/lib/re/domain.ml","/home/joaob/.opam/default/lib/re/parse_buffer.ml","/home/joaob/.opam/default/lib/re/emacs.ml","/home/joaob/.opam/default/lib/re/str.ml","/run/user/1000/RAMDISK/obj/OCamlFlat.ml","/run/user/1000/RAMDISK/obj/Lang.ml","/run/user/1000/RAMDISK/obj/JS.ml","/run/user/1000/RAMDISK/obj/ViewUtil.ml","/run/user/1000/RAMDISK/obj/Listeners.ml","/run/user/1000/RAMDISK/obj/Cytoscape.ml","/run/user/1000/RAMDISK/obj/AutomatonView.ml","/run/user/1000/RAMDISK/obj/FiniteAutomatonView.ml","/run/user/1000/RAMDISK/obj/RegularExpressionView.ml","/run/user/1000/RAMDISK/obj/StateVariables.ml","/run/user/1000/RAMDISK/obj/ContextFreeGrammarLL1View.ml","/run/user/1000/RAMDISK/obj/ContextFreeGrammarLRView.ml","/run/user/1000/RAMDISK/obj/ContextFreeGrammarView.ml","/run/user/1000/RAMDISK/obj/PushdownAutomatonView.ml","/run/user/1000/RAMDISK/obj/TuringMachineView.ml","/run/user/1000/RAMDISK/obj/CompositionView.ml","/run/user/1000/RAMDISK/obj/GrammarView.ml","/run/user/1000/RAMDISK/obj/HtmlPageClient.ml","/run/user/1000/RAMDISK/obj/Controller.ml","/run/user/1000/RAMDISK/obj/AutomatonController.ml","/run/user/1000/RAMDISK/obj/FiniteAutomatonController.ml","/run/user/1000/RAMDISK/obj/RegularExpressionController.ml","/run/user/1000/RAMDISK/obj/ContextFreeGrammarController.ml","/run/user/1000/RAMDISK/obj/PushdownAutomatonController.ml","/run/user/1000/RAMDISK/obj/TuringMachineController.ml","/run/user/1000/RAMDISK/obj/ExerciseController.ml","/run/user/1000/RAMDISK/obj/GrammarController.ml","/run/user/1000/RAMDISK/obj/CompositionController.ml","/run/user/1000/RAMDISK/obj/ControllerListeners.ml","/run/user/1000/RAMDISK/obj/Calling.ml","/usr/lib/ocaml/std_exit.ml"],"sourcesContent":["(* generated code *)","// /*\n//  * OFLAT/GraphLibrary.js\n//  *\n//  * This file is part of the OFLAT app\n//  *\n//  * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\n//  * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\n//  *\n//  * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\n//  * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\n//  *\n//  * This software is distributed under the terms of the GPLv3 license.\n//  * See the included LICENSE file for details.\n//  *\n//  *  Written by Rita Macedo\n//  */\n\n// /*var number = 0;\n\n// var cy = null;\n// var cy2 = null;\n// var direction = null;\n\n// var layoutDir = null;\n\n// function doAction (automaton){\n//   bc.postMessage(automaton);\n// }\n\n//function onComplete (event, sourceNode, targetNode, addedEles) {\n//       //let a = arguments;\n//        //var theSource = a[2].id();\n//  //     var theTarget = targetNode.id();\n//  //     var ele = addedEles.id();\n//  //     var symb = prompt(textEnterTransition (), \"c\");\n//  //     var getEdge = cy.getElementById(ele);\n//  //     getEdge.remove();\n//  //     jscode.m7 (theSource, theTarget, symb);\n//    console.log (\"test\");\n//  }\n//  \n//function onComplete2 () {\n//  console.log (\"newww\");\n//}\n\n//function setUpListener () {\n//  cy.on('ehcomplete', onComplete);\n//}\n\n//function setUpListener2 () {\n//  cy.on('ehcomplete', onComplete2);\n//}\n\n//// /* -------------------- Language -------------------- */\n\n var language = 'en';\n\n function changeLanguage (lang) {\n   language = lang;\n  // if (cy != null) {\n  //   cy.reset ();\n   //}\n }\n\n// function textRemove () {\n//   if (language == \"en\") {\n//     return 'Remove'\n//   } else if (language == \"pt\") {\n//     return 'Remover'\n//   } else if (language == \"fr\") {\n//     return 'Supprimer'\n//   } else {\n//     return 'Remove'\n//   }\n// }\n\n// function textAdd () {\n//   if (language == \"en\") {\n//     return 'Add state'\n//   } else if (language == \"pt\") {\n//     return 'Adicionar estado'\n//   } else if (language == \"fr\") {\n//     return 'Ajouter un état'\n//   } else {\n//     return 'Add state'\n//   }\n// }\n\n// function textAddInitial () {\n//   if (language == \"en\") {\n//     return 'Add initial state'\n//   } else if (language == \"pt\") {\n//     return 'Adicionar estado inicial'\n//   } else if (language == \"fr\") {\n//     return 'Ajouter un état initial'\n//   } else {\n//     return 'Add initial state'\n//   }\n// }\n\n// function textAddFinal () {\n//   if (language == \"en\") {\n//     return 'Add final state'\n//   } else if (language == \"pt\") {\n//     return 'Adicionar estado final'\n//   } else if (language == \"fr\") {\n//     return \"Ajouter l'état final\"\n//   } else {\n//     return 'Add final state'\n//   }\n// }\n\n// function textAddTransition () {\n//   if (language == \"en\") {\n//     return 'Add transition'\n//   } else if (language == \"pt\") {\n//     return 'Adicionar transição'\n//   } else if (language == \"fr\") {\n//     return \"Ajouter une transition\"\n//   } else {\n//     return 'Add transition'\n//   }\n// }\n\n// function textTurnFinal () {\n//   if (language == \"en\") {\n//     return 'Make final'\n//   } else if (language == \"pt\") {\n//     return 'Tornar final'\n//   } else if (language == \"fr\") {\n//     return \"Rendre définitif\"\n//   } else {\n//     return 'Make final'\n//   }\n// }\n\n// function textRemoveFinal () {\n//   if (language == \"en\") {\n//     return 'Remove final'\n//   } else if (language == \"pt\") {\n//     return 'Remover final'\n//   } else if (language == \"fr\") {\n//     return \"Supprimer la finale\"\n//   } else {\n//     return 'Remove final'\n//   }\n// }\n\n// function textTurnInitial () {\n//   if (language == \"en\") {\n//     return 'Make initial'\n//   } else if (language == \"pt\") {\n//     return 'Tornar inicial'\n//   } else if (language == \"fr\") {\n//     return \"Faire initiale\"\n//   } else {\n//     return 'Make initial'\n//   }\n// }\n\n// function textEnterState () {\n//   if (language == \"en\") {\n//     return 'Please enter the state name'\n//   } else if (language == \"pt\") {\n//     return 'Por favor indique o nome do estado'\n//   } else if (language == \"fr\") {\n//     return \"Veuillez saisir le nom de l'état\"\n//   } else {\n//     return 'Please enter the state name'\n//   }\n// }\n\n// function textEnterStartState () {\n//   if (language == \"en\") {\n//     return 'Please enter the start state'\n//   } else if (language == \"pt\") {\n//     return 'Por favor indique o nome do estado de partida'\n//   } else if (language == \"fr\") {\n//     return \"Veuillez saisir l'état de départ\"\n//   } else {\n//     return 'Please enter the start state'\n//   }\n// }\n\n// function textEnterTransition () {\n//   if (language == \"en\") {\n//     return 'Please enter the transition symbol'\n//   } else if (language == \"pt\") {\n//     return 'Por favor indique o simbolo da transição'\n//   } else if (language == \"fr\") {\n//     return \"Veuillez saisir le symbole de transition\"\n//   } else {\n//     return 'Please enter the transition symbol'\n//   }\n// }\n\n// function textEnterEndState () {\n//   if (language == \"en\") {\n//     return 'Please enter the end state'\n//   } else if (language == \"pt\") {\n//     return 'Por favor indique o estado de chegada'\n//   } else if (language == \"fr\") {\n//     return \"Veuillez saisir l'état final\"\n//   } else {\n//     return 'Please enter the end state'\n//   }\n// }\n\n// /* -------------------- Automatos -------------------- */\n\n// function start () {\n\n//   var cy = window.cy = cytoscape({\n//     container: document.getElementById('cy'),\n//     layout: {\n//       name: 'grid',\n//       rows: 2,\n//       cols: 2\n//     },\n//     style: [\n//       {\n//         selector: 'node[name]',\n//         style: {\n//           'content': 'data(name)',\n//           'width': '40px',\n//           'height': '40px',\n//           'text-valign': 'bottom',\n//           'text-halign': 'center'\n//         }\n//       },\n//       {\n//         selector: 'edge[symbol]',\n//         style: {\n//           'content': 'data(symbol)'\n//         }\n//       },\n//       {\n//         selector: 'edge',\n//         style: {\n//           'curve-style': 'bezier',\n//           'target-arrow-shape': 'triangle'\n//         }\n//       },\n//     {\n//       selector: '#transparent',\n//       style: {\n//         'visibility': 'hidden'\n//       }\n//     },\n//     {\n//       selector: '.SUCCESS',\n//       style: {\n//         'border-width': '7px',\n//         'border-color': 'black',\n//         'border-style': 'double'\n//       }\n//     },\n//     // some style for the extension\n\n//     {\n//       selector: '.eh-handle',\n//       style: {\n//         'background-color': 'red',\n//         'width': 12,\n//         'height': 12,\n//         'shape': 'ellipse',\n//         'overlay-opacity': 0,\n//         'border-width': 12, // makes the handle easier to hit\n//         'border-opacity': 0\n//       }\n//     },\n\n//     {\n//       selector: '.eh-hover',\n//       style: {\n//         'background-color': 'red'\n//       }\n//     },\n\n//     {\n//       selector: '.eh-source',\n//       style: {\n//         'border-width': 2,\n//         'border-color': 'red'\n//       }\n//     },\n\n//     {\n//       selector: '.eh-target',\n//       style: {\n//         'border-width': 2,\n//         'border-color': 'red'\n//       }\n//     },\n\n//     {\n//       selector: '.eh-preview, .eh-ghost-edge',\n//       style: {\n//         'background-color': 'red',\n//         'line-color': 'red',\n//         'target-arrow-color': 'red',\n//         'source-arrow-color': 'red'\n//       }\n//     },\n\n//     {\n//       selector: '.eh-ghost-edge.eh-preview-active',\n//       style: {\n//         'opacity': 0\n//       }\n//     }\n//     ],\n//     elements: {\n//       nodes: [\n//         {data: { id: 'transparent', name: 'transparent' }}\n//       ]\n//     },\n//   });\n//   var eh = cy.edgehandles();\n//   eh.enableDrawMode();\n\n//   function onComplete (event, sourceNode, targetNode, addedEles) {\n//     var theSource = sourceNode.id();\n//     var theTarget = targetNode.id();\n//     var ele = addedEles.id();\n//     var symb = prompt(textEnterTransition (), \"c\");\n//     var getEdge = cy.getElementById(ele);\n//     getEdge.remove();\n//     jscode.m7 (theSource, theTarget, symb);\n//   }\n\n//   cy.on('ehcomplete', onComplete) \n\n//   var defaults = {\n//     menuRadius: function menuRadius(ele) {\n//       return 70;\n//     }, // the radius of the circular menu in pixels\n//     commands: [// an array of commands to list in the menu or a function that returns the array \n//       /*\n//       { // example command\n//         fillColor: 'rgba(200, 200, 200, 0.75)', // optional: custom background color for item\n//         content: 'a command name' // html/text content to be displayed in the menu\n//         contentStyle: {}, // css key:value pairs to set the command's css in js if you want\n//         select: function(ele){ // a function to execute when the command is selected\n//           console.log( ele.id() ) // `ele` holds the reference to the active element\n//         },\n//         enabled: true // whether the command is selectable\n//       }\n//       */\n//     ], // function( ele ){ return [ /*...*/ ] }, // example function for commands\n//     fillColor: 'rgba(0, 0, 48, 0.75)', // the background colour of the menu\n//     activeFillColor: 'rgba(176,190,197, 0.75)', // the colour used to indicate the selected command\n//     activePadding: 20, // additional size in pixels for the active command\n//     indicatorSize: 20, // the size in pixels of the pointer to the active command, will default to the node size if the node size is smaller than the indicator size, \n//     separatorWidth: 3, // the empty spacing in pixels between successive commands\n//     spotlightPadding: 0, // extra spacing in pixels between the element and the spotlight\n//     adaptativeNodeSpotlightRadius: false, // specify whether the spotlight radius should adapt to the node size\n//     minSpotlightRadius: 15, // the minimum radius in pixels of the spotlight (ignored for the node if adaptativeNodeSpotlightRadius is enabled but still used for the edge & background)\n//     maxSpotlightRadius: 25, // the maximum radius in pixels of the spotlight (ignored for the node if adaptativeNodeSpotlightRadius is enabled but still used for the edge & background)\n//     openMenuEvents: 'cxttapstart taphold', // space-separated cytoscape events that will open the menu; only `cxttapstart` and/or `taphold` work here\n//     itemColor: 'white', // the colour of text in the command's content\n//     itemTextShadowColor: 'transparent', // the text shadow colour of the command's content\n//     zIndex: 9999, // the z-index of the ui div\n//     atMouse: false // draw menu at mouse position\n//   };\n\n//   function config (c) {\n//     var empty = {};\n//     var a = Object.assign (empty, defaults);\n//     return Object.assign (a, c);\n//   };\n\n//   var nodeConfig = config ({\n//     selector: 'node', // elements matching this Cytoscape.js selector will trigger cxtmenus\n//     commands: [ \n//       {\n//         content: textRemove (),\n//         select: function (ele) {\n//           var name = ele.id();\n//           jscode.m3 (name);\n//         }\n//       },\n\n//       {\n//         content: textTurnFinal (),\n//         select: function (ele) {\n//           var name = ele.id();\n//           jscode.m15 (name)\n//         }\n//       },\n\n//       {\n//         content: textRemoveFinal (),\n//         select: function (ele) {\n//           var name = ele.id();\n//           jscode.m16 (name)\n//         },\n//       },\n\n//       {\n//         content: textTurnInitial (),\n//         select: function (ele) {\n//           var name = ele.id();\n//           jscode.m6 (name)\n//         }\n//       }\n//     ]\n//   });\n\n//   var menu = cy.cxtmenu(nodeConfig); \n\n//   /* menu = cy.cxtmenu({\n//     selector: 'node',\n\n//     commands: [\n//       {\n//         content: textRemove (),\n//         select: function (event) {\n//           var target = event.target || event.cyTarget;\n//           var name = target.id();\n//           jscode.m3 (name);\n//         }\n//       },\n\n//       {\n//         content: textTurnFinal (),\n//         select: function (event) {\n//           var target = event.target || event.cyTarget;\n//           var name = target.id();\n//           jscode.m15 (name)\n//         }\n//       },\n\n//       {\n//         content: textRemoveFinal (),\n//         select: function (event) {\n//           var target = event.target || event.cyTarget;\n//           var name = target.id();\n//           jscode.m16 (name)\n//         },\n//       },\n\n//       {\n//         content: textTurnInitial (),\n//         select: function (event) {\n//           var target = event.target || event.cyTarget;\n//           var name = target.id();\n//           jscode.m6 (name)\n//         }\n//       }\n//     ], \n//     fillColor: 'rgba(5, 8, 9, 0.75)'\n//   }); */\n\n//   var nodeConfig1 = config({\n//     menuRadius: function menuRadius(ele) {\n//       return 100;\n//     }, // the radius of the circular menu in pixels\n//     selector: 'core',\n\n//     commands: [\n//       {\n//         content: textAdd (),\n//         select: function(ele){\n//           var person = prompt(textEnterState (), \"A\");\n//           jscode.m4 (person);\n        \n//         }\n//       },\n//       {\n//         content: textAddInitial (),\n//         select: function (event) {\n//           var person = prompt(textEnterState (), \"A\");\n//           jscode.m6 (person);\n//         }\n        \n//       },\n//       {\n//         content: textAddFinal (),\n//         select: function (event) {\n\n//           var person = prompt(textEnterState (), \"A\");\n//           jscode.m5 (person);\n//         }\n        \n//       },\n\n//       {\n//         content: textAddTransition (),\n//         select: function (event) {\n//           var person = prompt(textEnterStartState(), \"A\");\n//           var symb = prompt(textEnterTransition (), \"c\");\n//           var state2 = prompt(textEnterEndState (), \"A\");\n//           jscode.m7 (person, state2, symb);\n//         }\n//       }\n//     ]\n//   });\n\n//   var menu2 = cy.cxtmenu(nodeConfig1);\n\n//   var nodeConfig3 = config({\n//     menuRadius: function menuRadius(ele) {\n//       return 55;\n//     }, // the radius of the circular menu in pixels\n//     selector: 'edge',\n\n//     commands: [\n//       {\n//         content: textRemove (),\n//         select: function (ele) {\n//           var name = ele.source().id();\n//           var name2 = ele.target().id();\n//           var s = ele.data('symbol');\n//           jscode.m8 (name, name2, s);\n//         }\n//       }\n//     ]\n//   });\n\n//   var menu3 = cy.cxtmenu(nodeConfig3); \n\n//   cy.autounselectify( false );\n//   cy.$('#transparent').position('y', 200);\n//   cy.$('#transparent').position('x', -200);\n//   cy.$('#transparent').lock();\n\n//   cy.onresize = function(){jscode.m11 ()};\n// };\n\n// window.addEventListener('resize', checkForChanges);\n\n\n// function checkForChanges () {\n//   if (cy != null) {\n//     cy.resize();\n//     cy.fit();\n//   } \n// }\n\n// function turnFinal (name) {\n//   var na = '#' + name;\n//   cy.$(na).classes('SUCCESS');\n// }\n\n// function removeFinal (name) {\n//   var na = '#' + name;\n//   cy.$(na).removeClass('SUCCESS');\n// }\n\n// function makeNode (nm, isStart, final)  {\n//   var  verify = cy.getElementById (nm);\n//   console.log (verify);\n//   if (verify.length < 1) { \n//     if (final == \"true\") {\n//     if (isStart == \"true\") {\n//       cy.add({\n//         data: { id: nm, name: nm }, classes: 'SUCCESS'\n//       });\n//       cy.$('#' + nm).position('y', 200);\n//       cy.$('#' + nm).position('x', -100);\n//       cy.$('#' + nm).lock();\n//       makeEdge ('transparent', nm, '')\n//     } else {\n//         cy.add({\n//           data: { id: nm, name: nm },\n//           position: { x: Math.floor(Math.random() * 1399), y: Math.floor(Math.random() * 299) }, classes: 'SUCCESS'\n//         });\n//     }\n//     } else {\n//       if (isStart == \"true\") {\n//         cy.add({\n//           data: { id: nm, name: nm }\n//         });\n//         cy.$('#' + nm).position('y', 200);\n//         cy.$('#' + nm).position('x', -100);\n//         cy.$('#' + nm).lock();\n//         makeEdge ('transparent', nm, '')\n//       } else {\n//           cy.add({\n//             data: { id: nm, name: nm },\n//             position: { x: Math.floor(Math.random() * 1399), y: Math.floor(Math.random() * 299) }\n//           });\n//       }\n//     }\n//     cy.fit();\n//   }\n// };\n\n// function makeEdge (first, second, third)  {\n\n//   var nId = first + second;\n//   var getEdge = cy.getElementById(nId);\n\n//   if (getEdge.length  == 0) {\n//     cy.add({\n//       data: { id: nId, source: first, symbol: third, target: second }\n//     });\n//   } else {\n//     var k = getEdge.data('symbol');\n//     getEdge.remove();\n//     var newsymbol = k + ', ' + third;\n//     cy.add({\n//       data: { id: nId, source: first, symbol: newsymbol, target: second }\n//     })\n//   }\n// };\n\n// function removeNode (node) {\n//   var getNode = cy.getElementById(node);\n//   getNode.remove();\n// }\n\n// function removeEdge (first, second, third)  {\n\n//   var nId = first + second;\n//   var getEdge = cy.getElementById(nId);\n\n//   var k = getEdge.data('symbol');\n\n//   var g = \"\";\n\n//   for (i = 0; i < k.length; i++) {\n//     var j = k.charAt (i);\n//     if (j != ',' && j != ' ' && j != third) {\n//       if (g.length == 0) {\n//         g = j;\n//       } else {\n//         g = g + ', ' + j;\n//       }\n//     }\n//   }\n//   getEdge.remove();\n//   if (g.length > 0) {\n//     cy.add({\n//       data: { id: nId, source: first, symbol: g, target: second}\n//     })\n//   }\n// };\n\n// function resetStyle () {\n//   cy.style()\n//      .resetToDefault()\n//     .selector ('node[name]')\n//     .style ({'content': 'data(name)',\n//           'width': '40px',\n//           'height': '40px', 'text-valign': 'bottom',\n//           'text-halign': 'center'})\n//     .selector( 'edge[symbol]')\n//     .style ( {\n//                 'content': 'data(symbol)'\n//               })\n//     .selector( 'edge')\n//     .style ({\n//             'curve-style': 'bezier',\n//             'target-arrow-shape': 'triangle'\n//           })\n//     .selector ('.SUCCESS')\n//     .style ({\n//                 'border-width': '10px',\n//                 'border-color': 'black',\n//                 'border-style': 'double'\n//               })\n//     .selector( '#transparent')\n//     .style ({\n//           'visibility': 'hidden'\n//     })\n//     .selector( '.eh-handle')\n//     .style ({\n//       'background-color': 'red',\n//       'width': 12,\n//       'height': 12,\n//       'shape': 'ellipse',\n//       'overlay-opacity': 0,\n//       'border-width': 12, // makes the handle easier to hit\n//       'border-opacity': 0\n//     })\n//     .selector( '.eh-hover')\n//     .style ({\n//       'background-color': 'red'\n//     })\n//     .selector( '.eh-source')\n//     .style ({\n//       'border-width': 2,\n//       'border-color': 'red'\n//     })\n//     .selector( '.eh-target')\n//     .style ({\n//       'border-width': 2,\n//       'border-color': 'red'\n//     })\n//     .selector( '.eh-preview, .eh-ghost-edge')\n//     .style ({\n//       'background-color': 'red',\n//     'line-color': 'red',\n//     'target-arrow-color': 'red',\n//     'source-arrow-color': 'red'\n//     })\n//     .selector('.eh-ghost-edge.eh-preview-active')\n//     .style ({\n//       'opacity': 0\n//     })\n//     .update()\n// }\n\n\n// function paintNode (node, color) {\n//   cy.style ()\n//     .selector('#' + node)\n//     .style ( {\n//       'background-color': color\n//     })\n//     .update()\n// }\n\n// function start2 () {\n//   cy2 = window.cy2 = cytoscape({\n//     container: document.getElementById('cy2'),\n//     layout: {\n//       name: 'grid',\n//       rows: 2,\n//       cols: 2\n//     },\n//     style: [\n//       {\n//         selector: 'node[name]',\n//         style: {\n//           'content': 'data(name)',\n//           'width': '40px',\n//           'height': '40px',\n//           'text-valign': 'bottom',\n//           'text-halign': 'center'\n//         }\n//       },\n//       {\n//         selector: 'edge[symbol]',\n//         style: {\n//           'content': 'data(symbol)'\n//         }\n//       },\n//       {\n//         selector: 'edge',\n//         style: {\n//           'curve-style': 'bezier',\n//           'target-arrow-shape': 'triangle'\n//         }\n//       },\n//     {\n//       selector: '#transparent1',\n//       style: {\n//         'visibility': 'hidden'\n//       }\n//     },\n//     {\n//       selector: '.SUCCESS',\n//       style: {\n//         'border-width': '7px',\n//         'border-color': 'black',\n//         'border-style': 'double'\n//       }\n//   },\n//     ],\n//     elements: {\n//       nodes: [\n//         {data: { id: 'transparent1', name: 'transparent1' }}\n//       ]\n//     }\n//   });\n//   cy2.$('#transparent1').position('y', 200);\n//   cy2.$('#transparent1').position('x', -200);\n//   cy2.$('#transparent1').lock();\n// }\n\n// function makeNode2 (nm, isStart, final)  {\n//   var  verify = cy2.getElementById (nm);\n//   if (verify.length < 1) { \n//     if (final == \"true\") {\n//     if (isStart == \"true\") {\n//       cy2.add({\n//         data: { id: nm, name: nm }, classes: 'SUCCESS'\n//       });\n//       cy2.$('#' + nm).position('y', 200);\n//       cy2.$('#' + nm).position('x', -100);\n//       cy2.$('#' + nm).lock();\n//       makeEdge2 ('transparent1', nm, '')\n//     } else {\n//         cy2.add({\n//           data: { id: nm, name: nm },\n//           position: { x: Math.floor(Math.random() * 1399), y: Math.floor(Math.random() * 299) }, classes: 'SUCCESS'\n//         });\n//     }\n//     } else {\n//       if (isStart == \"true\") {\n//         cy2.add({\n//           data: { id: nm, name: nm }\n//         });\n//         cy2.$('#' + nm).position('y', 200);\n//         cy2.$('#' + nm).position('x', -100);\n//         cy2.$('#' + nm).lock();\n//         makeEdge2 ('transparent1', nm, '')\n//       } else {\n//           cy2.add({\n//             data: { id: nm, name: nm },\n//             position: { x: Math.floor(Math.random() * 1399), y: Math.floor(Math.random() * 299) }\n//           });\n//       }\n//     }\n//     cy2.fit();\n//   }\n// };\n\n// function makeEdge2 (first, second, third)  {\n\n//   var nId = first + second;\n//   var getEdge = cy2.getElementById(nId);\n\n//   if (getEdge.length  == 0) {\n//     cy2.add({\n//       data: { id: nId, source: first, symbol: third, target: second }\n//     });\n//   } else {\n//     var k = getEdge.data('symbol');\n//     getEdge.remove();\n//     var newsymbol = k + ', ' + third;\n//     cy2.add({\n//       data: { id: nId, source: first, symbol: newsymbol, target: second }\n//     })\n//   }\n\n//   cy2.fit();\n// };\n\n// function paintNode1 (node, color) {\n//   cy2.style ()\n//     .selector('#' + node)\n//     .style ( {\n//       'background-color': color\n//     })\n//     .update()\n// }\n\n\n// /* -------------------- Regular Expressions -------------------- */\n\n// var stack = new Array ();\n// var conjunto = [[], []];\n// var counter = 0;\n// var number = 0;\n\n// function makeNewTree (s) {\n//   var index = s.indexOf(\"|\");\n//   var index2 = s.indexOf (\"/\");\n//   var st = \"|\";\n//   if (index > index2) {\n//     index = index2;\n//     st = \"/\";\n//   }\n//   var str = \"\";\n//   var newString = \"\";\n//   if (index != -1) {\n//     str = (s.substring(0, index));\n//     newString = (s.substring(index + 1, s.length));\n//   } \n//   if (st == \"/\") {\n//     stack.pop();\n//   } else {\n//     var newId = \"n\" + number;\n//     if (str.length != 0) {\n//      if (stack.length != 0) {\n//        conjunto[1].push ({data: {source: stack[stack.length-1], target: newId}});\n//      }\n//       conjunto[0].push ({data: {id: newId, name: str}, classes: str});\n//       stack.push (newId);\n//       number++;\n//     }\n//   }\n//   if (newString.length != 0) {\n//     makeNewTree (newString);\n//   }\n// }\n\n// function makeTree1 (s) {\n//   var idgen = \"n\" + number;\n//   number ++;\n//   var str = s;\n//   var st = str[0];\n//   switch (st) {\n//     case 'E': return [idgen, [{data: {id: idgen, name: \"()\"}}], [], str.substr(1)];\n//     case '+': case '.': {let [lid, lnode, ledge, lret] = makeTree1 (str.substr(1));\n//       let [rid, rnode, redge, rret] = makeTree1 (lret);\n//       return [idgen, [{data: {id: idgen, name: st }}].concat(lnode).concat(rnode), [{data: {source: idgen, target: lid}}].concat([{data: {source: idgen, target: rid}}]).concat(ledge).concat(redge), rret];\n//       }\n//     case '*': let [cid, cnode, cedge, cret] = makeTree1 (str.substr(1));\n//               return [idgen, [{data: {id: idgen, name: \"*\"}}].concat(cnode), [{data: {source: idgen, target: cid}}].concat(cedge), cret];\n//     default: return [idgen, [{data: {id: idgen, name: st}}], [], str.substr(1)];\n//   }\n// }\n\n// function startTree(nString) {\n//   var teste = makeTree1 (nString);\n//   layoutDir = \"LR\";\n//   cy = window.cy = cytoscape({\n//     container: document.getElementById('cy'),\n//     boxSelectionEnabled: false,\n//     autounselectify: true,\n//     layout: {\n//       name: 'dagre',\n//       rankDir: 'LR'\n//     },\n//     style: [\n//       {\n//         selector: 'node[name]',\n//         style: {\n//           'content': 'data(name)',\n//           'width': '40px',\n//           'height': '40px',\n//           'text-valign': 'center',\n//           'text-halign': 'center',\n//           'font-size': '20px'\n//         }\n//       },\n//       {\n//         selector: 'node',\n//         style: {\n//           'background-color': 'white'\n//         }\n//       },\n//       {\n//         selector: 'edge',\n//         style: {\n//           'width': 4,\n//           'target-arrow-shape': 'triangle',\n//           'line-color': '#9dbaea',\n//           'target-arrow-color': '#9dbaea',\n//           'curve-style': 'bezier'\n//         }\n//       }\n//     ],\n//     elements: {\n//       nodes: teste[1],\n//       edges: teste[2]\n//     }\n//   });\n//   direction = 'LR';\n\n// };\n\n// function startTree1(nString) {\n//   stack = new Array ();\n//   conjunto = [[], []];\n//   counter = 0;\n//   number = 0;\n//   makeNewTree (nString);\n//   cy2 = window.cy2 = cytoscape({\n//     container: document.getElementById('cy2'),\n//     boxSelectionEnabled: false,\n//     autounselectify: true,\n//     layout: {\n//       name: 'dagre',\n//       rankDir: 'TB'\n//     },\n//     style: [\n//       {\n//         selector: 'node[name]',\n//         style: {\n//           'content': 'data(name)',\n//           'width': '110px',\n//           'height': '40px',\n//           'text-valign': 'center',\n//           'text-halign': 'center',\n//           'font-size': '20px'\n//         }\n//       },\n//       {\n//         selector: '.Fail',\n//         style: {\n//           'color': 'red'\n//         }\n//       },\n//       {\n//         selector: 'node',\n//         style: {\n//           'background-color': 'white'\n//         }\n//       },\n//       {\n//         selector: 'edge',\n//         style: {\n//           'width': 4,\n//           'target-arrow-shape': 'triangle',\n//           'line-color': '#9dbaea',\n//           'target-arrow-color': '#9dbaea',\n//           'curve-style': 'bezier'\n//         }\n//       }\n//     ],\n//     elements: {\n//       nodes: conjunto[0],\n//       edges: conjunto[1]\n//     }\n//   });\n\n// };\n\n// function changeToHorizontal () {\n//   cy.layout ({name: 'dagre', rankDir: 'LR'}).run()\n// };\n\n// function changeToVertical () {\n//   cy.layout ({name: 'dagre', rankDir: 'TB'}).run()\n// };\n\n// function changeDirection () {\n//   if (layoutDir == \"LR\") {\n\n//     layoutDir = \"TB\";\n//     cy.layout ({name: 'dagre', rankDir: 'TB'}).run();\n    \n//   } else {\n//     layoutDir = \"LR\";\n//     cy.layout ({name: 'dagre', rankDir: 'LR'}).run();\n//   };\n// }\n\n// /* ----------------- General Functions ------------------ */\n\n// function destroy1 () {\n//   if (cy != null) {\n//     cy.destroy();\n//     cy = null;\n//   }\n\n// };\n\n// function fit () {\n//   if (cy != null) {\n//     cy.resize();\n//     cy.fit();\n//   }\n\n// };\n\n// function destroy2 () {\n//   if (cy2 != null) {\n//     cy2.destroy();\n//   }\n//   cy2 = null;\n\n// }; \n\n// /* ------- Not Used ---------- */\n// function makeTreeNode2 (nm)  {\n//   var newId = 'n' + number;\n//     ids.push (newId);\n//     cy2.add({\n//       data: { id: newId, name: nm }\n//     });\n\n//   cy.fit();\n// };\n\n// function makeTreeEdge2 (first, second)  {\n\n//     cy2.add({\n//       data: { source: first, target: second }\n//     });\n//   cy2.fit();\n// };\n\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Array\n\n//Provides: caml_array_sub mutable\nfunction caml_array_sub(a, i, len) {\n  var a2 = new Array(len + 1);\n  a2[0] = 0;\n  for (var i2 = 1, i1 = i + 1; i2 <= len; i2++, i1++) {\n    a2[i2] = a[i1];\n  }\n  return a2;\n}\n\n//Provides: caml_floatarray_sub mutable\n//Requires: caml_array_sub\n//Version: >= 5.3\nfunction caml_floatarray_sub(a, i, len) {\n  return caml_array_sub(a, i, len);\n}\n\n//Provides: caml_uniform_array_sub mutable\n//Requires: caml_array_sub\n//Version: >= 5.3\nfunction caml_uniform_array_sub(a, i, len) {\n  return caml_array_sub(a, i, len);\n}\n\n//Provides: caml_array_append mutable\nfunction caml_array_append(a1, a2) {\n  var l1 = a1.length,\n    l2 = a2.length;\n  var l = l1 + l2 - 1;\n  var a = new Array(l);\n  a[0] = 0;\n  var i = 1,\n    j = 1;\n  for (; i < l1; i++) a[i] = a1[i];\n  for (; i < l; i++, j++) a[i] = a2[j];\n  return a;\n}\n\n//Provides: caml_floatarray_append mutable\n//Requires: caml_array_append\n//Version: >= 5.3\nfunction caml_floatarray_append(a1, a2) {\n  return caml_array_append(a1, a2);\n}\n\n//Provides: caml_uniform_array_append mutable\n//Requires: caml_array_append\n//Version: >= 5.3\nfunction caml_uniform_array_append(a1, a2) {\n  return caml_array_append(a1, a2);\n}\n\n//Provides: caml_array_concat mutable\nfunction caml_array_concat(l) {\n  var a = [0];\n  while (l !== 0) {\n    var b = l[1];\n    for (var i = 1; i < b.length; i++) a.push(b[i]);\n    l = l[2];\n  }\n  return a;\n}\n\n//Provides: caml_floatarray_concat mutable\n//Version: >= 5.4\nfunction caml_floatarray_concat(l) {\n  var a = [0];\n  while (l !== 0) {\n    var b = l[1];\n    for (var i = 1; i < b.length; i++) a.push(b[i]);\n    l = l[2];\n  }\n  return a;\n}\n\n//Provides: caml_uniform_array_concat mutable\n//Version: >= 5.4\nfunction caml_uniform_array_concat(l) {\n  var a = [0];\n  while (l !== 0) {\n    var b = l[1];\n    for (var i = 1; i < b.length; i++) a.push(b[i]);\n    l = l[2];\n  }\n  return a;\n}\n\n//Provides: caml_array_blit\nfunction caml_array_blit(a1, i1, a2, i2, len) {\n  if (i2 <= i1) {\n    for (var j = 1; j <= len; j++) a2[i2 + j] = a1[i1 + j];\n  } else {\n    for (var j = len; j >= 1; j--) a2[i2 + j] = a1[i1 + j];\n  }\n  return 0;\n}\n\n//Provides: caml_floatarray_blit\n//Requires: caml_array_blit\nfunction caml_floatarray_blit(a1, i1, a2, i2, len) {\n  return caml_array_blit(a1, i1, a2, i2, len);\n}\n\n//Provides: caml_uniform_array_blit\n//Requires: caml_array_blit\n//Version: >= 5.3\nfunction caml_uniform_array_blit(a1, i1, a2, i2, len) {\n  return caml_array_blit(a1, i1, a2, i2, len);\n}\n\n///////////// Pervasive\n//Provides: caml_array_set (mutable, const, mutable)\n//Requires: caml_array_bound_error\n//Alias: caml_array_set_float\n//Alias: caml_floatarray_set\n//Alias: caml_array_set_addr\nfunction caml_array_set(array, index, newval) {\n  if (index < 0 || index >= array.length - 1) caml_array_bound_error();\n  array[index + 1] = newval;\n  return 0;\n}\n\n//Provides: caml_array_get mutable (mutable, const)\n//Requires: caml_array_bound_error\n//Alias: caml_array_get_float\n//Alias: caml_floatarray_get\n//Alias: caml_array_get_addr\nfunction caml_array_get(array, index) {\n  if (index < 0 || index >= array.length - 1) caml_array_bound_error();\n  return array[index + 1];\n}\n\n//Provides: caml_array_fill\nfunction caml_array_fill(array, ofs, len, v) {\n  for (var i = 0; i < len; i++) {\n    array[ofs + i + 1] = v;\n  }\n  return 0;\n}\n\n//Provides: caml_floatarray_fill\n//Requires: caml_array_fill\n//Version: >= 5.3\nfunction caml_floatarray_fill(array, ofs, len, v) {\n  return caml_array_fill(array, ofs, len, v);\n}\n\n//Provides: caml_floatarray_fill_unboxed\n//Requires: caml_array_fill\n//Version: >= 5.3\nfunction caml_floatarray_fill_unboxed(array, ofs, len, v) {\n  return caml_array_fill(array, ofs, len, v);\n}\n\n//Provides: caml_uniform_array_fill\n//Requires: caml_array_fill\n//Version: >= 5.3\nfunction caml_uniform_array_fill(array, ofs, len, v) {\n  return caml_array_fill(array, ofs, len, v);\n}\n\n//Provides: caml_check_bound (mutable, const)\n//Requires: caml_array_bound_error\n//Alias: caml_check_bound_gen\n//Alias: caml_check_bound_float\nfunction caml_check_bound(array, index) {\n  if (index >>> 0 >= array.length - 1) caml_array_bound_error();\n  return array;\n}\n\n//Provides: caml_array_make const (const, mutable)\n//Requires: caml_array_bound_error\nfunction caml_array_make(len, init) {\n  if (len >>> 0 >= ((0x7fffffff / 4) | 0)) caml_array_bound_error();\n  var len = (len + 1) | 0;\n  var b = new Array(len);\n  b[0] = 0;\n  for (var i = 1; i < len; i++) b[i] = init;\n  return b;\n}\n\n//Provides: caml_make_vect const (const, mutable)\n//Requires: caml_array_make\nfunction caml_make_vect(len, init) {\n  return caml_array_make(len, init);\n}\n\n//Provides: caml_make_float_vect const (const)\n//Requires: caml_array_bound_error\nfunction caml_make_float_vect(len) {\n  if (len >>> 0 >= ((0x7fffffff / 8) | 0)) caml_array_bound_error();\n  var len = (len + 1) | 0;\n  var b = new Array(len);\n  b[0] = 254;\n  for (var i = 1; i < len; i++) b[i] = 0;\n  return b;\n}\n\n//Provides: caml_array_create_float const (const)\n//Requires: caml_array_bound_error\n//Version: >= 5.3\nfunction caml_array_create_float(len) {\n  if (len >>> 0 >= ((0x7fffffff / 8) | 0)) caml_array_bound_error();\n  var len = (len + 1) | 0;\n  var b = new Array(len);\n  b[0] = 254;\n  for (var i = 1; i < len; i++) b[i] = 0;\n  return b;\n}\n//Provides: caml_floatarray_create const (const)\n//Requires: caml_array_bound_error\nfunction caml_floatarray_create(len) {\n  if (len >>> 0 >= ((0x7fffffff / 8) | 0)) caml_array_bound_error();\n  var len = (len + 1) | 0;\n  var b = new Array(len);\n  b[0] = 254;\n  for (var i = 1; i < len; i++) b[i] = 0;\n  return b;\n}\n\n//Provides: caml_floatarray_make const (const)\n//Requires: caml_array_bound_error\n//Version: >= 5.3\nfunction caml_floatarray_make(len, init) {\n  if (len >>> 0 >= ((0x7fffffff / 8) | 0)) caml_array_bound_error();\n  var len = (len + 1) | 0;\n  var b = new Array(len);\n  b[0] = 254;\n  for (var i = 1; i < len; i++) b[i] = init;\n  return b;\n}\n\n//Provides: caml_floatarray_make_unboxed const (const)\n//Requires: caml_floatarray_make\n//Version: >= 5.3\nfunction caml_floatarray_make_unboxed(len, init) {\n  return caml_floatarray_make(len, init);\n}\n\n//Provides: caml_uniform_array_make const (const)\n//Requires: caml_array_make\n//Version: >= 5.3\nfunction caml_uniform_array_make(len, init) {\n  return caml_array_make(len, init);\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010-2014 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n// An OCaml string is an object with three fields:\n// - tag 't'\n// - length 'l'\n// - contents 'c'\n//\n// The contents of the string can be either a JavaScript array or\n// a JavaScript string. The length of this string can be less than the\n// length of the OCaml string. In this case, remaining bytes are\n// assumed to be zeroes. Arrays are mutable but consumes more memory\n// than strings. A common pattern is to start from an empty string and\n// progressively fill it from the start. Partial strings makes it\n// possible to implement this efficiently.\n//\n// When converting to and from UTF-16, we keep track of whether the\n// string is composed only of ASCII characters (in which case, no\n// conversion needs to be performed) or not.\n//\n// The string tag can thus take the following values:\n//   full string     BYTE | UNKNOWN:      0\n//                   BYTE | ASCII:        9\n//                   BYTE | NOT_ASCII:    8\n//   string prefix   PARTIAL:             2\n//   array           ARRAY:               4\n//\n// One can use bit masking to discriminate these different cases:\n//   known_encoding(x) = x&8\n//   is_ascii(x) =       x&1\n//   kind(x) =           x&6\n\n//Provides: caml_str_repeat\nfunction caml_str_repeat(n, s) {\n  return s.repeat(n);\n}\n\n//Provides: caml_subarray_to_jsbytes\n//Weakdef\n// Pre ECMAScript 5, [apply] would not support array-like object.\n// In such setup, Typed_array would be implemented as polyfill, and [f.apply] would\n// fail here. Mark the primitive as Weakdef, so that people can override it easily.\nfunction caml_subarray_to_jsbytes(a, i, len) {\n  var f = String.fromCharCode;\n  if (i === 0 && len <= 4096 && len === a.length) return f.apply(null, a);\n  var s = \"\";\n  for (; 0 < len; i += 1024, len -= 1024)\n    s += f.apply(null, a.slice(i, i + Math.min(len, 1024)));\n  return s;\n}\n\n//Provides: caml_sub_uint8_array_to_jsbytes\n//Weakdef\n// Pre ECMAScript 5, [apply] would not support array-like object.\n// In such setup, Typed_array would be implemented as polyfill, and [f.apply] would\n// fail here. Mark the primitive as Weakdef, so that people can override it easily.\nfunction caml_sub_uint8_array_to_jsbytes(a, i, len) {\n  var f = String.fromCharCode;\n  if (i === 0 && len <= 4096 && len === a.length) return f.apply(null, a);\n  var s = \"\";\n  for (; 0 < len; i += 1024, len -= 1024)\n    s += f.apply(null, a.subarray(i, i + Math.min(len, 1024)));\n  return s;\n}\n\n//Provides: jsoo_is_ascii\nfunction jsoo_is_ascii(s) {\n  // The regular expression gets better at around this point for all browsers\n  if (s.length < 24) {\n    // Spidermonkey gets much slower when s.length >= 24 (on 64 bit archs)\n    for (var i = 0; i < s.length; i++) if (s.charCodeAt(i) > 127) return false;\n    return true;\n  }\n  // biome-ignore lint/suspicious/noControlCharactersInRegex: expected\n  else return !/[^\\x00-\\x7f]/.test(s);\n}\n\n//Provides: caml_bytes_unsafe_get mutable\nfunction caml_bytes_unsafe_get(s, i) {\n  switch (s.t & 6) {\n    case 0 /* BYTES */:\n      return s.c.charCodeAt(i);\n    case 2 /* PARTIAL */:\n      if (i >= s.c.length) return 0;\n      return s.c.charCodeAt(i);\n    case 4 /* ARRAY */:\n      return s.c[i];\n  }\n}\n\n//Provides: caml_bytes_unsafe_set\n//Requires: caml_convert_bytes_to_array\nfunction caml_bytes_unsafe_set(s, i, c) {\n  // The OCaml compiler uses Char.unsafe_chr on integers larger than 255!\n  c &= 0xff;\n  if (s.t !== 4 /* ARRAY */) {\n    if (i === s.c.length) {\n      s.c += String.fromCharCode(c);\n      if (i + 1 === s.l) s.t = 0; /*BYTES | UNKOWN*/\n      return 0;\n    }\n    caml_convert_bytes_to_array(s);\n  }\n  s.c[i] = c;\n  return 0;\n}\n\n//Provides: caml_string_bound_error\n//Requires: caml_invalid_argument\nfunction caml_string_bound_error() {\n  caml_invalid_argument(\"index out of bounds\");\n}\n\n//Provides: caml_bytes_bound_error\n//Requires: caml_invalid_argument\nfunction caml_bytes_bound_error() {\n  caml_invalid_argument(\"index out of bounds\");\n}\n\n//Provides: caml_string_get\n//Requires: caml_string_bound_error, caml_string_unsafe_get\n//Requires: caml_ml_string_length\nfunction caml_string_get(s, i) {\n  if (i >>> 0 >= caml_ml_string_length(s)) caml_string_bound_error();\n  return caml_string_unsafe_get(s, i);\n}\n\n//Provides: caml_string_get16\n//Requires: caml_string_unsafe_get, caml_string_bound_error\n//Requires: caml_ml_string_length\nfunction caml_string_get16(s, i) {\n  if (i >>> 0 >= caml_ml_string_length(s) - 1) caml_string_bound_error();\n  var b1 = caml_string_unsafe_get(s, i),\n    b2 = caml_string_unsafe_get(s, i + 1);\n  return (b2 << 8) | b1;\n}\n\n//Provides: caml_bytes_get16\n//Requires: caml_bytes_unsafe_get, caml_bytes_bound_error\nfunction caml_bytes_get16(s, i) {\n  if (i >>> 0 >= s.l - 1) caml_bytes_bound_error();\n  var b1 = caml_bytes_unsafe_get(s, i),\n    b2 = caml_bytes_unsafe_get(s, i + 1);\n  return (b2 << 8) | b1;\n}\n\n//Provides: caml_string_get32\n//Requires: caml_string_unsafe_get, caml_string_bound_error\n//Requires: caml_ml_string_length\nfunction caml_string_get32(s, i) {\n  if (i >>> 0 >= caml_ml_string_length(s) - 3) caml_string_bound_error();\n  var b1 = caml_string_unsafe_get(s, i),\n    b2 = caml_string_unsafe_get(s, i + 1),\n    b3 = caml_string_unsafe_get(s, i + 2),\n    b4 = caml_string_unsafe_get(s, i + 3);\n  return (b4 << 24) | (b3 << 16) | (b2 << 8) | b1;\n}\n\n//Provides: caml_bytes_get32\n//Requires: caml_bytes_unsafe_get, caml_bytes_bound_error\nfunction caml_bytes_get32(s, i) {\n  if (i >>> 0 >= s.l - 3) caml_bytes_bound_error();\n  var b1 = caml_bytes_unsafe_get(s, i),\n    b2 = caml_bytes_unsafe_get(s, i + 1),\n    b3 = caml_bytes_unsafe_get(s, i + 2),\n    b4 = caml_bytes_unsafe_get(s, i + 3);\n  return (b4 << 24) | (b3 << 16) | (b2 << 8) | b1;\n}\n\n//Provides: caml_string_get64\n//Requires: caml_string_unsafe_get, caml_string_bound_error\n//Requires: caml_int64_of_bytes\n//Requires: caml_ml_string_length\nfunction caml_string_get64(s, i) {\n  if (i >>> 0 >= caml_ml_string_length(s) - 7) caml_string_bound_error();\n  var a = new Array(8);\n  for (var j = 0; j < 8; j++) {\n    a[7 - j] = caml_string_unsafe_get(s, i + j);\n  }\n  return caml_int64_of_bytes(a);\n}\n\n//Provides: caml_bytes_get64\n//Requires: caml_bytes_unsafe_get, caml_bytes_bound_error\n//Requires: caml_int64_of_bytes\nfunction caml_bytes_get64(s, i) {\n  if (i >>> 0 >= s.l - 7) caml_bytes_bound_error();\n  var a = new Array(8);\n  for (var j = 0; j < 8; j++) {\n    a[7 - j] = caml_bytes_unsafe_get(s, i + j);\n  }\n  return caml_int64_of_bytes(a);\n}\n\n//Provides: caml_bytes_get\n//Requires: caml_bytes_bound_error, caml_bytes_unsafe_get\nfunction caml_bytes_get(s, i) {\n  if (i >>> 0 >= s.l) caml_bytes_bound_error();\n  return caml_bytes_unsafe_get(s, i);\n}\n\n//Provides: caml_string_set\n//Requires: caml_failwith\n//If: js-string\nfunction caml_string_set(_s, _i, _c) {\n  caml_failwith(\"caml_string_set\");\n}\n\n//Provides: caml_string_set\n//Requires: caml_string_unsafe_set, caml_string_bound_error\n//If: !js-string\nfunction caml_string_set(s, i, c) {\n  if (i >>> 0 >= s.l) caml_string_bound_error();\n  return caml_string_unsafe_set(s, i, c);\n}\n\n//Provides: caml_bytes_set16\n//Requires: caml_bytes_bound_error, caml_bytes_unsafe_set\nfunction caml_bytes_set16(s, i, i16) {\n  if (i >>> 0 >= s.l - 1) caml_bytes_bound_error();\n  var b2 = 0xff & (i16 >> 8),\n    b1 = 0xff & i16;\n  caml_bytes_unsafe_set(s, i + 0, b1);\n  caml_bytes_unsafe_set(s, i + 1, b2);\n  return 0;\n}\n\n//Provides: caml_bytes_set32\n//Requires: caml_bytes_bound_error, caml_bytes_unsafe_set\nfunction caml_bytes_set32(s, i, i32) {\n  if (i >>> 0 >= s.l - 3) caml_bytes_bound_error();\n  var b4 = 0xff & (i32 >> 24),\n    b3 = 0xff & (i32 >> 16),\n    b2 = 0xff & (i32 >> 8),\n    b1 = 0xff & i32;\n  caml_bytes_unsafe_set(s, i + 0, b1);\n  caml_bytes_unsafe_set(s, i + 1, b2);\n  caml_bytes_unsafe_set(s, i + 2, b3);\n  caml_bytes_unsafe_set(s, i + 3, b4);\n  return 0;\n}\n\n//Provides: caml_bytes_set64\n//Requires: caml_bytes_bound_error, caml_bytes_unsafe_set\n//Requires: caml_int64_to_bytes\nfunction caml_bytes_set64(s, i, i64) {\n  if (i >>> 0 >= s.l - 7) caml_bytes_bound_error();\n  var a = caml_int64_to_bytes(i64);\n  for (var j = 0; j < 8; j++) {\n    caml_bytes_unsafe_set(s, i + 7 - j, a[j]);\n  }\n  return 0;\n}\n\n//Provides: caml_bytes_set\n//Requires: caml_bytes_bound_error, caml_bytes_unsafe_set\nfunction caml_bytes_set(s, i, c) {\n  if (i >>> 0 >= s.l) caml_bytes_bound_error();\n  return caml_bytes_unsafe_set(s, i, c);\n}\n\n//Provides: jsoo_text_encoder\nvar jsoo_text_encoder = new TextEncoder();\n\n//Provides: jsoo_text_decoder\nvar jsoo_text_decoder = new TextDecoder();\n\n//Provides: caml_bytes_of_utf16_jsstring\n//Requires: MlBytes, jsoo_text_encoder\n//Requires: jsoo_is_ascii\nfunction caml_bytes_of_utf16_jsstring(s) {\n  if (jsoo_is_ascii(s)) {\n    return new MlBytes(9, s, s.length);\n  } else {\n    var a = jsoo_text_encoder.encode(s);\n    return new MlBytes(4, a, a.length);\n  }\n}\n\n//Provides: MlBytes\n//Requires: caml_convert_string_to_bytes, jsoo_is_ascii\n//Requires: caml_uint8_array_of_bytes\n//Requires: jsoo_text_decoder\nclass MlBytes {\n  constructor(tag, contents, length) {\n    this.t = tag;\n    this.c = contents;\n    this.l = length;\n  }\n\n  toString() {\n    switch (this.t) {\n      case 9: /*BYTES | ASCII*/\n      case 8 /*BYTES | NOT_ASCII*/:\n        return this.c;\n      case 4: /* ARRAY */\n      case 2 /* PARTIAL */:\n        // biome-ignore lint/suspicious/noFallthroughSwitchClause:\n        caml_convert_string_to_bytes(this);\n      // fallthrough\n      case 0 /*BYTES | UNKOWN*/:\n        if (jsoo_is_ascii(this.c)) this.t = 9; /*BYTES | ASCII*/\n        else this.t = 8; /*BYTES | NOT_ASCII*/\n        return this.c;\n    }\n  }\n\n  toUtf16() {\n    if (this.t === 9) return this.c;\n    var a = caml_uint8_array_of_bytes(this);\n    return jsoo_text_decoder.decode(a);\n  }\n\n  slice() {\n    var content = this.t === 4 ? this.c.slice() : this.c;\n    return new MlBytes(this.t, content, this.l);\n  }\n}\n\n//Provides: caml_convert_string_to_bytes\n//Requires: caml_str_repeat, caml_sub_uint8_array_to_jsbytes\nfunction caml_convert_string_to_bytes(s) {\n  /* Assumes not BYTES */\n  if (s.t === 2 /* PARTIAL */) s.c += caml_str_repeat(s.l - s.c.length, \"\\0\");\n  else s.c = caml_sub_uint8_array_to_jsbytes(s.c, 0, s.c.length);\n  s.t = 0; /*BYTES | UNKOWN*/\n}\n\n//Provides: caml_convert_bytes_to_array\nfunction caml_convert_bytes_to_array(s) {\n  /* Assumes not ARRAY */\n  var a = new Uint8Array(s.l);\n  var b = s.c,\n    l = b.length,\n    i = 0;\n  for (; i < l; i++) a[i] = b.charCodeAt(i);\n  for (l = s.l; i < l; i++) a[i] = 0;\n  s.c = a;\n  s.t = 4; /* ARRAY */\n  return a;\n}\n\n//Provides: caml_uint8_array_of_bytes mutable\n//Requires: caml_convert_bytes_to_array\nfunction caml_uint8_array_of_bytes(s) {\n  if (s.t !== 4 /* ARRAY */) caml_convert_bytes_to_array(s);\n  return s.c;\n}\n\n//Provides: caml_uint8_array_of_string mutable\n//Requires: caml_ml_string_length, caml_string_unsafe_get\nfunction caml_uint8_array_of_string(s) {\n  var l = caml_ml_string_length(s);\n  var a = new Uint8Array(l);\n  var i = 0;\n  for (; i < l; i++) a[i] = caml_string_unsafe_get(s, i);\n  return a;\n}\n\n//Provides: caml_create_string const\n//Requires: MlBytes, caml_invalid_argument\n//If: !js-string\nfunction caml_create_string(len) {\n  if (len < 0) caml_invalid_argument(\"String.create\");\n  return new MlBytes(len ? 2 : 9, \"\", len);\n}\n\n//Provides: caml_create_string const\n//Requires: caml_invalid_argument\n//If: js-string\nfunction caml_create_string(_len) {\n  caml_invalid_argument(\"String.create\");\n}\n\n//Provides: caml_create_bytes const\n//Requires: MlBytes,caml_invalid_argument\nfunction caml_create_bytes(len) {\n  if (len < 0) caml_invalid_argument(\"Bytes.create\");\n  return new MlBytes(len ? 2 : 9, \"\", len);\n}\n\n//Provides: caml_string_of_array\n//Requires: caml_subarray_to_jsbytes, caml_string_of_jsbytes\nfunction caml_string_of_array(a) {\n  return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a, 0, a.length));\n}\n\n//Provides: caml_string_of_uint8_array\n//Requires: caml_sub_uint8_array_to_jsbytes\n//If: js-string\nfunction caml_string_of_uint8_array(a) {\n  return caml_sub_uint8_array_to_jsbytes(a, 0, a.length);\n}\n\n//Provides: caml_string_of_uint8_array\n//Requires: caml_bytes_of_uint8_array\n//If: !js-string\nfunction caml_string_of_uint8_array(a) {\n  return caml_bytes_of_uint8_array(a.slice());\n}\n\n//Provides: caml_bytes_of_array\n//Requires: MlBytes\nfunction caml_bytes_of_array(a) {\n  if (!(a instanceof Uint8Array)) {\n    a = new Uint8Array(a);\n  }\n  return new MlBytes(4, a, a.length);\n}\n\n//Provides: caml_bytes_of_uint8_array\n//Requires: MlBytes\nfunction caml_bytes_of_uint8_array(a) {\n  return new MlBytes(4, a, a.length);\n}\n\n//Provides: caml_bytes_compare mutable\n//Requires: caml_convert_string_to_bytes\nfunction caml_bytes_compare(s1, s2) {\n  s1.t & 6 && caml_convert_string_to_bytes(s1);\n  s2.t & 6 && caml_convert_string_to_bytes(s2);\n  return s1.c < s2.c ? -1 : s1.c > s2.c ? 1 : 0;\n}\n\n//Provides: caml_bytes_equal mutable (const, const)\n//Requires: caml_convert_string_to_bytes\nfunction caml_bytes_equal(s1, s2) {\n  if (s1 === s2) return 1;\n  s1.t & 6 && caml_convert_string_to_bytes(s1);\n  s2.t & 6 && caml_convert_string_to_bytes(s2);\n  return s1.c === s2.c ? 1 : 0;\n}\n\n//Provides: caml_string_notequal mutable (const, const)\n//Requires: caml_string_equal\nfunction caml_string_notequal(s1, s2) {\n  return 1 - caml_string_equal(s1, s2);\n}\n\n//Provides: caml_bytes_notequal mutable (const, const)\n//Requires: caml_bytes_equal\nfunction caml_bytes_notequal(s1, s2) {\n  return 1 - caml_bytes_equal(s1, s2);\n}\n\n//Provides: caml_bytes_lessequal mutable\n//Requires: caml_convert_string_to_bytes\nfunction caml_bytes_lessequal(s1, s2) {\n  s1.t & 6 && caml_convert_string_to_bytes(s1);\n  s2.t & 6 && caml_convert_string_to_bytes(s2);\n  return s1.c <= s2.c ? 1 : 0;\n}\n\n//Provides: caml_bytes_lessthan mutable\n//Requires: caml_convert_string_to_bytes\nfunction caml_bytes_lessthan(s1, s2) {\n  s1.t & 6 && caml_convert_string_to_bytes(s1);\n  s2.t & 6 && caml_convert_string_to_bytes(s2);\n  return s1.c < s2.c ? 1 : 0;\n}\n\n//Provides: caml_string_greaterequal\n//Requires: caml_string_lessequal\nfunction caml_string_greaterequal(s1, s2) {\n  return caml_string_lessequal(s2, s1);\n}\n//Provides: caml_bytes_greaterequal\n//Requires: caml_bytes_lessequal\nfunction caml_bytes_greaterequal(s1, s2) {\n  return caml_bytes_lessequal(s2, s1);\n}\n\n//Provides: caml_string_greaterthan\n//Requires: caml_string_lessthan\nfunction caml_string_greaterthan(s1, s2) {\n  return caml_string_lessthan(s2, s1);\n}\n\n//Provides: caml_bytes_greaterthan\n//Requires: caml_bytes_lessthan\nfunction caml_bytes_greaterthan(s1, s2) {\n  return caml_bytes_lessthan(s2, s1);\n}\n\n//Provides: caml_fill_bytes\n//Requires: caml_str_repeat, caml_convert_bytes_to_array\n//Alias: caml_fill_string\nfunction caml_fill_bytes(s, i, l, c) {\n  if (l > 0) {\n    if (i === 0 && (l >= s.l || (s.t === 2 /* PARTIAL */ && l >= s.c.length))) {\n      if (c === 0) {\n        s.c = \"\";\n        s.t = 2; /* PARTIAL */\n      } else {\n        s.c = caml_str_repeat(l, String.fromCharCode(c));\n        s.t = l === s.l ? 0 /* BYTES | UNKOWN */ : 2; /* PARTIAL */\n      }\n    } else {\n      if (s.t !== 4 /* ARRAY */) caml_convert_bytes_to_array(s);\n      for (l += i; i < l; i++) s.c[i] = c;\n    }\n  }\n  return 0;\n}\n\n//Provides: caml_blit_bytes\n//Requires: caml_sub_uint8_array_to_jsbytes, caml_convert_bytes_to_array\nfunction caml_blit_bytes(s1, i1, s2, i2, len) {\n  if (len === 0) return 0;\n  if (\n    i2 === 0 &&\n    (len >= s2.l || (s2.t === 2 /* PARTIAL */ && len >= s2.c.length))\n  ) {\n    s2.c =\n      s1.t === 4 /* ARRAY */\n        ? caml_sub_uint8_array_to_jsbytes(s1.c, i1, len)\n        : i1 === 0 && s1.c.length === len\n          ? s1.c\n          : s1.c.slice(i1, i1 + len);\n    s2.t = s2.c.length === s2.l ? 0 /* BYTES | UNKOWN */ : 2; /* PARTIAL */\n  } else if (s2.t === 2 /* PARTIAL */ && i2 === s2.c.length) {\n    s2.c +=\n      s1.t === 4 /* ARRAY */\n        ? caml_sub_uint8_array_to_jsbytes(s1.c, i1, len)\n        : i1 === 0 && s1.c.length === len\n          ? s1.c\n          : s1.c.slice(i1, i1 + len);\n    s2.t = s2.c.length === s2.l ? 0 /* BYTES | UNKOWN */ : 2; /* PARTIAL */\n  } else {\n    if (s2.t !== 4 /* ARRAY */) caml_convert_bytes_to_array(s2);\n    var c1 = s1.c,\n      c2 = s2.c;\n    if (s1.t === 4 /* ARRAY */) {\n      if (i2 <= i1) {\n        for (var i = 0; i < len; i++) c2[i2 + i] = c1[i1 + i];\n      } else {\n        for (var i = len - 1; i >= 0; i--) c2[i2 + i] = c1[i1 + i];\n      }\n    } else {\n      var l = Math.min(len, c1.length - i1);\n      for (var i = 0; i < l; i++) c2[i2 + i] = c1.charCodeAt(i1 + i);\n      for (; i < len; i++) c2[i2 + i] = 0;\n    }\n  }\n  return 0;\n}\n\n//Provides: caml_blit_string\n//Requires: caml_blit_bytes, caml_bytes_of_string\nfunction caml_blit_string(a, b, c, d, e) {\n  caml_blit_bytes(caml_bytes_of_string(a), b, c, d, e);\n  return 0;\n}\n\n//Provides: caml_ml_bytes_length const\nfunction caml_ml_bytes_length(s) {\n  return s.l;\n}\n\n//Provides: caml_string_concat const\n//If: js-string\nfunction caml_string_concat(a, b) {\n  return a + b;\n}\n\n//Provides: caml_string_concat const\n//Requires: caml_convert_string_to_bytes, MlBytes\n//If: !js-string\nfunction caml_string_concat(s1, s2) {\n  s1.t & 6 && caml_convert_string_to_bytes(s1);\n  s2.t & 6 && caml_convert_string_to_bytes(s2);\n  return new MlBytes(0, s1.c + s2.c, s1.l + s2.l);\n}\n\n//Provides: caml_string_unsafe_get const\n//If: js-string\nfunction caml_string_unsafe_get(s, i) {\n  return s.charCodeAt(i);\n}\n\n//Provides: caml_ml_string_length const\n//If: js-string\nfunction caml_ml_string_length(s) {\n  return s.length;\n}\n\n//Provides: caml_string_compare const\n//If: js-string\nfunction caml_string_compare(s1, s2) {\n  return s1 < s2 ? -1 : s1 > s2 ? 1 : 0;\n}\n\n//Provides: caml_string_equal const\n//If: js-string\nfunction caml_string_equal(s1, s2) {\n  if (s1 === s2) return 1;\n  return 0;\n}\n\n//Provides: caml_string_lessequal const\n//If: js-string\nfunction caml_string_lessequal(s1, s2) {\n  return s1 <= s2 ? 1 : 0;\n}\n\n//Provides: caml_string_lessthan const\n//If: js-string\nfunction caml_string_lessthan(s1, s2) {\n  return s1 < s2 ? 1 : 0;\n}\n\n//Provides: caml_string_of_bytes\n//Requires: caml_convert_string_to_bytes, caml_string_of_jsbytes\n//If: js-string\nfunction caml_string_of_bytes(s) {\n  s.t & 6 && caml_convert_string_to_bytes(s);\n  return caml_string_of_jsbytes(s.c);\n}\n\n//Provides: caml_bytes_of_string const\n//Requires: caml_bytes_of_jsbytes, caml_jsbytes_of_string\n//If: js-string\nfunction caml_bytes_of_string(s) {\n  return caml_bytes_of_jsbytes(caml_jsbytes_of_string(s));\n}\n\n//Provides: caml_string_of_jsbytes const\n//If: js-string\nfunction caml_string_of_jsbytes(x) {\n  return x;\n}\n\n//Provides: caml_jsbytes_of_string const\n//If: js-string\nfunction caml_jsbytes_of_string(x) {\n  return x;\n}\n\n//Provides: jsoo_text_decoder_buff\nvar jsoo_text_decoder_buff = new ArrayBuffer(1024);\n\n//Provides: caml_jsstring_of_string const\n//Requires: jsoo_is_ascii\n//Requires: jsoo_text_decoder\n//Requires: jsoo_text_decoder_buff\n//If: js-string\nfunction caml_jsstring_of_string(s) {\n  if (jsoo_is_ascii(s)) return s;\n  var a =\n    s.length <= jsoo_text_decoder_buff.length\n      ? new Uint8Array(jsoo_text_decoder_buff, 0, s.length)\n      : new Uint8Array(s.length);\n  for (var i = 0; i < s.length; i++) {\n    a[i] = s.charCodeAt(i);\n  }\n  return jsoo_text_decoder.decode(a);\n}\n\n//Provides: caml_string_of_jsstring const\n//Requires: caml_string_of_array\n//Requires: jsoo_text_encoder\n//Requires: jsoo_is_ascii, caml_string_of_jsbytes\n//If: js-string\nfunction caml_string_of_jsstring(s) {\n  if (jsoo_is_ascii(s)) return caml_string_of_jsbytes(s);\n  var a = jsoo_text_encoder.encode(s);\n  return caml_string_of_array(a);\n}\n\n//Provides: caml_bytes_of_jsbytes const\n//Requires: MlBytes\nfunction caml_bytes_of_jsbytes(s) {\n  return new MlBytes(0, s, s.length);\n}\n\n// The section below should be used when use-js-string=false\n\n//Provides: caml_string_unsafe_get const\n//Requires: caml_bytes_unsafe_get\n//If: !js-string\nfunction caml_string_unsafe_get(s, i) {\n  return caml_bytes_unsafe_get(s, i);\n}\n\n//Provides: caml_string_unsafe_set\n//Requires: caml_bytes_unsafe_set\n//If: !js-string\nfunction caml_string_unsafe_set(s, i, c) {\n  return caml_bytes_unsafe_set(s, i, c);\n}\n\n//Provides: caml_ml_string_length const\n//Requires: caml_ml_bytes_length\n//If: !js-string\nfunction caml_ml_string_length(s) {\n  return caml_ml_bytes_length(s);\n}\n\n//Provides: caml_string_compare\n//Requires: caml_bytes_compare\n//If: !js-string\nfunction caml_string_compare(s1, s2) {\n  return caml_bytes_compare(s1, s2);\n}\n\n//Provides: caml_string_equal\n//Requires: caml_bytes_equal\n//If: !js-string\nfunction caml_string_equal(s1, s2) {\n  return caml_bytes_equal(s1, s2);\n}\n\n//Provides: caml_string_lessequal\n//Requires: caml_bytes_lessequal\n//If: !js-string\nfunction caml_string_lessequal(s1, s2) {\n  return caml_bytes_lessequal(s1, s2);\n}\n\n//Provides: caml_string_lessthan\n//Requires: caml_bytes_lessthan\n//If: !js-string\nfunction caml_string_lessthan(s1, s2) {\n  return caml_bytes_lessthan(s1, s2);\n}\n\n//Provides: caml_string_of_bytes\n//If: !js-string\nfunction caml_string_of_bytes(s) {\n  return s;\n}\n\n//Provides: caml_bytes_of_string const\n//If: !js-string\nfunction caml_bytes_of_string(s) {\n  return s;\n}\n\n//Provides: caml_string_of_jsbytes const\n//Requires: caml_bytes_of_jsbytes\n//If: !js-string\nfunction caml_string_of_jsbytes(s) {\n  return caml_bytes_of_jsbytes(s);\n}\n\n//Provides: caml_jsbytes_of_string const\n//Requires: caml_convert_string_to_bytes\n//If: !js-string\nfunction caml_jsbytes_of_string(s) {\n  s.t & 6 && caml_convert_string_to_bytes(s);\n  return s.c;\n}\n\n//Provides: caml_jsstring_of_string mutable (const)\n//If: !js-string\nfunction caml_jsstring_of_string(s) {\n  return s.toUtf16();\n}\n\n//Provides: caml_string_of_jsstring\n//Requires: caml_bytes_of_utf16_jsstring\n//If: !js-string\nfunction caml_string_of_jsstring(s) {\n  return caml_bytes_of_utf16_jsstring(s);\n}\n\n//Provides: caml_is_ml_bytes\n//Requires: MlBytes\nfunction caml_is_ml_bytes(s) {\n  return s instanceof MlBytes;\n}\n\n//Provides: caml_ml_bytes_content\n//Requires: MlBytes, caml_convert_string_to_bytes\n//Returns a (full) string of bytes or an array\nfunction caml_ml_bytes_content(s) {\n  switch (s.t & 6) {\n    case 2 /* PARTIAL */:\n      caml_convert_string_to_bytes(s);\n      return s.c;\n    default: /* BYTES or ARRAY */\n      return s.c;\n  }\n}\n\n//Provides: caml_is_ml_string\n//If: js-string\nfunction caml_is_ml_string(s) {\n  // biome-ignore lint/suspicious/noControlCharactersInRegex: expected\n  return typeof s === \"string\" && !/[^\\x00-\\xff]/.test(s);\n}\n\n//Provides: caml_is_ml_string\n//Requires: caml_is_ml_bytes\n//If: !js-string\nfunction caml_is_ml_string(s) {\n  return caml_is_ml_bytes(s);\n}\n\n// The functions below are deprecated\n\n//Provides: caml_js_to_byte_string const\n//Requires: caml_string_of_jsbytes\n//Deprecated: Use [caml_string_of_jsbytes] instead\nfunction caml_js_to_byte_string(s) {\n  return caml_string_of_jsbytes(s);\n}\n\n//Provides: caml_js_from_string mutable (const)\n//Requires: caml_jsstring_of_string\n//Deprecated: Use [caml_jsstring_of_string] instead\nfunction caml_js_from_string(s) {\n  return caml_jsstring_of_string(s);\n}\n\n//Provides: caml_to_js_string mutable (const)\n//Requires: caml_jsstring_of_string\n//Deprecated: Use [caml_jsstring_of_string] instead\nfunction caml_to_js_string(s) {\n  return caml_jsstring_of_string(s);\n}\n\n//Provides: caml_js_to_string const\n//Requires: caml_string_of_jsstring\n//Deprecated: Use [caml_string_of_jsstring] instead\nfunction caml_js_to_string(s) {\n  return caml_string_of_jsstring(s);\n}\n\n//Provides: caml_array_of_string\n//Requires: caml_uint8_array_of_string\n//Deprecated: Use [caml_uint8_array_of_string] instead\nfunction caml_array_of_string(x) {\n  return caml_uint8_array_of_string(x);\n}\n\n//Provides: caml_array_of_bytes\n//Requires: caml_uint8_array_of_bytes\n//Deprecated: Use [caml_uint8_array_of_bytes] instead\nfunction caml_array_of_bytes(x) {\n  return caml_uint8_array_of_bytes(x);\n}\n\n//Provides: caml_new_string\n//Requires: caml_string_of_jsbytes\n//Deprecated: Use [caml_string_of_jsbytes] instead\nfunction caml_new_string(s) {\n  return caml_string_of_jsbytes(s);\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Sys\n\n//Provides: caml_raise_sys_error (const)\n//Requires: caml_raise_with_arg, caml_global_data, caml_string_of_jsstring\nfunction caml_raise_sys_error(msg) {\n  caml_raise_with_arg(caml_global_data.Sys_error, caml_string_of_jsstring(msg));\n}\n\n//Provides: caml_sys_exit\n//Requires: caml_invalid_argument\n//Alias: caml_unix_exit\n//Alias: unix_exit\nfunction caml_sys_exit(code) {\n  if (globalThis.quit) globalThis.quit(code);\n  //nodejs\n  if (globalThis.process?.exit) globalThis.process.exit(code);\n  caml_invalid_argument(\"Function 'exit' not implemented\");\n}\n\n//Provides: caml_is_special_exception\nfunction caml_is_special_exception(exn) {\n  switch (exn[2]) {\n    case -8: // Match_failure\n    case -11: // Assert_failure\n    case -12: // Undefined_recursive_module\n      return 1;\n    default:\n      return 0;\n  }\n}\n\n//Provides: caml_format_exception\n//Requires: MlBytes, caml_is_special_exception\nfunction caml_format_exception(exn) {\n  var r = \"\";\n  if (exn[0] === 0) {\n    r += exn[1][1];\n    if (\n      exn.length === 3 &&\n      exn[2][0] === 0 &&\n      caml_is_special_exception(exn[1])\n    ) {\n      var bucket = exn[2];\n      var start = 1;\n    } else {\n      var start = 2;\n      var bucket = exn;\n    }\n    r += \"(\";\n    for (var i = start; i < bucket.length; i++) {\n      if (i > start) r += \", \";\n      var v = bucket[i];\n      if (typeof v === \"number\") r += v.toString();\n      else if (v instanceof MlBytes) {\n        r += '\"' + v.toString() + '\"';\n      } else if (typeof v === \"string\") {\n        r += '\"' + v.toString() + '\"';\n      } else r += \"_\";\n    }\n    r += \")\";\n  } else if (exn[0] === 248) {\n    r += exn[1];\n  }\n  return r;\n}\n\n//Provides: caml_fatal_uncaught_exception\n//Requires: caml_named_value, caml_format_exception, caml_callback\nfunction caml_fatal_uncaught_exception(err) {\n  if (Array.isArray(err) && (err[0] === 0 || err[0] === 248)) {\n    var handler = caml_named_value(\"Printexc.handle_uncaught_exception\");\n    if (handler) caml_callback(handler, [err, false]);\n    else {\n      var msg = caml_format_exception(err);\n      var at_exit = caml_named_value(\"Pervasives.do_at_exit\");\n      if (at_exit) caml_callback(at_exit, [0]);\n      console.error(\"Fatal error: exception \" + msg);\n      if (err.js_error) throw err.js_error;\n    }\n  } else {\n    throw err;\n  }\n}\n\n//Provides: jsoo_static_env\nvar jsoo_static_env = {};\n\n//Provides: caml_set_static_env\n//Requires: jsoo_static_env\nfunction caml_set_static_env(k, v) {\n  jsoo_static_env[k] = v;\n  return 0;\n}\n\n//Provides: jsoo_sys_getenv (const)\n//Requires: jsoo_static_env\nfunction jsoo_sys_getenv(n) {\n  if (jsoo_static_env[n]) return jsoo_static_env[n];\n  var process = globalThis.process;\n  //nodejs env\n  if (process && process.env && process.env[n] !== undefined)\n    return process.env[n];\n  if (globalThis.jsoo_env && typeof globalThis.jsoo_env[n] === \"string\") {\n    return globalThis.jsoo_env[n];\n  }\n}\n\n//Provides: caml_sys_getenv (const)\n//Requires: caml_raise_not_found\n//Requires: caml_string_of_jsstring\n//Requires: caml_jsstring_of_string\n//Requires: jsoo_sys_getenv\nfunction caml_sys_getenv(name) {\n  var r = jsoo_sys_getenv(caml_jsstring_of_string(name));\n  if (r === undefined) caml_raise_not_found();\n  return caml_string_of_jsstring(r);\n}\n\n//Provides: caml_sys_getenv_opt (const)\n//Requires: caml_string_of_jsstring\n//Requires: caml_jsstring_of_string\n//Requires: jsoo_sys_getenv\n//Version: >= 5.4\nfunction caml_sys_getenv_opt(name) {\n  var r = jsoo_sys_getenv(caml_jsstring_of_string(name));\n  if (r === undefined) return 0;\n  return [0, caml_string_of_jsstring(r)];\n}\n\n//Provides: caml_sys_unsafe_getenv\n//Requires: caml_sys_getenv\nfunction caml_sys_unsafe_getenv(name) {\n  return caml_sys_getenv(name);\n}\n\n//Provides: caml_argv\n//Requires: caml_string_of_jsstring\nvar caml_argv = (function () {\n  var process = globalThis.process;\n  var main = \"a.out\";\n  var args = [];\n\n  if (process?.argv?.length > 1) {\n    var argv = process.argv;\n    //nodejs\n    main = argv[1];\n    args = argv.slice(2);\n  }\n\n  var p = caml_string_of_jsstring(main);\n  var args2 = [0, p];\n  for (var i = 0; i < args.length; i++)\n    args2.push(caml_string_of_jsstring(args[i]));\n  return args2;\n})();\n\n//Provides: caml_executable_name\n//Requires: caml_argv\nvar caml_executable_name = caml_argv[1];\n\n//Provides: caml_sys_get_argv\n//Requires: caml_argv\nfunction caml_sys_get_argv(_unit) {\n  return [0, caml_argv[1], caml_argv];\n}\n\n//Provides: caml_sys_argv\n//Requires: caml_argv\nfunction caml_sys_argv(_unit) {\n  return caml_argv;\n}\n\n//Provides: caml_sys_modify_argv\n//Requires: caml_argv\nfunction caml_sys_modify_argv(arg) {\n  caml_argv = arg;\n  return 0;\n}\n\n//Provides: caml_sys_executable_name const\n//Requires: caml_executable_name\nfunction caml_sys_executable_name(_unit) {\n  return caml_executable_name;\n}\n\n//Provides: caml_sys_system_command\n//Requires: caml_jsstring_of_string\nfunction caml_sys_system_command(cmd) {\n  var cmd = caml_jsstring_of_string(cmd);\n  if (typeof require !== \"undefined\") {\n    var child_process = require(\"node:child_process\");\n    if (child_process?.execSync)\n      try {\n        child_process.execSync(cmd, { stdio: \"inherit\" });\n        return 0;\n      } catch (e) {\n        return 1;\n      }\n  } else return 127;\n}\n\n//Provides: caml_sys_system_command\n//Requires: caml_jsstring_of_string\n//If: browser\nfunction caml_sys_system_command(_cmd) {\n  return 127;\n}\n\n//Provides: caml_sys_time mutable\nvar caml_initial_time = new Date().getTime() * 0.001;\nfunction caml_sys_time() {\n  var now = new Date().getTime();\n  return now * 0.001 - caml_initial_time;\n}\n\n//Provides: caml_sys_time_include_children\n//Requires: caml_sys_time\nfunction caml_sys_time_include_children(_b) {\n  return caml_sys_time();\n}\n\n//Provides: caml_sys_random_seed mutable\n//The function needs to return an array since OCaml 4.0...\nfunction caml_sys_random_seed() {\n  if (globalThis.crypto) {\n    if (globalThis.crypto.getRandomValues) {\n      var a = globalThis.crypto.getRandomValues(new Int32Array(4));\n      return [0, a[0], a[1], a[2], a[3]];\n    } else if (globalThis.crypto.randomBytes) {\n      var a = new Int32Array(globalThis.crypto.randomBytes(16).buffer);\n      return [0, a[0], a[1], a[2], a[3]];\n    }\n  }\n  var now = new Date().getTime();\n  var x = now ^ (0xffffffff * Math.random());\n  return [0, x];\n}\n\n//Provides: caml_sys_const_big_endian const\nfunction caml_sys_const_big_endian() {\n  return 0;\n}\n\n//Provides: caml_sys_const_word_size const\nfunction caml_sys_const_word_size() {\n  return 32;\n}\n\n//Provides: caml_sys_const_int_size const\nfunction caml_sys_const_int_size() {\n  return 32;\n}\n\n//Provides: caml_sys_const_max_wosize const\n// max_int / 4 so that the following does not overflow\n//let max_string_length = word_size / 8 * max_array_length - 1;;\nfunction caml_sys_const_max_wosize() {\n  return (0x7fffffff / 4) | 0;\n}\n\n//Provides: caml_sys_const_ostype_unix const\n//Requires: os_type\nfunction caml_sys_const_ostype_unix() {\n  return os_type === \"Unix\" ? 1 : 0;\n}\n//Provides: caml_sys_const_ostype_win32 const\n//Requires: os_type\nfunction caml_sys_const_ostype_win32() {\n  return os_type === \"Win32\" ? 1 : 0;\n}\n//Provides: caml_sys_const_ostype_cygwin const\n//Requires: os_type\nfunction caml_sys_const_ostype_cygwin() {\n  return os_type === \"Cygwin\" ? 1 : 0;\n}\n\n//Provides: caml_sys_const_backend_type const\n//Requires: caml_string_of_jsbytes\nfunction caml_sys_const_backend_type() {\n  return [0, caml_string_of_jsbytes(\"js_of_ocaml\")];\n}\n\n//Provides: os_type\nvar os_type = globalThis.process?.platform === \"win32\" ? \"Win32\" : \"Unix\";\n\n//Provides: caml_sys_get_config const\n//Requires: caml_string_of_jsbytes, os_type\nfunction caml_sys_get_config() {\n  return [0, caml_string_of_jsbytes(os_type), 32, 0];\n}\n\n//Provides: caml_sys_isatty\nfunction caml_sys_isatty(_chan) {\n  return 0;\n}\n\n//Provides: caml_runtime_variant\n//Requires: caml_string_of_jsbytes\nfunction caml_runtime_variant(_unit) {\n  return caml_string_of_jsbytes(\"\");\n}\n//Provides: caml_runtime_parameters\n//Requires: caml_string_of_jsbytes\nfunction caml_runtime_parameters(_unit) {\n  return caml_string_of_jsbytes(\"\");\n}\n\n//Provides: caml_install_signal_handler const\nfunction caml_install_signal_handler() {\n  return 0;\n}\n\n//Provides: caml_runtime_warnings\nvar caml_runtime_warnings = 0;\n\n//Provides: caml_ml_enable_runtime_warnings\n//Requires: caml_runtime_warnings\nfunction caml_ml_enable_runtime_warnings(bool) {\n  caml_runtime_warnings = bool;\n  return 0;\n}\n\n//Provides: caml_ml_runtime_warnings_enabled\n//Requires: caml_runtime_warnings\nfunction caml_ml_runtime_warnings_enabled(_unit) {\n  return caml_runtime_warnings;\n}\n\n//Provides: caml_sys_const_naked_pointers_checked const (const)\nfunction caml_sys_const_naked_pointers_checked(_unit) {\n  return 0;\n}\n\n//Provides: caml_xdg_defaults\n//Version: >= 5.2\nfunction caml_xdg_defaults(_unit) {\n  return 0; // empty list\n}\n\n//Provides: caml_sys_is_regular_file\n//Requires: resolve_fs_device\n//Version: >= 5.1\nfunction caml_sys_is_regular_file(name) {\n  var root = resolve_fs_device(name);\n  return root.device.isFile(root.rest);\n}\n\n//Provides: caml_io_buffer_size\nvar caml_io_buffer_size = 65536;\n\n//Provides: caml_sys_io_buffer_size\n//Requires: caml_io_buffer_size\n//Version: >= 5.4\nfunction caml_sys_io_buffer_size(_unit) {\n  return caml_io_buffer_size;\n}\n\n//Provides: caml_sys_temp_dir_name\n//Requires: os_type\n//Requires: caml_string_of_jsstring\n//Version: >= 5.4\nfunction caml_sys_temp_dir_name(_unit) {\n  if (os_type === \"Win32\") {\n    return caml_string_of_jsstring(require(\"node:os\").tmpdir());\n  } else {\n    return caml_string_of_jsstring(\"\");\n  }\n}\n\n//Provides: caml_sys_convert_signal_number\n//Version: >= 5.4\nfunction caml_sys_convert_signal_number(signo) {\n  return signo;\n}\n\n//Provides: caml_sys_rev_convert_signal_number\n//Version: >= 5.4\nfunction caml_sys_rev_convert_signal_number(signo) {\n  return signo;\n}\n\n//Always\n//Requires: caml_fatal_uncaught_exception\n//If: !wasm\nfunction caml_setup_uncaught_exception_handler() {\n  var process = globalThis.process;\n  if (process?.on) {\n    process.on(\"uncaughtException\", function (err, origin) {\n      caml_fatal_uncaught_exception(err);\n      process.exit(2);\n    });\n  } else if (globalThis.addEventListener) {\n    globalThis.addEventListener(\"error\", function (event) {\n      if (event.error) {\n        caml_fatal_uncaught_exception(event.error);\n      }\n    });\n  }\n}\ncaml_setup_uncaught_exception_handler();\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: caml_record_backtrace_env_flag\n//Requires: jsoo_sys_getenv\nvar caml_record_backtrace_env_flag = FLAG(\"with-js-error\");\n\n(function () {\n  var r = jsoo_sys_getenv(\"OCAMLRUNPARAM\");\n  if (r !== undefined) {\n    var l = r.split(\",\");\n    for (var i = 0; i < l.length; i++) {\n      if (l[i] === \"b\") {\n        caml_record_backtrace_env_flag = 1;\n        break;\n      } else if (l[i].startsWith(\"b=\")) {\n        caml_record_backtrace_env_flag = +l[i].slice(2);\n      } else continue;\n    }\n  }\n})();\n\n//Provides: caml_record_backtrace_runtime_flag\n//Requires: caml_record_backtrace_env_flag\nvar caml_record_backtrace_runtime_flag = caml_record_backtrace_env_flag;\n\n//Provides: caml_ml_debug_info_status const\nfunction caml_ml_debug_info_status() {\n  return 0;\n}\n//Provides: caml_backtrace_status\n//Requires: caml_record_backtrace_runtime_flag\nfunction caml_backtrace_status(_unit) {\n  return caml_record_backtrace_runtime_flag ? 1 : 0;\n}\n//Provides: caml_get_exception_backtrace const\nfunction caml_get_exception_backtrace() {\n  return 0;\n}\n//Provides: caml_get_exception_raw_backtrace const\nfunction caml_get_exception_raw_backtrace(_unit) {\n  return [0];\n}\n//Provides: caml_record_backtrace\n//Requires: caml_record_backtrace_runtime_flag\nfunction caml_record_backtrace(b) {\n  caml_record_backtrace_runtime_flag = b;\n  return 0;\n}\n//Provides: caml_convert_raw_backtrace const\nfunction caml_convert_raw_backtrace() {\n  return [0];\n}\n//Provides: caml_raw_backtrace_length\nfunction caml_raw_backtrace_length() {\n  return 0;\n}\n//Provides: caml_raw_backtrace_next_slot\nfunction caml_raw_backtrace_next_slot(_slot) {\n  return 0;\n}\n//Provides: caml_raw_backtrace_slot\n//Requires: caml_invalid_argument\nfunction caml_raw_backtrace_slot(_bt, _idx) {\n  caml_invalid_argument(\"Printexc.get_raw_backtrace_slot: index out of bounds\");\n}\n//Provides: caml_restore_raw_backtrace\nfunction caml_restore_raw_backtrace(_exn, _bt) {\n  return 0;\n}\n//Provides: caml_get_current_callstack const\nfunction caml_get_current_callstack() {\n  return [0];\n}\n\n//Provides: caml_convert_raw_backtrace_slot\n//Requires: caml_failwith\nfunction caml_convert_raw_backtrace_slot(_rbt) {\n  caml_failwith(\"caml_convert_raw_backtrace_slot\");\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: caml_call_gen (const, shallow)\n//If: !effects\n//Weakdef\nfunction caml_call_gen(f, args) {\n  var n = f.l >= 0 ? f.l : (f.l = f.length);\n  var argsLen = args.length;\n  var d = n - argsLen;\n  if (d === 0) return f(...args);\n  else if (d < 0) {\n    var g = f(...args.slice(0, n));\n    if (typeof g !== \"function\") return g;\n    return caml_call_gen(g, args.slice(n));\n  } else {\n    switch (d) {\n      case 1: {\n        var g = function (x) {\n          var nargs = new Array(argsLen + 1);\n          for (var i = 0; i < argsLen; i++) nargs[i] = args[i];\n          nargs[argsLen] = x;\n          return f(...nargs);\n        };\n        break;\n      }\n      case 2: {\n        var g = function (x, y) {\n          var nargs = new Array(argsLen + 2);\n          for (var i = 0; i < argsLen; i++) nargs[i] = args[i];\n          nargs[argsLen] = x;\n          nargs[argsLen + 1] = y;\n          return f(...nargs);\n        };\n        break;\n      }\n      default: {\n        var g = function (...extra_args) {\n          if (extra_args.length === 0) extra_args = [undefined];\n          return caml_call_gen(f, args.concat(extra_args));\n        };\n      }\n    }\n    g.l = d;\n    return g;\n  }\n}\n\n//Provides: caml_call_gen (const, shallow)\n//If: effects\n//If: !doubletranslate\n//Weakdef\nfunction caml_call_gen(f, args) {\n  var n = f.l >= 0 ? f.l : (f.l = f.length);\n  var argsLen = args.length;\n  var d = n - argsLen;\n  if (d === 0) {\n    return f(...args);\n  } else if (d < 0) {\n    var rest = args.slice(n - 1);\n    var k = args[argsLen - 1];\n    args = args.slice(0, n);\n    args[n - 1] = function (g) {\n      if (typeof g !== \"function\") return k(g);\n      var args = rest.slice();\n      args[args.length - 1] = k;\n      return caml_call_gen(g, args);\n    };\n    return f(...args);\n  } else {\n    argsLen--;\n    var k = args[argsLen];\n    switch (d) {\n      case 1: {\n        var g = function (x, y) {\n          var nargs = new Array(argsLen + 2);\n          for (var i = 0; i < argsLen; i++) nargs[i] = args[i];\n          nargs[argsLen] = x;\n          nargs[argsLen + 1] = y;\n          return f(...nargs);\n        };\n        break;\n      }\n      case 2: {\n        var g = function (x, y, z) {\n          var nargs = new Array(argsLen + 3);\n          for (var i = 0; i < argsLen; i++) nargs[i] = args[i];\n          nargs[argsLen] = x;\n          nargs[argsLen + 1] = y;\n          nargs[argsLen + 2] = z;\n          return f(...nargs);\n        };\n        break;\n      }\n      default: {\n        args.length = argsLen;\n        var g = function (...extra_args) {\n          if (extra_args.length === 0) extra_args = [undefined];\n          return caml_call_gen(f, args.concat(extra_args));\n        };\n      }\n    }\n    g.l = d + 1;\n    return k(g);\n  }\n}\n\n//Provides: caml_call_gen_cps\n//Requires: caml_call_gen\n//If: effects\n//If: !doubletranslate\n//Weakdef\nvar caml_call_gen_cps = caml_call_gen;\n\n//Provides: caml_call_gen_tuple (const, shallow)\n//Requires: caml_cps_closure\n//If: effects\n//If: doubletranslate\n//Weakdef\nvar caml_call_gen_tuple = (function () {\n  function caml_call_gen_direct(f, args) {\n    var n = f.l >= 0 ? f.l : (f.l = f.length);\n    var argsLen = args.length;\n    var d = n - argsLen;\n    if (d === 0) {\n      return f.apply(null, args);\n    } else if (d < 0) {\n      var g = f(...args.slice(0, n));\n      if (typeof g !== \"function\") return g;\n      return caml_call_gen_direct(g, args.slice(n));\n    } else {\n      // FIXME: Restore the optimization of handling specially d = 1 or 2\n      var args_ = args.slice();\n      args_.length = argsLen;\n      var ret = caml_cps_closure(\n        function (...extra_args) {\n          if (extra_args.length === 0) extra_args = [undefined];\n          return caml_call_gen_direct(f, args.concat(extra_args));\n        },\n        function (...extra_args) {\n          if (extra_args.length === 0) extra_args = [undefined];\n          return caml_call_gen_cps(f, args_.concat(extra_args));\n        },\n      );\n      ret.l = d;\n      ret.cps.l = d + 1;\n      return ret;\n    }\n  }\n  function caml_call_gen_cps(f, args) {\n    if (!f.cps) {\n      var k = args.pop();\n      return k(caml_call_gen_direct(f, args));\n    }\n    var n = f.cps.l >= 0 ? f.cps.l : (f.cps.l = f.cps.length);\n    var argsLen = args.length;\n    var d = n - argsLen;\n    if (d === 0) {\n      return f.cps.apply(null, args);\n    } else if (d < 0) {\n      var rest = args.slice(n - 1);\n      var k = args[argsLen - 1];\n      args = args.slice(0, n);\n      args[n - 1] = function (g) {\n        var args = rest.slice();\n        args[args.length - 1] = k;\n        return caml_call_gen_cps(g, args);\n      };\n      return f.cps.apply(null, args);\n    } else {\n      argsLen--;\n      var args_ = args.slice();\n      args_.length = argsLen;\n      var cont = caml_cps_closure(\n        function (...extra_args) {\n          if (extra_args.length === 0) extra_args = [undefined];\n          return caml_call_gen_direct(f, args_.concat(extra_args));\n        },\n        function (...extra_args) {\n          if (extra_args.length === 0) extra_args = [undefined];\n          return caml_call_gen_cps(f, args_.concat(extra_args));\n        },\n      );\n      var k = args[argsLen];\n      cont.l = d;\n      cont.cps.l = d + 1;\n      return k(cont);\n    }\n  }\n  return [caml_call_gen_direct, caml_call_gen_cps];\n})();\n\n//Provides: caml_call_gen\n//Requires: caml_call_gen_tuple\n//If: effects\n//If: doubletranslate\n//Weakdef\nvar caml_call_gen = caml_call_gen_tuple[0];\n\n//Provides: caml_call_gen_cps\n//Requires: caml_call_gen_tuple\n//If: effects\n//If: doubletranslate\n//Weakdef\nvar caml_call_gen_cps = caml_call_gen_tuple[1];\n\n//Provides: caml_named_values\nvar caml_named_values = {};\n\n//Provides: caml_register_named_value (const,mutable)\n//Requires: caml_named_values, caml_jsbytes_of_string\nfunction caml_register_named_value(nm, v) {\n  caml_named_values[caml_jsbytes_of_string(nm)] = v;\n  return 0;\n}\n\n//Provides: caml_named_value\n//Requires: caml_named_values\nfunction caml_named_value(nm) {\n  return caml_named_values[nm];\n}\n\n//Provides: caml_global_data\nvar caml_global_data = [0];\n\n//Provides: caml_build_symbols\n//Requires: caml_jsstring_of_string\nfunction caml_build_symbols(symb) {\n  var r = {};\n  var max = -1;\n  if (symb) {\n    for (var i = 1; i < symb.length; i++) {\n      var idx = symb[i][2];\n      max = Math.max(max, idx);\n      r[caml_jsstring_of_string(symb[i][1])] = idx;\n    }\n  }\n  r.next_idx = max + 1;\n  return r;\n}\n\n//Provides: jsoo_toplevel_reloc\nvar jsoo_toplevel_reloc = undefined;\n\n//Provides: caml_register_global (const, shallow, const)\n//Requires: caml_global_data, caml_callback, caml_build_symbols\n//Requires: caml_failwith\n//Requires: jsoo_toplevel_reloc\nfunction caml_register_global(n, v, name_opt) {\n  if (name_opt) {\n    var name = name_opt;\n    if (jsoo_toplevel_reloc) {\n      n = caml_callback(jsoo_toplevel_reloc, [name]);\n    } else if (caml_global_data.symbols) {\n      if (!caml_global_data.symidx) {\n        caml_global_data.symidx = caml_build_symbols(caml_global_data.symbols);\n      }\n      var nid = caml_global_data.symidx[name];\n      if (nid >= 0) n = nid;\n      else {\n        // The unit is unknown, this can happen when dynlinking a precompiled js,\n        // let's allocate a fresh idx.\n        var n = caml_global_data.symidx.next_idx++;\n        caml_global_data.symidx[name] = n;\n      }\n    }\n  }\n  caml_global_data[n + 1] = v;\n  if (name_opt) caml_global_data[name_opt] = v;\n}\n\n//Provides: caml_get_global_data mutable\n//Requires: caml_global_data\nfunction caml_get_global_data(_unit) {\n  return caml_global_data;\n}\n\n//Provides: caml_is_printable const (const)\nfunction caml_is_printable(c) {\n  return +(c > 31 && c < 127);\n}\n\n//Provides: caml_maybe_print_stats\nfunction caml_maybe_print_stats(_unit) {\n  return 0;\n}\n","// Js_of_ocaml library\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Jslib\n\n//Provides: caml_js_pure_expr const\n//Requires: caml_callback\nfunction caml_js_pure_expr(f) {\n  return caml_callback(f, [0]);\n}\n\n//Provides: caml_js_set (mutable, const, mutable)\nfunction caml_js_set(o, f, v) {\n  o[f] = v;\n  return 0;\n}\n//Provides: caml_js_get (mutable, const)\nfunction caml_js_get(o, f) {\n  return o[f];\n}\n//Provides: caml_js_delete (mutable, const)\nfunction caml_js_delete(o, f) {\n  delete o[f];\n  return 0;\n}\n\n//Provides: caml_js_instanceof (const, const)\nfunction caml_js_instanceof(o, c) {\n  return o instanceof c ? 1 : 0;\n}\n\n//Provides: caml_js_typeof (const)\nfunction caml_js_typeof(o) {\n  return typeof o;\n}\n\n//Provides:caml_trampoline\nfunction caml_trampoline(res) {\n  var c = 1;\n  while (res?.joo_tramp) {\n    res = res.joo_tramp.apply(null, res.joo_args);\n    c++;\n  }\n  return res;\n}\n\n//Provides:caml_trampoline_return\nfunction caml_trampoline_return(f, args, direct) {\n  return { joo_tramp: f, joo_args: args, joo_direct: direct };\n}\n\n//Provides:caml_stack_depth\n//If: effects\nvar caml_stack_depth = 0;\n\n//Provides:caml_stack_check_depth\n//If: effects\n//Requires:caml_stack_depth\nfunction caml_stack_check_depth() {\n  return --caml_stack_depth > 0;\n}\n\n//Provides: caml_callback\n//If: !effects\n//Requires:caml_call_gen\nvar caml_callback = caml_call_gen;\n\n//Provides: caml_callback\n//If: effects\n//If: !doubletranslate\n//Requires: caml_stack_depth, caml_call_gen, caml_wrap_exception\n//Requires: caml_current_stack\n//Alias: caml_cps_trampoline\nfunction caml_callback(f, args) {\n  var saved_stack_depth = caml_stack_depth;\n  var saved_current_stack = caml_current_stack;\n  try {\n    caml_current_stack = { k: 0, x: 0, h: 0, e: 0 };\n    var res = {\n      joo_tramp: f,\n      joo_args: args.concat(function (x) {\n        return x;\n      }),\n    };\n    do {\n      caml_stack_depth = 40;\n      try {\n        res = caml_call_gen(res.joo_tramp, res.joo_args);\n      } catch (e) {\n        /* Handle exception coming from JavaScript or from the runtime. */\n        if (!caml_current_stack.x) throw e;\n        var handler = caml_current_stack.x.h;\n        caml_current_stack.x = caml_current_stack.x.t;\n        res = { joo_tramp: handler, joo_args: [caml_wrap_exception(e)] };\n      }\n    } while (res?.joo_args);\n  } finally {\n    caml_stack_depth = saved_stack_depth;\n    caml_current_stack = saved_current_stack;\n  }\n  return res;\n}\n\n//Provides: caml_callback\n//If: effects\n//If: doubletranslate\n//Requires: caml_call_gen\nvar caml_callback = caml_call_gen;\n\n//Provides: caml_is_js\nfunction caml_is_js() {\n  return 1;\n}\n\n//Provides: caml_jsoo_flags_use_js_string\nfunction caml_jsoo_flags_use_js_string(_unit) {\n  return FLAG(\"use-js-string\");\n}\n\n//Provides: caml_jsoo_flags_effects\n//Requires: caml_string_of_jsstring\nfunction caml_jsoo_flags_effects(_unit) {\n  return caml_string_of_jsstring(CONFIG(\"effects\"));\n}\n\n//Provides: caml_wrap_exception const (mutable)\n//Requires: caml_global_data,caml_string_of_jsstring,caml_named_value\nfunction caml_wrap_exception(e) {\n  if (FLAG(\"excwrap\")) {\n    if (Array.isArray(e)) return e;\n    var exn;\n    //Stack_overflow: chrome, safari\n    if (\n      globalThis.RangeError &&\n      e instanceof globalThis.RangeError &&\n      e.message &&\n      e.message.match(/maximum call stack/i)\n    )\n      exn = caml_global_data.Stack_overflow;\n    //Stack_overflow: firefox\n    else if (\n      globalThis.InternalError &&\n      e instanceof globalThis.InternalError &&\n      e.message &&\n      e.message.match(/too much recursion/i)\n    )\n      exn = caml_global_data.Stack_overflow;\n    //Wrap Error in Js.Error exception\n    else if (e instanceof globalThis.Error && caml_named_value(\"jsError\"))\n      exn = [0, caml_named_value(\"jsError\"), e];\n    //fallback: wrapped in Failure\n    else\n      exn = [0, caml_global_data.Failure, caml_string_of_jsstring(String(e))];\n    // We already have an error at hand, let's use it.\n    if (e instanceof globalThis.Error) exn.js_error = e;\n    return exn;\n  } else return e;\n}\n\n//Provides: caml_maybe_attach_backtrace\n//Requires: caml_exn_with_js_backtrace\n//Requires: caml_record_backtrace_env_flag\n//Requires: caml_record_backtrace_runtime_flag\nfunction caml_maybe_attach_backtrace(exn, force) {\n  // Backtraces are very expensive, we only enable them when explicitly requested\n  // at compile-time (--enable with-js-error) or at startup with OCAMLRUNPARAM=b=1.\n  // Libraries such as Base unconditionally enable backtraces (programmatically) but\n  // it's way to slow. Here, we force the end-user to opt-in to backtraces.\n  if (caml_record_backtrace_env_flag && caml_record_backtrace_runtime_flag)\n    return caml_exn_with_js_backtrace(exn, force);\n  else return exn;\n}\n\n// Experimental\n//Provides: caml_exn_with_js_backtrace\n//Requires: caml_global_data\nfunction caml_exn_with_js_backtrace(exn, force) {\n  //never reraise for constant exn\n  if (!exn.js_error || force || exn[0] === 248)\n    exn.js_error = new globalThis.Error(\"Js exception containing backtrace\");\n  return exn;\n}\n\n//Provides: caml_js_error_option_of_exception\nfunction caml_js_error_option_of_exception(exn) {\n  if (exn.js_error) {\n    return [0, exn.js_error];\n  }\n  return 0;\n}\n\n//Provides: caml_throw_js_exception\nfunction caml_throw_js_exception(exn) {\n  throw exn;\n}\n\n//Provides: caml_js_from_bool const (const)\nfunction caml_js_from_bool(x) {\n  return !!x;\n}\n//Provides: caml_js_to_bool const (const)\nfunction caml_js_to_bool(x) {\n  return +x;\n}\n//Provides: caml_js_from_float const (const)\n//Alias: caml_js_from_int32\n//Alias: caml_js_from_nativeint\nfunction caml_js_from_float(x) {\n  return x;\n}\n//Provides: caml_js_to_float const (const)\nfunction caml_js_to_float(x) {\n  return x;\n}\n//Provides: caml_js_to_int32 const (const)\n//Alias: caml_js_to_nativeint\nfunction caml_js_to_int32(x) {\n  return x | 0;\n}\n\n//Provides: caml_js_from_array mutable (shallow)\nfunction caml_js_from_array(a) {\n  return a.slice(1);\n}\n//Provides: caml_js_to_array mutable (shallow)\nfunction caml_js_to_array(a) {\n  var len = a.length;\n  var b = new Array(len + 1);\n  b[0] = 0;\n  for (var i = 0; i < len; i++) b[i + 1] = a[i];\n  return b;\n}\n\n//Provides: caml_list_of_js_array const (mutable)\nfunction caml_list_of_js_array(a) {\n  var l = 0;\n  for (var i = a.length - 1; i >= 0; i--) {\n    var e = a[i];\n    l = [0, e, l];\n  }\n  return l;\n}\n\n//Provides: caml_list_to_js_array const (mutable)\nfunction caml_list_to_js_array(l) {\n  var a = [];\n  for (; l !== 0; l = l[2]) {\n    a.push(l[1]);\n  }\n  return a;\n}\n\n//Provides: caml_js_var mutable\n//Requires: caml_jsstring_of_string\nfunction caml_js_var(x) {\n  var x = caml_jsstring_of_string(x);\n  //Checks that x has the form ident[.ident]*\n  if (!x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/)) {\n    console.error(\n      'caml_js_var: \"' +\n        x +\n        '\" is not a valid JavaScript variable. continuing ..',\n    );\n    //console.error(\"Js.Unsafe.eval_string\")\n  }\n  // biome-ignore lint/security/noGlobalEval:\n  return eval(x);\n}\n//Provides: caml_js_call (const, mutable, shallow)\n//Requires: caml_js_from_array\nfunction caml_js_call(f, o, args) {\n  return f.apply(o, caml_js_from_array(args));\n}\n//Provides: caml_js_fun_call (const, shallow)\n//Requires: caml_js_from_array\nfunction caml_js_fun_call(f, a) {\n  switch (a.length) {\n    case 1:\n      return f();\n    case 2:\n      return f(a[1]);\n    case 3:\n      return f(a[1], a[2]);\n    case 4:\n      return f(a[1], a[2], a[3]);\n    case 5:\n      return f(a[1], a[2], a[3], a[4]);\n    case 6:\n      return f(a[1], a[2], a[3], a[4], a[5]);\n    case 7:\n      return f(a[1], a[2], a[3], a[4], a[5], a[6]);\n    case 8:\n      return f(a[1], a[2], a[3], a[4], a[5], a[6], a[7]);\n  }\n  return f.apply(null, caml_js_from_array(a));\n}\n//Provides: caml_js_meth_call (mutable, const, shallow)\n//Requires: caml_jsstring_of_string\n//Requires: caml_js_from_array\nfunction caml_js_meth_call(o, f, args) {\n  return o[caml_jsstring_of_string(f)].apply(o, caml_js_from_array(args));\n}\n//Provides: caml_js_new (const, shallow)\n//Requires: caml_js_from_array\nfunction caml_js_new(c, a) {\n  switch (a.length) {\n    case 1:\n      return new c();\n    case 2:\n      return new c(a[1]);\n    case 3:\n      return new c(a[1], a[2]);\n    case 4:\n      return new c(a[1], a[2], a[3]);\n    case 5:\n      return new c(a[1], a[2], a[3], a[4]);\n    case 6:\n      return new c(a[1], a[2], a[3], a[4], a[5]);\n    case 7:\n      return new c(a[1], a[2], a[3], a[4], a[5], a[6]);\n    case 8:\n      return new c(a[1], a[2], a[3], a[4], a[5], a[6], a[7]);\n  }\n  function F() {\n    return c.apply(this, caml_js_from_array(a));\n  }\n  F.prototype = c.prototype;\n  return new F();\n}\n//Provides: caml_ojs_new_arr (const, shallow)\n//Requires: caml_js_from_array\nfunction caml_ojs_new_arr(c, a) {\n  switch (a.length) {\n    case 0:\n      return new c();\n    case 1:\n      return new c(a[0]);\n    case 2:\n      return new c(a[0], a[1]);\n    case 3:\n      return new c(a[0], a[1], a[2]);\n    case 4:\n      return new c(a[0], a[1], a[2], a[3]);\n    case 5:\n      return new c(a[0], a[1], a[2], a[3], a[4]);\n    case 6:\n      return new c(a[0], a[1], a[2], a[3], a[4], a[5]);\n    case 7:\n      return new c(a[0], a[1], a[2], a[3], a[4], a[5], a[6]);\n  }\n  function F() {\n    return c.apply(this, a);\n  }\n  F.prototype = c.prototype;\n  return new F();\n}\n//Provides: caml_js_wrap_callback const (const)\n//Requires: caml_callback\nfunction caml_js_wrap_callback(f) {\n  return function (...args) {\n    if (args.length === 0) {\n      args = [undefined];\n    }\n    var res = caml_callback(f, args);\n    return res instanceof Function ? caml_js_wrap_callback(res) : res;\n  };\n}\n\n//Provides: caml_js_wrap_callback_arguments\n//Requires: caml_callback\nfunction caml_js_wrap_callback_arguments(f) {\n  return function (...args) {\n    return caml_callback(f, [args]);\n  };\n}\n//Provides: caml_js_wrap_callback_strict const\n//Requires: caml_callback\nfunction caml_js_wrap_callback_strict(arity, f) {\n  return function (...args) {\n    args.length = arity;\n    return caml_callback(f, args);\n  };\n}\n//Provides: caml_js_wrap_callback_unsafe const (const)\n//Requires: caml_callback, caml_js_function_arity\nfunction caml_js_wrap_callback_unsafe(f) {\n  return function (...args) {\n    var len = caml_js_function_arity(f);\n    args.length = len;\n    return caml_callback(f, args);\n  };\n}\n//Provides: caml_js_wrap_meth_callback const (const)\n//Requires: caml_callback, caml_js_wrap_callback\nfunction caml_js_wrap_meth_callback(f) {\n  return function (...args) {\n    args.unshift(this);\n    var res = caml_callback(f, args);\n    return res instanceof Function ? caml_js_wrap_callback(res) : res;\n  };\n}\n//Provides: caml_js_wrap_meth_callback_arguments const (const)\n//Requires: caml_callback\nfunction caml_js_wrap_meth_callback_arguments(f) {\n  return function (...args) {\n    return caml_callback(f, [this, args]);\n  };\n}\n//Provides: caml_js_wrap_meth_callback_strict const\n//Requires: caml_callback\nfunction caml_js_wrap_meth_callback_strict(arity, f) {\n  return function (...args) {\n    args.length = arity;\n    args.unshift(this);\n    return caml_callback(f, args);\n  };\n}\n//Provides: caml_js_wrap_meth_callback_unsafe const (const)\n//Requires: caml_callback, caml_js_function_arity\nfunction caml_js_wrap_meth_callback_unsafe(f) {\n  return function (...args) {\n    var len = caml_js_function_arity(f);\n    args.unshift(this);\n    args.length = len;\n    return caml_callback(f, args);\n  };\n}\n\n//Provides: caml_js_function_arity\n//If: !effects\nfunction caml_js_function_arity(f) {\n  return f.l >= 0 ? f.l : (f.l = f.length);\n}\n\n//Provides: caml_js_function_arity\n//If: effects\n//If: doubletranslate\nfunction caml_js_function_arity(f) {\n  return f.l >= 0 ? f.l : (f.l = f.length);\n}\n\n//Provides: caml_js_function_arity\n//If: effects\n//If: !doubletranslate\nfunction caml_js_function_arity(f) {\n  // Functions have an additional continuation parameter. This should\n  // not be visible when calling them from JavaScript\n  return (f.l >= 0 ? f.l : (f.l = f.length)) - 1;\n}\n\n//Provides: caml_js_equals mutable (const, const)\nfunction caml_js_equals(x, y) {\n  // biome-ignore lint/suspicious/noDoubleEquals:\n  return +(x == y);\n}\n\n//Provides: caml_js_strict_equals mutable (const, const)\nfunction caml_js_strict_equals(x, y) {\n  return +(x === y);\n}\n\n//Provides: caml_js_eval_string (const)\n//Requires: caml_jsstring_of_string\nfunction caml_js_eval_string(s) {\n  // biome-ignore lint/security/noGlobalEval:\n  return eval(caml_jsstring_of_string(s));\n}\n\n//Provides: caml_js_expr (const)\n//Requires: caml_jsstring_of_string\nfunction caml_js_expr(s) {\n  console.error(\"caml_js_expr: fallback to runtime evaluation\\n\");\n  // biome-ignore lint/security/noGlobalEval:\n  return eval(caml_jsstring_of_string(s));\n}\n\n//Provides: caml_pure_js_expr const (const)\n//Requires: caml_jsstring_of_string\nfunction caml_pure_js_expr(s) {\n  console.error(\"caml_pure_js_expr: fallback to runtime evaluation\\n\");\n  // biome-ignore lint/security/noGlobalEval:\n  return eval(caml_jsstring_of_string(s));\n}\n\n//Provides: caml_js_object (object_literal)\n//Requires: caml_jsstring_of_string\nfunction caml_js_object(a) {\n  var o = {};\n  for (var i = 1; i < a.length; i++) {\n    var p = a[i];\n    o[caml_jsstring_of_string(p[1])] = p[2];\n  }\n  return o;\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Raise exception\n\n//Provides: caml_raise_constant (const)\nfunction caml_raise_constant(tag) {\n  throw tag;\n}\n\n//Provides: caml_raise_with_arg (const, mutable)\n//Requires: caml_maybe_attach_backtrace\nfunction caml_raise_with_arg(tag, arg) {\n  throw caml_maybe_attach_backtrace([0, tag, arg]);\n}\n\n//Provides: caml_raise_with_args (const, mutable)\n//Requires: caml_maybe_attach_backtrace\nfunction caml_raise_with_args(tag, args) {\n  throw caml_maybe_attach_backtrace([0, tag].concat(args));\n}\n\n//Provides: caml_raise_with_string (const, const)\n//Requires: caml_raise_with_arg, caml_string_of_jsbytes\nfunction caml_raise_with_string(tag, msg) {\n  caml_raise_with_arg(tag, caml_string_of_jsbytes(msg));\n}\n\n//Provides: caml_failwith (const)\n//Requires: caml_raise_with_string, caml_global_data, caml_string_of_jsbytes\nfunction caml_failwith(msg) {\n  if (!caml_global_data.Failure)\n    caml_global_data.Failure = [248, caml_string_of_jsbytes(\"Failure\"), -3];\n  caml_raise_with_string(caml_global_data.Failure, msg);\n}\n\n//Provides: caml_invalid_argument (const)\n//Requires: caml_raise_with_string, caml_global_data\nfunction caml_invalid_argument(msg) {\n  caml_raise_with_string(caml_global_data.Invalid_argument, msg);\n}\n\n//Provides: caml_raise_end_of_file\n//Requires: caml_raise_constant, caml_global_data\nfunction caml_raise_end_of_file() {\n  caml_raise_constant(caml_global_data.End_of_file);\n}\n\n//Provides: caml_raise_zero_divide\n//Requires: caml_raise_constant, caml_global_data\nfunction caml_raise_zero_divide() {\n  caml_raise_constant(caml_global_data.Division_by_zero);\n}\n\n//Provides: caml_raise_not_found\n//Requires: caml_raise_constant, caml_global_data\nfunction caml_raise_not_found() {\n  caml_raise_constant(caml_global_data.Not_found);\n}\n\n//Provides: caml_array_bound_error\n//Requires: caml_invalid_argument\nfunction caml_array_bound_error() {\n  caml_invalid_argument(\"index out of bounds\");\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: caml_int64_offset\nvar caml_int64_offset = Math.pow(2, -24);\n\n//Provides: MlInt64\n//Requires: caml_int64_offset, caml_raise_zero_divide\nclass MlInt64 {\n  constructor(lo, mi, hi) {\n    this.lo = lo & 0xffffff;\n    this.mi = mi & 0xffffff;\n    this.hi = hi & 0xffff;\n    this.caml_custom = \"_j\";\n  }\n\n  static UNSIGNED_MAX = new MlInt64(0xffffff, 0xffffff, 0xffff);\n  static SIGNED_MAX = new MlInt64(0xffffff, 0xffffff, 0x7fff);\n  static SIGNED_MIN = new MlInt64(0x000000, 0x000000, 0x8000);\n\n  slice() {\n    return new MlInt64(this.lo, this.mi, this.hi);\n  }\n\n  ucompare(x) {\n    if (this.hi > x.hi) return 1;\n    if (this.hi < x.hi) return -1;\n    if (this.mi > x.mi) return 1;\n    if (this.mi < x.mi) return -1;\n    if (this.lo > x.lo) return 1;\n    if (this.lo < x.lo) return -1;\n    return 0;\n  }\n\n  compare(x) {\n    var hi = this.hi << 16;\n    var xhi = x.hi << 16;\n    if (hi > xhi) return 1;\n    if (hi < xhi) return -1;\n    if (this.mi > x.mi) return 1;\n    if (this.mi < x.mi) return -1;\n    if (this.lo > x.lo) return 1;\n    if (this.lo < x.lo) return -1;\n    return 0;\n  }\n\n  neg() {\n    var lo = -this.lo;\n    var mi = -this.mi + (lo >> 24);\n    var hi = -this.hi + (mi >> 24);\n    return new MlInt64(lo, mi, hi);\n  }\n\n  add(x) {\n    var lo = this.lo + x.lo;\n    var mi = this.mi + x.mi + (lo >> 24);\n    var hi = this.hi + x.hi + (mi >> 24);\n    return new MlInt64(lo, mi, hi);\n  }\n\n  sub(x) {\n    var lo = this.lo - x.lo;\n    var mi = this.mi - x.mi + (lo >> 24);\n    var hi = this.hi - x.hi + (mi >> 24);\n    return new MlInt64(lo, mi, hi);\n  }\n\n  mul(x) {\n    var lo = this.lo * x.lo;\n    var mi = ((lo * caml_int64_offset) | 0) + this.mi * x.lo + this.lo * x.mi;\n    var hi =\n      ((mi * caml_int64_offset) | 0) +\n      this.hi * x.lo +\n      this.mi * x.mi +\n      this.lo * x.hi;\n    return new MlInt64(lo, mi, hi);\n  }\n\n  isZero() {\n    return (this.lo | this.mi | this.hi) === 0;\n  }\n\n  isNeg() {\n    return this.hi << 16 < 0;\n  }\n\n  and(x) {\n    return new MlInt64(this.lo & x.lo, this.mi & x.mi, this.hi & x.hi);\n  }\n\n  or(x) {\n    return new MlInt64(this.lo | x.lo, this.mi | x.mi, this.hi | x.hi);\n  }\n\n  xor(x) {\n    return new MlInt64(this.lo ^ x.lo, this.mi ^ x.mi, this.hi ^ x.hi);\n  }\n\n  shift_left(s) {\n    s = s & 63;\n    if (s === 0) return this;\n    if (s < 24) {\n      return new MlInt64(\n        this.lo << s,\n        (this.mi << s) | (this.lo >> (24 - s)),\n        (this.hi << s) | (this.mi >> (24 - s)),\n      );\n    }\n    if (s < 48)\n      return new MlInt64(\n        0,\n        this.lo << (s - 24),\n        (this.mi << (s - 24)) | (this.lo >> (48 - s)),\n      );\n    return new MlInt64(0, 0, this.lo << (s - 48));\n  }\n\n  shift_right_unsigned(s) {\n    s = s & 63;\n    if (s === 0) return this;\n    if (s < 24)\n      return new MlInt64(\n        (this.lo >> s) | (this.mi << (24 - s)),\n        (this.mi >> s) | (this.hi << (24 - s)),\n        this.hi >> s,\n      );\n    if (s < 48)\n      return new MlInt64(\n        (this.mi >> (s - 24)) | (this.hi << (48 - s)),\n        this.hi >> (s - 24),\n        0,\n      );\n    return new MlInt64(this.hi >> (s - 48), 0, 0);\n  }\n\n  shift_right(s) {\n    s = s & 63;\n    if (s === 0) return this;\n    var h = (this.hi << 16) >> 16;\n    if (s < 24)\n      return new MlInt64(\n        (this.lo >> s) | (this.mi << (24 - s)),\n        (this.mi >> s) | (h << (24 - s)),\n        ((this.hi << 16) >> s) >>> 16,\n      );\n    var sign = (this.hi << 16) >> 31;\n    if (s < 48)\n      return new MlInt64(\n        (this.mi >> (s - 24)) | (this.hi << (48 - s)),\n        ((this.hi << 16) >> (s - 24)) >> 16,\n        sign & 0xffff,\n      );\n    return new MlInt64((this.hi << 16) >> (s - 32), sign, sign);\n  }\n\n  lsl1() {\n    this.hi = (this.hi << 1) | (this.mi >> 23);\n    this.mi = ((this.mi << 1) | (this.lo >> 23)) & 0xffffff;\n    this.lo = (this.lo << 1) & 0xffffff;\n  }\n\n  lsr1() {\n    this.lo = ((this.lo >>> 1) | (this.mi << 23)) & 0xffffff;\n    this.mi = ((this.mi >>> 1) | (this.hi << 23)) & 0xffffff;\n    this.hi = this.hi >>> 1;\n  }\n\n  udivmod(x) {\n    var offset = 0;\n    var modulus = this.slice();\n    var divisor = x.slice();\n    var quotient = new MlInt64(0, 0, 0);\n    while (modulus.ucompare(divisor) > 0) {\n      offset++;\n      divisor.lsl1();\n    }\n    while (offset >= 0) {\n      offset--;\n      quotient.lsl1();\n      if (modulus.ucompare(divisor) >= 0) {\n        quotient.lo++;\n        modulus = modulus.sub(divisor);\n      }\n      divisor.lsr1();\n    }\n    return { quotient: quotient, modulus: modulus };\n  }\n\n  div(y) {\n    var x = this;\n    if (y.isZero()) caml_raise_zero_divide();\n    var sign = x.hi ^ y.hi;\n    if (x.hi & 0x8000) x = x.neg();\n    if (y.hi & 0x8000) y = y.neg();\n    var q = x.udivmod(y).quotient;\n    if (sign & 0x8000) q = q.neg();\n    return q;\n  }\n\n  mod(y) {\n    var x = this;\n    if (y.isZero()) caml_raise_zero_divide();\n    var sign = x.hi;\n    if (x.hi & 0x8000) x = x.neg();\n    if (y.hi & 0x8000) y = y.neg();\n    var r = x.udivmod(y).modulus;\n    if (sign & 0x8000) r = r.neg();\n    return r;\n  }\n\n  toInt() {\n    return this.lo | (this.mi << 24);\n  }\n\n  toFloat() {\n    return (\n      (this.hi << 16) * Math.pow(2, 32) + this.mi * Math.pow(2, 24) + this.lo\n    );\n  }\n\n  toArray() {\n    return [\n      this.hi >> 8,\n      this.hi & 0xff,\n      this.mi >> 16,\n      (this.mi >> 8) & 0xff,\n      this.mi & 0xff,\n      this.lo >> 16,\n      (this.lo >> 8) & 0xff,\n      this.lo & 0xff,\n    ];\n  }\n\n  lo32() {\n    return this.lo | ((this.mi & 0xff) << 24);\n  }\n\n  hi32() {\n    return ((this.mi >>> 8) & 0xffff) | (this.hi << 16);\n  }\n}\n\n//Provides: caml_int64_ult const\nfunction caml_int64_ult(x, y) {\n  return x.ucompare(y) < 0;\n}\n\n//Provides: caml_int64_compare const\nfunction caml_int64_compare(x, y, _total) {\n  return x.compare(y);\n}\n\n//Provides: caml_int64_neg const\nfunction caml_int64_neg(x) {\n  return x.neg();\n}\n\n//Provides: caml_int64_add const\nfunction caml_int64_add(x, y) {\n  return x.add(y);\n}\n\n//Provides: caml_int64_sub const\nfunction caml_int64_sub(x, y) {\n  return x.sub(y);\n}\n\n//Provides: caml_int64_mul const\n//Requires: caml_int64_offset\nfunction caml_int64_mul(x, y) {\n  return x.mul(y);\n}\n\n//Provides: caml_int64_is_zero const\nfunction caml_int64_is_zero(x) {\n  return +x.isZero();\n}\n\n//Provides: caml_int64_is_negative const\nfunction caml_int64_is_negative(x) {\n  return +x.isNeg();\n}\n\n//Provides: caml_int64_and const\nfunction caml_int64_and(x, y) {\n  return x.and(y);\n}\n\n//Provides: caml_int64_or const\nfunction caml_int64_or(x, y) {\n  return x.or(y);\n}\n\n//Provides: caml_int64_xor const\nfunction caml_int64_xor(x, y) {\n  return x.xor(y);\n}\n\n//Provides: caml_int64_shift_left const\nfunction caml_int64_shift_left(x, s) {\n  return x.shift_left(s);\n}\n\n//Provides: caml_int64_shift_right_unsigned const\nfunction caml_int64_shift_right_unsigned(x, s) {\n  return x.shift_right_unsigned(s);\n}\n\n//Provides: caml_int64_shift_right const\nfunction caml_int64_shift_right(x, s) {\n  return x.shift_right(s);\n}\n\n//Provides: caml_int64_div\nfunction caml_int64_div(x, y) {\n  return x.div(y);\n}\n\n//Provides: caml_int64_mod\nfunction caml_int64_mod(x, y) {\n  return x.mod(y);\n}\n\n//Provides: caml_int64_of_int32 const\n//Requires: MlInt64\n//Alias: caml_int64_of_int\n//Alias: caml_int64_of_nativeint\nfunction caml_int64_of_int32(x) {\n  return new MlInt64(x & 0xffffff, (x >> 24) & 0xffffff, (x >> 31) & 0xffff);\n}\n\n//Provides: caml_int64_to_int32 const\n//Alias: caml_int64_to_int\n//Alias: caml_int64_to_nativeint\nfunction caml_int64_to_int32(x) {\n  return x.toInt();\n}\n\n//Provides: caml_int64_to_float const\nfunction caml_int64_to_float(x) {\n  return x.toFloat();\n}\n\n//Provides: caml_int64_of_float const\n//Requires: caml_int64_offset, MlInt64\nfunction caml_int64_of_float(x) {\n  if (x < 0) x = Math.ceil(x);\n  return new MlInt64(\n    x & 0xffffff,\n    Math.floor(x * caml_int64_offset) & 0xffffff,\n    Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff,\n  );\n}\n\n//Provides: caml_int64_format const\n//Requires: caml_parse_format, caml_finish_formatting\n//Requires: caml_int64_is_negative, caml_int64_neg\n//Requires: caml_int64_of_int32, caml_int64_to_int32\n//Requires: caml_int64_is_zero, caml_str_repeat\nfunction caml_int64_format(fmt, x) {\n  var f = caml_parse_format(fmt);\n  if (f.signedconv && caml_int64_is_negative(x)) {\n    f.sign = -1;\n    x = caml_int64_neg(x);\n  }\n  var buffer = \"\";\n  var wbase = caml_int64_of_int32(f.base);\n  var cvtbl = \"0123456789abcdef\";\n  do {\n    var p = x.udivmod(wbase);\n    x = p.quotient;\n    buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer;\n  } while (!caml_int64_is_zero(x));\n  if (f.prec >= 0) {\n    f.filler = \" \";\n    var n = f.prec - buffer.length;\n    if (n > 0) buffer = caml_str_repeat(n, \"0\") + buffer;\n  }\n  return caml_finish_formatting(f, buffer);\n}\n\n//Provides: caml_int64_of_string\n//Requires: caml_parse_sign_and_base, caml_failwith, caml_parse_digit\n//Requires: caml_int64_of_int32, caml_int64_ult\n//Requires: caml_int64_add, caml_int64_mul, caml_int64_neg\n//Requires: caml_ml_string_length,caml_string_unsafe_get, MlInt64\nfunction caml_int64_of_string(s) {\n  var r = caml_parse_sign_and_base(s);\n  var i = r[0],\n    sign = r[1],\n    base = r[2],\n    signedness = r[3];\n  var base64 = caml_int64_of_int32(base);\n  var threshold = MlInt64.UNSIGNED_MAX.udivmod(base64).quotient;\n  var c = caml_string_unsafe_get(s, i);\n  var d = caml_parse_digit(c);\n  if (d < 0 || d >= base) caml_failwith(\"Int64.of_string\");\n  var res = caml_int64_of_int32(d);\n  for (;;) {\n    i++;\n    c = caml_string_unsafe_get(s, i);\n    if (c === 95) continue;\n    d = caml_parse_digit(c);\n    if (d < 0 || d >= base) break;\n    /* Detect overflow in multiplication base * res */\n    if (caml_int64_ult(threshold, res)) caml_failwith(\"Int64.of_string\");\n    d = caml_int64_of_int32(d);\n    res = caml_int64_add(caml_int64_mul(base64, res), d);\n    /* Detect overflow in addition (base * res) + d */\n    if (caml_int64_ult(res, d)) caml_failwith(\"Int64.of_string\");\n  }\n  if (i !== caml_ml_string_length(s)) caml_failwith(\"Int64.of_string\");\n  if (\n    signedness &&\n    caml_int64_ult(sign < 0 ? MlInt64.SIGNED_MIN : MlInt64.SIGNED_MAX, res)\n  )\n    caml_failwith(\"Int64.of_string\");\n  if (sign < 0) res = caml_int64_neg(res);\n  return res;\n}\n\n//Provides: caml_int64_create_lo_mi_hi const\n//Requires: MlInt64\nfunction caml_int64_create_lo_mi_hi(lo, mi, hi) {\n  return new MlInt64(lo, mi, hi);\n}\n//Provides: caml_int64_create_lo_hi const\n//Requires: MlInt64\nfunction caml_int64_create_lo_hi(lo, hi) {\n  return new MlInt64(\n    lo & 0xffffff,\n    ((lo >>> 24) & 0xff) | ((hi & 0xffff) << 8),\n    (hi >>> 16) & 0xffff,\n  );\n}\n//Provides: caml_int64_lo32 const\nfunction caml_int64_lo32(v) {\n  return v.lo32();\n}\n\n//Provides: caml_int64_hi32 const\nfunction caml_int64_hi32(v) {\n  return v.hi32();\n}\n\n//Provides: caml_int64_of_bytes const\n//Requires: MlInt64\nfunction caml_int64_of_bytes(a) {\n  return new MlInt64(\n    (a[7] << 0) | (a[6] << 8) | (a[5] << 16),\n    (a[4] << 0) | (a[3] << 8) | (a[2] << 16),\n    (a[1] << 0) | (a[0] << 8),\n  );\n}\n//Provides: caml_int64_to_bytes const\nfunction caml_int64_to_bytes(x) {\n  return x.toArray();\n}\n\n//Provides: caml_int64_hash const\nfunction caml_int64_hash(v) {\n  return v.lo32() ^ v.hi32();\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: jsoo_dataview\nvar jsoo_dataview = new DataView(new ArrayBuffer(8));\n\n//Provides: caml_int64_bits_of_float const\n//Requires: caml_int64_create_lo_mi_hi\n//Requires: jsoo_dataview\nfunction caml_int64_bits_of_float(x) {\n  jsoo_dataview.setFloat64(0, x, true);\n  var lo32 = jsoo_dataview.getUint32(0, true);\n  var hi32 = jsoo_dataview.getUint32(4, true);\n  var r1 = lo32 & 0xffffff;\n  var r2 = (lo32 >>> 24) | ((hi32 << 8) & 0xffffff);\n  var r3 = (hi32 >>> 16) & 0xffff;\n  return caml_int64_create_lo_mi_hi(r1, r2, r3);\n}\n\n//Provides: caml_int32_bits_of_float const\n//Requires: jsoo_dataview\nfunction caml_int32_bits_of_float(x) {\n  jsoo_dataview.setFloat32(0, x, true);\n  return jsoo_dataview.getUint32(0, true) | 0;\n}\n\n//FP literals can be written using the hexadecimal\n//notation 0x<mantissa in hex>p<exponent> from ISO C99.\n//https://github.com/dankogai/js-hexfloat/blob/master/hexfloat.js\n//Provides: caml_hexstring_of_float const\n//Requires: caml_string_of_jsstring, caml_str_repeat\nfunction caml_hexstring_of_float(x, prec, style) {\n  if (!Number.isFinite(x)) {\n    if (Number.isNaN(x)) return caml_string_of_jsstring(\"nan\");\n    return caml_string_of_jsstring(x > 0 ? \"infinity\" : \"-infinity\");\n  }\n  var sign = x === 0 && 1 / x === Number.NEGATIVE_INFINITY ? 1 : x >= 0 ? 0 : 1;\n  if (sign) x = -x;\n  var exp = 0;\n  if (x === 0) {\n  } else if (x < 1) {\n    while (x < 1 && exp > -1022) {\n      x *= 2;\n      exp--;\n    }\n  } else {\n    while (x >= 2) {\n      x /= 2;\n      exp++;\n    }\n  }\n  var exp_sign = exp < 0 ? \"\" : \"+\";\n  var sign_str = \"\";\n  if (sign) sign_str = \"-\";\n  else {\n    switch (style) {\n      case 43 /* '+' */:\n        sign_str = \"+\";\n        break;\n      case 32 /* ' ' */:\n        sign_str = \" \";\n        break;\n      default:\n        break;\n    }\n  }\n  if (prec >= 0 && prec < 13) {\n    /* If a precision is given, and is small, round mantissa accordingly */\n    var cst = Math.pow(2, prec * 4);\n    x = Math.round(x * cst) / cst;\n  }\n  var x_str = x.toString(16);\n  if (prec >= 0) {\n    var idx = x_str.indexOf(\".\");\n    if (idx < 0) {\n      x_str += \".\" + caml_str_repeat(prec, \"0\");\n    } else {\n      var size = idx + 1 + prec;\n      if (x_str.length < size)\n        x_str += caml_str_repeat(size - x_str.length, \"0\");\n      else x_str = x_str.slice(0, size);\n    }\n  }\n  return caml_string_of_jsstring(\n    sign_str + \"0x\" + x_str + \"p\" + exp_sign + exp.toString(10),\n  );\n}\n\n//Provides: caml_int64_float_of_bits const\n//Requires: jsoo_dataview\nfunction caml_int64_float_of_bits(x) {\n  var lo = x.lo;\n  var mi = x.mi;\n  var hi = x.hi;\n  jsoo_dataview.setUint32(0, lo | (mi << 24), true);\n  jsoo_dataview.setUint32(4, (mi >>> 8) | (hi << 16), true);\n  return jsoo_dataview.getFloat64(0, true);\n}\n\n//Provides: caml_nextafter_float const\n//Requires: caml_int64_float_of_bits, caml_int64_bits_of_float, caml_int64_add, caml_int64_sub,caml_int64_of_int32\nfunction caml_nextafter_float(x, y) {\n  if (Number.isNaN(x) || Number.isNaN(y)) return Number.NaN;\n  if (x === y) return y;\n  if (x === 0) {\n    if (y < 0) return -Math.pow(2, -1074);\n    else return Math.pow(2, -1074);\n  }\n  var bits = caml_int64_bits_of_float(x);\n  var one = caml_int64_of_int32(1);\n  if (x < y === x > 0) bits = caml_int64_add(bits, one);\n  else bits = caml_int64_sub(bits, one);\n  return caml_int64_float_of_bits(bits);\n}\n\n//Provides: caml_trunc_float const\nfunction caml_trunc_float(x) {\n  return Math.trunc(x);\n}\n\n//Provides: caml_int32_float_of_bits const\n//Requires: jsoo_dataview\nfunction caml_int32_float_of_bits(x) {\n  jsoo_dataview.setUint32(0, x, true);\n  return jsoo_dataview.getFloat32(0, true);\n}\n\n//Provides: caml_classify_float const\nfunction caml_classify_float(x) {\n  if (Number.isFinite(x)) {\n    if (Math.abs(x) >= 2.2250738585072014e-308) return 0;\n    if (x !== 0) return 1;\n    return 2;\n  }\n  return Number.isNaN(x) ? 4 : 3;\n}\n//Provides: caml_modf_float const\nfunction caml_modf_float(x) {\n  if (Number.isFinite(x)) {\n    var neg = 1 / x < 0;\n    x = Math.abs(x);\n    var i = Math.floor(x);\n    var f = x - i;\n    if (neg) {\n      i = -i;\n      f = -f;\n    }\n    return [0, f, i];\n  }\n  if (Number.isNaN(x)) return [0, Number.NaN, Number.NaN];\n  return [0, 1 / x, x];\n}\n//Provides: caml_ldexp_float const\nfunction caml_ldexp_float(x, exp) {\n  exp |= 0;\n  if (exp > 1023) {\n    exp -= 1023;\n    x *= Math.pow(2, 1023);\n    if (exp > 1023) {\n      // in case x is subnormal\n      exp -= 1023;\n      x *= Math.pow(2, 1023);\n    }\n  }\n  if (exp < -1023) {\n    exp += 1023;\n    x *= Math.pow(2, -1023);\n  }\n  x *= Math.pow(2, exp);\n  return x;\n}\n//Provides: caml_frexp_float const\nfunction caml_frexp_float(x) {\n  if (x === 0 || !Number.isFinite(x)) return [0, x, 0];\n  var neg = x < 0;\n  if (neg) x = -x;\n  var exp = Math.max(-1023, Math.floor(Math.log2(x)) + 1);\n  x *= Math.pow(2, -exp);\n  while (x < 0.5) {\n    x *= 2;\n    exp--;\n  }\n  while (x >= 1) {\n    x *= 0.5;\n    exp++;\n  }\n  if (neg) x = -x;\n  return [0, x, exp];\n}\n\n//Provides: caml_float_compare const\nfunction caml_float_compare(x, y) {\n  if (x === y) return 0;\n  if (x < y) return -1;\n  if (x > y) return 1;\n  if (!Number.isNaN(x)) return 1;\n  if (!Number.isNaN(y)) return -1;\n  return 0;\n}\n\n//Provides: caml_copysign_float const\nfunction caml_copysign_float(x, y) {\n  if (y === 0) y = 1 / y;\n  x = Math.abs(x);\n  return y < 0 ? -x : x;\n}\n\n//Provides: caml_signbit_float const\n//Alias: caml_signbit\nfunction caml_signbit_float(x) {\n  if (x === 0) x = 1 / x;\n  return x < 0 ? 1 : 0;\n}\n\n//Provides: caml_expm1_float const\nfunction caml_expm1_float(x) {\n  return Math.expm1(x);\n}\n//Provides: caml_exp2_float const\nfunction caml_exp2_float(x) {\n  return Math.pow(2, x);\n}\n//Provides: caml_log1p_float const\nfunction caml_log1p_float(x) {\n  return Math.log1p(x);\n}\n//Provides: caml_log2_float const\nfunction caml_log2_float(x) {\n  return Math.log2(x);\n}\n//Provides: caml_hypot_float const\nfunction caml_hypot_float(x, y) {\n  return Math.hypot(x, y);\n}\n//Provides: caml_log10_float const\nfunction caml_log10_float(x) {\n  return Math.log10(x);\n}\n//Provides: caml_cosh_float const\nfunction caml_cosh_float(x) {\n  return Math.cosh(x);\n}\n//Provides: caml_acosh_float const\nfunction caml_acosh_float(x) {\n  return Math.acosh(x);\n}\n//Provides: caml_sinh_float const\nfunction caml_sinh_float(x) {\n  return Math.sinh(x);\n}\n//Provides: caml_asinh_float const\nfunction caml_asinh_float(x) {\n  return Math.asinh(x);\n}\n//Provides: caml_tanh_float const\nfunction caml_tanh_float(x) {\n  return Math.tanh(x);\n}\n//Provides: caml_atanh_float const\nfunction caml_atanh_float(x) {\n  return Math.atanh(x);\n}\n//Provides: caml_round_float const\nfunction caml_round_float(x) {\n  if (x >= 0) {\n    var y = Math.floor(x);\n    return x - y >= 0.5 ? y + 1 : y;\n  } else {\n    var y = Math.ceil(x);\n    return y - x >= 0.5 ? y - 1 : y;\n  }\n}\n//Provides: caml_cbrt_float const\nfunction caml_cbrt_float(x) {\n  return Math.cbrt(x);\n}\n\n//Provides: caml_erf_float const\nfunction caml_erf_float(x) {\n  var a1 = 0.254829592;\n  var a2 = -0.284496736;\n  var a3 = 1.421413741;\n  var a4 = -1.453152027;\n  var a5 = 1.061405429;\n  var p = 0.3275911;\n\n  var sign = 1;\n  if (x < 0) {\n    sign = -1;\n  }\n  x = Math.abs(x);\n  var t = 1.0 / (1.0 + p * x);\n  var y =\n    1.0 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);\n\n  return sign * y;\n}\n\n//Provides: caml_erfc_float const\n//Requires: caml_erf_float\nfunction caml_erfc_float(x) {\n  return 1 - caml_erf_float(x);\n}\n\n//Provides: caml_fma_float const\nfunction caml_fma_float(x, y, z) {\n  var SPLIT = Math.pow(2, 27) + 1;\n  var MIN_VALUE = Math.pow(2, -1022);\n  var EPSILON = Math.pow(2, -52);\n  var C = 416;\n  var A = Math.pow(2, +C);\n  var B = Math.pow(2, -C);\n\n  function multiply(a, b) {\n    var at = SPLIT * a;\n    var ahi = at - (at - a);\n    var alo = a - ahi;\n    var bt = SPLIT * b;\n    var bhi = bt - (bt - b);\n    var blo = b - bhi;\n    var p = a * b;\n    var e = ahi * bhi - p + ahi * blo + alo * bhi + alo * blo;\n    return {\n      p: p,\n      e: e,\n    };\n  }\n\n  function add(a, b) {\n    var s = a + b;\n    var v = s - a;\n    var e = a - (s - v) + (b - v);\n    return {\n      s: s,\n      e: e,\n    };\n  }\n\n  function adjust(x, y) {\n    return x !== 0 && y !== 0 && SPLIT * x - (SPLIT * x - x) === x\n      ? x * (1 + (x < 0 ? -1 : +1) * (y < 0 ? -1 : +1) * EPSILON)\n      : x;\n  }\n\n  if (x === 0 || y === 0 || !Number.isFinite(x) || !Number.isFinite(y)) {\n    return x * y + z;\n  }\n  if (z === 0) {\n    return x * y;\n  }\n  if (!Number.isFinite(z)) {\n    return z;\n  }\n\n  var scale = 1;\n  while (Math.abs(x) > A) {\n    scale *= A;\n    x *= B;\n  }\n  while (Math.abs(y) > A) {\n    scale *= A;\n    y *= B;\n  }\n  if (scale === 1 / 0) {\n    return x * y * scale;\n  }\n  while (Math.abs(x) < B) {\n    scale *= B;\n    x *= A;\n  }\n  while (Math.abs(y) < B) {\n    scale *= B;\n    y *= A;\n  }\n  if (scale === 0) {\n    return z;\n  }\n\n  var xs = x;\n  var ys = y;\n  var zs = z / scale;\n\n  if (Math.abs(zs) > (Math.abs(xs * ys) * 4) / EPSILON) {\n    return z;\n  }\n  if (Math.abs(zs) < (((Math.abs(xs * ys) * EPSILON) / 4) * EPSILON) / 4) {\n    zs = (z < 0 ? -1 : +1) * MIN_VALUE;\n  }\n\n  var xy = multiply(xs, ys);\n  var s = add(xy.p, zs);\n  var u = add(xy.e, s.e);\n  var i = add(s.s, u.s);\n\n  var f = i.s + adjust(i.e, u.e);\n  if (f === 0) {\n    return f;\n  }\n\n  var fs = f * scale;\n  if (Math.abs(fs) > MIN_VALUE) {\n    return fs;\n  }\n\n  // It is possible that there was extra rounding for a denormalized value.\n  return fs + adjust(f - fs / scale, i.e) * scale;\n}\n\n//Provides: caml_format_float const\n//Requires: caml_str_repeat, caml_parse_format, caml_finish_formatting\nfunction caml_format_float(fmt, x) {\n  function toFixed(x, dp) {\n    if (Math.abs(x) < 1.0) {\n      return x.toFixed(dp);\n    } else {\n      var e = Number.parseInt(x.toString().split(\"+\")[1]);\n      if (e > 20) {\n        e -= 20;\n        x /= Math.pow(10, e);\n        x += caml_str_repeat(e, \"0\");\n        if (dp > 0) {\n          x = x + \".\" + caml_str_repeat(dp, \"0\");\n        }\n        return x;\n      } else return x.toFixed(dp);\n    }\n  }\n  var s,\n    f = caml_parse_format(fmt);\n  var prec = f.prec < 0 ? 6 : f.prec;\n  if (x < 0 || (x === 0 && 1 / x === Number.NEGATIVE_INFINITY)) {\n    f.sign = -1;\n    x = -x;\n  }\n  if (Number.isNaN(x)) {\n    s = \"nan\";\n    f.filler = \" \";\n  } else if (!Number.isFinite(x)) {\n    s = \"inf\";\n    f.filler = \" \";\n  } else\n    switch (f.conv) {\n      case \"e\":\n        var s = x.toExponential(prec);\n        // exponent should be at least two digits\n        var i = s.length;\n        if (s.charAt(i - 3) === \"e\")\n          s = s.slice(0, i - 1) + \"0\" + s.slice(i - 1);\n        break;\n      case \"f\":\n        s = toFixed(x, prec);\n        break;\n      case \"g\":\n        prec = prec ? prec : 1;\n        s = x.toExponential(prec - 1);\n        var j = s.indexOf(\"e\");\n        var exp = +s.slice(j + 1);\n        if (exp < -4 || x >= 1e21 || x.toFixed(0).length > prec) {\n          // remove trailing zeroes\n          var i = j - 1;\n          while (s.charAt(i) === \"0\") i--;\n          if (s.charAt(i) === \".\") i--;\n          s = s.slice(0, i + 1) + s.slice(j);\n          i = s.length;\n          if (s.charAt(i - 3) === \"e\")\n            s = s.slice(0, i - 1) + \"0\" + s.slice(i - 1);\n          break;\n        } else {\n          var p = prec;\n          if (exp < 0) {\n            p -= exp + 1;\n            s = x.toFixed(p);\n          } else while (((s = x.toFixed(p)), s.length > prec + 1)) p--;\n          if (p) {\n            // remove trailing zeroes\n            var i = s.length - 1;\n            while (s.charAt(i) === \"0\") i--;\n            if (s.charAt(i) === \".\") i--;\n            s = s.slice(0, i + 1);\n          }\n        }\n        break;\n    }\n  return caml_finish_formatting(f, s);\n}\n\n//Provides: caml_float_of_string (const)\n//Requires: caml_failwith, caml_jsbytes_of_string\nfunction caml_float_of_string(s) {\n  var res;\n  var r_float = /^ *[-+]?(?:\\d*\\.?\\d+|\\d+\\.?\\d*)(?:[eE][-+]?\\d+)?$/;\n  s = caml_jsbytes_of_string(s);\n  res = +s;\n  //Fast path\n  if (!Number.isNaN(res) && r_float.test(s)) return res;\n  s = s.replace(/_/g, \"\");\n  res = +s;\n  if ((!Number.isNaN(res) && r_float.test(s)) || /^[+-]?nan$/i.test(s))\n    return res;\n  var m = /^ *([+-]?)0x([0-9a-f]+)\\.?([0-9a-f]*)(p([+-]?[0-9]+))?$/i.exec(s);\n  //          1        2             3           5\n  if (m) {\n    var m3 = m[3].replace(/0+$/, \"\");\n    var mantissa = Number.parseInt(m[1] + m[2] + m3, 16);\n    var exponent = (+m[5] || 0) - 4 * m3.length;\n    res = mantissa * Math.pow(2, exponent);\n    return res;\n  }\n  if (/^\\+?inf(inity)?$/i.test(s)) return Number.POSITIVE_INFINITY;\n  if (/^-inf(inity)?$/i.test(s)) return Number.NEGATIVE_INFINITY;\n  caml_failwith(\"float_of_string\");\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: caml_update_dummy\nfunction caml_update_dummy(x, y) {\n  if (y.fun) {\n    x.fun = y.fun;\n    return 0;\n  }\n  if (typeof y === \"function\") {\n    x.fun = y;\n    return 0;\n  }\n  var i = y.length;\n  while (i--) x[i] = y[i];\n  return 0;\n}\n\n//Provides: caml_alloc_dummy_infix\n//Requires: caml_call_gen\n//Version: < 5.4\nfunction caml_alloc_dummy_infix() {\n  return function f(x) {\n    return caml_call_gen(f.fun, [x]);\n  };\n}\n\n//Provides: caml_alloc_dummy_lazy\n//Version: >= 5.4\nfunction caml_alloc_dummy_lazy(_unit) {\n  return [0, 0];\n}\n\n//Provides: caml_update_dummy_lazy\n//Requires: caml_obj_tag\n//Requires: caml_update_dummy\n//Version: >= 5.4\nfunction caml_update_dummy_lazy(dummy, newval) {\n  switch (caml_obj_tag(newval)) {\n    case 246: // Lazy\n    case 244: // Forcing\n    case 250: // Forward\n      caml_update_dummy(dummy, newval);\n      break;\n    default:\n      dummy[1] = newval;\n      dummy[0] = 250;\n      break;\n  }\n  return 0;\n}\n\n//Provides: caml_obj_tag\n//Requires: caml_is_ml_bytes, caml_is_ml_string\nfunction caml_obj_tag(x) {\n  if (Array.isArray(x) && x[0] === x[0] >>> 0) return x[0];\n  else if (caml_is_ml_bytes(x)) return 252;\n  else if (caml_is_ml_string(x)) return 252;\n  else if (x instanceof Function || typeof x === \"function\") return 247;\n  else if (x?.caml_custom) return 255;\n  else return 1000;\n}\n\n//Provides: caml_obj_set_tag (mutable, const)\n//Version: < 5.0\nfunction caml_obj_set_tag(x, tag) {\n  x[0] = tag;\n  return 0;\n}\n//Provides: caml_obj_block const (const,const)\nfunction caml_obj_block(tag, size) {\n  // TODO: fail for value that are not represented as an array\n  var o = new Array(size + 1);\n  o[0] = tag;\n  for (var i = 1; i <= size; i++) o[i] = 0;\n  return o;\n}\n\n//Provides: caml_obj_with_tag\nfunction caml_obj_with_tag(tag, x) {\n  var l = x.length;\n  var a = new Array(l);\n  a[0] = tag;\n  for (var i = 1; i < l; i++) a[i] = x[i];\n  return a;\n}\n\n//Provides: caml_obj_dup mutable (mutable)\nfunction caml_obj_dup(x) {\n  return typeof x === \"number\" ? x : x.slice();\n}\n\n//Provides: caml_obj_truncate (mutable, const)\n//Requires: caml_invalid_argument\n//Version: < 5.0\nfunction caml_obj_truncate(x, s) {\n  if (s <= 0 || s + 1 > x.length) caml_invalid_argument(\"Obj.truncate\");\n  if (x.length !== s + 1) x.length = s + 1;\n  return 0;\n}\n\n//Provides: caml_obj_make_forward\n//Version: < 5.0\nfunction caml_obj_make_forward(b, v) {\n  b[0] = 250;\n  b[1] = v;\n  return 0;\n}\n\n//Provides: caml_obj_compare_and_swap\n//Version: >= 5.0\nfunction caml_obj_compare_and_swap(x, i, old, n) {\n  if (x[i + 1] === old) {\n    x[i + 1] = n;\n    return 1;\n  }\n  return 0;\n}\n\n//Provides: caml_obj_is_shared\n//Version: >= 5.0\nfunction caml_obj_is_shared(_x) {\n  return 1;\n}\n\n//Provides: caml_lazy_make_forward const (mutable)\nfunction caml_lazy_make_forward(v) {\n  return [250, v];\n}\n\n//Provides: caml_method_cache\nvar caml_method_cache = [];\n\n//Provides: caml_oo_cache_id const\n//Requires: caml_method_cache\nfunction caml_oo_cache_id() {\n  var cacheid = caml_method_cache.length;\n  caml_method_cache[cacheid] = 0;\n  cacheid;\n}\n\n///////////// CamlinternalOO\n//Provides: caml_get_cached_method const\n//Requires: caml_method_cache\nfunction caml_get_cached_method(obj, tag, cacheid) {\n  var meths = obj[1];\n  var ofs = caml_method_cache[cacheid];\n  if (meths[ofs + 4] === tag) {\n    return meths[ofs + 3];\n  }\n  var li = 3,\n    hi = meths[1] * 2 + 1,\n    mi;\n  while (li < hi) {\n    mi = ((li + hi) >> 1) | 1;\n    if (tag < meths[mi + 1]) hi = mi - 2;\n    else li = mi;\n  }\n  caml_method_cache[cacheid] = li - 3;\n  return meths[li];\n}\n\n//Provides: caml_get_public_method const\nfunction caml_get_public_method(obj, tag) {\n  var meths = obj[1];\n  var li = 3,\n    hi = meths[1] * 2 + 1,\n    mi;\n  while (li < hi) {\n    mi = ((li + hi) >> 1) | 1;\n    if (tag < meths[mi + 1]) hi = mi - 2;\n    else li = mi;\n  }\n  /* return 0 if tag is not there */\n  return tag === meths[li + 1] ? meths[li] : 0;\n}\n\n//Provides: caml_oo_last_id\nvar caml_oo_last_id = 0;\n\n//Provides: caml_set_oo_id\n//Requires: caml_oo_last_id\nfunction caml_set_oo_id(b) {\n  b[2] = caml_oo_last_id++;\n  return b;\n}\n\n//Provides: caml_fresh_oo_id const\n//Requires: caml_oo_last_id\nfunction caml_fresh_oo_id() {\n  return caml_oo_last_id++;\n}\n\n//Provides: caml_obj_raw_field\nfunction caml_obj_raw_field(o, i) {\n  return o[i + 1];\n}\n\n//Provides: caml_obj_set_raw_field\nfunction caml_obj_set_raw_field(o, i, v) {\n  return (o[i + 1] = v);\n}\n\n//Provides: caml_obj_reachable_words\nfunction caml_obj_reachable_words(_o) {\n  return 0;\n}\n\n//Provides: caml_obj_add_offset\n//Requires: caml_failwith\nfunction caml_obj_add_offset(_v, _offset) {\n  caml_failwith(\"Obj.add_offset is not supported\");\n}\n\n//Provides: caml_obj_update_tag\n//Version: >= 5.0\nfunction caml_obj_update_tag(b, o, n) {\n  if (b[0] === o) {\n    b[0] = n;\n    return 1;\n  }\n  return 0;\n}\n\n//Provides: caml_lazy_update_to_forcing\n//Requires: caml_obj_update_tag\n//Version: >= 5.0\nfunction caml_lazy_update_to_forcing(o) {\n  if (\n    Array.isArray(o) &&\n    o[0] === o[0] >>> 0 &&\n    caml_obj_update_tag(o, 246, 244)\n  ) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\n//Provides: caml_lazy_update_to_forward\n//Requires: caml_obj_update_tag\n//Version: >= 5.0\nfunction caml_lazy_update_to_forward(o) {\n  caml_obj_update_tag(o, 244, 250);\n  return 0; // unit\n}\n\n//Provides: caml_lazy_reset_to_lazy\n//Requires: caml_obj_update_tag\n//Version: >= 5.0\nfunction caml_lazy_reset_to_lazy(o) {\n  caml_obj_update_tag(o, 244, 246);\n  return 0;\n}\n\n//Provides: caml_lazy_read_result\n//Requires: caml_obj_tag\n//Version: >= 5.0\nfunction caml_lazy_read_result(o) {\n  return caml_obj_tag(o) === 250 ? o[1] : o;\n}\n\n//Provides: caml_is_continuation_tag\n//Version: < 5\nfunction caml_is_continuation_tag(_t) {\n  return 0;\n}\n\n//Provides: caml_is_continuation_tag\n//Version: >= 5\nfunction caml_is_continuation_tag(t) {\n  return t === 245 ? 1 : 0;\n}\n\n//Provides: caml_custom_identifier\n//Requires: caml_string_of_jsstring\nfunction caml_custom_identifier(o) {\n  return caml_string_of_jsstring(o.caml_custom);\n}\n\n//Provides: caml_ml_gc_ramp_up\n//Requires: caml_callback\n//Version: >= 5.4\nfunction caml_ml_gc_ramp_up(f) {\n  var a = caml_callback(f, [0]);\n  var suspended = 0;\n  return [0, a, suspended];\n}\n\n//Provides: caml_ml_gc_ramp_down\n//Version: >= 5.4\nfunction caml_ml_gc_ramp_down(_suspended_collection_work) {\n  return 0;\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2014 Jérôme Vouillon, Hugo Heuzard, Andy Ray\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n//\n// Bigarray.\n//\n// - all bigarray types including Int64 and Complex.\n// - fortran + c layouts\n// - sub/slice/reshape\n// - retain fast path for 1d array access\n\n//Provides: caml_ba_init const\nfunction caml_ba_init() {\n  return 0;\n}\n\n//Provides: caml_ba_get_size\n//Requires: caml_invalid_argument\nfunction caml_ba_get_size(dims) {\n  var n_dims = dims.length;\n  var size = 1;\n  for (var i = 0; i < n_dims; i++) {\n    if (dims[i] < 0)\n      caml_invalid_argument(\"Bigarray.create: negative dimension\");\n    size = size * dims[i];\n  }\n  return size;\n}\n\n//Provides: caml_unpackFloat16\nvar caml_unpackFloat16 = (function () {\n  var pow = Math.pow;\n\n  var EXP_MASK16 = 31; // 2 ** 5 - 1\n  var SIGNIFICAND_MASK16 = 1023; // 2 ** 10 - 1\n  var MIN_SUBNORMAL16 = pow(2, -24); // 2 ** -10 * 2 ** -14\n  var SIGNIFICAND_DENOM16 = 0.0009765625; // 2 ** -10\n\n  return function (bytes) {\n    var sign = bytes >>> 15;\n    var exponent = (bytes >>> 10) & EXP_MASK16;\n    var significand = bytes & SIGNIFICAND_MASK16;\n    if (exponent === EXP_MASK16)\n      return significand === 0\n        ? sign === 0\n          ? Number.POSITIVE_INFINITY\n          : Number.NEGATIVE_INFINITY\n        : Number.NaN;\n    if (exponent === 0)\n      return significand * (sign === 0 ? MIN_SUBNORMAL16 : -MIN_SUBNORMAL16);\n    var r =\n      pow(2, exponent - 15) *\n      (sign === 0\n        ? 1 + significand * SIGNIFICAND_DENOM16\n        : -1 - significand * SIGNIFICAND_DENOM16);\n    return r;\n  };\n})();\n\n//Provides: caml_packFloat16\nvar caml_packFloat16 = (function () {\n  const INVERSE_OF_EPSILON = 1 / Number.EPSILON;\n\n  function roundTiesToEven(num) {\n    return num + INVERSE_OF_EPSILON - INVERSE_OF_EPSILON;\n  }\n\n  const FLOAT16_MIN_VALUE = 6.103515625e-5;\n  const FLOAT16_MAX_VALUE = 65504;\n  const FLOAT16_EPSILON = 0.0009765625;\n\n  const FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE =\n    FLOAT16_EPSILON * FLOAT16_MIN_VALUE;\n  const FLOAT16_EPSILON_DEVIDED_BY_EPSILON =\n    FLOAT16_EPSILON * INVERSE_OF_EPSILON;\n\n  function roundToFloat16(num) {\n    const number = +num;\n\n    // NaN, Infinity, -Infinity, 0, -0\n    if (!Number.isFinite(number) || number === 0) {\n      return number;\n    }\n\n    // finite except 0, -0\n    const sign = number > 0 ? 1 : -1;\n    const absolute = Math.abs(number);\n\n    // small number\n    if (absolute < FLOAT16_MIN_VALUE) {\n      return (\n        sign *\n        roundTiesToEven(\n          absolute / FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE,\n        ) *\n        FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE\n      );\n    }\n\n    const temp = (1 + FLOAT16_EPSILON_DEVIDED_BY_EPSILON) * absolute;\n    const result = temp - (temp - absolute);\n\n    // large number\n    if (result > FLOAT16_MAX_VALUE || Number.isNaN(result)) {\n      return sign * Number.POSITIVE_INFINITY;\n    }\n\n    return sign * result;\n  }\n\n  // base algorithm: http://fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\n  const baseTable = new Uint16Array(512);\n  const shiftTable = new Uint8Array(512);\n\n  for (let i = 0; i < 256; ++i) {\n    const e = i - 127;\n\n    // very small number (0, -0)\n    if (e < -24) {\n      baseTable[i] = 0x0000;\n      baseTable[i | 0x100] = 0x8000;\n      shiftTable[i] = 24;\n      shiftTable[i | 0x100] = 24;\n\n      // small number (denorm)\n    } else if (e < -14) {\n      baseTable[i] = 0x0400 >> (-e - 14);\n      baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;\n      shiftTable[i] = -e - 1;\n      shiftTable[i | 0x100] = -e - 1;\n\n      // normal number\n    } else if (e <= 15) {\n      baseTable[i] = (e + 15) << 10;\n      baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;\n      shiftTable[i] = 13;\n      shiftTable[i | 0x100] = 13;\n\n      // large number (Infinity, -Infinity)\n    } else if (e < 128) {\n      baseTable[i] = 0x7c00;\n      baseTable[i | 0x100] = 0xfc00;\n      shiftTable[i] = 24;\n      shiftTable[i | 0x100] = 24;\n\n      // stay (NaN, Infinity, -Infinity)\n    } else {\n      baseTable[i] = 0x7c00;\n      baseTable[i | 0x100] = 0xfc00;\n      shiftTable[i] = 13;\n      shiftTable[i | 0x100] = 13;\n    }\n  }\n\n  const buffer = new ArrayBuffer(4);\n  const floatView = new Float32Array(buffer);\n  const uint32View = new Uint32Array(buffer);\n\n  return function (num) {\n    floatView[0] = roundToFloat16(num);\n    const f = uint32View[0];\n    const e = (f >> 23) & 0x1ff;\n    return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);\n  };\n})();\n\n//Provides: caml_ba_get_size_per_element\nfunction caml_ba_get_size_per_element(kind) {\n  switch (kind) {\n    case 7:\n    case 10:\n    case 11:\n      return 2;\n    default:\n      return 1;\n  }\n}\n\n//Provides: caml_ba_create_buffer\n//Requires: caml_ba_get_size_per_element\n//Requires: caml_invalid_argument\nfunction caml_ba_create_buffer(kind, size) {\n  var view;\n  switch (kind) {\n    case 0:\n      view = Float32Array;\n      break;\n    case 1:\n      view = Float64Array;\n      break;\n    case 2:\n      view = Int8Array;\n      break;\n    case 3:\n      view = Uint8Array;\n      break;\n    case 4:\n      view = Int16Array;\n      break;\n    case 5:\n      view = Uint16Array;\n      break;\n    case 6:\n      view = Int32Array;\n      break;\n    case 7:\n      view = Int32Array;\n      break;\n    case 8:\n      view = Int32Array;\n      break;\n    case 9:\n      view = Int32Array;\n      break;\n    case 10:\n      view = Float32Array;\n      break;\n    case 11:\n      view = Float64Array;\n      break;\n    case 12:\n      view = Uint8Array;\n      break;\n    case 13:\n      view = Uint16Array;\n      break;\n  }\n  if (!view) caml_invalid_argument(\"Bigarray.create: unsupported kind\");\n  var data = new view(size * caml_ba_get_size_per_element(kind));\n  return data;\n}\n\n//Provides: caml_ba_custom_name\nvar caml_ba_custom_name = \"_bigarr02\";\n\n//Provides: Ml_Bigarray\n//Requires: caml_array_bound_error, caml_invalid_argument, caml_ba_custom_name\n//Requires: caml_int64_create_lo_hi, caml_int64_hi32, caml_int64_lo32\n//Requires: caml_packFloat16, caml_unpackFloat16\nclass Ml_Bigarray {\n  constructor(kind, layout, dims, buffer) {\n    this.kind = kind;\n    this.layout = layout;\n    this.dims = dims;\n    this.data = buffer;\n    this.caml_custom = caml_ba_custom_name;\n  }\n\n  offset(arg) {\n    var ofs = 0;\n    if (typeof arg === \"number\") arg = [arg];\n    if (!Array.isArray(arg))\n      caml_invalid_argument(\"bigarray.js: invalid offset\");\n    if (this.dims.length !== arg.length)\n      caml_invalid_argument(\"Bigarray.get/set: bad number of dimensions\");\n    if (this.layout === 0 /* c_layout */) {\n      for (var i = 0; i < this.dims.length; i++) {\n        if (arg[i] < 0 || arg[i] >= this.dims[i]) caml_array_bound_error();\n        ofs = ofs * this.dims[i] + arg[i];\n      }\n    } else {\n      for (var i = this.dims.length - 1; i >= 0; i--) {\n        if (arg[i] < 1 || arg[i] > this.dims[i]) {\n          caml_array_bound_error();\n        }\n        ofs = ofs * this.dims[i] + (arg[i] - 1);\n      }\n    }\n    return ofs;\n  }\n\n  get(ofs) {\n    switch (this.kind) {\n      case 7:\n        // Int64\n        var l = this.data[ofs * 2 + 0];\n        var h = this.data[ofs * 2 + 1];\n        return caml_int64_create_lo_hi(l, h);\n      case 10:\n      case 11:\n        // Complex32, Complex64\n        var r = this.data[ofs * 2 + 0];\n        var i = this.data[ofs * 2 + 1];\n        return [254, r, i];\n      case 13:\n        return caml_unpackFloat16(this.data[ofs]);\n      default:\n        return this.data[ofs];\n    }\n  }\n\n  set(ofs, v) {\n    switch (this.kind) {\n      case 7:\n        // Int64\n        this.data[ofs * 2 + 0] = caml_int64_lo32(v);\n        this.data[ofs * 2 + 1] = caml_int64_hi32(v);\n        break;\n      case 10:\n      case 11:\n        // Complex32, Complex64\n        this.data[ofs * 2 + 0] = v[1];\n        this.data[ofs * 2 + 1] = v[2];\n        break;\n      case 13:\n        this.data[ofs] = caml_packFloat16(v);\n        break;\n      default:\n        this.data[ofs] = v;\n        break;\n    }\n    return 0;\n  }\n\n  fill(v) {\n    switch (this.kind) {\n      case 7:\n        // Int64\n        var a = caml_int64_lo32(v);\n        var b = caml_int64_hi32(v);\n        if (a === b) {\n          this.data.fill(a);\n        } else {\n          for (var i = 0; i < this.data.length; i++) {\n            this.data[i] = i % 2 === 0 ? a : b;\n          }\n        }\n        break;\n      case 10:\n      case 11:\n        // Complex32, Complex64\n        var im = v[1];\n        var re = v[2];\n        if (im === re) {\n          this.data.fill(im);\n        } else {\n          for (var i = 0; i < this.data.length; i++) {\n            this.data[i] = i % 2 === 0 ? im : re;\n          }\n        }\n        break;\n      case 13:\n        this.data.fill(caml_packFloat16(v));\n        break;\n      default:\n        this.data.fill(v);\n        break;\n    }\n  }\n\n  compare(b, total) {\n    if (this.layout !== b.layout || this.kind !== b.kind) {\n      var k1 = this.kind | (this.layout << 8);\n      var k2 = b.kind | (b.layout << 8);\n      return k2 - k1;\n    }\n    if (this.dims.length !== b.dims.length) {\n      return b.dims.length - this.dims.length;\n    }\n    for (var i = 0; i < this.dims.length; i++)\n      if (this.dims[i] !== b.dims[i]) return this.dims[i] < b.dims[i] ? -1 : 1;\n    switch (this.kind) {\n      case 0:\n      case 1:\n      case 10:\n      case 11:\n        // Floats\n        var x, y;\n        for (var i = 0; i < this.data.length; i++) {\n          x = this.data[i];\n          y = b.data[i];\n          if (x < y) return -1;\n          if (x > y) return 1;\n          if (x !== y) {\n            if (!total) return Number.NaN;\n            if (!Number.isNaN(x)) return 1;\n            if (!Number.isNaN(y)) return -1;\n          }\n        }\n        break;\n      case 7:\n        // Int64\n        for (var i = 0; i < this.data.length; i += 2) {\n          // Check highest bits first\n          if (this.data[i + 1] < b.data[i + 1]) return -1;\n          if (this.data[i + 1] > b.data[i + 1]) return 1;\n          if (this.data[i] >>> 0 < b.data[i] >>> 0) return -1;\n          if (this.data[i] >>> 0 > b.data[i] >>> 0) return 1;\n        }\n        break;\n      case 13:\n        for (var i = 0; i < this.data.length; i++) {\n          var aa = caml_unpackFloat16(this.data[i]);\n          var bb = caml_unpackFloat16(b.data[i]);\n          if (aa < bb) return -1;\n          if (aa > bb) return 1;\n        }\n        break;\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 8:\n      case 9:\n      case 12:\n        for (var i = 0; i < this.data.length; i++) {\n          if (this.data[i] < b.data[i]) return -1;\n          if (this.data[i] > b.data[i]) return 1;\n        }\n        break;\n    }\n    return 0;\n  }\n}\n\n//Provides: Ml_Bigarray_c_1_1\n//Requires: Ml_Bigarray, caml_array_bound_error, caml_invalid_argument\nclass Ml_Bigarray_c_1_1 extends Ml_Bigarray {\n  offset(arg) {\n    if (typeof arg !== \"number\") {\n      if (Array.isArray(arg) && arg.length === 1) arg = arg[0];\n      else caml_invalid_argument(\"Ml_Bigarray_c_1_1.offset\");\n    }\n    if (arg < 0 || arg >= this.dims[0]) caml_array_bound_error();\n    return arg;\n  }\n\n  get(ofs) {\n    return this.data[ofs];\n  }\n\n  set(ofs, v) {\n    this.data[ofs] = v;\n    return 0;\n  }\n\n  fill(v) {\n    this.data.fill(v);\n    return 0;\n  }\n}\n\n//Provides: caml_ba_compare\nfunction caml_ba_compare(a, b, total) {\n  return a.compare(b, total);\n}\n\n//Provides: caml_ba_create_unsafe\n//Requires: Ml_Bigarray, Ml_Bigarray_c_1_1, caml_ba_get_size, caml_ba_get_size_per_element\n//Requires: caml_invalid_argument\nfunction caml_ba_create_unsafe(kind, layout, dims, data) {\n  var size_per_element = caml_ba_get_size_per_element(kind);\n  if (caml_ba_get_size(dims) * size_per_element !== data.length) {\n    caml_invalid_argument(\"length doesn't match dims\");\n  }\n  if (\n    layout === 0 && // c_layout\n    dims.length === 1 && // Array1\n    size_per_element === 1 &&\n    kind !== 13 // float16\n  )\n    // 1-to-1 mapping\n    return new Ml_Bigarray_c_1_1(kind, layout, dims, data);\n  return new Ml_Bigarray(kind, layout, dims, data);\n}\n\n//Provides: caml_ba_create\n//Requires: caml_js_from_array\n//Requires: caml_ba_get_size, caml_ba_create_unsafe\n//Requires: caml_ba_create_buffer\nfunction caml_ba_create(kind, layout, dims_ml) {\n  var dims = caml_js_from_array(dims_ml);\n  var data = caml_ba_create_buffer(kind, caml_ba_get_size(dims));\n  return caml_ba_create_unsafe(kind, layout, dims, data);\n}\n\n//Provides: caml_ba_change_layout\n//Requires: caml_ba_create_unsafe\nfunction caml_ba_change_layout(ba, layout) {\n  if (ba.layout === layout) return ba;\n  var new_dims = [];\n  for (var i = 0; i < ba.dims.length; i++)\n    new_dims[i] = ba.dims[ba.dims.length - i - 1];\n  return caml_ba_create_unsafe(ba.kind, layout, new_dims, ba.data);\n}\n\n//Provides: caml_ba_kind\nfunction caml_ba_kind(ba) {\n  return ba.kind;\n}\n\n//Provides: caml_ba_layout\nfunction caml_ba_layout(ba) {\n  return ba.layout;\n}\n\n//Provides: caml_ba_num_dims\nfunction caml_ba_num_dims(ba) {\n  return ba.dims.length;\n}\n\n//Provides: caml_ba_dim\n//Requires: caml_invalid_argument\nfunction caml_ba_dim(ba, i) {\n  if (i < 0 || i >= ba.dims.length) caml_invalid_argument(\"Bigarray.dim\");\n  return ba.dims[i];\n}\n\n//Provides: caml_ba_dim_1\n//Requires: caml_ba_dim\nfunction caml_ba_dim_1(ba) {\n  return caml_ba_dim(ba, 0);\n}\n\n//Provides: caml_ba_dim_2\n//Requires: caml_ba_dim\nfunction caml_ba_dim_2(ba) {\n  return caml_ba_dim(ba, 1);\n}\n\n//Provides: caml_ba_dim_3\n//Requires: caml_ba_dim\nfunction caml_ba_dim_3(ba) {\n  return caml_ba_dim(ba, 2);\n}\n\n//Provides: caml_ba_get_generic\n//Requires: caml_js_from_array\nfunction caml_ba_get_generic(ba, i) {\n  var ofs = ba.offset(caml_js_from_array(i));\n  return ba.get(ofs);\n}\n\n//Provides: caml_ba_uint8_get16\n//Requires: caml_array_bound_error\nfunction caml_ba_uint8_get16(ba, i0) {\n  var ofs = ba.offset(i0);\n  if (ofs + 1 >= ba.data.length) caml_array_bound_error();\n  var b1 = ba.get(ofs);\n  var b2 = ba.get(ofs + 1);\n  return b1 | (b2 << 8);\n}\n\n//Provides: caml_ba_uint8_get32\n//Requires: caml_array_bound_error\nfunction caml_ba_uint8_get32(ba, i0) {\n  var ofs = ba.offset(i0);\n  if (ofs + 3 >= ba.data.length) caml_array_bound_error();\n  var b1 = ba.get(ofs + 0);\n  var b2 = ba.get(ofs + 1);\n  var b3 = ba.get(ofs + 2);\n  var b4 = ba.get(ofs + 3);\n  return (b1 << 0) | (b2 << 8) | (b3 << 16) | (b4 << 24);\n}\n\n//Provides: caml_ba_uint8_get64\n//Requires: caml_array_bound_error, caml_int64_of_bytes\nfunction caml_ba_uint8_get64(ba, i0) {\n  var ofs = ba.offset(i0);\n  if (ofs + 7 >= ba.data.length) caml_array_bound_error();\n  var b1 = ba.get(ofs + 0);\n  var b2 = ba.get(ofs + 1);\n  var b3 = ba.get(ofs + 2);\n  var b4 = ba.get(ofs + 3);\n  var b5 = ba.get(ofs + 4);\n  var b6 = ba.get(ofs + 5);\n  var b7 = ba.get(ofs + 6);\n  var b8 = ba.get(ofs + 7);\n  return caml_int64_of_bytes([b8, b7, b6, b5, b4, b3, b2, b1]);\n}\n\n//Provides: caml_ba_get_1\nfunction caml_ba_get_1(ba, i0) {\n  return ba.get(ba.offset(i0));\n}\n\n//Provides: caml_ba_get_2\nfunction caml_ba_get_2(ba, i0, i1) {\n  return ba.get(ba.offset([i0, i1]));\n}\n\n//Provides: caml_ba_get_3\nfunction caml_ba_get_3(ba, i0, i1, i2) {\n  return ba.get(ba.offset([i0, i1, i2]));\n}\n\n//Provides: caml_ba_set_generic\n//Requires: caml_js_from_array\nfunction caml_ba_set_generic(ba, i, v) {\n  ba.set(ba.offset(caml_js_from_array(i)), v);\n  return 0;\n}\n\n//Provides: caml_ba_uint8_set16\n//Requires: caml_array_bound_error\nfunction caml_ba_uint8_set16(ba, i0, v) {\n  var ofs = ba.offset(i0);\n  if (ofs + 1 >= ba.data.length) caml_array_bound_error();\n  ba.set(ofs + 0, v & 0xff);\n  ba.set(ofs + 1, (v >>> 8) & 0xff);\n  return 0;\n}\n\n//Provides: caml_ba_uint8_set32\n//Requires: caml_array_bound_error\nfunction caml_ba_uint8_set32(ba, i0, v) {\n  var ofs = ba.offset(i0);\n  if (ofs + 3 >= ba.data.length) caml_array_bound_error();\n  ba.set(ofs + 0, v & 0xff);\n  ba.set(ofs + 1, (v >>> 8) & 0xff);\n  ba.set(ofs + 2, (v >>> 16) & 0xff);\n  ba.set(ofs + 3, (v >>> 24) & 0xff);\n  return 0;\n}\n\n//Provides: caml_ba_uint8_set64\n//Requires: caml_array_bound_error, caml_int64_to_bytes\nfunction caml_ba_uint8_set64(ba, i0, v) {\n  var ofs = ba.offset(i0);\n  if (ofs + 7 >= ba.data.length) caml_array_bound_error();\n  var v = caml_int64_to_bytes(v);\n  for (var i = 0; i < 8; i++) ba.set(ofs + i, v[7 - i]);\n  return 0;\n}\n\n//Provides: caml_ba_set_1\nfunction caml_ba_set_1(ba, i0, v) {\n  ba.set(ba.offset(i0), v);\n  return 0;\n}\n\n//Provides: caml_ba_set_2\nfunction caml_ba_set_2(ba, i0, i1, v) {\n  ba.set(ba.offset([i0, i1]), v);\n  return 0;\n}\n\n//Provides: caml_ba_set_3\nfunction caml_ba_set_3(ba, i0, i1, i2, v) {\n  ba.set(ba.offset([i0, i1, i2]), v);\n  return 0;\n}\n\n//Provides: caml_ba_fill\nfunction caml_ba_fill(ba, v) {\n  ba.fill(v);\n  return 0;\n}\n\n//Provides: caml_ba_blit\n//Requires: caml_invalid_argument\nfunction caml_ba_blit(src, dst) {\n  if (dst.dims.length !== src.dims.length)\n    caml_invalid_argument(\"Bigarray.blit: dimension mismatch\");\n  for (var i = 0; i < dst.dims.length; i++)\n    if (dst.dims[i] !== src.dims[i])\n      caml_invalid_argument(\"Bigarray.blit: dimension mismatch\");\n  dst.data.set(src.data);\n  return 0;\n}\n\n//Provides: caml_ba_sub\n//Requires: caml_invalid_argument, caml_ba_create_unsafe, caml_ba_get_size\n//Requires: caml_ba_get_size_per_element\nfunction caml_ba_sub(ba, ofs, len) {\n  var changed_dim;\n  var mul = 1;\n  if (ba.layout === 0) {\n    for (var i = 1; i < ba.dims.length; i++) mul = mul * ba.dims[i];\n    changed_dim = 0;\n  } else {\n    for (var i = 0; i < ba.dims.length - 1; i++) mul = mul * ba.dims[i];\n    changed_dim = ba.dims.length - 1;\n    ofs = ofs - 1;\n  }\n  if (ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim]) {\n    caml_invalid_argument(\"Bigarray.sub: bad sub-array\");\n  }\n  var new_dims = [];\n  for (var i = 0; i < ba.dims.length; i++) new_dims[i] = ba.dims[i];\n  new_dims[changed_dim] = len;\n  mul *= caml_ba_get_size_per_element(ba.kind);\n  var new_data = ba.data.subarray(ofs * mul, (ofs + len) * mul);\n  return caml_ba_create_unsafe(ba.kind, ba.layout, new_dims, new_data);\n}\n\n//Provides: caml_ba_slice\n//Requires: caml_js_from_array, caml_ba_create_unsafe, caml_invalid_argument, caml_ba_get_size\n//Requires: caml_ba_get_size_per_element\nfunction caml_ba_slice(ba, vind) {\n  vind = caml_js_from_array(vind);\n  var num_inds = vind.length;\n  var index = [];\n  var sub_dims = [];\n  var ofs;\n\n  if (num_inds > ba.dims.length)\n    caml_invalid_argument(\"Bigarray.slice: too many indices\");\n\n  // Compute offset and check bounds\n  if (ba.layout === 0) {\n    for (var i = 0; i < num_inds; i++) index[i] = vind[i];\n    for (; i < ba.dims.length; i++) index[i] = 0;\n    sub_dims = ba.dims.slice(num_inds);\n  } else {\n    for (var i = 0; i < num_inds; i++)\n      index[ba.dims.length - num_inds + i] = vind[i];\n    for (var i = 0; i < ba.dims.length - num_inds; i++) index[i] = 1;\n    sub_dims = ba.dims.slice(0, ba.dims.length - num_inds);\n  }\n  ofs = ba.offset(index);\n  var size = caml_ba_get_size(sub_dims);\n  var size_per_element = caml_ba_get_size_per_element(ba.kind);\n  var new_data = ba.data.subarray(\n    ofs * size_per_element,\n    (ofs + size) * size_per_element,\n  );\n  return caml_ba_create_unsafe(ba.kind, ba.layout, sub_dims, new_data);\n}\n\n//Provides: caml_ba_reshape\n//Requires: caml_js_from_array, caml_invalid_argument, caml_ba_create_unsafe, caml_ba_get_size\nfunction caml_ba_reshape(ba, vind) {\n  vind = caml_js_from_array(vind);\n  var new_dim = [];\n  var num_dims = vind.length;\n\n  if (num_dims < 0 || num_dims > 16) {\n    caml_invalid_argument(\"Bigarray.reshape: bad number of dimensions\");\n  }\n  var num_elts = 1;\n  for (var i = 0; i < num_dims; i++) {\n    new_dim[i] = vind[i];\n    if (new_dim[i] < 0)\n      caml_invalid_argument(\"Bigarray.reshape: negative dimension\");\n    num_elts = num_elts * new_dim[i];\n  }\n\n  var size = caml_ba_get_size(ba.dims);\n  // Check that sizes agree\n  if (num_elts !== size)\n    caml_invalid_argument(\"Bigarray.reshape: size mismatch\");\n  return caml_ba_create_unsafe(ba.kind, ba.layout, new_dim, ba.data);\n}\n\n//Provides: caml_ba_serialize\n//Requires: caml_int64_bits_of_float, caml_int64_to_bytes\n//Requires: caml_int32_bits_of_float\n//Requires: caml_packFloat16\nfunction caml_ba_serialize(writer, ba, sz) {\n  writer.write(32, ba.dims.length);\n  writer.write(32, ba.kind | (ba.layout << 8));\n  if (ba.caml_custom === \"_bigarr02\")\n    for (var i = 0; i < ba.dims.length; i++) {\n      if (ba.dims[i] < 0xffff) writer.write(16, ba.dims[i]);\n      else {\n        writer.write(16, 0xffff);\n        writer.write(32, 0);\n        writer.write(32, ba.dims[i]);\n      }\n    }\n  else for (var i = 0; i < ba.dims.length; i++) writer.write(32, ba.dims[i]);\n  switch (ba.kind) {\n    case 2: //Int8Array\n    case 3: //Uint8Array\n    case 12: //Uint8Array\n      for (var i = 0; i < ba.data.length; i++) {\n        writer.write(8, ba.data[i]);\n      }\n      break;\n    case 4: // Int16Array\n    case 5: // Uint16Array\n      for (var i = 0; i < ba.data.length; i++) {\n        writer.write(16, ba.data[i]);\n      }\n      break;\n    case 6: // Int32Array (int32)\n      for (var i = 0; i < ba.data.length; i++) {\n        writer.write(32, ba.data[i]);\n      }\n      break;\n    case 8: // Int32Array (int)\n    case 9: // Int32Array (nativeint)\n      writer.write(8, 0);\n      for (var i = 0; i < ba.data.length; i++) {\n        writer.write(32, ba.data[i]);\n      }\n      break;\n    case 7: // Int32Array (int64)\n      for (var i = 0; i < ba.data.length / 2; i++) {\n        var b = caml_int64_to_bytes(ba.get(i));\n        for (var j = 0; j < 8; j++) writer.write(8, b[j]);\n      }\n      break;\n    case 1: // Float64Array\n      for (var i = 0; i < ba.data.length; i++) {\n        var b = caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));\n        for (var j = 0; j < 8; j++) writer.write(8, b[j]);\n      }\n      break;\n    case 13: // Float16Array\n      for (var i = 0; i < ba.data.length; i++) {\n        writer.write(16, ba.data[i]);\n      }\n      break;\n    case 0: // Float32Array\n      for (var i = 0; i < ba.data.length; i++) {\n        var b = caml_int32_bits_of_float(ba.get(i));\n        writer.write(32, b);\n      }\n      break;\n    case 10: // Float32Array (complex32)\n      for (var i = 0; i < ba.data.length / 2; i++) {\n        var j = ba.get(i);\n        writer.write(32, caml_int32_bits_of_float(j[1]));\n        writer.write(32, caml_int32_bits_of_float(j[2]));\n      }\n      break;\n    case 11: // Float64Array (complex64)\n      for (var i = 0; i < ba.data.length / 2; i++) {\n        var complex = ba.get(i);\n        var b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));\n        for (var j = 0; j < 8; j++) writer.write(8, b[j]);\n        var b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));\n        for (var j = 0; j < 8; j++) writer.write(8, b[j]);\n      }\n      break;\n  }\n  sz[0] = (4 + ba.dims.length) * 4;\n  sz[1] = (4 + ba.dims.length) * 8;\n}\n\n//Provides: caml_ba_deserialize\n//Requires: caml_ba_create_unsafe, caml_failwith\n//Requires: caml_ba_get_size\n//Requires: caml_int64_of_bytes, caml_int64_float_of_bits\n//Requires: caml_int32_float_of_bits\n//Requires: caml_ba_create_buffer\n//Requires: caml_unpackFloat16\nfunction caml_ba_deserialize(reader, sz, name) {\n  var num_dims = reader.read32s();\n  if (num_dims < 0 || num_dims > 16)\n    caml_failwith(\"input_value: wrong number of bigarray dimensions\");\n  var tag = reader.read32s();\n  var kind = tag & 0xff;\n  var layout = (tag >> 8) & 1;\n  var dims = [];\n  if (name === \"_bigarr02\")\n    for (var i = 0; i < num_dims; i++) {\n      var size_dim = reader.read16u();\n      if (size_dim === 0xffff) {\n        var size_dim_hi = reader.read32u();\n        var size_dim_lo = reader.read32u();\n        if (size_dim_hi !== 0)\n          caml_failwith(\"input_value: bigarray dimension overflow in 32bit\");\n        size_dim = size_dim_lo;\n      }\n      dims.push(size_dim);\n    }\n  else for (var i = 0; i < num_dims; i++) dims.push(reader.read32u());\n  var size = caml_ba_get_size(dims);\n  var data = caml_ba_create_buffer(kind, size);\n  var ba = caml_ba_create_unsafe(kind, layout, dims, data);\n  switch (kind) {\n    case 2: //Int8Array\n      for (var i = 0; i < size; i++) {\n        data[i] = reader.read8s();\n      }\n      break;\n    case 3: //Uint8Array\n    case 12: //Uint8Array\n      for (var i = 0; i < size; i++) {\n        data[i] = reader.read8u();\n      }\n      break;\n    case 4: // Int16Array\n      for (var i = 0; i < size; i++) {\n        data[i] = reader.read16s();\n      }\n      break;\n    case 5: // Uint16Array\n      for (var i = 0; i < size; i++) {\n        data[i] = reader.read16u();\n      }\n      break;\n    case 6: // Int32Array (int32)\n      for (var i = 0; i < size; i++) {\n        data[i] = reader.read32s();\n      }\n      break;\n    case 8: // Int32Array (int)\n    case 9: // Int32Array (nativeint)\n      var sixty = reader.read8u();\n      if (sixty)\n        caml_failwith(\n          \"input_value: cannot read bigarray with 64-bit OCaml ints\",\n        );\n      for (var i = 0; i < size; i++) {\n        data[i] = reader.read32s();\n      }\n      break;\n    case 7: // (int64)\n      var t = new Array(8);\n      for (var i = 0; i < size; i++) {\n        for (var j = 0; j < 8; j++) t[j] = reader.read8u();\n        var int64 = caml_int64_of_bytes(t);\n        ba.set(i, int64);\n      }\n      break;\n    case 1: // Float64Array\n      var t = new Array(8);\n      for (var i = 0; i < size; i++) {\n        for (var j = 0; j < 8; j++) t[j] = reader.read8u();\n        var f = caml_int64_float_of_bits(caml_int64_of_bytes(t));\n        ba.set(i, f);\n      }\n      break;\n    case 13: // Float16Array\n      for (var i = 0; i < size; i++) {\n        data[i] = reader.read16u();\n      }\n      break;\n    case 0: // Float32Array\n      for (var i = 0; i < size; i++) {\n        var f = caml_int32_float_of_bits(reader.read32s());\n        ba.set(i, f);\n      }\n      break;\n    case 10: // Float32Array (complex32)\n      for (var i = 0; i < size; i++) {\n        var re = caml_int32_float_of_bits(reader.read32s());\n        var im = caml_int32_float_of_bits(reader.read32s());\n        ba.set(i, [254, re, im]);\n      }\n      break;\n    case 11: // Float64Array (complex64)\n      var t = new Array(8);\n      for (var i = 0; i < size; i++) {\n        for (var j = 0; j < 8; j++) t[j] = reader.read8u();\n        var re = caml_int64_float_of_bits(caml_int64_of_bytes(t));\n        for (var j = 0; j < 8; j++) t[j] = reader.read8u();\n        var im = caml_int64_float_of_bits(caml_int64_of_bytes(t));\n        ba.set(i, [254, re, im]);\n      }\n      break;\n  }\n  sz[0] = (4 + num_dims) * 4;\n  return caml_ba_create_unsafe(kind, layout, dims, data);\n}\n\n//Provides: caml_ba_create_from\n//Requires: caml_ba_create_unsafe, caml_invalid_argument, caml_ba_get_size_per_element\n//Deprecated: Use [caml_ba_create_unsafe] instead\nfunction caml_ba_create_from(data1, data2, _jstyp, kind, layout, dims) {\n  if (data2 || caml_ba_get_size_per_element(kind) === 2) {\n    caml_invalid_argument(\n      \"caml_ba_create_from: use return caml_ba_create_unsafe\",\n    );\n  }\n  return caml_ba_create_unsafe(kind, layout, dims, data1);\n}\n\n//Provides: caml_ba_hash const\n//Requires: caml_ba_get_size, caml_hash_mix_int, caml_hash_mix_float\n//Requires: caml_unpackFloat16, caml_hash_mix_float16, caml_hash_mix_float32\nfunction caml_ba_hash(ba) {\n  var num_elts = caml_ba_get_size(ba.dims);\n  var h = 0;\n  switch (ba.kind) {\n    case 2: //Int8Array\n    case 3: //Uint8Array\n    case 12: //Uint8Array\n      if (num_elts > 256) num_elts = 256;\n      var w = 0,\n        i = 0;\n      for (i = 0; i + 4 <= num_elts; i += 4) {\n        w =\n          (ba.data[i + 0] & 0xff) |\n          ((ba.data[i + 1] & 0xff) << 8) |\n          ((ba.data[i + 2] & 0xff) << 16) |\n          (ba.data[i + 3] << 24);\n        h = caml_hash_mix_int(h, w);\n      }\n      w = 0;\n      switch (num_elts & 3) {\n        case 3:\n          // biome-ignore lint/suspicious/noFallthroughSwitchClause:\n          w = ba.data[i + 2] << 16;\n        // fallthrough\n        case 2:\n          // biome-ignore lint/suspicious/noFallthroughSwitchClause:\n          w |= ba.data[i + 1] << 8;\n        // fallthrough\n        case 1:\n          w |= ba.data[i + 0];\n          h = caml_hash_mix_int(h, w);\n      }\n      break;\n    case 4: // Int16Array\n    case 5: // Uint16Array\n      if (num_elts > 128) num_elts = 128;\n      var w = 0,\n        i = 0;\n      for (i = 0; i + 2 <= num_elts; i += 2) {\n        w = (ba.data[i + 0] & 0xffff) | (ba.data[i + 1] << 16);\n        h = caml_hash_mix_int(h, w);\n      }\n      if ((num_elts & 1) !== 0) h = caml_hash_mix_int(h, ba.data[i]);\n      break;\n    case 6: // Int32Array (int32)\n      if (num_elts > 64) num_elts = 64;\n      for (var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);\n      break;\n    case 8: // Int32Array (int)\n    case 9: // Int32Array (nativeint)\n      if (num_elts > 64) num_elts = 64;\n      for (var i = 0; i < num_elts; i++) h = caml_hash_mix_int(h, ba.data[i]);\n      break;\n    case 7: // Int32Array (int64)\n      if (num_elts > 32) num_elts = 32;\n      num_elts *= 2;\n      for (var i = 0; i < num_elts; i++) {\n        h = caml_hash_mix_int(h, ba.data[i]);\n      }\n      break;\n    case 10: // Float32Array (complex32)\n      // biome-ignore lint/suspicious/noFallthroughSwitchClause:\n      num_elts *= 2;\n    // fallthrough\n    case 0: // Float32Array\n      if (num_elts > 64) num_elts = 64;\n      for (var i = 0; i < num_elts; i++)\n        h = caml_hash_mix_float32(h, ba.data[i]);\n      break;\n    case 11: // Float64Array (complex64)\n      // biome-ignore lint/suspicious/noFallthroughSwitchClause:\n      num_elts *= 2;\n    // fallthrough\n    case 1: // Float64Array\n      if (num_elts > 32) num_elts = 32;\n      for (var i = 0; i < num_elts; i++) h = caml_hash_mix_float(h, ba.data[i]);\n      break;\n    case 13:\n      if (num_elts > 128) num_elts = 128;\n      for (var i = 0; i < num_elts; i++) {\n        h = caml_hash_mix_float16(h, ba.data[i]);\n      }\n      break;\n  }\n  return h;\n}\n\n//Provides: caml_hash_mix_float16\n//Requires: caml_hash_mix_int\nfunction caml_hash_mix_float16(hash, d) {\n  /* Normalize NaNs */\n  if ((d & 0x7c00) === 0x7c00 && (d & 0x03ff) !== 0) {\n    d = 0x7c01;\n  } else if (d === 0x8000) {\n    /* Normalize -0 into +0 */\n    d = 0;\n  }\n  return caml_hash_mix_int(hash, d);\n}\n\n//Provides: caml_hash_mix_float32\n//Requires: caml_int32_bits_of_float\n//Requires: caml_hash_mix_int\nfunction caml_hash_mix_float32(hash, v) {\n  var i = caml_int32_bits_of_float(v);\n  /* Normalize NaNs */\n  if ((i & 0x7f800000) === 0x7f800000 && (i & 0x7fffff) !== 0) {\n    i = 0x7f800001;\n  } else if (i === (0x80000000 | 0)) {\n    /* Normalize -0 into +0 */\n    // This code path is not used by caml_hash because 0 and -0 look\n    // like integers\n    i = 0;\n  }\n  hash = caml_hash_mix_int(hash, i);\n  return hash;\n}\n\n//Provides: caml_ba_to_typed_array mutable\nfunction caml_ba_to_typed_array(ba) {\n  return ba.data;\n}\n\n//Provides: caml_ba_kind_of_typed_array mutable\n//Requires: caml_invalid_argument\nfunction caml_ba_kind_of_typed_array(ta) {\n  var kind;\n  if (ta instanceof Float32Array) kind = 0;\n  else if (ta instanceof Float64Array) kind = 1;\n  else if (ta instanceof Int8Array) kind = 2;\n  else if (ta instanceof Uint8Array) kind = 3;\n  else if (ta instanceof Uint8ClampedArray) kind = 3;\n  else if (ta instanceof Int16Array) kind = 4;\n  else if (ta instanceof Uint16Array) kind = 5;\n  else if (ta instanceof Int32Array) kind = 6;\n  else if (ta instanceof Uint32Array) kind = 6;\n  else caml_invalid_argument(\"caml_ba_kind_of_typed_array: unsupported kind\");\n  return kind;\n}\n\n//Provides: caml_ba_from_typed_array mutable\n//Requires: caml_ba_kind_of_typed_array\n//Requires: caml_ba_create_unsafe\nfunction caml_ba_from_typed_array(ta) {\n  var kind = caml_ba_kind_of_typed_array(ta);\n  var ta =\n    /* Needed to avoid unsigned setters overflowing\n         the range of OCaml [int32] values. */\n    ta instanceof Uint32Array\n      ? new Int32Array(ta.buffer, ta.byteOffset, ta.length)\n      : ta;\n  return caml_ba_create_unsafe(kind, 0, [ta.length], ta);\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: caml_format_int const (const, const)\n//Requires: caml_parse_format, caml_finish_formatting, caml_str_repeat\n//Requires: caml_string_of_jsbytes, caml_jsbytes_of_string\n//Alias: caml_int32_format\n//Alias: caml_nativeint_format\nfunction caml_format_int(fmt, i) {\n  if (caml_jsbytes_of_string(fmt) === \"%d\")\n    return caml_string_of_jsbytes(\"\" + i);\n  var f = caml_parse_format(fmt);\n  if (i < 0) {\n    if (f.signedconv) {\n      f.sign = -1;\n      i = -i;\n    } else i >>>= 0;\n  }\n  var s = i.toString(f.base);\n  if (f.prec >= 0) {\n    f.filler = \" \";\n    var n = f.prec - s.length;\n    if (n > 0) s = caml_str_repeat(n, \"0\") + s;\n  }\n  return caml_finish_formatting(f, s);\n}\n\n//Provides: caml_parse_sign_and_base\n//Requires: caml_string_unsafe_get, caml_ml_string_length\nfunction caml_parse_sign_and_base(s) {\n  var i = 0,\n    len = caml_ml_string_length(s),\n    base = 10,\n    sign = 1,\n    signedness = 1;\n  if (len > 0) {\n    switch (caml_string_unsafe_get(s, i)) {\n      case 45:\n        i++;\n        sign = -1;\n        break;\n      case 43:\n        i++;\n        sign = 1;\n        break;\n    }\n  }\n  if (i + 1 < len && caml_string_unsafe_get(s, i) === 48)\n    switch (caml_string_unsafe_get(s, i + 1)) {\n      case 120:\n      case 88:\n        signedness = 0;\n        base = 16;\n        i += 2;\n        break;\n      case 111:\n      case 79:\n        signedness = 0;\n        base = 8;\n        i += 2;\n        break;\n      case 98:\n      case 66:\n        signedness = 0;\n        base = 2;\n        i += 2;\n        break;\n      case 117:\n      case 85:\n        signedness = 0;\n        i += 2;\n        break;\n    }\n  return [i, sign, base, signedness];\n}\n\n//Provides: caml_parse_digit\nfunction caml_parse_digit(c) {\n  if (c >= 48 && c <= 57) return c - 48;\n  if (c >= 65 && c <= 90) return c - 55;\n  if (c >= 97 && c <= 122) return c - 87;\n  return -1;\n}\n\n//Provides: caml_int_of_string (const)\n//Requires: caml_ml_string_length, caml_string_unsafe_get\n//Requires: caml_parse_sign_and_base, caml_parse_digit, caml_failwith\n//Alias: caml_int32_of_string\n//Alias: caml_nativeint_of_string\nfunction caml_int_of_string(s) {\n  var r = caml_parse_sign_and_base(s);\n  var i = r[0],\n    sign = r[1],\n    base = r[2],\n    signedness = r[3];\n  var len = caml_ml_string_length(s);\n  var threshold = -1 >>> 0;\n  var c = i < len ? caml_string_unsafe_get(s, i) : 0;\n  var d = caml_parse_digit(c);\n  if (d < 0 || d >= base) caml_failwith(\"int_of_string\");\n  var res = d;\n  for (i++; i < len; i++) {\n    c = caml_string_unsafe_get(s, i);\n    if (c === 95) continue;\n    d = caml_parse_digit(c);\n    if (d < 0 || d >= base) break;\n    res = base * res + d;\n    if (res > threshold) caml_failwith(\"int_of_string\");\n  }\n  if (i !== len) caml_failwith(\"int_of_string\");\n  // For base different from 10, we expect an unsigned representation,\n  // hence any value of 'res' (less than 'threshold') is acceptable.\n  // But we have to convert the result back to a signed integer.\n  res = sign * res;\n  if (signedness && (res | 0) !== res)\n    /* Signed representation expected, allow -2^(nbits-1) to 2^(nbits-1) - 1 */\n    caml_failwith(\"int_of_string\");\n  return res | 0;\n}\n\n//Provides: caml_mul const\n//Alias: caml_int32_mul\n//Alias: caml_nativeint_mul\n//Alias: %int_mul\nfunction caml_mul(a, b) {\n  return Math.imul(a, b);\n}\n\n//Provides: caml_div\n//Requires: caml_raise_zero_divide\n//Alias: caml_int32_div\n//Alias: caml_nativeint_div\n//Alias: %int_div\nfunction caml_div(x, y) {\n  if (y === 0) caml_raise_zero_divide();\n  return (x / y) | 0;\n}\n\n//Provides: caml_mod\n//Requires: caml_raise_zero_divide\n//Alias: caml_int32_mod\n//Alias: caml_nativeint_mod\n//Alias: %int_mod\nfunction caml_mod(x, y) {\n  if (y === 0) caml_raise_zero_divide();\n  return x % y;\n}\n\n//Provides: caml_bswap16 const\nfunction caml_bswap16(x) {\n  return ((x & 0x00ff) << 8) | ((x & 0xff00) >> 8);\n}\n\n//Provides: caml_int32_bswap const\n//Alias: caml_nativeint_bswap\nfunction caml_int32_bswap(x) {\n  return (\n    ((x & 0x000000ff) << 24) |\n    ((x & 0x0000ff00) << 8) |\n    ((x & 0x00ff0000) >>> 8) |\n    ((x & 0xff000000) >>> 24)\n  );\n}\n//Provides: caml_int64_bswap const\n//Requires: caml_int64_to_bytes, caml_int64_of_bytes\nfunction caml_int64_bswap(x) {\n  var y = caml_int64_to_bytes(x);\n  return caml_int64_of_bytes([y[7], y[6], y[5], y[4], y[3], y[2], y[1], y[0]]);\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Hashtbl\n\n//function ROTL32(x,n) { return ((x << n) | (x >>> (32-n))); }\n//Provides: caml_hash_mix_int\n//Requires: caml_mul\nfunction caml_hash_mix_int(h, d) {\n  d = caml_mul(d, 0xcc9e2d51 | 0);\n  d = (d << 15) | (d >>> (32 - 15)); // ROTL32(d, 15);\n  d = caml_mul(d, 0x1b873593);\n  h ^= d;\n  h = (h << 13) | (h >>> (32 - 13)); //ROTL32(h, 13);\n  return (((h + (h << 2)) | 0) + (0xe6546b64 | 0)) | 0;\n}\n\n//Provides: caml_hash_mix_final\n//Requires: caml_mul\nfunction caml_hash_mix_final(h) {\n  h ^= h >>> 16;\n  h = caml_mul(h, 0x85ebca6b | 0);\n  h ^= h >>> 13;\n  h = caml_mul(h, 0xc2b2ae35 | 0);\n  h ^= h >>> 16;\n  return h;\n}\n\n//Provides: caml_hash_mix_float\n//Requires: caml_int64_bits_of_float\n//Requires: caml_hash_mix_int\n//Requires: caml_int64_lo32, caml_int64_hi32\nfunction caml_hash_mix_float(hash, v0) {\n  var i64 = caml_int64_bits_of_float(v0);\n  var l = caml_int64_lo32(i64);\n  var h = caml_int64_hi32(i64);\n  /* Normalize NaNs */\n  if ((h & 0x7ff00000) === 0x7ff00000 && (l | (h & 0xfffff)) !== 0) {\n    h = 0x7ff00000;\n    l = 0x00000001;\n  } else if (h === (0x80000000 | 0) && l === 0) {\n    /* Normalize -0 into +0 */\n    // This code path is not used by caml_hash because 0 and -0 look\n    // like integers\n    h = 0;\n  }\n  hash = caml_hash_mix_int(hash, l);\n  hash = caml_hash_mix_int(hash, h);\n  return hash;\n}\n//Provides: caml_hash_mix_int64\n//Requires: caml_hash_mix_int\n//Requires: caml_int64_lo32, caml_int64_hi32\nfunction caml_hash_mix_int64(h, v) {\n  h = caml_hash_mix_int(h, caml_int64_lo32(v));\n  h = caml_hash_mix_int(h, caml_int64_hi32(v));\n  return h;\n}\n\n//Provides: caml_hash_mix_jsbytes\n//Requires: caml_hash_mix_int\nfunction caml_hash_mix_jsbytes(h, s) {\n  var len = s.length,\n    i,\n    w;\n  for (i = 0; i + 4 <= len; i += 4) {\n    w =\n      s.charCodeAt(i) |\n      (s.charCodeAt(i + 1) << 8) |\n      (s.charCodeAt(i + 2) << 16) |\n      (s.charCodeAt(i + 3) << 24);\n    h = caml_hash_mix_int(h, w);\n  }\n  w = 0;\n  switch (len & 3) {\n    case 3:\n      // biome-ignore lint/suspicious/noFallthroughSwitchClause:\n      w = s.charCodeAt(i + 2) << 16;\n    // fallthrough\n    case 2:\n      // biome-ignore lint/suspicious/noFallthroughSwitchClause:\n      w |= s.charCodeAt(i + 1) << 8;\n    // fallthrough\n    case 1:\n      w |= s.charCodeAt(i);\n      h = caml_hash_mix_int(h, w);\n  }\n  h ^= len;\n  return h;\n}\n\n//Provides: caml_hash_mix_bytes_arr\n//Requires: caml_hash_mix_int\nfunction caml_hash_mix_bytes_arr(h, s) {\n  var len = s.length,\n    i,\n    w;\n  for (i = 0; i + 4 <= len; i += 4) {\n    w = s[i] | (s[i + 1] << 8) | (s[i + 2] << 16) | (s[i + 3] << 24);\n    h = caml_hash_mix_int(h, w);\n  }\n  w = 0;\n  switch (len & 3) {\n    case 3:\n      // biome-ignore lint/suspicious/noFallthroughSwitchClause:\n      w = s[i + 2] << 16;\n    // fallthrough\n    case 2:\n      // biome-ignore lint/suspicious/noFallthroughSwitchClause:\n      w |= s[i + 1] << 8;\n    // fallthrough\n    case 1:\n      w |= s[i];\n      h = caml_hash_mix_int(h, w);\n  }\n  h ^= len;\n  return h;\n}\n\n//Provides: caml_hash_mix_bytes\n//Requires: caml_ml_bytes_content\n//Requires: caml_hash_mix_jsbytes\n//Requires: caml_hash_mix_bytes_arr\nfunction caml_hash_mix_bytes(h, v) {\n  var content = caml_ml_bytes_content(v);\n  if (typeof content === \"string\") return caml_hash_mix_jsbytes(h, content);\n  /* ARRAY */ else return caml_hash_mix_bytes_arr(h, content);\n}\n\n//Provides: caml_hash_mix_string\n//Requires: caml_hash_mix_jsbytes, caml_jsbytes_of_string\nfunction caml_hash_mix_string(h, v) {\n  return caml_hash_mix_jsbytes(h, caml_jsbytes_of_string(v));\n}\n\n//Provides: caml_hash mutable\n//Requires: caml_is_ml_string, caml_is_ml_bytes\n//Requires: caml_hash_mix_int, caml_hash_mix_final\n//Requires: caml_hash_mix_float, caml_hash_mix_string, caml_hash_mix_bytes, caml_custom_ops\n//Requires: caml_hash_mix_jsbytes\n//Requires: caml_is_continuation_tag\nfunction caml_hash(count, limit, seed, obj) {\n  var queue, rd, wr, sz, num, h, v, i, len;\n  sz = limit;\n  if (sz < 0 || sz > 256) sz = 256;\n  num = count;\n  h = seed;\n  queue = [obj];\n  rd = 0;\n  wr = 1;\n  while (rd < wr && num > 0) {\n    v = queue[rd++];\n    if (v?.caml_custom) {\n      if (\n        caml_custom_ops[v.caml_custom] &&\n        caml_custom_ops[v.caml_custom].hash\n      ) {\n        var hh = caml_custom_ops[v.caml_custom].hash(v);\n        h = caml_hash_mix_int(h, hh);\n        num--;\n      }\n    } else if (Array.isArray(v) && v[0] === (v[0] | 0)) {\n      switch (v[0]) {\n        case 248:\n          // Object\n          h = caml_hash_mix_int(h, v[2]);\n          num--;\n          break;\n        case 250:\n          // Forward\n          queue[--rd] = v[1];\n          break;\n        default:\n          if (caml_is_continuation_tag(v[0])) {\n            /* All continuations hash to the same value,\n             since we have no idea how to distinguish them. */\n            break;\n          }\n          var tag = ((v.length - 1) << 10) | v[0];\n          h = caml_hash_mix_int(h, tag);\n          for (i = 1, len = v.length; i < len; i++) {\n            if (wr >= sz) break;\n            queue[wr++] = v[i];\n          }\n          break;\n      }\n    } else if (caml_is_ml_bytes(v)) {\n      h = caml_hash_mix_bytes(h, v);\n      num--;\n    } else if (caml_is_ml_string(v)) {\n      h = caml_hash_mix_string(h, v);\n      num--;\n    } else if (typeof v === \"string\") {\n      h = caml_hash_mix_jsbytes(h, v);\n      num--;\n    } else if (v === (v | 0)) {\n      // Integer\n      h = caml_hash_mix_int(h, v + v + 1);\n      num--;\n    } else if (typeof v === \"number\") {\n      // Float\n      h = caml_hash_mix_float(h, v);\n      num--;\n    }\n  }\n  h = caml_hash_mix_final(h);\n  return h & 0x3fffffff;\n}\n\n//Provides: caml_string_hash\n//Requires: caml_hash_mix_final, caml_hash_mix_string\n//Version: >= 5.0\nfunction caml_string_hash(h, v) {\n  var h = caml_hash_mix_string(h, v);\n  var h = caml_hash_mix_final(h);\n  return h & 0x3fffffff;\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: caml_marshal_constants\nvar caml_marshal_constants = {\n  PREFIX_SMALL_BLOCK: 0x80,\n  PREFIX_SMALL_INT: 0x40,\n  PREFIX_SMALL_STRING: 0x20,\n  CODE_INT8: 0x00,\n  CODE_INT16: 0x01,\n  CODE_INT32: 0x02,\n  CODE_INT64: 0x03,\n  CODE_SHARED8: 0x04,\n  CODE_SHARED16: 0x05,\n  CODE_SHARED32: 0x06,\n  CODE_BLOCK32: 0x08,\n  CODE_BLOCK64: 0x13,\n  CODE_STRING8: 0x09,\n  CODE_STRING32: 0x0a,\n  CODE_DOUBLE_BIG: 0x0b,\n  CODE_DOUBLE_LITTLE: 0x0c,\n  CODE_DOUBLE_ARRAY8_BIG: 0x0d,\n  CODE_DOUBLE_ARRAY8_LITTLE: 0x0e,\n  CODE_DOUBLE_ARRAY32_BIG: 0x0f,\n  CODE_DOUBLE_ARRAY32_LITTLE: 0x07,\n  CODE_CODEPOINTER: 0x10,\n  CODE_INFIXPOINTER: 0x11,\n  CODE_CUSTOM: 0x12,\n  CODE_CUSTOM_LEN: 0x18,\n  CODE_CUSTOM_FIXED: 0x19,\n};\n\n//Provides: UInt8ArrayReader\n//Requires: caml_string_of_uint8_array\nclass UInt8ArrayReader {\n  constructor(s, i) {\n    this.s = s;\n    this.i = i;\n  }\n\n  read8u() {\n    return this.s[this.i++];\n  }\n\n  read8s() {\n    return (this.s[this.i++] << 24) >> 24;\n  }\n\n  read16u() {\n    var s = this.s,\n      i = this.i;\n    this.i = i + 2;\n    return (s[i] << 8) | s[i + 1];\n  }\n\n  read16s() {\n    var s = this.s,\n      i = this.i;\n    this.i = i + 2;\n    return ((s[i] << 24) >> 16) | s[i + 1];\n  }\n\n  read32u() {\n    var s = this.s,\n      i = this.i;\n    this.i = i + 4;\n    return ((s[i] << 24) | (s[i + 1] << 16) | (s[i + 2] << 8) | s[i + 3]) >>> 0;\n  }\n\n  read32s() {\n    var s = this.s,\n      i = this.i;\n    this.i = i + 4;\n    return (s[i] << 24) | (s[i + 1] << 16) | (s[i + 2] << 8) | s[i + 3];\n  }\n\n  readstr(len) {\n    var i = this.i;\n    this.i = i + len;\n    return caml_string_of_uint8_array(this.s.subarray(i, i + len));\n  }\n\n  readuint8array(len) {\n    var i = this.i;\n    this.i = i + len;\n    return this.s.subarray(i, i + len);\n  }\n}\n\n//Provides: JsStringReader\n//Requires: caml_string_of_jsbytes\nclass JsStringReader {\n  constructor(s, i) {\n    this.s = s;\n    this.i = i;\n  }\n\n  read8u() {\n    return this.s.charCodeAt(this.i++);\n  }\n\n  read8s() {\n    return (this.s.charCodeAt(this.i++) << 24) >> 24;\n  }\n\n  read16u() {\n    var s = this.s,\n      i = this.i;\n    this.i = i + 2;\n    return (s.charCodeAt(i) << 8) | s.charCodeAt(i + 1);\n  }\n\n  read16s() {\n    var s = this.s,\n      i = this.i;\n    this.i = i + 2;\n    return ((s.charCodeAt(i) << 24) >> 16) | s.charCodeAt(i + 1);\n  }\n\n  read32u() {\n    var s = this.s,\n      i = this.i;\n    this.i = i + 4;\n    return (\n      ((s.charCodeAt(i) << 24) |\n        (s.charCodeAt(i + 1) << 16) |\n        (s.charCodeAt(i + 2) << 8) |\n        s.charCodeAt(i + 3)) >>>\n      0\n    );\n  }\n\n  read32s() {\n    var s = this.s,\n      i = this.i;\n    this.i = i + 4;\n    return (\n      (s.charCodeAt(i) << 24) |\n      (s.charCodeAt(i + 1) << 16) |\n      (s.charCodeAt(i + 2) << 8) |\n      s.charCodeAt(i + 3)\n    );\n  }\n\n  readstr(len) {\n    var i = this.i;\n    this.i = i + len;\n    return caml_string_of_jsbytes(this.s.slice(i, i + len));\n  }\n\n  readuint8array(len) {\n    var b = new Uint8Array(len);\n    var s = this.s;\n    var i = this.i;\n    for (var j = 0; j < len; j++) {\n      b[j] = s.charCodeAt(i + j);\n    }\n    this.i = i + len;\n    return b;\n  }\n}\n\n//Provides: caml_float_of_bytes\n//Requires: caml_int64_float_of_bits, caml_int64_of_bytes\nfunction caml_float_of_bytes(a) {\n  return caml_int64_float_of_bits(caml_int64_of_bytes(a));\n}\n\n//Provides: caml_input_value_from_bytes mutable\n//Requires: JsStringReader, UInt8ArrayReader\n//Requires: caml_input_value_from_reader\n//Requires: caml_ml_bytes_content\nfunction caml_input_value_from_bytes(s, ofs) {\n  var c = caml_ml_bytes_content(s);\n  var ofs = typeof ofs === \"number\" ? ofs : ofs[0];\n  var reader =\n    c instanceof Uint8Array\n      ? new UInt8ArrayReader(c, ofs)\n      : new JsStringReader(c, ofs);\n  return caml_input_value_from_reader(reader);\n}\n\n//Provides: caml_int64_unmarshal\n//Requires: caml_int64_of_bytes\nfunction caml_int64_unmarshal(reader, size) {\n  var t = new Array(8);\n  for (var j = 0; j < 8; j++) t[j] = reader.read8u();\n  size[0] = 8;\n  return caml_int64_of_bytes(t);\n}\n\n//Provides: caml_int64_marshal\n//Requires: caml_int64_to_bytes\nfunction caml_int64_marshal(writer, v, sizes) {\n  var b = caml_int64_to_bytes(v);\n  for (var i = 0; i < 8; i++) writer.write(8, b[i]);\n  sizes[0] = 8;\n  sizes[1] = 8;\n}\n\n//Provides: caml_int32_unmarshal\nfunction caml_int32_unmarshal(reader, size) {\n  size[0] = 4;\n  return reader.read32s();\n}\n\n//Provides: caml_nativeint_unmarshal\n//Requires: caml_failwith\nfunction caml_nativeint_unmarshal(reader, size) {\n  switch (reader.read8u()) {\n    case 1:\n      size[0] = 4;\n      return reader.read32s();\n    case 2:\n      caml_failwith(\"input_value: native integer value too large\");\n      break;\n    default:\n      caml_failwith(\"input_value: ill-formed native integer\");\n  }\n}\n\n//Provides: caml_custom_ops\n//Requires: caml_int64_unmarshal, caml_int64_marshal, caml_int64_compare, caml_int64_hash\n//Requires: caml_int32_unmarshal, caml_nativeint_unmarshal\n//Requires: caml_ba_serialize, caml_ba_deserialize, caml_ba_compare, caml_ba_hash\nvar caml_custom_ops = {\n  _j: {\n    deserialize: caml_int64_unmarshal,\n    serialize: caml_int64_marshal,\n    fixed_length: 8,\n    compare: caml_int64_compare,\n    hash: caml_int64_hash,\n  },\n  _i: {\n    deserialize: caml_int32_unmarshal,\n    fixed_length: 4,\n  },\n  _n: {\n    deserialize: caml_nativeint_unmarshal,\n    fixed_length: 4,\n  },\n  _bigarray: {\n    deserialize: function (reader, sz) {\n      return caml_ba_deserialize(reader, sz, \"_bigarray\");\n    },\n    serialize: caml_ba_serialize,\n    compare: caml_ba_compare,\n    hash: caml_ba_hash,\n  },\n  _bigarr02: {\n    deserialize: function (reader, sz) {\n      return caml_ba_deserialize(reader, sz, \"_bigarr02\");\n    },\n    serialize: caml_ba_serialize,\n    compare: caml_ba_compare,\n    hash: caml_ba_hash,\n  },\n};\n\n//Provides: caml_input_value_from_reader mutable\n//Requires: caml_failwith\n//Requires: caml_float_of_bytes, caml_custom_ops\n//Requires: UInt8ArrayReader\n//Requires: caml_decompress_input\n//Requires: caml_set_oo_id\nfunction caml_input_value_from_reader(reader) {\n  function readvlq(overflow) {\n    var c = reader.read8u();\n    var n = c & 0x7f;\n    while ((c & 0x80) !== 0) {\n      c = reader.read8u();\n      var n7 = n << 7;\n      if (n !== n7 >> 7) overflow[0] = true;\n      n = n7 | (c & 0x7f);\n    }\n    return n;\n  }\n  var old_pos = reader.i;\n  var magic = reader.read32u();\n  switch (magic) {\n    case 0x8495a6be /* Intext_magic_number_small */:\n      var header_len = 20;\n      var compressed = 0;\n      var data_len = reader.read32u();\n      var uncompressed_data_len = data_len;\n      var num_objects = reader.read32u();\n      var _size_32 = reader.read32u();\n      var _size_64 = reader.read32u();\n      break;\n    case 0x8495a6bd /* Intext_magic_number_compressed */:\n      var header_len = reader.read8u() & 0x3f;\n      var compressed = 1;\n      var overflow = [false];\n      var data_len = readvlq(overflow);\n      var uncompressed_data_len = readvlq(overflow);\n      var num_objects = readvlq(overflow);\n      var _size_32 = readvlq(overflow);\n      var _size_64 = readvlq(overflow);\n      if (overflow[0]) {\n        caml_failwith(\n          \"caml_input_value_from_reader: object too large to be read back on this platform\",\n        );\n      }\n      break;\n    case 0x8495a6bf /* Intext_magic_number_big */:\n      caml_failwith(\n        \"caml_input_value_from_reader: object too large to be read back on a 32-bit platform\",\n      );\n      break;\n    default:\n      caml_failwith(\"caml_input_value_from_reader: bad object\");\n      break;\n  }\n  if (header_len !== reader.i - old_pos) {\n    caml_failwith(\"caml_input_value_from_reader: invalid header\");\n  }\n  var stack = [];\n  var objects = [];\n  var intern_obj_table = num_objects > 0 ? [] : null;\n  var obj_counter = 0;\n  function intern_rec(reader) {\n    var code = reader.read8u();\n    if (code >= 0x40 /*cst.PREFIX_SMALL_INT*/) {\n      if (code >= 0x80 /*cst.PREFIX_SMALL_BLOCK*/) {\n        var tag = code & 0xf;\n        var size = (code >> 4) & 0x7;\n        var v = [tag];\n        if (size === 0) return v;\n        if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n        if (tag === 248) objects.push(v);\n        stack.push(v, size);\n        return v;\n      } else return code & 0x3f;\n    } else {\n      if (code >= 0x20 /*cst.PREFIX_SMALL_STRING */) {\n        var len = code & 0x1f;\n        var v = reader.readstr(len);\n        if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n        return v;\n      } else {\n        switch (code) {\n          case 0x00: //cst.CODE_INT8:\n            return reader.read8s();\n          case 0x01: //cst.CODE_INT16:\n            return reader.read16s();\n          case 0x02: //cst.CODE_INT32:\n            return reader.read32s();\n          case 0x03: //cst.CODE_INT64:\n            caml_failwith(\"input_value: integer too large\");\n            break;\n          case 0x04: //cst.CODE_SHARED8:\n            var offset = reader.read8u();\n            if (compressed === 0) offset = obj_counter - offset;\n            return intern_obj_table[offset];\n          case 0x05: //cst.CODE_SHARED16:\n            var offset = reader.read16u();\n            if (compressed === 0) offset = obj_counter - offset;\n            return intern_obj_table[offset];\n          case 0x06: //cst.CODE_SHARED32:\n            var offset = reader.read32u();\n            if (compressed === 0) offset = obj_counter - offset;\n            return intern_obj_table[offset];\n          case 0x08: //cst.CODE_BLOCK32:\n            var header = reader.read32u();\n            var tag = header & 0xff;\n            var size = header >> 10;\n            var v = [tag];\n            if (size === 0) return v;\n            if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n            if (tag === 248) objects.push(v);\n            stack.push(v, size);\n            return v;\n          case 0x13: //cst.CODE_BLOCK64:\n            caml_failwith(\"input_value: data block too large\");\n            break;\n          case 0x09: //cst.CODE_STRING8:\n            var len = reader.read8u();\n            var v = reader.readstr(len);\n            if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n            return v;\n          case 0x0a: //cst.CODE_STRING32:\n            var len = reader.read32u();\n            var v = reader.readstr(len);\n            if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n            return v;\n          case 0x0c: //cst.CODE_DOUBLE_LITTLE:\n            var t = new Array(8);\n            for (var i = 0; i < 8; i++) t[7 - i] = reader.read8u();\n            var v = caml_float_of_bytes(t);\n            if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n            return v;\n          case 0x0b: //cst.CODE_DOUBLE_BIG:\n            var t = new Array(8);\n            for (var i = 0; i < 8; i++) t[i] = reader.read8u();\n            var v = caml_float_of_bytes(t);\n            if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n            return v;\n          case 0x0e: //cst.CODE_DOUBLE_ARRAY8_LITTLE:\n            var len = reader.read8u();\n            var v = new Array(len + 1);\n            v[0] = 254;\n            var t = new Array(8);\n            if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n            for (var i = 1; i <= len; i++) {\n              for (var j = 0; j < 8; j++) t[7 - j] = reader.read8u();\n              v[i] = caml_float_of_bytes(t);\n            }\n            return v;\n          case 0x0d: //cst.CODE_DOUBLE_ARRAY8_BIG:\n            var len = reader.read8u();\n            var v = new Array(len + 1);\n            v[0] = 254;\n            var t = new Array(8);\n            if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n            for (var i = 1; i <= len; i++) {\n              for (var j = 0; j < 8; j++) t[j] = reader.read8u();\n              v[i] = caml_float_of_bytes(t);\n            }\n            return v;\n          case 0x07: //cst.CODE_DOUBLE_ARRAY32_LITTLE:\n            var len = reader.read32u();\n            var v = new Array(len + 1);\n            v[0] = 254;\n            if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n            var t = new Array(8);\n            for (var i = 1; i <= len; i++) {\n              for (var j = 0; j < 8; j++) t[7 - j] = reader.read8u();\n              v[i] = caml_float_of_bytes(t);\n            }\n            return v;\n          case 0x0f: //cst.CODE_DOUBLE_ARRAY32_BIG:\n            var len = reader.read32u();\n            var v = new Array(len + 1);\n            v[0] = 254;\n            var t = new Array(8);\n            for (var i = 1; i <= len; i++) {\n              for (var j = 0; j < 8; j++) t[j] = reader.read8u();\n              v[i] = caml_float_of_bytes(t);\n            }\n            return v;\n          case 0x10: //cst.CODE_CODEPOINTER:\n          case 0x11: //cst.CODE_INFIXPOINTER:\n            caml_failwith(\"input_value: code pointer\");\n            break;\n          case 0x12: //cst.CODE_CUSTOM:\n          case 0x18: //cst.CODE_CUSTOM_LEN:\n          case 0x19: //cst.CODE_CUSTOM_FIXED:\n            var c,\n              s = \"\";\n            while ((c = reader.read8u()) !== 0) s += String.fromCharCode(c);\n            var ops = caml_custom_ops[s];\n            var expected_size;\n            if (!ops)\n              caml_failwith(\"input_value: unknown custom block identifier\");\n            switch (code) {\n              case 0x12: // cst.CODE_CUSTOM (deprecated)\n                break;\n              case 0x19: // cst.CODE_CUSTOM_FIXED\n                if (!ops.fixed_length)\n                  caml_failwith(\n                    \"input_value: expected a fixed-size custom block\",\n                  );\n                expected_size = ops.fixed_length;\n                break;\n              case 0x18: // cst.CODE_CUSTOM_LEN\n                expected_size = reader.read32u();\n                // Skip size64\n                reader.read32s();\n                reader.read32s();\n                break;\n            }\n            var size = [0];\n            var v = ops.deserialize(reader, size);\n            if (expected_size !== undefined) {\n              if (expected_size !== size[0])\n                caml_failwith(\n                  \"input_value: incorrect length of serialized custom block\",\n                );\n            }\n            if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n            return v;\n          default:\n            caml_failwith(\"input_value: ill-formed message\");\n        }\n      }\n    }\n  }\n  if (compressed) {\n    if (caml_decompress_input) {\n      var data = reader.readuint8array(data_len);\n      var res = new Uint8Array(uncompressed_data_len);\n      var res = caml_decompress_input(data, res);\n      var reader = new UInt8ArrayReader(res, 0);\n    } else {\n      caml_failwith(\"input_value: compressed object, cannot decompress\");\n    }\n  }\n  var res = intern_rec(reader);\n  while (stack.length > 0) {\n    var size = stack.pop();\n    var v = stack.pop();\n    var d = v.length;\n    if (d < size) stack.push(v, size);\n    v[d] = intern_rec(reader);\n  }\n  while (objects.length > 0) {\n    var x = objects.pop();\n    if (x[2] >= 0) caml_set_oo_id(x);\n  }\n  return res;\n}\n\n//Provides: caml_marshal_header_size\n//Version: < 5.1.0\nvar caml_marshal_header_size = 20;\n\n//Provides: caml_marshal_header_size\n//Version: >= 5.1.0\nvar caml_marshal_header_size = 16;\n\n//Provides: caml_marshal_data_size mutable\n//Requires: caml_failwith, caml_bytes_unsafe_get\n//Requires: caml_uint8_array_of_bytes\n//Requires: UInt8ArrayReader\n//Requires: caml_marshal_header_size\nfunction caml_marshal_data_size(s, ofs) {\n  var r = new UInt8ArrayReader(caml_uint8_array_of_bytes(s), ofs);\n  function readvlq(overflow) {\n    var c = r.read8u();\n    var n = c & 0x7f;\n    while ((c & 0x80) !== 0) {\n      c = r.read8u();\n      var n7 = n << 7;\n      if (n !== n7 >> 7) overflow[0] = true;\n      n = n7 | (c & 0x7f);\n    }\n    return n;\n  }\n\n  switch (r.read32u()) {\n    case 0x8495a6be /* Intext_magic_number_small */:\n      var header_len = 20;\n      var data_len = r.read32u();\n      break;\n    case 0x8495a6bd /* Intext_magic_number_compressed */:\n      var header_len = r.read8u() & 0x3f;\n      var overflow = [false];\n      var data_len = readvlq(overflow);\n      if (overflow[0]) {\n        caml_failwith(\n          \"Marshal.data_size: object too large to be read back on this platform\",\n        );\n      }\n      break;\n    case 0x8495a6bf /* Intext_magic_number_big */:\n      caml_failwith(\n        \"Marshal.data_size: object too large to be read back on a 32-bit platform\",\n      );\n      break;\n    default:\n      caml_failwith(\"Marshal.data_size: bad object\");\n      break;\n  }\n  return header_len - caml_marshal_header_size + data_len;\n}\n\n//Provides: MlObjectTable\nclass MlObjectTable {\n  constructor() {\n    this.objs = [];\n    this.lookup = new globalThis.Map();\n  }\n\n  store(v) {\n    this.lookup.set(v, this.objs.length);\n    this.objs.push(v);\n  }\n\n  recall(v) {\n    var i = this.lookup.get(v);\n    return i === undefined\n      ? undefined\n      : this.objs.length - i; /* index is relative */\n  }\n}\n\n//Provides: caml_output_val\n//Requires: caml_int64_to_bytes, caml_failwith\n//Requires: caml_int64_bits_of_float\n//Requires: caml_is_ml_bytes, caml_ml_bytes_length, caml_bytes_unsafe_get\n//Requires: caml_is_ml_string, caml_ml_string_length, caml_string_unsafe_get\n//Requires: MlObjectTable, caml_list_to_js_array, caml_custom_ops\n//Requires: caml_invalid_argument,caml_string_of_jsbytes, caml_is_continuation_tag\nvar caml_output_val = (function () {\n  class Writer {\n    constructor() {\n      this.chunk = [];\n      this.chunk_idx = 20;\n      this.block_len = 0;\n      this.obj_counter = 0;\n      this.size_32 = 0;\n      this.size_64 = 0;\n    }\n\n    write(size, value) {\n      for (var i = size - 8; i >= 0; i -= 8)\n        this.chunk[this.chunk_idx++] = (value >> i) & 0xff;\n    }\n\n    write_at(pos, size, value) {\n      var pos = pos;\n      for (var i = size - 8; i >= 0; i -= 8)\n        this.chunk[pos++] = (value >> i) & 0xff;\n    }\n\n    write_code(size, code, value) {\n      this.chunk[this.chunk_idx++] = code;\n      for (var i = size - 8; i >= 0; i -= 8)\n        this.chunk[this.chunk_idx++] = (value >> i) & 0xff;\n    }\n\n    write_shared(offset) {\n      if (offset < 1 << 8)\n        this.write_code(8, 0x04 /*cst.CODE_SHARED8*/, offset);\n      else if (offset < 1 << 16)\n        this.write_code(16, 0x05 /*cst.CODE_SHARED16*/, offset);\n      else this.write_code(32, 0x06 /*cst.CODE_SHARED32*/, offset);\n    }\n\n    pos() {\n      return this.chunk_idx;\n    }\n\n    finalize() {\n      this.block_len = this.chunk_idx - 20;\n      this.chunk_idx = 0;\n      this.write(32, 0x8495a6be);\n      this.write(32, this.block_len);\n      this.write(32, this.obj_counter);\n      this.write(32, this.size_32);\n      this.write(32, this.size_64);\n      return this.chunk;\n    }\n  }\n  return function (v, flags) {\n    flags = caml_list_to_js_array(flags);\n\n    var no_sharing = flags.indexOf(0 /*Marshal.No_sharing*/) !== -1,\n      closures = flags.indexOf(1 /*Marshal.Closures*/) !== -1;\n    /* Marshal.Compat_32 is redundant since integers are 32-bit anyway */\n\n    if (closures)\n      console.warn(\n        \"in caml_output_val: flag Marshal.Closures is not supported.\",\n      );\n\n    var writer = new Writer();\n    var stack = [];\n    var intern_obj_table = no_sharing ? null : new MlObjectTable();\n\n    function memo(v) {\n      if (no_sharing) return false;\n      var existing_offset = intern_obj_table.recall(v);\n      if (existing_offset) {\n        writer.write_shared(existing_offset);\n        return true;\n      } else {\n        intern_obj_table.store(v);\n        return false;\n      }\n    }\n\n    function extern_rec(v) {\n      if (v.caml_custom) {\n        if (memo(v)) return;\n        var name = v.caml_custom;\n        var ops = caml_custom_ops[name];\n        var sz_32_64 = [0, 0];\n        if (!ops.serialize)\n          caml_invalid_argument(\"output_value: abstract value (Custom)\");\n        if (ops.fixed_length === undefined) {\n          writer.write(8, 0x18 /*cst.CODE_CUSTOM_LEN*/);\n          for (var i = 0; i < name.length; i++)\n            writer.write(8, name.charCodeAt(i));\n          writer.write(8, 0);\n          var header_pos = writer.pos();\n          for (var i = 0; i < 12; i++) {\n            writer.write(8, 0);\n          }\n          ops.serialize(writer, v, sz_32_64);\n          writer.write_at(header_pos, 32, sz_32_64[0]);\n          writer.write_at(header_pos + 4, 32, 0); // zero\n          writer.write_at(header_pos + 8, 32, sz_32_64[1]);\n        } else {\n          writer.write(8, 0x19 /*cst.CODE_CUSTOM_FIXED*/);\n          for (var i = 0; i < name.length; i++)\n            writer.write(8, name.charCodeAt(i));\n          writer.write(8, 0);\n          ops.serialize(writer, v, sz_32_64);\n          if (ops.fixed_length !== sz_32_64[0])\n            caml_failwith(\n              \"output_value: incorrect fixed sizes specified by \" + name,\n            );\n        }\n        writer.size_32 += 2 + ((sz_32_64[0] + 3) >> 2);\n        writer.size_64 += 2 + ((sz_32_64[1] + 7) >> 3);\n      } else if (Array.isArray(v) && v[0] === (v[0] | 0)) {\n        if (v[0] === 251) {\n          caml_failwith(\"output_value: abstract value (Abstract)\");\n        }\n        if (caml_is_continuation_tag(v[0]))\n          caml_invalid_argument(\"output_value: continuation value\");\n        if (v.length > 1 && memo(v)) return;\n        if (v[0] < 16 && v.length - 1 < 8)\n          writer.write(\n            8,\n            0x80 /*cst.PREFIX_SMALL_BLOCK*/ + v[0] + ((v.length - 1) << 4),\n          );\n        else\n          writer.write_code(\n            32,\n            0x08 /*cst.CODE_BLOCK32*/,\n            ((v.length - 1) << 10) | v[0],\n          );\n        writer.size_32 += v.length;\n        writer.size_64 += v.length;\n        if (v.length > 1) stack.push(v, 1);\n      } else if (caml_is_ml_bytes(v)) {\n        if (!caml_is_ml_bytes(caml_string_of_jsbytes(\"\"))) {\n          caml_failwith(\n            \"output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]\",\n          );\n        }\n        if (memo(v)) return;\n        var len = caml_ml_bytes_length(v);\n        if (len < 0x20) writer.write(8, 0x20 /*cst.PREFIX_SMALL_STRING*/ + len);\n        else if (len < 0x100)\n          writer.write_code(8, 0x09 /*cst.CODE_STRING8*/, len);\n        else writer.write_code(32, 0x0a /*cst.CODE_STRING32*/, len);\n        for (var i = 0; i < len; i++)\n          writer.write(8, caml_bytes_unsafe_get(v, i));\n        writer.size_32 += 1 + (((len + 4) / 4) | 0);\n        writer.size_64 += 1 + (((len + 8) / 8) | 0);\n      } else if (caml_is_ml_string(v)) {\n        if (memo(v)) return;\n        var len = caml_ml_string_length(v);\n        if (len < 0x20) writer.write(8, 0x20 /*cst.PREFIX_SMALL_STRING*/ + len);\n        else if (len < 0x100)\n          writer.write_code(8, 0x09 /*cst.CODE_STRING8*/, len);\n        else writer.write_code(32, 0x0a /*cst.CODE_STRING32*/, len);\n        for (var i = 0; i < len; i++)\n          writer.write(8, caml_string_unsafe_get(v, i));\n        writer.size_32 += 1 + (((len + 4) / 4) | 0);\n        writer.size_64 += 1 + (((len + 8) / 8) | 0);\n      } else {\n        if (v !== (v | 0)) {\n          var type_of_v = typeof v;\n          if (type_of_v !== \"number\")\n            caml_failwith(\"output_value: abstract value (\" + type_of_v + \")\");\n          // If a float happens to be an integer it is serialized as an integer\n          // (Js_of_ocaml cannot tell whether the type of an integer number is\n          // float or integer.) This can result in unexpected crashes when\n          // unmarshalling using the standard runtime.\n          if (memo(v)) return;\n          var t = caml_int64_to_bytes(caml_int64_bits_of_float(v));\n          writer.write(8, 0x0c /*cst.CODE_DOUBLE_LITTLE*/);\n          for (var i = 0; i < 8; i++) {\n            writer.write(8, t[7 - i]);\n          }\n          writer.size_32 += 3;\n          writer.size_64 += 2;\n        } else if (v >= 0 && v < 0x40) {\n          writer.write(8, 0x40 /*cst.PREFIX_SMALL_INT*/ + v);\n        } else {\n          if (v >= -(1 << 7) && v < 1 << 7)\n            writer.write_code(8, 0x00 /*cst.CODE_INT8*/, v);\n          else if (v >= -(1 << 15) && v < 1 << 15)\n            writer.write_code(16, 0x01 /*cst.CODE_INT16*/, v);\n          else writer.write_code(32, 0x02 /*cst.CODE_INT32*/, v);\n        }\n      }\n    }\n    extern_rec(v);\n    while (stack.length > 0) {\n      var i = stack.pop();\n      var v = stack.pop();\n      if (i + 1 < v.length) stack.push(v, i + 1);\n      extern_rec(v[i]);\n    }\n    if (intern_obj_table) writer.obj_counter = intern_obj_table.objs.length;\n    writer.finalize();\n    return new Uint8Array(writer.chunk);\n  };\n})();\n\n//Provides: caml_output_value_to_string mutable\n//Requires: caml_output_val, caml_string_of_uint8_array\nfunction caml_output_value_to_string(v, flags) {\n  return caml_string_of_uint8_array(caml_output_val(v, flags));\n}\n\n//Provides: caml_output_value_to_bytes mutable\n//Requires: caml_output_val, caml_bytes_of_uint8_array\nfunction caml_output_value_to_bytes(v, flags) {\n  return caml_bytes_of_uint8_array(caml_output_val(v, flags));\n}\n\n//Provides: caml_output_value_to_buffer\n//Requires: caml_output_val, caml_failwith, caml_blit_bytes, caml_bytes_of_uint8_array\nfunction caml_output_value_to_buffer(s, ofs, len, v, flags) {\n  var t = caml_output_val(v, flags);\n  if (t.length > len) caml_failwith(\"Marshal.to_buffer: buffer overflow\");\n  caml_blit_bytes(caml_bytes_of_uint8_array(t), 0, s, ofs, t.length);\n  return 0;\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: caml_compare_val_tag\n//Requires: caml_is_ml_string, caml_is_ml_bytes\nfunction caml_compare_val_tag(a) {\n  if (typeof a === \"number\")\n    return 1000; // int_tag (we use it for all numbers)\n  else if (caml_is_ml_bytes(a))\n    return 252; // string_tag\n  else if (caml_is_ml_string(a))\n    return 1252; // ocaml string (if different from bytes)\n  else if (Array.isArray(a) && a[0] === a[0] >>> 0 && a[0] <= 255) {\n    // Look like an ocaml block\n    var tag = a[0] | 0;\n    // ignore double_array_tag because we cannot accurately set\n    // this tag when we create an array of float.\n    return tag === 254 ? 0 : tag;\n  } else if (a instanceof String)\n    return 12520; // javascript string, like string_tag (252)\n  else if (typeof a === \"string\")\n    return 12520; // javascript string, like string_tag (252)\n  else if (a instanceof Number)\n    return 1000; // int_tag (we use it for all numbers)\n  else if (a?.caml_custom)\n    return 1255; // like custom_tag (255)\n  else if (a?.compare)\n    return 1256; // like custom_tag (255)\n  else if (typeof a === \"function\")\n    return 1247; // like closure_tag (247)\n  else if (typeof a === \"symbol\") return 1251;\n  return 1001; //out_of_heap_tag\n}\n\n//Provides: caml_compare_val_get_custom\n//Requires: caml_custom_ops\nfunction caml_compare_val_get_custom(a) {\n  return (\n    caml_custom_ops[a.caml_custom] && caml_custom_ops[a.caml_custom].compare\n  );\n}\n\n//Provides: caml_compare_val_number_custom\n//Requires: caml_compare_val_get_custom\nfunction caml_compare_val_number_custom(num, custom, swap, total) {\n  var comp = caml_compare_val_get_custom(custom);\n  if (comp) {\n    var x = swap > 0 ? comp(custom, num, total) : comp(num, custom, total);\n    if (total && Number.isNaN(x)) return swap; // total && nan\n    if (Number.isNaN(+x)) return +x; // nan\n    if ((x | 0) !== 0) return x | 0; // !nan\n  }\n  return swap;\n}\n\n//Provides: caml_compare_val (const, const, const)\n//Requires: caml_int_compare, caml_string_compare, caml_bytes_compare\n//Requires: caml_invalid_argument, caml_compare_val_get_custom, caml_compare_val_tag\n//Requires: caml_compare_val_number_custom\n//Requires: caml_jsbytes_of_string\n//Requires: caml_is_continuation_tag\nfunction caml_compare_val(a, b, total) {\n  var stack = [];\n  for (;;) {\n    if (!(total && a === b)) {\n      var tag_a = caml_compare_val_tag(a);\n      // forward_tag ?\n      if (tag_a === 250) {\n        a = a[1];\n        continue;\n      }\n\n      var tag_b = caml_compare_val_tag(b);\n      // forward_tag ?\n      if (tag_b === 250) {\n        b = b[1];\n        continue;\n      }\n\n      // tags are different\n      if (tag_a !== tag_b) {\n        if (tag_a === 1000) {\n          if (tag_b === 1255) {\n            //immediate can compare against custom\n            return caml_compare_val_number_custom(a, b, -1, total);\n          }\n          return -1;\n        }\n        if (tag_b === 1000) {\n          if (tag_a === 1255) {\n            //immediate can compare against custom\n            return caml_compare_val_number_custom(b, a, 1, total);\n          }\n          return 1;\n        }\n        return tag_a < tag_b ? -1 : 1;\n      }\n      // tag_a = tag_b\n      switch (tag_a) {\n        // 246: Lazy_tag handled bellow\n        case 247: // Closure_tag\n          // Cannot happen\n          caml_invalid_argument(\"compare: functional value\");\n          break;\n        case 248: // Object\n          var x = caml_int_compare(a[2], b[2]) | 0;\n          if (x !== 0) return x;\n          break;\n        case 249: // Infix\n          // Cannot happen\n          caml_invalid_argument(\"compare: functional value\");\n          break;\n        case 250: // Forward tag\n          // Cannot happen, handled above\n          caml_invalid_argument(\"equal: got Forward_tag, should not happen\");\n          break;\n        case 251: //Abstract\n          caml_invalid_argument(\"equal: abstract value\");\n          break;\n        case 252: // OCaml bytes\n          if (a !== b) {\n            var x = caml_bytes_compare(a, b) | 0;\n            if (x !== 0) return x;\n          }\n          break;\n        case 253: // Double_tag\n          // Cannot happen\n          caml_invalid_argument(\"equal: got Double_tag, should not happen\");\n          break;\n        case 254: // Double_array_tag\n          // Cannot happen, handled in caml_compare_val_tag\n          caml_invalid_argument(\n            \"equal: got Double_array_tag, should not happen\",\n          );\n          break;\n        case 255: // Custom_tag\n          caml_invalid_argument(\"equal: got Custom_tag, should not happen\");\n          break;\n        case 1247: // Function\n          caml_invalid_argument(\"compare: functional value\");\n          break;\n        case 1255: // Custom\n          var comp = caml_compare_val_get_custom(a);\n          if (comp !== caml_compare_val_get_custom(b)) {\n            return a.caml_custom < b.caml_custom ? -1 : 1;\n          }\n          if (!comp) caml_invalid_argument(\"compare: abstract value\");\n          var x = comp(a, b, total);\n          if (Number.isNaN(x)) {\n            // Protect against invalid UNORDERED\n            return total ? -1 : x;\n          }\n          if (x !== (x | 0)) {\n            // Protect against invalid return value\n            return -1;\n          }\n          if (x !== 0) return x | 0;\n          break;\n        case 1256: // compare function\n          var x = a.compare(b, total);\n          if (Number.isNaN(x)) {\n            // Protect against invalid UNORDERED\n            return total ? -1 : x;\n          }\n          if (x !== (x | 0)) {\n            // Protect against invalid return value\n            return -1;\n          }\n          if (x !== 0) return x | 0;\n          break;\n        case 1000: // Number\n          a = +a;\n          b = +b;\n          if (a < b) return -1;\n          if (a > b) return 1;\n          if (a !== b) {\n            if (!total) return Number.NaN;\n            if (!Number.isNaN(a)) return 1;\n            if (!Number.isNaN(b)) return -1;\n          }\n          break;\n        case 1001: // The rest\n          // Here we can be in the following cases:\n          // 1. JavaScript primitive types\n          // 2. JavaScript object that can be coerced to primitive types\n          // 3. JavaScript object than cannot be coerced to primitive types\n          //\n          // (3) will raise a [TypeError]\n          // (2) will coerce to primitive types using [valueOf] or [toString]\n          // (2) and (3), after eventual coercion\n          // - if a and b are strings, apply lexicographic comparison\n          // - if a or b are not strings, convert a and b to number\n          //   and apply standard comparison\n          if (a < b) return -1;\n          if (a > b) return 1;\n          if (a !== b) {\n            return total ? 1 : Number.NaN;\n          }\n          break;\n        case 1251: // JavaScript Symbol, no ordering.\n          if (a !== b) {\n            return total ? 1 : Number.NaN;\n          }\n          break;\n        case 1252: // ocaml strings\n          var a = caml_jsbytes_of_string(a);\n          var b = caml_jsbytes_of_string(b);\n          if (a !== b) {\n            if (a < b) return -1;\n            if (a > b) return 1;\n          }\n          break;\n        case 12520: // javascript strings\n          var a = a.toString();\n          var b = b.toString();\n          if (a !== b) {\n            if (a < b) return -1;\n            if (a > b) return 1;\n          }\n          break;\n        default: // Lazy_tag or Block with other tag\n          if (caml_is_continuation_tag(tag_a)) {\n            caml_invalid_argument(\"compare: continuation value\");\n            break;\n          }\n          if (a.length !== b.length) return a.length < b.length ? -1 : 1;\n          if (a.length > 1) stack.push(a, b, 1);\n          break;\n      }\n    }\n    if (stack.length === 0) return 0;\n    var i = stack.pop();\n    b = stack.pop();\n    a = stack.pop();\n    if (i + 1 < a.length) stack.push(a, b, i + 1);\n    a = a[i];\n    b = b[i];\n  }\n}\n//Provides: caml_compare mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_compare(a, b) {\n  return caml_compare_val(a, b, true);\n}\n\n//Provides: caml_int_compare const\n//Alias: caml_int32_compare\n//Alias: caml_nativeint_compare\nfunction caml_int_compare(a, b) {\n  if (a < b) return -1;\n  if (a === b) return 0;\n  return 1;\n}\n//Provides: caml_equal mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_equal(x, y) {\n  return +(caml_compare_val(x, y, false) === 0);\n}\n//Provides: caml_notequal mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_notequal(x, y) {\n  return +(caml_compare_val(x, y, false) !== 0);\n}\n//Provides: caml_greaterequal mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_greaterequal(x, y) {\n  return +(caml_compare_val(x, y, false) >= 0);\n}\n//Provides: caml_greaterthan mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_greaterthan(x, y) {\n  return +(caml_compare_val(x, y, false) > 0);\n}\n//Provides: caml_lessequal mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_lessequal(x, y) {\n  return +(caml_compare_val(x, y, false) <= 0);\n}\n//Provides: caml_lessthan mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_lessthan(x, y) {\n  return +(caml_compare_val(x, y, false) < 0);\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Format\n\n//Provides: caml_parse_format\n//Requires: caml_jsbytes_of_string, caml_invalid_argument\nfunction caml_parse_format(fmt) {\n  fmt = caml_jsbytes_of_string(fmt);\n  var len = fmt.length;\n  if (len > 31) caml_invalid_argument(\"format_int: format too long\");\n  var f = {\n    justify: \"+\",\n    signstyle: \"-\",\n    filler: \" \",\n    alternate: false,\n    base: 0,\n    signedconv: false,\n    width: 0,\n    uppercase: false,\n    sign: 1,\n    prec: -1,\n    conv: \"f\",\n  };\n  for (var i = 0; i < len; i++) {\n    var c = fmt.charAt(i);\n    switch (c) {\n      case \"-\":\n        f.justify = \"-\";\n        break;\n      case \"+\":\n      case \" \":\n        f.signstyle = c;\n        break;\n      case \"0\":\n        f.filler = \"0\";\n        break;\n      case \"#\":\n        f.alternate = true;\n        break;\n      case \"1\":\n      case \"2\":\n      case \"3\":\n      case \"4\":\n      case \"5\":\n      case \"6\":\n      case \"7\":\n      case \"8\":\n      case \"9\":\n        f.width = 0;\n        while (((c = fmt.charCodeAt(i) - 48), c >= 0 && c <= 9)) {\n          f.width = f.width * 10 + c;\n          i++;\n        }\n        i--;\n        break;\n      case \".\":\n        f.prec = 0;\n        i++;\n        while (((c = fmt.charCodeAt(i) - 48), c >= 0 && c <= 9)) {\n          f.prec = f.prec * 10 + c;\n          i++;\n        }\n        i--;\n        break;\n      case \"d\":\n      case \"i\":\n        f.signedconv = true;\n        f.base = 10;\n        break;\n      case \"u\":\n        f.base = 10;\n        break;\n      case \"x\":\n        f.base = 16;\n        break;\n      case \"X\":\n        f.base = 16;\n        f.uppercase = true;\n        break;\n      case \"o\":\n        f.base = 8;\n        break;\n      case \"e\":\n      case \"f\":\n      case \"g\":\n        f.signedconv = true;\n        f.conv = c;\n        break;\n      case \"E\":\n      case \"F\":\n      case \"G\":\n        f.signedconv = true;\n        f.uppercase = true;\n        f.conv = c.toLowerCase();\n        break;\n    }\n  }\n  return f;\n}\n\n//Provides: caml_finish_formatting\n//Requires: caml_string_of_jsbytes\nfunction caml_finish_formatting(f, rawbuffer) {\n  if (f.uppercase) rawbuffer = rawbuffer.toUpperCase();\n  var len = rawbuffer.length;\n  /* Adjust len to reflect additional chars (sign, etc) */\n  if (f.signedconv && (f.sign < 0 || f.signstyle !== \"-\")) len++;\n  if (f.alternate) {\n    if (f.base === 8) len += 1;\n    if (f.base === 16) len += 2;\n  }\n  /* Do the formatting */\n  var buffer = \"\";\n  if (f.justify === \"+\" && f.filler === \" \")\n    for (var i = len; i < f.width; i++) buffer += \" \";\n  if (f.signedconv) {\n    if (f.sign < 0) buffer += \"-\";\n    else if (f.signstyle !== \"-\") buffer += f.signstyle;\n  }\n  if (f.alternate && f.base === 8) buffer += \"0\";\n  if (f.alternate && f.base === 16) buffer += f.uppercase ? \"0X\" : \"0x\";\n  if (f.justify === \"+\" && f.filler === \"0\")\n    for (var i = len; i < f.width; i++) buffer += \"0\";\n  buffer += rawbuffer;\n  if (f.justify === \"-\") for (var i = len; i < f.width; i++) buffer += \" \";\n  return caml_string_of_jsbytes(buffer);\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2014 Jérôme Vouillon, Hugo Heuzard\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: fs_node_supported\nfunction fs_node_supported() {\n  return globalThis.process?.versions?.node !== undefined;\n}\n//Provides: fs_node_supported\n//If: browser\nfunction fs_node_supported() {\n  return false;\n}\n\n//Provides: MlNodeDevice\n//Requires: MlNodeFd, caml_raise_sys_error, caml_string_of_jsstring\n//Requires: caml_raise_nodejs_error, fs_node_stats_from_js\nclass MlNodeDevice {\n  constructor(root) {\n    this.fs = require(\"node:fs\");\n    this.root = root;\n  }\n\n  nm(name) {\n    return this.root + name;\n  }\n\n  exists(name) {\n    try {\n      return this.fs.existsSync(this.nm(name)) ? 1 : 0;\n    } catch (err) {\n      return 0;\n    }\n  }\n\n  isFile(name) {\n    try {\n      return this.fs.statSync(this.nm(name)).isFile() ? 1 : 0;\n    } catch (err) {\n      caml_raise_sys_error(err.toString());\n    }\n  }\n\n  mkdir(name, mode, raise_unix) {\n    try {\n      this.fs.mkdirSync(this.nm(name), { mode: mode });\n      return 0;\n    } catch (err) {\n      caml_raise_nodejs_error(err, raise_unix);\n    }\n  }\n\n  rmdir(name, raise_unix) {\n    try {\n      this.fs.rmdirSync(this.nm(name));\n      return 0;\n    } catch (err) {\n      caml_raise_nodejs_error(err, raise_unix);\n    }\n  }\n\n  readdir(name, raise_unix) {\n    try {\n      return this.fs.readdirSync(this.nm(name));\n    } catch (err) {\n      caml_raise_nodejs_error(err, raise_unix);\n    }\n  }\n\n  is_dir(name) {\n    try {\n      return this.fs.statSync(this.nm(name)).isDirectory() ? 1 : 0;\n    } catch (err) {\n      caml_raise_sys_error(err.toString());\n    }\n  }\n\n  unlink(name, raise_unix) {\n    try {\n      this.fs.unlinkSync(this.nm(name));\n      return 0;\n    } catch (err) {\n      caml_raise_nodejs_error(err, raise_unix);\n    }\n  }\n\n  utimes(name, atime, mtime, raise_unix) {\n    try {\n      if (atime === 0 && mtime === 0) {\n        atime = new Date().getTime() / 1000;\n        mtime = atime;\n      }\n      this.fs.utimesSync(this.nm(name), atime, mtime);\n      return 0;\n    } catch (err) {\n      caml_raise_nodejs_error(err, raise_unix);\n    }\n  }\n\n  truncate(name, len, raise_unix) {\n    try {\n      this.fs.truncateSync(this.nm(name), len | 0);\n      return 0;\n    } catch (err) {\n      caml_raise_nodejs_error(err, raise_unix);\n    }\n  }\n\n  access(name, f, raise_unix) {\n    var consts = require(\"node:fs\").constants;\n    var res = 0;\n    for (var key in f) {\n      switch (key) {\n        case \"r\":\n          res |= consts.R_OK;\n          break;\n        case \"w\":\n          res |= consts.W_OK;\n          break;\n        case \"x\":\n          res |=\n            globalThis.process?.platform === \"win32\"\n              ? consts.R_OK\n              : consts.X_OK;\n          break;\n        case \"f\":\n          res |= consts.F_OK;\n          break;\n      }\n    }\n    try {\n      this.fs.accessSync(this.nm(name), res);\n      return 0;\n    } catch (err) {\n      caml_raise_nodejs_error(err, raise_unix);\n    }\n  }\n\n  open(name, f, perms, raise_unix) {\n    var consts = require(\"node:fs\").constants;\n    var res = 0;\n    for (var key in f) {\n      switch (key) {\n        case \"rdonly\":\n          res |= consts.O_RDONLY;\n          break;\n        case \"wronly\":\n          res |= consts.O_WRONLY;\n          break;\n        case \"rdwr\":\n          res |= consts.O_RDWR;\n          break;\n        case \"append\":\n          res |= consts.O_APPEND;\n          break;\n        case \"create\":\n          res |= consts.O_CREAT;\n          break;\n        case \"truncate\":\n          res |= consts.O_TRUNC;\n          break;\n        case \"excl\":\n          res |= consts.O_EXCL;\n          break;\n        case \"binary\":\n          res |= consts.O_BINARY;\n          break;\n        case \"text\":\n          res |= consts.O_TEXT;\n          break;\n        case \"nonblock\":\n          res |= consts.O_NONBLOCK;\n          break;\n        case \"noctty\":\n          res |= consts.O_NOCTTY;\n          break;\n        case \"dsync\":\n          res |= consts.O_DSYNC;\n          break;\n        case \"sync\":\n          res |= consts.O_SYNC;\n          break;\n      }\n    }\n    try {\n      var fd = this.fs.openSync(this.nm(name), res, perms);\n      return new MlNodeFd(fd, f);\n    } catch (err) {\n      caml_raise_nodejs_error(err, raise_unix);\n    }\n  }\n\n  slash(name) {\n    return /\\/$/.test(name) ? name : name + \"/\";\n  }\n\n  rename(o, n, raise_unix) {\n    if (globalThis.process?.platform === \"win32\") {\n      try {\n        var target = this.nm(n);\n        var source = this.nm(o);\n        var target_stats, source_stats;\n        if (\n          (target_stats = this.fs.statSync(target, {\n            throwIfNoEntry: false,\n          })) &&\n          (source_stats = this.fs.statSync(source, {\n            throwIfNoEntry: false,\n          })) &&\n          source_stats.isDirectory()\n        ) {\n          if (target_stats.isDirectory()) {\n            if (!this.slash(target).startsWith(this.slash(source)))\n              try {\n                this.fs.rmdirSync(target);\n              } catch {}\n          } else {\n            var err = new Error(\n              `ENOTDIR: not a directory, rename '${source}' -> '${target}'`,\n            );\n            throw Object.assign(err, {\n              errno: -20,\n              code: \"ENOTDIR\",\n              syscall: \"rename\",\n              path: target,\n            });\n          }\n        }\n        this.fs.renameSync(this.nm(o), this.nm(n));\n      } catch (err) {\n        caml_raise_nodejs_error(err, raise_unix);\n      }\n    } else {\n      try {\n        this.fs.renameSync(this.nm(o), this.nm(n));\n      } catch (err) {\n        caml_raise_nodejs_error(err, raise_unix);\n      }\n    }\n  }\n\n  stat(name, large, raise_unix) {\n    try {\n      var js_stats = this.fs.statSync(this.nm(name));\n      return fs_node_stats_from_js(js_stats, large);\n    } catch (err) {\n      caml_raise_nodejs_error(err, raise_unix);\n    }\n  }\n\n  lstat(name, large, raise_unix) {\n    try {\n      var js_stats = this.fs.lstatSync(this.nm(name));\n      return fs_node_stats_from_js(js_stats, large);\n    } catch (err) {\n      caml_raise_nodejs_error(err, raise_unix);\n    }\n  }\n\n  chmod(name, perms, raise_unix) {\n    try {\n      this.fs.chmodSync(this.nm(name), perms);\n      return 0;\n    } catch (err) {\n      caml_raise_nodejs_error(err, raise_unix);\n    }\n  }\n\n  link(target, path, raise_unix) {\n    try {\n      this.fs.linkSync(this.nm(target), this.nm(path));\n      return 0;\n    } catch (err) {\n      caml_raise_nodejs_error(err, raise_unix);\n    }\n  }\n\n  symlink(to_dir, target, path, raise_unix) {\n    try {\n      this.fs.symlinkSync(\n        target,\n        this.nm(path),\n        to_dir === 0 ? null : to_dir[1] ? \"dir\" : \"file\",\n      );\n      return 0;\n    } catch (err) {\n      caml_raise_nodejs_error(err, raise_unix);\n    }\n  }\n\n  readlink(name, raise_unix) {\n    try {\n      var link = this.fs.readlinkSync(this.nm(name), \"utf8\");\n      return caml_string_of_jsstring(link);\n    } catch (err) {\n      caml_raise_nodejs_error(err, raise_unix);\n    }\n  }\n\n  opendir(name, raise_unix) {\n    try {\n      return this.fs.opendirSync(this.nm(name));\n    } catch (err) {\n      caml_raise_nodejs_error(err, raise_unix);\n    }\n  }\n}\n\n//Provides: fs_node_stats_from_js\n//Requires: caml_int64_of_float\nfunction fs_node_stats_from_js(js_stats, large) {\n  /* ===Unix.file_kind===\n   * type file_kind =\n   *     S_REG                       (** Regular file *)\n   *   | S_DIR                       (** Directory *)\n   *   | S_CHR                       (** Character device *)\n   *   | S_BLK                       (** Block device *)\n   *   | S_LNK                       (** Symbolic link *)\n   *   | S_FIFO                      (** Named pipe *)\n   *   | S_SOCK                      (** Socket *)\n   */\n  var file_kind;\n  if (js_stats.isFile()) {\n    file_kind = 0;\n  } else if (js_stats.isDirectory()) {\n    file_kind = 1;\n  } else if (js_stats.isCharacterDevice()) {\n    file_kind = 2;\n  } else if (js_stats.isBlockDevice()) {\n    file_kind = 3;\n  } else if (js_stats.isSymbolicLink()) {\n    file_kind = 4;\n  } else if (js_stats.isFIFO()) {\n    file_kind = 5;\n  } else if (js_stats.isSocket()) {\n    file_kind = 6;\n  }\n  /* ===Unix.stats===\n   * type stats =\n   *  { st_dev : int;               (** Device number *)\n   *    st_ino : int;               (** Inode number *)\n   *    st_kind : file_kind;        (** Kind of the file *)\n   *    st_perm : file_perm;        (** Access rights *)\n   *    st_nlink : int;             (** Number of links *)\n   *    st_uid : int;               (** User id of the owner *)\n   *    st_gid : int;               (** Group ID of the file's group *)\n   *    st_rdev : int;              (** Device ID (if special file) *)\n   *    st_size : int;              (** Size in bytes *)\n   *    st_atime : float;           (** Last access time *)\n   *    st_mtime : float;           (** Last modification time *)\n   *    st_ctime : float;           (** Last status change time *)\n   *  }\n   */\n  return BLOCK(\n    0,\n    js_stats.dev,\n    js_stats.ino | 0,\n    file_kind,\n    js_stats.mode,\n    js_stats.nlink,\n    js_stats.uid,\n    js_stats.gid,\n    js_stats.rdev,\n    large ? caml_int64_of_float(js_stats.size) : js_stats.size | 0,\n    js_stats.atimeMs / 1000,\n    js_stats.mtimeMs / 1000,\n    js_stats.ctimeMs / 1000,\n  );\n}\n\n//Provides: MlNodeDevice\n//If: browser\nclass MlNodeDevice {}\n\n//Provides: MlNodeFd\n//Requires: MlFile, caml_uint8_array_of_string, caml_uint8_array_of_bytes, caml_bytes_set, caml_raise_sys_error\n//Requires: caml_raise_nodejs_error, caml_raise_system_error, fs_node_stats_from_js\nclass MlNodeFd extends MlFile {\n  constructor(fd, flags) {\n    super();\n    this.fs = require(\"node:fs\");\n    this.fd = fd;\n    this.flags = flags;\n    try {\n      var stats = this.fs.fstatSync(fd);\n      flags.noSeek =\n        stats.isCharacterDevice() || stats.isFIFO() || stats.isSocket();\n    } catch (err) {\n      // The fstat will fail on standard streams under Windows with node\n      // 18 (and lower). See https://github.com/libuv/libuv/pull/3811.\n      flags.noSeek = true;\n    }\n    this.offset = this.flags.append ? stats.size : 0;\n    this.seeked = false;\n  }\n\n  truncate(len, raise_unix) {\n    try {\n      this.fs.ftruncateSync(this.fd, len | 0);\n      if (this.offset > len) this.offset = len;\n    } catch (err) {\n      caml_raise_nodejs_error(err, raise_unix);\n    }\n  }\n\n  length() {\n    try {\n      return this.fs.fstatSync(this.fd).size;\n    } catch (err) {\n      caml_raise_sys_error(err.toString());\n    }\n  }\n\n  write(buf, buf_offset, len, raise_unix) {\n    try {\n      if (this.flags.noSeek || !this.seeked) {\n        var written = this.fs.writeSync(this.fd, buf, buf_offset, len);\n      } else {\n        var written = this.fs.writeSync(\n          this.fd,\n          buf,\n          buf_offset,\n          len,\n          this.offset,\n        );\n      }\n      this.offset += written;\n    } catch (err) {\n      caml_raise_nodejs_error(err, raise_unix);\n    }\n    return written;\n  }\n\n  read(a, buf_offset, len, raise_unix) {\n    try {\n      if (this.flags.noSeek || !this.seeked) {\n        var read = this.fs.readSync(this.fd, a, buf_offset, len);\n      } else {\n        var read = this.fs.readSync(this.fd, a, buf_offset, len, this.offset);\n      }\n      this.offset += read;\n      return read;\n    } catch (err) {\n      caml_raise_nodejs_error(err, raise_unix);\n    }\n  }\n\n  seek(offset, whence, raise_unix) {\n    if (this.flags.noSeek) {\n      caml_raise_system_error(raise_unix, \"ESPIPE\", \"lseek\", \"illegal seek\");\n    }\n    switch (whence) {\n      case 0:\n        break;\n      case 1:\n        offset += this.offset;\n        break;\n      case 2:\n        offset += this.length();\n        break;\n    }\n    if (offset < 0) {\n      caml_raise_system_error(\n        raise_unix,\n        \"EINVAL\",\n        \"lseek\",\n        \"invalid argument\",\n      );\n    }\n    this.offset = offset;\n    this.seeked = true;\n    return this.offset;\n  }\n\n  stat(large) {\n    try {\n      var js_stats = this.fs.fstatSync(this.fd);\n      return fs_node_stats_from_js(js_stats, large);\n    } catch (err) {\n      caml_raise_nodejs_error(err, /* raise Unix_error */ 1);\n    }\n  }\n\n  chmod(perms) {\n    try {\n      this.fs.fchmodSync(this.fd, perms);\n      return 0;\n    } catch (err) {\n      caml_raise_nodejs_error(err, /* raise Unix_error */ 1);\n    }\n  }\n\n  sync() {\n    try {\n      this.fs.fsyncSync(this.fd);\n      return 0;\n    } catch (err) {\n      caml_raise_nodejs_error(err, /* raise Unix_error */ 1);\n    }\n  }\n\n  close(raise_unix) {\n    try {\n      this.fs.closeSync(this.fd);\n      return 0;\n    } catch (err) {\n      caml_raise_nodejs_error(err, raise_unix);\n    }\n  }\n\n  check_stream_semantics(cmd) {\n    try {\n      var js_stats = this.fs.fstatSync(this.fd);\n    } catch (err) {\n      caml_raise_nodejs_error(err, /* raise Unix_error */ 1, cmd);\n    }\n    if (\n      !(\n        js_stats.isFile() ||\n        js_stats.isCharacterDevice() ||\n        js_stats.isFIFO() ||\n        js_stats.isSocket()\n      )\n    )\n      caml_raise_system_error(\n        /* raise Unix_error */ 1,\n        \"EINVAL\",\n        cmd,\n        \"invalid argument\",\n      );\n  }\n}\n\n//Provides: MlNodeFd\n//If: browser\nclass MlNodeFd {}\n\n//Provides: caml_sys_open_for_node\n//Requires: MlNodeFd\nfunction caml_sys_open_for_node(fd, flags) {\n  if (flags.altname) {\n    try {\n      var fs = require(\"node:fs\");\n      var fd2 = fs.openSync(flags.altname, \"rs\");\n      return new MlNodeFd(fd2, flags);\n    } catch (e) {}\n  }\n  return new MlNodeFd(fd, flags);\n}\n\n//Provides: caml_sys_open_for_node\n//If: browser\nfunction caml_sys_open_for_node(_fd, _flags) {\n  return null;\n}\n\n//Provides: caml_raise_nodejs_error\n//Requires: caml_raise_with_args, make_unix_err_args, caml_named_value\n//Requires: caml_raise_sys_error\nfunction caml_raise_nodejs_error(err, raise_unix, cmd) {\n  var unix_error = caml_named_value(\"Unix.Unix_error\");\n  if (raise_unix && unix_error) {\n    var args = make_unix_err_args(\n      err.code,\n      cmd || err.syscall,\n      err.path,\n      err.errno,\n    );\n    caml_raise_with_args(unix_error, args);\n  } else {\n    caml_raise_sys_error(err.toString());\n  }\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2014 Jérôme Vouillon, Hugo Heuzard\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Dummy filesystem\n\n//Provides: caml_trailing_slash\nfunction caml_trailing_slash(name) {\n  return name.slice(-1) !== \"/\" ? name + \"/\" : name;\n}\n\n//Provides: caml_current_dir\n//Requires: caml_trailing_slash, fs_node_supported\nif (fs_node_supported() && globalThis.process && globalThis.process.cwd)\n  var caml_current_dir = globalThis.process.cwd().replace(/\\\\/g, \"/\");\nelse var caml_current_dir = \"/static\";\ncaml_current_dir = caml_trailing_slash(caml_current_dir);\n\n//Provides: caml_get_root\n//Requires: path_is_absolute\nfunction caml_get_root(path) {\n  var x = path_is_absolute(path);\n  if (!x) return;\n  return x[0] + \"/\";\n}\n\n//Provides: caml_root\n//Requires: caml_get_root, caml_current_dir, caml_failwith\nvar caml_root =\n  caml_get_root(caml_current_dir) ||\n  caml_failwith(\"unable to compute caml_root\");\n\n//Provides: MlFile\nfunction MlFile() {}\n\n//Provides: path_is_absolute\n//Requires: fs_node_supported\nfunction make_path_is_absolute() {\n  function posix(path) {\n    if (path.charAt(0) === \"/\") return [\"\", path.slice(1)];\n    return;\n  }\n\n  function win32(path) {\n    // https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56\n    var splitDeviceRe =\n      /^([a-zA-Z]:|[\\\\/]{2}[^\\\\/]+[\\\\/]+[^\\\\/]+)?([\\\\/])?([\\s\\S]*?)$/;\n    var result = splitDeviceRe.exec(path);\n    var device = result[1] || \"\";\n    var isUnc = device.length > 0 && device.charAt(1) !== \":\";\n\n    // UNC paths are always absolute\n    if (result[2] || isUnc) {\n      var root = result[1] || \"\";\n      var sep = result[2] || \"\";\n      return [root, path.slice(root.length + sep.length)];\n    }\n    return;\n  }\n  if (\n    fs_node_supported() &&\n    globalThis.process &&\n    globalThis.process.platform\n  ) {\n    return globalThis.process.platform === \"win32\" ? win32 : posix;\n  } else return posix;\n}\nvar path_is_absolute = make_path_is_absolute();\n\n//Provides: caml_make_path\n//Requires: caml_current_dir\n//Requires: caml_jsstring_of_string, path_is_absolute\nfunction caml_make_path(name) {\n  name = caml_jsstring_of_string(name);\n  if (!path_is_absolute(name)) name = caml_current_dir + name;\n  var comp0 = path_is_absolute(name);\n  var comp = comp0[1].split(/[/\\\\]/);\n  var ncomp = [];\n  for (var i = 0; i < comp.length; i++) {\n    switch (comp[i]) {\n      case \"..\":\n        ncomp.pop();\n        break;\n      case \".\":\n        break;\n      case \"\":\n        break;\n      default:\n        ncomp.push(comp[i]);\n        break;\n    }\n  }\n  ncomp.unshift(comp0[0]);\n  ncomp.orig = name;\n  return ncomp;\n}\n\n//Provides:jsoo_mount_point\n//Requires: MlFakeDevice, MlNodeDevice, caml_root, fs_node_supported\nvar jsoo_mount_point = [];\nif (fs_node_supported()) {\n  jsoo_mount_point.push({\n    path: caml_root,\n    device: new MlNodeDevice(caml_root),\n  });\n} else {\n  jsoo_mount_point.push({\n    path: caml_root,\n    device: new MlFakeDevice(caml_root),\n  });\n}\njsoo_mount_point.push({\n  path: \"/static/\",\n  device: new MlFakeDevice(\"/static/\"),\n});\n\n//Provides:caml_list_mount_point\n//Requires: jsoo_mount_point, caml_string_of_jsstring\nfunction caml_list_mount_point() {\n  var prev = 0;\n  for (var i = 0; i < jsoo_mount_point.length; i++) {\n    var old = prev;\n    prev = [0, caml_string_of_jsstring(jsoo_mount_point[i].path), old];\n  }\n  return prev;\n}\n\n//Provides: resolve_fs_device\n//Requires: caml_make_path, jsoo_mount_point, caml_raise_sys_error, caml_get_root, MlNodeDevice, caml_trailing_slash, fs_node_supported\nfunction resolve_fs_device(name) {\n  var path = caml_make_path(name);\n  var name = path.join(\"/\");\n  var name_slash = caml_trailing_slash(name);\n  var res;\n  for (var i = 0; i < jsoo_mount_point.length; i++) {\n    var m = jsoo_mount_point[i];\n    if (\n      name_slash.search(m.path) === 0 &&\n      (!res || res.path.length < m.path.length)\n    )\n      res = {\n        path: m.path,\n        device: m.device,\n        rest: name.slice(m.path.length, name.length),\n      };\n  }\n  if (!res && fs_node_supported()) {\n    var root = caml_get_root(name);\n    if (root?.match(/^[a-zA-Z]:\\/$/)) {\n      var m = { path: root, device: new MlNodeDevice(root) };\n      jsoo_mount_point.push(m);\n      res = {\n        path: m.path,\n        device: m.device,\n        rest: name.slice(m.path.length, name.length),\n      };\n    }\n  }\n  if (res) return res;\n  caml_raise_sys_error(\"no device found for \" + name_slash);\n}\n\n//Provides: caml_mount_autoload\n//Requires: MlFakeDevice, caml_make_path, jsoo_mount_point, caml_trailing_slash\nfunction caml_mount_autoload(name, f) {\n  var path = caml_make_path(name);\n  var name = caml_trailing_slash(path.join(\"/\"));\n  jsoo_mount_point.push({ path: name, device: new MlFakeDevice(name, f) });\n  return 0;\n}\n\n//Provides: caml_unmount\n//Requires: jsoo_mount_point, caml_make_path, caml_trailing_slash\nfunction caml_unmount(name) {\n  var path = caml_make_path(name);\n  var name = caml_trailing_slash(path.join(\"/\"));\n  var idx = -1;\n  for (var i = 0; i < jsoo_mount_point.length; i++)\n    if (jsoo_mount_point[i].path === name) idx = i;\n  if (idx > -1) jsoo_mount_point.splice(idx, 1);\n  return 0;\n}\n\n//Provides: caml_sys_getcwd\n//Requires: caml_current_dir, caml_string_of_jsstring\n//Alias: caml_unix_getcwd\n//Alias: unix_getcwd\nfunction caml_sys_getcwd() {\n  return caml_string_of_jsstring(caml_current_dir);\n}\n\n//Provides: caml_sys_chdir\n//Requires: caml_current_dir, caml_raise_no_such_file, resolve_fs_device, caml_trailing_slash, caml_jsstring_of_string, caml_raise_system_error\nfunction caml_sys_chdir(dir, raise_unix) {\n  var root = resolve_fs_device(dir);\n  if (root.device.is_dir(root.rest)) {\n    if (root.rest)\n      caml_current_dir = caml_trailing_slash(root.path + root.rest);\n    else caml_current_dir = root.path;\n    return 0;\n  } else if (root.device.exists(root.rest)) {\n    caml_raise_system_error(\n      raise_unix,\n      \"ENOTDIR\",\n      \"chdir\",\n      \"not a directory\",\n      caml_jsstring_of_string(dir),\n    );\n  } else {\n    caml_raise_no_such_file(caml_jsstring_of_string(dir), raise_unix);\n  }\n}\n\n//Provides: caml_raise_no_such_file\n//Requires: caml_raise_system_error\nfunction caml_raise_no_such_file(name, raise_unix) {\n  caml_raise_system_error(\n    raise_unix,\n    \"ENOENT\",\n    \"no such file or directory\",\n    name,\n  );\n}\n\n//Provides: caml_sys_file_exists\n//Requires: resolve_fs_device\nfunction caml_sys_file_exists(name) {\n  var root = resolve_fs_device(name);\n  return root.device.exists(root.rest);\n}\n\n//Provides: caml_sys_read_directory\n//Requires: caml_string_of_jsstring\n//Requires: resolve_fs_device\nfunction caml_sys_read_directory(name) {\n  var root = resolve_fs_device(name);\n  var a = root.device.readdir(root.rest);\n  var l = new Array(a.length + 1);\n  l[0] = 0;\n  for (var i = 0; i < a.length; i++) l[i + 1] = caml_string_of_jsstring(a[i]);\n  return l;\n}\n\n//Provides: caml_sys_remove\n//Requires: resolve_fs_device\nfunction caml_sys_remove(name) {\n  var root = resolve_fs_device(name);\n  return root.device.unlink(root.rest);\n}\n\n//Provides: caml_sys_is_directory\n//Requires: resolve_fs_device\nfunction caml_sys_is_directory(name) {\n  var root = resolve_fs_device(name);\n  var a = root.device.is_dir(root.rest);\n  return a ? 1 : 0;\n}\n\n//Provides: caml_sys_rename\n//Requires: caml_failwith, resolve_fs_device\nfunction caml_sys_rename(o, n) {\n  var o_root = resolve_fs_device(o);\n  var n_root = resolve_fs_device(n);\n  if (o_root.device !== n_root.device)\n    caml_failwith(\"caml_sys_rename: cannot move file between two filesystem\");\n  if (!o_root.device.rename) caml_failwith(\"caml_sys_rename: no implemented\");\n  o_root.device.rename(o_root.rest, n_root.rest);\n}\n\n//Provides: caml_sys_mkdir\n//Requires: resolve_fs_device\nfunction caml_sys_mkdir(name, perm) {\n  var root = resolve_fs_device(name);\n  root.device.mkdir(root.rest, perm);\n  return 0;\n}\n\n//Provides: caml_sys_rmdir\n//Requires: resolve_fs_device\nfunction caml_sys_rmdir(name) {\n  var root = resolve_fs_device(name);\n  root.device.rmdir(root.rest);\n  return 0;\n}\n\n//Provides: caml_ba_map_file\n//Requires: caml_failwith\nfunction caml_ba_map_file(_vfd, _kind, _layout, _shared, _dims, _pos) {\n  // var data = caml_sys_fds[vfd];\n  caml_failwith(\"caml_ba_map_file not implemented\");\n}\n\n//Provides: caml_ba_map_file_bytecode\n//Requires: caml_ba_map_file\nfunction caml_ba_map_file_bytecode(argv, _argn) {\n  // argn === 6\n  return caml_ba_map_file(argv[0], argv[1], argv[2], argv[3], argv[4], argv[5]);\n}\n\n//Provides: jsoo_create_file_extern\nfunction jsoo_create_file_extern(name, content) {\n  if (globalThis.jsoo_create_file) globalThis.jsoo_create_file(name, content);\n  else {\n    if (!globalThis.jsoo_fs_tmp) globalThis.jsoo_fs_tmp = [];\n    globalThis.jsoo_fs_tmp.push({ name: name, content: content });\n  }\n  return 0;\n}\n\n//Provides: caml_fs_init\n//Requires: jsoo_create_file\nfunction caml_fs_init() {\n  var tmp = globalThis.jsoo_fs_tmp;\n  if (tmp) {\n    for (var i = 0; i < tmp.length; i++) {\n      jsoo_create_file(tmp[i].name, tmp[i].content);\n    }\n  }\n  globalThis.jsoo_create_file = jsoo_create_file;\n  globalThis.jsoo_fs_tmp = [];\n  return 0;\n}\n\n//Provides: caml_create_file\n//Requires: caml_failwith, resolve_fs_device\nfunction caml_create_file(name, content) {\n  var root = resolve_fs_device(name);\n  if (!root.device.register) caml_failwith(\"cannot register file\");\n  root.device.register(root.rest, content);\n  return 0;\n}\n\n//Provides: jsoo_create_file\n//Requires: caml_create_file, caml_string_of_jsbytes, caml_string_of_jsstring\nfunction jsoo_create_file(name, content) {\n  var name = caml_string_of_jsstring(name);\n  var content = caml_string_of_jsbytes(content);\n  return caml_create_file(name, content);\n}\n\n//Provides: caml_read_file_content\n//Requires: resolve_fs_device, caml_raise_no_such_file, caml_string_of_uint8_array\n//Requires: caml_string_of_jsstring, caml_jsstring_of_string\nfunction caml_read_file_content(name) {\n  var name = typeof name === \"string\" ? caml_string_of_jsstring(name) : name;\n  var root = resolve_fs_device(name);\n  if (root.device.exists(root.rest)) {\n    var file = root.device.open(root.rest, { rdonly: 1 });\n    var len = file.length();\n    var buf = new Uint8Array(len);\n    file.read(buf, 0, len);\n    return caml_string_of_uint8_array(buf);\n  }\n  caml_raise_no_such_file(caml_jsstring_of_string(name));\n}\n","//Provides: caml_unix_gettimeofday\n//Alias: unix_gettimeofday\nfunction caml_unix_gettimeofday() {\n  return new Date().getTime() / 1000;\n}\n\n//Provides: caml_unix_time\n//Requires: caml_unix_gettimeofday\n//Alias: unix_time\nfunction caml_unix_time() {\n  return Math.floor(caml_unix_gettimeofday());\n}\n\n//Provides: caml_unix_times\n//Requires: caml_failwith\n//Alias: unix_times\nfunction caml_unix_times() {\n  if (globalThis.process?.cpuUsage) {\n    var t = globalThis.process.cpuUsage();\n    return BLOCK(0, t.user / 1e6, t.system / 1e6, 0, 0);\n  } else if (globalThis.performance?.now) {\n    return BLOCK(0, globalThis.performance.now() / 1000, 0, 0, 0);\n  } else {\n    caml_failwith(\"caml_unix_times: not implemented\");\n  }\n}\n\n//Provides: caml_unix_gmtime\n//Alias: unix_gmtime\nfunction caml_unix_gmtime(t) {\n  var d = new Date(t * 1000);\n  var d_num = d.getTime();\n  var januaryfirst = new Date(Date.UTC(d.getUTCFullYear(), 0, 1)).getTime();\n  var doy = Math.floor((d_num - januaryfirst) / 86400000);\n  return BLOCK(\n    0,\n    d.getUTCSeconds(),\n    d.getUTCMinutes(),\n    d.getUTCHours(),\n    d.getUTCDate(),\n    d.getUTCMonth(),\n    d.getUTCFullYear() - 1900,\n    d.getUTCDay(),\n    doy,\n    false | 0 /* for UTC daylight savings time is false */,\n  );\n}\n\n//Provides: caml_unix_localtime\n//Alias: unix_localtime\nfunction caml_unix_localtime(t) {\n  var d = new Date(t * 1000);\n  var d_num = d.getTime();\n  var januaryfirst = new Date(d.getFullYear(), 0, 1).getTime();\n  var doy = Math.floor((d_num - januaryfirst) / 86400000);\n  var jan = new Date(d.getFullYear(), 0, 1);\n  var jul = new Date(d.getFullYear(), 6, 1);\n  var stdTimezoneOffset = Math.max(\n    jan.getTimezoneOffset(),\n    jul.getTimezoneOffset(),\n  );\n  return BLOCK(\n    0,\n    d.getSeconds(),\n    d.getMinutes(),\n    d.getHours(),\n    d.getDate(),\n    d.getMonth(),\n    d.getFullYear() - 1900,\n    d.getDay(),\n    doy,\n    (d.getTimezoneOffset() < stdTimezoneOffset) |\n      0 /* daylight savings time  field. */,\n  );\n}\n\n//Provides: caml_unix_mktime\n//Requires: caml_unix_localtime\n//Alias: unix_mktime\nfunction caml_unix_mktime(tm) {\n  var d = new Date(tm[6] + 1900, tm[5], tm[4], tm[3], tm[2], tm[1]).getTime();\n  var t = Math.floor(d / 1000);\n  var tm2 = caml_unix_localtime(t);\n  return BLOCK(0, t, tm2);\n}\n//Provides: caml_unix_startup const\n//Alias: win_startup\nfunction caml_unix_startup() {}\n\n//Provides: caml_unix_cleanup const\n//Alias: win_cleanup\nfunction caml_unix_cleanup() {}\n\n//Provides: caml_unix_filedescr_of_fd const\n//Alias: win_handle_fd\nfunction caml_unix_filedescr_of_fd(x) {\n  return x;\n}\n\n//Provides: caml_unix_isatty\n//Requires: fs_node_supported, caml_unix_lookup_file\n//Alias: unix_isatty\nfunction caml_unix_isatty(fd) {\n  if (fs_node_supported()) {\n    var tty = require(\"node:tty\");\n    return tty.isatty(caml_unix_lookup_file(fd).fd) ? 1 : 0;\n  } else {\n    return 0;\n  }\n}\n\n//Provides: caml_unix_isatty\n//Alias: unix_isatty\n//If: browser\nfunction caml_unix_isatty(_fileDescriptor) {\n  return 0;\n}\n\n//Provides: unix_error\nvar unix_error = [\n  /* ===Unix.error===\n   *\n   * This array is in order of the variant in OCaml\n   */\n  \"E2BIG\",\n  \"EACCES\",\n  \"EAGAIN\",\n  \"EBADF\",\n  \"EBUSY\",\n  \"ECHILD\",\n  \"EDEADLK\",\n  \"EDOM\",\n  \"EEXIST\",\n  \"EFAULT\",\n  \"EFBIG\",\n  \"EINTR\",\n  \"EINVAL\",\n  \"EIO\",\n  \"EISDIR\",\n  \"EMFILE\",\n  \"EMLINK\",\n  \"ENAMETOOLONG\",\n  \"ENFILE\",\n  \"ENODEV\",\n  \"ENOENT\",\n  \"ENOEXEC\",\n  \"ENOLCK\",\n  \"ENOMEM\",\n  \"ENOSPC\",\n  \"ENOSYS\",\n  \"ENOTDIR\",\n  \"ENOTEMPTY\",\n  \"ENOTTY\",\n  \"ENXIO\",\n  \"EPERM\",\n  \"EPIPE\",\n  \"ERANGE\",\n  \"EROFS\",\n  \"ESPIPE\",\n  \"ESRCH\",\n  \"EXDEV\",\n  \"EWOULDBLOCK\",\n  \"EINPROGRESS\",\n  \"EALREADY\",\n  \"ENOTSOCK\",\n  \"EDESTADDRREQ\",\n  \"EMSGSIZE\",\n  \"EPROTOTYPE\",\n  \"ENOPROTOOPT\",\n  \"EPROTONOSUPPORT\",\n  \"ESOCKTNOSUPPORT\",\n  \"EOPNOTSUPP\",\n  \"EPFNOSUPPORT\",\n  \"EAFNOSUPPORT\",\n  \"EADDRINUSE\",\n  \"EADDRNOTAVAIL\",\n  \"ENETDOWN\",\n  \"ENETUNREACH\",\n  \"ENETRESET\",\n  \"ECONNABORTED\",\n  \"ECONNRESET\",\n  \"ENOBUFS\",\n  \"EISCONN\",\n  \"ENOTCONN\",\n  \"ESHUTDOWN\",\n  \"ETOOMANYREFS\",\n  \"ETIMEDOUT\",\n  \"ECONNREFUSED\",\n  \"EHOSTDOWN\",\n  \"EHOSTUNREACH\",\n  \"ELOOP\",\n  \"EOVERFLOW\",\n];\n\n//Provides: make_unix_err_args\n//Requires: unix_error, caml_string_of_jsstring\nfunction make_unix_err_args(code, syscall, path, errno) {\n  var variant = unix_error.indexOf(code);\n  if (variant < 0) {\n    // Default if undefined\n    if (errno == null) {\n      errno = -9999;\n    }\n    // If none of the above variants, fallback to EUNKNOWNERR(int)\n    // errno is expected to be positive\n    variant = BLOCK(0, -errno);\n  }\n  var args = [\n    variant,\n    caml_string_of_jsstring(syscall || \"\"),\n    caml_string_of_jsstring(path || \"\"),\n  ];\n  return args;\n}\n\n//Provides: caml_strerror\n//Requires: unix_error\nfunction caml_strerror(errno) {\n  const util = require(\"node:util\");\n  if (errno >= 0) {\n    const code = unix_error[errno];\n    return util\n      .getSystemErrorMap()\n      .entries()\n      .find((x) => x[1][0] === code)[1][1];\n  } else {\n    return util.getSystemErrorMessage(errno);\n  }\n}\n\n//Provides: unix_error_message\n//Alias: caml_unix_error_message\n//Requires: caml_strerror, caml_string_of_jsstring\nfunction unix_error_message(err) {\n  const errno = typeof err === \"number\" ? err : -err[1];\n  return caml_string_of_jsstring(caml_strerror(errno));\n}\n\n//Provides: caml_unix_chdir\n//Requires: caml_sys_chdir\n//Alias: unix_chdir\nfunction caml_unix_chdir(dir) {\n  return caml_sys_chdir(dir, /* raise Unix_error */ true);\n}\n\n//Provides: caml_unix_stat\n//Requires: resolve_fs_device, caml_failwith\n//Alias: unix_stat\nfunction caml_unix_stat(name) {\n  var root = resolve_fs_device(name);\n  if (!root.device.stat) {\n    caml_failwith(\"caml_unix_stat: not implemented\");\n  }\n  return root.device.stat(\n    root.rest,\n    /* large */ false,\n    /* raise Unix_error */ true,\n  );\n}\n\n//Provides: caml_unix_stat_64\n//Requires: resolve_fs_device, caml_failwith\n//Alias: unix_stat_64\nfunction caml_unix_stat_64(name) {\n  var root = resolve_fs_device(name);\n  if (!root.device.stat) {\n    caml_failwith(\"caml_unix_stat_64: not implemented\");\n  }\n  return root.device.stat(\n    root.rest,\n    /* large */ true,\n    /* raise Unix_error */ true,\n  );\n}\n\n//Provides: caml_unix_lstat\n//Requires: resolve_fs_device, caml_failwith\n//Alias: unix_lstat\nfunction caml_unix_lstat(name) {\n  var root = resolve_fs_device(name);\n  if (!root.device.lstat) {\n    caml_failwith(\"caml_unix_lstat: not implemented\");\n  }\n  return root.device.lstat(\n    root.rest,\n    /* large */ false,\n    /* raise Unix_error */ true,\n  );\n}\n\n//Provides: caml_unix_lstat_64\n//Requires: resolve_fs_device, caml_failwith\n//Alias: unix_lstat_64\nfunction caml_unix_lstat_64(name) {\n  var root = resolve_fs_device(name);\n  if (!root.device.lstat) {\n    caml_failwith(\"caml_unix_lstat_64: not implemented\");\n  }\n  return root.device.lstat(\n    root.rest,\n    /* large */ true,\n    /* raise Unix_error */ true,\n  );\n}\n\n//Provides: caml_unix_chmod\n//Requires: resolve_fs_device, caml_failwith\n//Alias: unix_chmod\nfunction caml_unix_chmod(name, perms) {\n  var root = resolve_fs_device(name);\n  if (!root.device.chmod) {\n    caml_failwith(\"caml_unix_chmod: not implemented\");\n  }\n  return root.device.chmod(root.rest, perms);\n}\n\n//Provides: caml_unix_rename\n//Requires: caml_failwith, resolve_fs_device\n//Requires: caml_raise_system_error\n//Alias: unix_rename\nfunction caml_unix_rename(o, n) {\n  var o_root = resolve_fs_device(o);\n  var n_root = resolve_fs_device(n);\n  if (o_root.device !== n_root.device)\n    caml_raise_system_error(/* raise Unix_error */ 1, \"EXDEV\", \"rename\");\n  if (!o_root.device.rename) caml_failwith(\"caml_sys_rename: no implemented\");\n  o_root.device.rename(o_root.rest, n_root.rest, /* raise Unix_error */ true);\n}\n\n//Provides: caml_unix_mkdir\n//Requires: resolve_fs_device, caml_failwith\n//Alias: unix_mkdir\nfunction caml_unix_mkdir(name, perm) {\n  var root = resolve_fs_device(name);\n  if (!root.device.mkdir) {\n    caml_failwith(\"caml_unix_mkdir: not implemented\");\n  }\n  return root.device.mkdir(root.rest, perm, /* raise Unix_error */ true);\n}\n\n//Provides: caml_unix_rmdir\n//Requires: resolve_fs_device, caml_failwith\n//Alias: unix_rmdir\nfunction caml_unix_rmdir(name) {\n  var root = resolve_fs_device(name);\n  if (!root.device.rmdir) {\n    caml_failwith(\"caml_unix_rmdir: not implemented\");\n  }\n  return root.device.rmdir(root.rest, /* raise Unix_error */ true);\n}\n\n//Provides: caml_unix_link\n//Requires: resolve_fs_device, caml_failwith, caml_raise_system_error\n//Alias: unix_link\nfunction caml_unix_link(follow, src, dst) {\n  var src_root = resolve_fs_device(src);\n  var dst_root = resolve_fs_device(dst);\n  if (!src_root.device.link) {\n    caml_failwith(\"caml_unix_link: not implemented\");\n  }\n  // We can't control whether a 'src' symlink is followed or not.\n  // So we fail when 'follow' is set, as documented in the Unix module.\n  if (typeof follow !== \"number\")\n    caml_raise_system_error(/* raise Unix_error */ 1, \"ENOSYS\", \"link\");\n  if (src_root.device !== dst_root.device)\n    caml_raise_system_error(/* raise Unix_error */ 1, \"EXDEV\", \"link\");\n  return src_root.device.link(\n    src_root.rest,\n    dst_root.rest,\n    /* raise Unix_error */ true,\n  );\n}\n\n//Provides: caml_unix_symlink\n//Requires: resolve_fs_device, caml_failwith, caml_jsstring_of_string\n//Alias: unix_symlink\nfunction caml_unix_symlink(to_dir, src, dst) {\n  var dst_root = resolve_fs_device(dst);\n  if (!dst_root.device.symlink) {\n    caml_failwith(\"caml_unix_symlink: not implemented\");\n  }\n  return dst_root.device.symlink(\n    to_dir,\n    caml_jsstring_of_string(src),\n    dst_root.rest,\n    /* raise Unix_error */ true,\n  );\n}\n\n//Provides: caml_unix_readlink\n//Requires: resolve_fs_device, caml_failwith\n//Alias: unix_readlink\nfunction caml_unix_readlink(name) {\n  var root = resolve_fs_device(name);\n  if (!root.device.readlink) {\n    caml_failwith(\"caml_unix_readlink: not implemented\");\n  }\n  return root.device.readlink(root.rest, /* raise Unix_error */ true);\n}\n\n//Provides: caml_unix_unlink\n//Requires: resolve_fs_device, caml_failwith\n//Alias: unix_unlink\nfunction caml_unix_unlink(name) {\n  var root = resolve_fs_device(name);\n  if (!root.device.unlink) {\n    caml_failwith(\"caml_unix_unlink: not implemented\");\n  }\n  root.device.unlink(root.rest, /* raise Unix_error */ true);\n  return 0;\n}\n\n//Provides: caml_unix_utimes\n//Requires: resolve_fs_device, caml_failwith\n//Alias: unix_utimes\nfunction caml_unix_utimes(name, atime, mtime) {\n  var root = resolve_fs_device(name);\n  if (!root.device.utimes) {\n    caml_failwith(\"caml_unix_utimes: not implemented\");\n  }\n  root.device.utimes(root.rest, atime, mtime, /* raise Unix_error */ true);\n  return 0;\n}\n\n//Provides: caml_unix_truncate\n//Requires: resolve_fs_device, caml_failwith\n//Alias: unix_truncate\nfunction caml_unix_truncate(name, len) {\n  var root = resolve_fs_device(name);\n  if (!root.device.truncate) {\n    caml_failwith(\"caml_unix_truncate: not implemented\");\n  }\n  root.device.truncate(root.rest, len, /* raise Unix_error */ true);\n  return 0;\n}\n\n//Provides: caml_unix_truncate_64\n//Requires: resolve_fs_device, caml_failwith, caml_int64_to_float\n//Alias: unix_truncate_64\nfunction caml_unix_truncate_64(name, len) {\n  var root = resolve_fs_device(name);\n  if (!root.device.truncate) {\n    caml_failwith(\"caml_unix_truncate_64: not implemented\");\n  }\n  root.device.truncate(\n    root.rest,\n    caml_int64_to_float(len),\n    /* raise Unix_error */ true,\n  );\n  return 0;\n}\n\n//Provides: caml_unix_access\n//Requires: resolve_fs_device, caml_failwith\n//Alias: unix_access\nfunction caml_unix_access(name, flags) {\n  var f = {};\n  while (flags) {\n    switch (flags[1]) {\n      case 0:\n        f.r = 1;\n        break;\n      case 1:\n        f.w = 1;\n        break;\n      case 2:\n        f.x = 1;\n        break;\n      case 3:\n        f.f = 1;\n        break;\n    }\n    flags = flags[2];\n  }\n  var root = resolve_fs_device(name);\n  if (!root.device.access) {\n    caml_failwith(\"caml_unix_access: not implemented\");\n  }\n  root.device.access(root.rest, f, /* raise Unix_error */ true);\n  return 0;\n}\n\n//Provides: caml_unix_open\n//Requires: resolve_fs_device, caml_sys_fds, MlChanid\n//Alias: unix_open\nfunction caml_unix_open(name, flags, perms) {\n  var f = {};\n  while (flags) {\n    switch (flags[1]) {\n      case 0:\n        f.rdonly = 1;\n        break;\n      case 1:\n        f.wronly = 1;\n        break;\n      case 2:\n        f.rdwr = 1;\n        break;\n      case 3:\n        f.nonblock = 1;\n        break;\n      case 4:\n        f.append = 1;\n        break;\n      case 5:\n        f.create = 1;\n        break;\n      case 6:\n        f.truncate = 1;\n        break;\n      case 7:\n        f.excl = 1;\n        break;\n      case 8:\n        f.noctty = 1;\n        break;\n      case 9:\n        f.dsync = 1;\n        break;\n      case 10:\n        f.sync = 1;\n        break;\n    }\n    flags = flags[2];\n  }\n  var root = resolve_fs_device(name);\n  var file = root.device.open(root.rest, f, perms, /* raise Unix_error */ true);\n  var idx = caml_sys_fds.length;\n  var chanid = new MlChanid(idx);\n  caml_sys_fds[idx] = { file: file, chanid: chanid };\n  return idx | 0;\n}\n\n//Provides: caml_unix_lookup_file\n//Requires: caml_sys_fds, caml_raise_system_error\nfunction caml_unix_lookup_file(fd, cmd) {\n  var fd_desc = caml_sys_fds[fd];\n  if (fd_desc === undefined)\n    caml_raise_system_error(/* raise Unix_error */ 1, \"EBADF\", cmd);\n  return fd_desc.file;\n}\n\n//Provides: caml_unix_fstat\n//Alias: unix_fstat\n//Requires: caml_unix_lookup_file, caml_failwith\nfunction caml_unix_fstat(fd) {\n  var file = caml_unix_lookup_file(fd, \"fstat\");\n  if (!file.stat) {\n    caml_failwith(\"caml_unix_fstat: not implemented\");\n  }\n  return file.stat(/* large */ false);\n}\n\n//Provides: caml_unix_fstat_64\n//Alias: unix_fstat_64\n//Requires: caml_unix_lookup_file, caml_failwith\nfunction caml_unix_fstat_64(fd) {\n  var file = caml_unix_lookup_file(fd, \"fstat\");\n  if (!file.stat) {\n    caml_failwith(\"caml_unix_fstat64: not implemented\");\n  }\n  return file.stat(/* large */ true);\n}\n\n//Provides: caml_unix_fchmod\n//Alias: unix_fchmod\n//Requires: caml_unix_lookup_file, caml_failwith\nfunction caml_unix_fchmod(fd, perms) {\n  var file = caml_unix_lookup_file(fd, \"fchmod\");\n  if (!file.chmod) {\n    caml_failwith(\"caml_unix_fchmod: not implemented\");\n  }\n  return file.chmod(perms);\n}\n\n//Provides: caml_unix_fsync\n//Alias: unix_fsync\n//Requires: caml_unix_lookup_file, caml_failwith\nfunction caml_unix_fsync(fd) {\n  var file = caml_unix_lookup_file(fd, \"fsync\");\n  if (!file.sync) {\n    caml_failwith(\"caml_unix_fsync: not implemented\");\n  }\n  return file.sync();\n}\n\n//Provides: caml_unix_write\n//Alias: unix_write\n//Requires: caml_unix_lookup_file, caml_uint8_array_of_bytes\nfunction caml_unix_write(fd, buf, pos, len) {\n  var file = caml_unix_lookup_file(fd, \"write\");\n  var a = caml_uint8_array_of_bytes(buf);\n  var written = 0;\n  while (len > 0) {\n    var n = file.write(a, pos, len, /* raise unix_error */ 1);\n    written += n;\n    pos += n;\n    len -= n;\n  }\n  return written;\n}\n\n//Provides: caml_unix_single_write\n//Alias: unix_single_write\n//Requires: caml_unix_lookup_file, caml_uint8_array_of_bytes\nfunction caml_unix_single_write(fd, buf, pos, len) {\n  var file = caml_unix_lookup_file(fd, \"write\");\n  if (len === 0) return 0;\n  return file.write(\n    caml_uint8_array_of_bytes(buf),\n    pos,\n    len,\n    /* raise unix_error */ 1,\n  );\n}\n\n//Provides: caml_unix_write_bigarray\n//Alias: caml_unix_lookup_file\n//Requires: caml_ba_to_typed_array, caml_unix_lookup_file\n//Version: >= 5.2\nfunction caml_unix_write_bigarray(fd, buf, pos, len) {\n  var a = caml_ba_to_typed_array(buf);\n  var file = caml_unix_lookup_file(fd, \"write\");\n  var written = 0;\n  while (len > 0) {\n    var n = file.write(a, pos, len, /* raise unix_error */ 1);\n    written += n;\n    pos += n;\n    len -= n;\n  }\n  return written;\n}\n\n//Provides: caml_unix_read\n//Alias: unix_read\n//Requires: caml_unix_lookup_file, caml_uint8_array_of_bytes\nfunction caml_unix_read(fd, buf, pos, len) {\n  var file = caml_unix_lookup_file(fd, \"read\");\n  return file.read(\n    caml_uint8_array_of_bytes(buf),\n    pos,\n    len,\n    /* raise unix_error */ 1,\n  );\n}\n\n//Provides: caml_unix_read_bigarray\n//Alias: unix_read_bigarray\n//Requires: caml_ba_to_typed_array, caml_unix_lookup_file\n//Version: >= 5.2\nfunction caml_unix_read_bigarray(fd, buf, pos, len) {\n  var a = caml_ba_to_typed_array(buf);\n  var file = caml_unix_lookup_file(fd, \"read\");\n  return file.read(a, pos, len, /* raise unix_error */ 1);\n}\n\n//Provides: caml_unix_lseek\n//Alias: unix_lseek\n//Requires: caml_unix_lookup_file\nfunction caml_unix_lseek(fd, len, whence) {\n  var file = caml_unix_lookup_file(fd, \"lseek\");\n  return file.seek(len, whence, /* raise unix_error */ 1);\n}\n\n//Provides: caml_unix_lseek_64\n//Alias: unix_lseek_64\n//Requires: caml_unix_lookup_file, caml_int64_to_float\nfunction caml_unix_lseek_64(fd, len, whence) {\n  var file = caml_unix_lookup_file(fd, \"lseek\");\n  return file.seek(caml_int64_to_float(len), whence, /* raise unix_error */ 1);\n}\n\n//Provides: caml_unix_ftruncate\n//Alias: unix_ftruncate\n//Requires: caml_unix_lookup_file, caml_failwith\nfunction caml_unix_ftruncate(fd, len) {\n  var file = caml_unix_lookup_file(fd, \"ftruncate\");\n  if (!file.truncate) {\n    caml_failwith(\"caml_unix_ftruncate: not implemented\");\n  }\n  file.truncate(len, /* raise unix_error */ 1);\n  return 0;\n}\n\n//Provides: caml_unix_ftruncate_64\n//Alias: unix_ftruncate_64\n//Requires: caml_unix_lookup_file, caml_failwith, caml_int64_to_float\nfunction caml_unix_ftruncate_64(fd, len) {\n  var file = caml_unix_lookup_file(fd, \"ftruncate\");\n  if (!file.truncate) {\n    caml_failwith(\"caml_unix_ftruncate_64: not implemented\");\n  }\n  file.truncate(caml_int64_to_float(len), /* raise unix_error */ 1);\n  return 0;\n}\n\n//Provides: caml_unix_close\n//Alias: unix_close\n//Requires: caml_unix_lookup_file\nfunction caml_unix_close(fd) {\n  var file = caml_unix_lookup_file(fd, \"close\");\n  file.close(/* raise unix_error */ 1);\n  return 0;\n}\n\n//Provides: caml_unix_inchannel_of_filedescr\n//Alias: unix_inchannel_of_filedescr\n//Alias: win_inchannel_of_filedescr\n//Requires: caml_unix_lookup_file, caml_ml_open_descriptor_in\nfunction caml_unix_inchannel_of_filedescr(fd) {\n  var file = caml_unix_lookup_file(fd, \"out_channel_of_descr\");\n  file.check_stream_semantics(\"in_channel_of_descr\");\n  return caml_ml_open_descriptor_in(fd);\n}\n\n//Provides: caml_unix_outchannel_of_filedescr\n//Alias: unix_outchannel_of_filedescr\n//Alias: win_outchannel_of_filedescr\n//Requires: caml_unix_lookup_file, caml_ml_open_descriptor_out\nfunction caml_unix_outchannel_of_filedescr(fd) {\n  var file = caml_unix_lookup_file(fd, \"out_channel_of_descr\");\n  file.check_stream_semantics(\"out_channel_of_descr\");\n  return caml_ml_open_descriptor_out(fd);\n}\n\n//Provides: caml_unix_getuid\n//Alias: unix_getuid\nfunction caml_unix_getuid(_unit) {\n  if (globalThis.process?.getuid) {\n    return globalThis.process.getuid();\n  }\n  return 1;\n}\n\n//Provides: caml_unix_geteuid\n//Alias: unix_geteuid\nfunction caml_unix_geteuid(_unit) {\n  if (globalThis.process?.geteuid) {\n    return globalThis.process.geteuid();\n  }\n  return 1;\n}\n\n//Provides: caml_unix_getgid\n//Alias: unix_getgid\nfunction caml_unix_getgid(_unit) {\n  if (globalThis.process?.getgid) {\n    return globalThis.process.getgid();\n  }\n  return 1;\n}\n\n//Provides: caml_unix_getegid\n//Alias: unix_getegid\nfunction caml_unix_getegid(_unit) {\n  if (globalThis.process?.getegid) {\n    return globalThis.process.getegid();\n  }\n  return 1;\n}\n\n//Provides: caml_unix_getpwnam\n//Requires: caml_raise_not_found\n//Alias: unix_getpwnam\n//Alias: caml_unix_getpwuid\n//Alias: unix_getpwuid\n//Alias: caml_unix_getgrnam\n//Alias: unix_getgrnam\n//Alias: caml_unix_getgrgid\n//Alias: unix_getgrgid\nfunction caml_unix_getpwnam(_unit) {\n  caml_raise_not_found();\n}\n\n//Provides: caml_unix_has_symlink\n//Requires: fs_node_supported\n//Alias: unix_has_symlink\nfunction caml_unix_has_symlink(_unit) {\n  return fs_node_supported() ? 1 : 0;\n}\n\n//Provides: caml_unix_opendir\n//Requires: resolve_fs_device, caml_failwith\n//Alias: unix_opendir\nfunction caml_unix_opendir(path) {\n  var root = resolve_fs_device(path);\n  if (!root.device.opendir) {\n    caml_failwith(\"caml_unix_opendir: not implemented\");\n  }\n  var dir_handle = root.device.opendir(root.rest, /* raise Unix_error */ true);\n  return { pointer: dir_handle, path: path };\n}\n\n//Provides: caml_unix_readdir\n//Requires: caml_raise_end_of_file\n//Requires: caml_string_of_jsstring\n//Requires: caml_raise_system_error\n//Alias: unix_readdir\nfunction caml_unix_readdir(dir_handle) {\n  var entry;\n  try {\n    entry = dir_handle.pointer.readSync();\n  } catch (e) {\n    caml_raise_system_error(/* raise Unix_error */ 1, \"EBADF\", \"readdir\");\n  }\n  if (entry === null) {\n    caml_raise_end_of_file();\n  } else {\n    return caml_string_of_jsstring(entry.name);\n  }\n}\n\n//Provides: caml_unix_closedir\n//Requires: caml_raise_system_error\n//Alias: unix_closedir\nfunction caml_unix_closedir(dir_handle) {\n  try {\n    dir_handle.pointer.closeSync();\n  } catch (e) {\n    caml_raise_system_error(/* raise Unix_error */ 1, \"EBADF\", \"closedir\");\n  }\n}\n\n//Provides: caml_unix_rewinddir\n//Requires: caml_unix_closedir, caml_unix_opendir\n//Alias: unix_rewinddir\nfunction caml_unix_rewinddir(dir_handle) {\n  caml_unix_closedir(dir_handle);\n  var new_dir_handle = caml_unix_opendir(dir_handle.path);\n  dir_handle.pointer = new_dir_handle.pointer;\n  return 0;\n}\n\n//Provides: caml_unix_findfirst\n//Requires: caml_jsstring_of_string, caml_string_of_jsstring\n//Requires: caml_unix_opendir, caml_unix_readdir\n//Alias: win_findfirst\nfunction caml_unix_findfirst(path) {\n  // The Windows code adds this glob to the path, so we need to remove it\n  var path_js = caml_jsstring_of_string(path);\n  path_js = path_js.replace(/(^|[\\\\/])\\*\\.\\*$/, \"\");\n  path = caml_string_of_jsstring(path_js);\n  // *.* is now stripped\n  var dir_handle = caml_unix_opendir(path);\n  var first_entry = caml_unix_readdir(dir_handle);\n  // The Windows bindings type dir_handle as an `int` but it's not in JS\n  return [0, first_entry, dir_handle];\n}\n\n//Provides: caml_unix_findnext\n//Requires: caml_unix_readdir\n//Alias: win_findnext\nfunction caml_unix_findnext(dir_handle) {\n  return caml_unix_readdir(dir_handle);\n}\n\n//Provides: caml_unix_findclose\n//Requires: caml_unix_closedir\n//Alias: win_findclose\nfunction caml_unix_findclose(dir_handle) {\n  return caml_unix_closedir(dir_handle);\n}\n\n//Provides: caml_unix_inet_addr_of_string const\n//Alias: unix_inet_addr_of_string\nfunction caml_unix_inet_addr_of_string() {\n  return 0;\n}\n\n//Provides: caml_raise_system_error\n//Requires: caml_raise_with_args, make_unix_err_args, caml_named_value\n//Requires: caml_raise_sys_error\nfunction caml_raise_system_error(raise_unix, code, cmd, msg, path) {\n  var unix_error = caml_named_value(\"Unix.Unix_error\");\n  if (raise_unix && unix_error)\n    caml_raise_with_args(unix_error, make_unix_err_args(code, cmd, path));\n  else {\n    var msg = code + \": \" + msg + \", \" + cmd;\n    if (path !== undefined) msg += \" '\" + path + \"'\";\n    caml_raise_sys_error(msg);\n  }\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2014 Jérôme Vouillon, Hugo Heuzard\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: MlFakeDevice\n//Requires: MlFakeFile, MlFakeFd, caml_create_bytes\n//Requires: caml_raise_sys_error, caml_raise_no_such_file\n//Requires: caml_string_of_jsbytes, caml_string_of_jsstring\n//Requires: caml_bytes_of_array, caml_bytes_of_string, caml_bytes_of_jsbytes\n//Requires: caml_is_ml_bytes, caml_is_ml_string\n//Requires: caml_raise_system_error\nclass MlFakeDevice {\n  constructor(root, f) {\n    this.content = {};\n    this.root = root;\n    this.lookupFun = f;\n  }\n\n  nm(name) {\n    return this.root + name;\n  }\n\n  create_dir_if_needed(name) {\n    var comp = name.split(\"/\");\n    var res = \"\";\n    for (var i = 0; i < comp.length - 1; i++) {\n      res += comp[i] + \"/\";\n      if (this.content[res]) continue;\n      this.content[res] = Symbol(\"directory\");\n    }\n  }\n\n  slash(name) {\n    return /\\/$/.test(name) ? name : name + \"/\";\n  }\n\n  lookup(name) {\n    if (!this.content[name] && this.lookupFun) {\n      var res = this.lookupFun(\n        caml_string_of_jsstring(this.root),\n        caml_string_of_jsstring(name),\n      );\n      if (res !== 0) {\n        this.create_dir_if_needed(name);\n        this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]));\n      }\n    }\n  }\n\n  exists(name, do_not_lookup) {\n    // The root of the device exists\n    if (name === \"\") return 1;\n    // Check if a directory exists\n    var name_slash = this.slash(name);\n    if (this.content[name_slash]) return 1;\n    // Check if a file exists\n    if (!do_not_lookup) this.lookup(name);\n    return this.content[name] ? 1 : 0;\n  }\n\n  isFile(name) {\n    if (this.exists(name) && !this.is_dir(name)) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n\n  rename_dir(oldname, newname) {\n    if (this.exists(newname)) {\n      if (!this.is_dir(newname)) {\n        caml_raise_sys_error(\n          this.nm(newname) + \" : file already exists and is not a directory\",\n        );\n      }\n      if (this.readdir(newname).length > 0) {\n        caml_raise_sys_error(this.nm(newname) + \" : directory not empty\");\n      }\n    }\n    var old_slash = this.slash(oldname);\n    var new_slash = this.slash(newname);\n    this.create_dir_if_needed(new_slash);\n    for (const f of this.readdir(oldname)) {\n      this.rename(old_slash + f, new_slash + f);\n    }\n    delete this.content[old_slash];\n  }\n\n  rename(oldname, newname) {\n    if (!this.exists(oldname))\n      caml_raise_sys_error(this.nm(oldname) + \" : no such file or directory\");\n    if (this.is_dir(oldname)) {\n      this.rename_dir(oldname, newname);\n    } else {\n      if (this.exists(newname) && this.is_dir(newname)) {\n        caml_raise_sys_error(\n          this.nm(newname) + \" : file already exists and is a directory\",\n        );\n      }\n      this.content[newname] = this.content[oldname];\n      delete this.content[oldname];\n    }\n  }\n\n  mkdir(name, _mode, raise_unix) {\n    if (this.exists(name))\n      caml_raise_system_error(\n        raise_unix,\n        \"EEXIST\",\n        \"mkdir\",\n        \"file already exists\",\n        this.nm(name),\n      );\n    var parent = /^(.*)\\/[^/]+/.exec(name);\n    parent = parent?.[1] || \"\";\n    if (!this.exists(parent))\n      caml_raise_system_error(\n        raise_unix,\n        \"ENOENT\",\n        \"mkdir\",\n        \"no such file or directory\",\n        this.nm(name),\n      );\n    if (!this.is_dir(parent))\n      caml_raise_system_error(\n        raise_unix,\n        \"ENOTDIR\",\n        \"mkdir\",\n        \"not a directory\",\n        this.nm(name),\n      );\n    this.create_dir_if_needed(this.slash(name));\n  }\n\n  rmdir(name, raise_unix) {\n    var name_slash = name === \"\" ? \"\" : this.slash(name);\n    var r = new RegExp(\"^\" + name_slash + \"([^/]+)\");\n    if (!this.exists(name))\n      caml_raise_system_error(\n        raise_unix,\n        \"ENOENT\",\n        \"rmdir\",\n        \"no such file or directory\",\n        this.nm(name),\n      );\n    if (!this.is_dir(name))\n      caml_raise_system_error(\n        raise_unix,\n        \"ENOTDIR\",\n        \"rmdir\",\n        \"not a directory\",\n        this.nm(name),\n      );\n    for (var n in this.content) {\n      if (n.match(r))\n        caml_raise_system_error(\n          raise_unix,\n          \"ENOTEMPTY\",\n          \"rmdir\",\n          \"directory not empty\",\n          this.nm(name),\n        );\n    }\n    delete this.content[name_slash];\n  }\n\n  readdir(name) {\n    var name_slash = name === \"\" ? \"\" : this.slash(name);\n    if (!this.exists(name)) {\n      caml_raise_sys_error(name + \": No such file or directory\");\n    }\n    if (!this.is_dir(name)) {\n      caml_raise_sys_error(name + \": Not a directory\");\n    }\n    var r = new RegExp(\"^\" + name_slash + \"([^/]+)\");\n    var seen = {};\n    var a = [];\n    for (var n in this.content) {\n      var m = n.match(r);\n      if (m && !seen[m[1]]) {\n        seen[m[1]] = true;\n        a.push(m[1]);\n      }\n    }\n    return a;\n  }\n\n  opendir(name, raise_unix) {\n    var a = this.readdir(name);\n    var c = false;\n    var i = 0;\n    return {\n      readSync: function () {\n        if (c)\n          caml_raise_system_error(\n            raise_unix,\n            \"EBADF\",\n            \"readdir\",\n            \"bad file descriptor\",\n          );\n        if (i === a.length) return null;\n        var entry = a[i];\n        i++;\n        return { name: entry };\n      },\n      closeSync: function () {\n        if (c)\n          caml_raise_system_error(\n            raise_unix,\n            \"EBADF\",\n            \"readdir\",\n            \"bad file descriptor\",\n          );\n        c = true;\n        a = [];\n      },\n    };\n  }\n\n  is_dir(name) {\n    if (name === \"\") return true;\n    var name_slash = this.slash(name);\n    return this.content[name_slash] ? 1 : 0;\n  }\n\n  unlink(name, raise_unix) {\n    if (!this.exists(name, true)) {\n      // [true] means no \"lookup\" if not found.\n      caml_raise_system_error(\n        raise_unix,\n        \"ENOENT\",\n        \"unlink\",\n        \"no such file or directory\",\n        name,\n      );\n    }\n    delete this.content[name];\n    return 0;\n  }\n\n  access(name, _flags, raise_unix) {\n    this.lookup(name);\n    if (this.content[name]) {\n      if (this.is_dir(name))\n        caml_raise_system_error(\n          raise_unix,\n          \"EACCESS\",\n          \"access\",\n          \"permission denied,\",\n          this.nm(name),\n        );\n    } else {\n      caml_raise_no_such_file(this.nm(name), raise_unix);\n    }\n    return 0;\n  }\n\n  open(name, f, _perms, raise_unix) {\n    var file;\n    this.lookup(name);\n    if (this.content[name]) {\n      if (this.is_dir(name))\n        caml_raise_system_error(\n          raise_unix,\n          \"EISDIR\",\n          \"open\",\n          \"illegal operation on a directory\",\n          this.nm(name),\n        );\n      if (f.create && f.excl)\n        caml_raise_system_error(\n          raise_unix,\n          \"EEXIST\",\n          \"open\",\n          \"file already exists\",\n          this.nm(name),\n        );\n      file = this.content[name];\n      if (f.truncate) file.truncate();\n    } else if (f.create) {\n      this.create_dir_if_needed(name);\n      this.content[name] = new MlFakeFile(caml_create_bytes(0));\n      file = this.content[name];\n    } else {\n      caml_raise_no_such_file(this.nm(name), raise_unix);\n    }\n    return new MlFakeFd(this.nm(name), file, f);\n  }\n\n  truncate(name, len, raise_unix) {\n    var file;\n    this.lookup(name);\n    if (this.content[name]) {\n      if (this.is_dir(name))\n        caml_raise_system_error(\n          raise_unix,\n          \"EISDIR\",\n          \"open\",\n          \"illegal operation on a directory\",\n          this.nm(name),\n        );\n      file = this.content[name];\n      file.truncate(len);\n    } else {\n      caml_raise_no_such_file(this.nm(name), raise_unix);\n    }\n  }\n\n  register(name, content) {\n    var file;\n    if (this.content[name])\n      caml_raise_sys_error(this.nm(name) + \" : file already exists\");\n    if (caml_is_ml_bytes(content)) file = new MlFakeFile(content);\n    if (caml_is_ml_string(content))\n      file = new MlFakeFile(caml_bytes_of_string(content));\n    else if (Array.isArray(content))\n      file = new MlFakeFile(caml_bytes_of_array(content));\n    else if (typeof content === \"string\")\n      file = new MlFakeFile(caml_bytes_of_jsbytes(content));\n    else if (content.toString) {\n      var bytes = caml_bytes_of_string(\n        caml_string_of_jsstring(content.toString()),\n      );\n      file = new MlFakeFile(bytes);\n    }\n    if (file) {\n      this.create_dir_if_needed(name);\n      this.content[name] = file;\n    } else\n      caml_raise_sys_error(\n        this.nm(name) + \" : registering file with invalid content type\",\n      );\n  }\n}\n\n//Provides: MlFakeFile\n//Requires: MlFile\n//Requires: caml_create_bytes, caml_ml_bytes_length, caml_blit_bytes\n//Requires: caml_uint8_array_of_bytes, caml_bytes_of_uint8_array\nclass MlFakeFile extends MlFile {\n  constructor(content) {\n    super();\n    this.data = content;\n  }\n\n  truncate(len) {\n    var old = this.data;\n    this.data = caml_create_bytes(len | 0);\n    caml_blit_bytes(old, 0, this.data, 0, len);\n  }\n\n  length() {\n    return caml_ml_bytes_length(this.data);\n  }\n\n  write(offset, buf, pos, len) {\n    var clen = this.length();\n    if (offset + len >= clen) {\n      var new_str = caml_create_bytes(offset + len);\n      var old_data = this.data;\n      this.data = new_str;\n      caml_blit_bytes(old_data, 0, this.data, 0, clen);\n    }\n    caml_blit_bytes(\n      caml_bytes_of_uint8_array(buf),\n      pos,\n      this.data,\n      offset,\n      len,\n    );\n    return len;\n  }\n\n  read(offset, buf, pos, len) {\n    var clen = this.length();\n    if (offset + len >= clen) {\n      len = clen - offset;\n    }\n    if (len) {\n      var data = caml_create_bytes(len | 0);\n      caml_blit_bytes(this.data, offset, data, 0, len);\n      buf.set(caml_uint8_array_of_bytes(data), pos);\n    }\n    return len;\n  }\n}\n\n//Provides: MlFakeFd_out\n//Requires: MlFakeFile, caml_create_bytes, caml_blit_bytes, caml_bytes_of_uint8_array\n//Requires: caml_raise_system_error\nclass MlFakeFd_out extends MlFakeFile {\n  constructor(fd, flags) {\n    super(caml_create_bytes(0));\n    this.log = function (_s) {\n      return 0;\n    };\n    if (fd === 1 && typeof console.log === \"function\") this.log = console.log;\n    else if (fd === 2 && typeof console.error === \"function\")\n      this.log = console.error;\n    else if (typeof console.log === \"function\") this.log = console.log;\n    this.flags = flags;\n  }\n\n  length() {\n    return 0;\n  }\n\n  truncate(_len, raise_unix) {\n    caml_raise_system_error(\n      raise_unix,\n      \"EINVAL\",\n      \"ftruncate\",\n      \"invalid argument\",\n    );\n  }\n\n  write(buf, pos, len, raise_unix) {\n    var written = len;\n    if (this.log) {\n      if (\n        len > 0 &&\n        pos >= 0 &&\n        pos + len <= buf.length &&\n        buf[pos + len - 1] === 10\n      )\n        len--;\n      // Do not output the last \\n if present\n      // as console logging display a newline at the end\n      var src = caml_create_bytes(len);\n      caml_blit_bytes(caml_bytes_of_uint8_array(buf), pos, src, 0, len);\n      this.log(src.toUtf16());\n      return written;\n    }\n    caml_raise_system_error(\n      raise_unix,\n      \"EBADF\",\n      \"write\",\n      \"bad file descriptor\",\n    );\n  }\n\n  read(_buf, _pos, _len, raise_unix) {\n    caml_raise_system_error(raise_unix, \"EBADF\", \"read\", \"bad file descriptor\");\n  }\n\n  seek(_len, _whence, raise_unix) {\n    caml_raise_system_error(raise_unix, \"ESPIPE\", \"lseek\", \"illegal seek\");\n  }\n\n  close() {\n    this.log = undefined;\n  }\n\n  check_stream_semantics(_cmd) {}\n}\n\n//Provides: MlFakeFd\n//Requires: MlFakeFile\n//Requires: caml_raise_system_error\nclass MlFakeFd {\n  constructor(name, file, flags) {\n    this.file = file;\n    this.name = name;\n    this.flags = flags;\n    this.offset = 0;\n    this.seeked = false;\n  }\n\n  err_closed(cmd, raise_unix) {\n    caml_raise_system_error(raise_unix, \"EBADF\", cmd, \"bad file descriptor\");\n  }\n\n  length() {\n    if (this.file) return this.file.length();\n    this.err_closed(\"length\");\n  }\n\n  truncate(len, raise_unix) {\n    if (this.file) {\n      if (!(this.flags.wronly || this.flags.rdwr))\n        caml_raise_system_error(\n          raise_unix,\n          \"EINVAL\",\n          \"truncate\",\n          \"invalid argument\",\n        );\n      return this.file.truncate(len);\n    }\n    this.err_closed(\"truncate\", raise_unix);\n  }\n\n  write(buf, pos, len, raise_unix) {\n    if (this.file && (this.flags.wronly || this.flags.rdwr)) {\n      var offset = this.offset;\n      len = this.file.write(offset, buf, pos, len);\n      this.offset += len;\n      return len;\n    }\n    this.err_closed(\"write\", raise_unix);\n  }\n\n  read(buf, pos, len, raise_unix) {\n    if (this.file && !this.flags.wronly) {\n      var offset = this.offset;\n      len = this.file.read(offset, buf, pos, len);\n      this.offset += len;\n      return len;\n    }\n    this.err_closed(\"read\", raise_unix);\n  }\n\n  seek(offset, whence, raise_unix) {\n    switch (whence) {\n      case 0:\n        break;\n      case 1:\n        offset += this.offset;\n        break;\n      case 2:\n        offset += this.length();\n        break;\n    }\n    if (offset < 0)\n      caml_raise_system_error(\n        raise_unix,\n        \"EINVAL\",\n        \"lseek\",\n        \"invalid argument\",\n      );\n    this.offset = offset;\n    this.seeked = true;\n  }\n\n  close() {\n    if (!this.file) this.err_closed(\"close\");\n    this.file = undefined;\n  }\n\n  check_stream_semantics(cmd) {\n    if (!this.file) return this.err_closed(cmd, /* raise Unix_error */ 1);\n  }\n}\n","// Js_of_ocaml library\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Jslib: code specific to Js_of_ocaml\n\n//Provides: caml_js_html_escape const (const)\nvar caml_js_regexps = { amp: /&/g, lt: /</g, quot: /\"/g, all: /[&<\"]/ };\nfunction caml_js_html_escape(s) {\n  if (!caml_js_regexps.all.test(s)) return s;\n  return s\n    .replace(caml_js_regexps.amp, \"&amp;\")\n    .replace(caml_js_regexps.lt, \"&lt;\")\n    .replace(caml_js_regexps.quot, \"&quot;\");\n}\n\n//Provides: caml_js_html_entities\nfunction caml_js_html_entities(s) {\n  var entity = /^&#?[0-9a-zA-Z]+;$/;\n  if (s.match(entity)) {\n    var str,\n      temp = document.createElement(\"p\");\n    temp.innerHTML = s;\n    str = temp.textContent || temp.innerText;\n    temp = null;\n    return str;\n  } else {\n    return null;\n  }\n}\n\n//Provides: caml_js_get_console const\nfunction caml_js_get_console() {\n  var c = console;\n  var m = [\n    \"log\",\n    \"debug\",\n    \"info\",\n    \"warn\",\n    \"error\",\n    \"assert\",\n    \"dir\",\n    \"dirxml\",\n    \"trace\",\n    \"group\",\n    \"groupCollapsed\",\n    \"groupEnd\",\n    \"time\",\n    \"timeEnd\",\n  ];\n  function f() {}\n  for (var i = 0; i < m.length; i++) if (!c[m[i]]) c[m[i]] = f;\n  return c;\n}\n\n//Provides: caml_xmlhttprequest_create\n//Requires: caml_failwith\n//Weakdef\nfunction caml_xmlhttprequest_create(_unit) {\n  if (typeof XMLHttpRequest === \"undefined\") {\n    caml_failwith(\"XMLHttpRequest is not available\");\n  }\n  try {\n    return new XMLHttpRequest();\n  } catch {\n    caml_failwith(\"Failed to create XMLHttpRequest\");\n  }\n}\n\n//Provides: caml_js_error_of_exception\nfunction caml_js_error_of_exception(exn) {\n  if (exn.js_error) {\n    return exn.js_error;\n  }\n  return null;\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: caml_md5_chan\n//Requires: caml_string_of_uint8_array\n//Requires: caml_raise_end_of_file, caml_ml_input_block\n//Requires: caml_MD5Init, caml_MD5Update, caml_MD5Final\nfunction caml_md5_chan(chanid, toread) {\n  var ctx = caml_MD5Init();\n  var buffer = new Uint8Array(4096);\n  if (toread < 0) {\n    while (true) {\n      var read = caml_ml_input_block(chanid, buffer, 0, buffer.length);\n      if (read === 0) break;\n      caml_MD5Update(ctx, buffer.subarray(0, read), read);\n    }\n  } else {\n    while (toread > 0) {\n      var read = caml_ml_input_block(\n        chanid,\n        buffer,\n        0,\n        toread > buffer.length ? buffer.length : toread,\n      );\n      if (read === 0) caml_raise_end_of_file();\n      caml_MD5Update(ctx, buffer.subarray(0, read), read);\n      toread -= read;\n    }\n  }\n  return caml_string_of_uint8_array(caml_MD5Final(ctx));\n}\n\n//Provides: caml_md5_string\n//Requires: caml_bytes_of_string, caml_md5_bytes\nfunction caml_md5_string(s, ofs, len) {\n  return caml_md5_bytes(caml_bytes_of_string(s), ofs, len);\n}\n\n//Provides: caml_MD5Transform\nvar caml_MD5Transform = (function () {\n  function add(x, y) {\n    return (x + y) | 0;\n  }\n  function xx(q, a, b, x, s, t) {\n    a = add(add(a, q), add(x, t));\n    return add((a << s) | (a >>> (32 - s)), b);\n  }\n  function ff(a, b, c, d, x, s, t) {\n    return xx((b & c) | (~b & d), a, b, x, s, t);\n  }\n  function gg(a, b, c, d, x, s, t) {\n    return xx((b & d) | (c & ~d), a, b, x, s, t);\n  }\n  function hh(a, b, c, d, x, s, t) {\n    return xx(b ^ c ^ d, a, b, x, s, t);\n  }\n  function ii(a, b, c, d, x, s, t) {\n    return xx(c ^ (b | ~d), a, b, x, s, t);\n  }\n\n  return function (w, buffer) {\n    var a = w[0],\n      b = w[1],\n      c = w[2],\n      d = w[3];\n\n    a = ff(a, b, c, d, buffer[0], 7, 0xd76aa478);\n    d = ff(d, a, b, c, buffer[1], 12, 0xe8c7b756);\n    c = ff(c, d, a, b, buffer[2], 17, 0x242070db);\n    b = ff(b, c, d, a, buffer[3], 22, 0xc1bdceee);\n    a = ff(a, b, c, d, buffer[4], 7, 0xf57c0faf);\n    d = ff(d, a, b, c, buffer[5], 12, 0x4787c62a);\n    c = ff(c, d, a, b, buffer[6], 17, 0xa8304613);\n    b = ff(b, c, d, a, buffer[7], 22, 0xfd469501);\n    a = ff(a, b, c, d, buffer[8], 7, 0x698098d8);\n    d = ff(d, a, b, c, buffer[9], 12, 0x8b44f7af);\n    c = ff(c, d, a, b, buffer[10], 17, 0xffff5bb1);\n    b = ff(b, c, d, a, buffer[11], 22, 0x895cd7be);\n    a = ff(a, b, c, d, buffer[12], 7, 0x6b901122);\n    d = ff(d, a, b, c, buffer[13], 12, 0xfd987193);\n    c = ff(c, d, a, b, buffer[14], 17, 0xa679438e);\n    b = ff(b, c, d, a, buffer[15], 22, 0x49b40821);\n\n    a = gg(a, b, c, d, buffer[1], 5, 0xf61e2562);\n    d = gg(d, a, b, c, buffer[6], 9, 0xc040b340);\n    c = gg(c, d, a, b, buffer[11], 14, 0x265e5a51);\n    b = gg(b, c, d, a, buffer[0], 20, 0xe9b6c7aa);\n    a = gg(a, b, c, d, buffer[5], 5, 0xd62f105d);\n    d = gg(d, a, b, c, buffer[10], 9, 0x02441453);\n    c = gg(c, d, a, b, buffer[15], 14, 0xd8a1e681);\n    b = gg(b, c, d, a, buffer[4], 20, 0xe7d3fbc8);\n    a = gg(a, b, c, d, buffer[9], 5, 0x21e1cde6);\n    d = gg(d, a, b, c, buffer[14], 9, 0xc33707d6);\n    c = gg(c, d, a, b, buffer[3], 14, 0xf4d50d87);\n    b = gg(b, c, d, a, buffer[8], 20, 0x455a14ed);\n    a = gg(a, b, c, d, buffer[13], 5, 0xa9e3e905);\n    d = gg(d, a, b, c, buffer[2], 9, 0xfcefa3f8);\n    c = gg(c, d, a, b, buffer[7], 14, 0x676f02d9);\n    b = gg(b, c, d, a, buffer[12], 20, 0x8d2a4c8a);\n\n    a = hh(a, b, c, d, buffer[5], 4, 0xfffa3942);\n    d = hh(d, a, b, c, buffer[8], 11, 0x8771f681);\n    c = hh(c, d, a, b, buffer[11], 16, 0x6d9d6122);\n    b = hh(b, c, d, a, buffer[14], 23, 0xfde5380c);\n    a = hh(a, b, c, d, buffer[1], 4, 0xa4beea44);\n    d = hh(d, a, b, c, buffer[4], 11, 0x4bdecfa9);\n    c = hh(c, d, a, b, buffer[7], 16, 0xf6bb4b60);\n    b = hh(b, c, d, a, buffer[10], 23, 0xbebfbc70);\n    a = hh(a, b, c, d, buffer[13], 4, 0x289b7ec6);\n    d = hh(d, a, b, c, buffer[0], 11, 0xeaa127fa);\n    c = hh(c, d, a, b, buffer[3], 16, 0xd4ef3085);\n    b = hh(b, c, d, a, buffer[6], 23, 0x04881d05);\n    a = hh(a, b, c, d, buffer[9], 4, 0xd9d4d039);\n    d = hh(d, a, b, c, buffer[12], 11, 0xe6db99e5);\n    c = hh(c, d, a, b, buffer[15], 16, 0x1fa27cf8);\n    b = hh(b, c, d, a, buffer[2], 23, 0xc4ac5665);\n\n    a = ii(a, b, c, d, buffer[0], 6, 0xf4292244);\n    d = ii(d, a, b, c, buffer[7], 10, 0x432aff97);\n    c = ii(c, d, a, b, buffer[14], 15, 0xab9423a7);\n    b = ii(b, c, d, a, buffer[5], 21, 0xfc93a039);\n    a = ii(a, b, c, d, buffer[12], 6, 0x655b59c3);\n    d = ii(d, a, b, c, buffer[3], 10, 0x8f0ccc92);\n    c = ii(c, d, a, b, buffer[10], 15, 0xffeff47d);\n    b = ii(b, c, d, a, buffer[1], 21, 0x85845dd1);\n    a = ii(a, b, c, d, buffer[8], 6, 0x6fa87e4f);\n    d = ii(d, a, b, c, buffer[15], 10, 0xfe2ce6e0);\n    c = ii(c, d, a, b, buffer[6], 15, 0xa3014314);\n    b = ii(b, c, d, a, buffer[13], 21, 0x4e0811a1);\n    a = ii(a, b, c, d, buffer[4], 6, 0xf7537e82);\n    d = ii(d, a, b, c, buffer[11], 10, 0xbd3af235);\n    c = ii(c, d, a, b, buffer[2], 15, 0x2ad7d2bb);\n    b = ii(b, c, d, a, buffer[9], 21, 0xeb86d391);\n\n    w[0] = add(a, w[0]);\n    w[1] = add(b, w[1]);\n    w[2] = add(c, w[2]);\n    w[3] = add(d, w[3]);\n  };\n})();\n\n//Provides: caml_MD5Init\nfunction caml_MD5Init() {\n  var buffer = new ArrayBuffer(64);\n  var b32 = new Uint32Array(buffer);\n  var b8 = new Uint8Array(buffer);\n  return {\n    len: 0,\n    w: new Uint32Array([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]),\n    b32: b32,\n    b8: b8,\n  };\n}\n\n//Provides: caml_MD5Update\n//Requires: caml_MD5Transform\nfunction caml_MD5Update(ctx, input, input_len) {\n  var in_buf = ctx.len & 0x3f;\n  var input_pos = 0;\n  ctx.len += input_len;\n  if (in_buf) {\n    var missing = 64 - in_buf;\n    if (input_len < missing) {\n      ctx.b8.set(input.subarray(0, input_len), in_buf);\n      return;\n    }\n    ctx.b8.set(input.subarray(0, missing), in_buf);\n    caml_MD5Transform(ctx.w, ctx.b32);\n    input_len -= missing;\n    input_pos += missing;\n  }\n  while (input_len >= 64) {\n    ctx.b8.set(input.subarray(input_pos, input_pos + 64), 0);\n    caml_MD5Transform(ctx.w, ctx.b32);\n    input_len -= 64;\n    input_pos += 64;\n  }\n  if (input_len)\n    ctx.b8.set(input.subarray(input_pos, input_pos + input_len), 0);\n}\n\n//Provides: caml_MD5Final\n//Requires: caml_MD5Transform\nfunction caml_MD5Final(ctx) {\n  var in_buf = ctx.len & 0x3f;\n  ctx.b8[in_buf] = 0x80;\n  in_buf++;\n  if (in_buf > 56) {\n    for (var j = in_buf; j < 64; j++) {\n      ctx.b8[j] = 0;\n    }\n    caml_MD5Transform(ctx.w, ctx.b32);\n    for (var j = 0; j < 56; j++) {\n      ctx.b8[j] = 0;\n    }\n  } else {\n    for (var j = in_buf; j < 56; j++) {\n      ctx.b8[j] = 0;\n    }\n  }\n  ctx.b32[14] = ctx.len << 3;\n  ctx.b32[15] = (ctx.len >> 29) & 0x1fffffff;\n  caml_MD5Transform(ctx.w, ctx.b32);\n  var t = new Uint8Array(16);\n  for (var i = 0; i < 4; i++)\n    for (var j = 0; j < 4; j++) t[i * 4 + j] = (ctx.w[i] >> (8 * j)) & 0xff;\n  return t;\n}\n\n//Provides: caml_md5_bytes\n//Requires: caml_uint8_array_of_bytes, caml_string_of_uint8_array\n//Requires: caml_MD5Init, caml_MD5Update, caml_MD5Final\nfunction caml_md5_bytes(s, ofs, len) {\n  var ctx = caml_MD5Init();\n  var a = caml_uint8_array_of_bytes(s);\n  caml_MD5Update(ctx, a.subarray(ofs, ofs + len), len);\n  return caml_string_of_uint8_array(caml_MD5Final(ctx));\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2014 Jérôme Vouillon, Hugo Heuzard\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Io\n\n//Provides: caml_sys_fds\nvar caml_sys_fds = new Array(3);\n\n//Provides: caml_sys_close\n//Requires: caml_sys_fds\nfunction caml_sys_close(fd) {\n  var x = caml_sys_fds[fd];\n  if (x) {\n    x.file.close();\n    delete caml_sys_fds[fd];\n  }\n  return 0;\n}\n\n//Provides: MlChanid\nfunction MlChanid(id) {\n  this.id = id;\n}\n\n//Provides: caml_sys_open\n//Requires: caml_raise_sys_error\n//Requires: MlFakeFd_out\n//Requires: resolve_fs_device\n//Requires: fs_node_supported\n//Requires: caml_sys_fds\n//Requires: caml_sys_open_for_node\n//Requires: MlChanid\nfunction caml_sys_open_internal(file, idx) {\n  var chanid;\n  if (idx === undefined) {\n    idx = caml_sys_fds.length;\n    chanid = new MlChanid(idx);\n  } else if (caml_sys_fds[idx]) {\n    chanid = caml_sys_fds[idx].chanid;\n  } else chanid = new MlChanid(idx);\n  caml_sys_fds[idx] = { file: file, chanid: chanid };\n  return idx | 0;\n}\nfunction caml_sys_open(name, flags, perms) {\n  var f = {};\n  while (flags) {\n    switch (flags[1]) {\n      case 0:\n        f.rdonly = 1;\n        break;\n      case 1:\n        f.wronly = 1;\n        break;\n      case 2:\n        f.append = 1;\n        f.writeonly = 1;\n        break;\n      case 3:\n        f.create = 1;\n        break;\n      case 4:\n        f.truncate = 1;\n        break;\n      case 5:\n        f.excl = 1;\n        break;\n      case 6:\n        f.binary = 1;\n        break;\n      case 7:\n        f.text = 1;\n        break;\n      case 8:\n        f.nonblock = 1;\n        break;\n    }\n    flags = flags[2];\n  }\n  var root = resolve_fs_device(name);\n  var file = root.device.open(root.rest, f, perms);\n  return caml_sys_open_internal(file, undefined);\n}\n(function () {\n  var is_node = fs_node_supported();\n  function file(fd, flags) {\n    if (is_node) {\n      return caml_sys_open_for_node(fd, flags);\n    } else return new MlFakeFd_out(fd, flags);\n  }\n  caml_sys_open_internal(\n    file(0, { rdonly: 1, altname: \"/dev/stdin\", isCharacterDevice: true }),\n    0,\n  );\n  caml_sys_open_internal(\n    file(1, { buffered: is_node ? 1 : 2, wronly: 1, isCharacterDevice: true }),\n    1,\n  );\n  caml_sys_open_internal(\n    file(2, { buffered: is_node ? 1 : 2, wronly: 1, isCharacterDevice: true }),\n    2,\n  );\n})();\n\n// ocaml Channels\n\n//Provides: caml_ml_set_channel_name\n//Requires: caml_ml_channel_get\nfunction caml_ml_set_channel_name(chanid, name) {\n  var chan = caml_ml_channel_get(chanid);\n  chan.name = name;\n  return 0;\n}\n\n//Provides: caml_ml_channels\n//Requires: MlChanid\nclass caml_ml_channels_state {\n  constructor() {\n    this.map = new globalThis.WeakMap();\n    this.opened = new globalThis.Set();\n  }\n\n  close(chanid) {\n    this.opened.delete(chanid);\n  }\n\n  get(chanid) {\n    return this.map.get(chanid);\n  }\n\n  set(chanid, val) {\n    if (val.opened) this.opened.add(chanid);\n    return this.map.set(chanid, val);\n  }\n\n  all() {\n    return this.opened.values();\n  }\n}\n\nvar caml_ml_channels = new caml_ml_channels_state();\n\n//Provides: caml_ml_channel_get\n//Requires: caml_ml_channels\nfunction caml_ml_channel_get(id) {\n  return caml_ml_channels.get(id);\n}\n\n//Provides: caml_ml_channel_redirect\n//Requires: caml_ml_channel_get, caml_ml_channels\nfunction caml_ml_channel_redirect(captured, into) {\n  var to_restore = caml_ml_channel_get(captured);\n  var new_ = caml_ml_channel_get(into);\n  caml_ml_channels.set(captured, new_);\n  return to_restore;\n}\n\n//Provides: caml_ml_channel_restore\n//Requires: caml_ml_channels\nfunction caml_ml_channel_restore(captured, to_restore) {\n  caml_ml_channels.set(captured, to_restore);\n  return 0;\n}\n\n//Provides: caml_ml_out_channels_list\n//Requires: caml_ml_channels\n//Requires: caml_ml_channel_get\nfunction caml_ml_out_channels_list() {\n  var l = 0;\n  var keys = caml_ml_channels.all();\n  for (var k of keys) {\n    var chan = caml_ml_channel_get(k);\n    if (chan.opened && chan.out) l = [0, k, l];\n  }\n  return l;\n}\n\n//Provides: caml_ml_open_descriptor_out\n//Requires: caml_ml_channels, caml_sys_fds\n//Requires: caml_raise_sys_error\n//Requires: caml_sys_open\n//Requires: caml_io_buffer_size\nfunction caml_ml_open_descriptor_out(fd) {\n  var fd_desc = caml_sys_fds[fd];\n  if (fd_desc === undefined)\n    caml_raise_sys_error(\"fd \" + fd + \" doesn't exist\");\n  var file = fd_desc.file;\n  var chanid = fd_desc.chanid;\n  var buffered = file.flags.buffered !== undefined ? file.flags.buffered : 1;\n  var channel = {\n    file: file,\n    offset: file.offset,\n    fd: fd,\n    opened: true,\n    out: true,\n    buffer_curr: 0,\n    buffer: new Uint8Array(caml_io_buffer_size),\n    buffered: buffered,\n  };\n  caml_ml_channels.set(chanid, channel);\n  return chanid;\n}\n\n//Provides: caml_ml_open_descriptor_in\n//Requires: caml_ml_channels, caml_sys_fds\n//Requires: caml_raise_sys_error\n//Requires: caml_sys_open\n//Requires: caml_io_buffer_size\nfunction caml_ml_open_descriptor_in(fd) {\n  var fd_desc = caml_sys_fds[fd];\n  if (fd_desc === undefined)\n    caml_raise_sys_error(\"fd \" + fd + \" doesn't exist\");\n  var file = fd_desc.file;\n  var chanid = fd_desc.chanid;\n  var refill = null;\n  var channel = {\n    file: file,\n    offset: file.offset,\n    fd: fd,\n    opened: true,\n    out: false,\n    buffer_curr: 0,\n    buffer_max: 0,\n    buffer: new Uint8Array(caml_io_buffer_size),\n    refill: refill,\n  };\n  caml_ml_channels.set(chanid, channel);\n  return chanid;\n}\n\n//Provides: caml_ml_open_descriptor_in_with_flags\n//Requires: caml_ml_open_descriptor_in\n//Version: >= 5.1\nfunction caml_ml_open_descriptor_in_with_flags(fd, _flags) {\n  return caml_ml_open_descriptor_in(fd);\n}\n\n//Provides: caml_ml_open_descriptor_out_with_flags\n//Requires: caml_ml_open_descriptor_out\n//Version: >= 5.1\nfunction caml_ml_open_descriptor_out_with_flags(fd, _flags) {\n  return caml_ml_open_descriptor_out(fd);\n}\n\n//Provides: caml_channel_descriptor\n//Requires: caml_ml_channel_get\n//Alias: win_filedescr_of_channel\nfunction caml_channel_descriptor(chanid) {\n  var chan = caml_ml_channel_get(chanid);\n  return chan.fd;\n}\n\n//Provides: caml_ml_set_binary_mode\n//Requires: caml_ml_channel_get\nfunction caml_ml_set_binary_mode(chanid, mode) {\n  var chan = caml_ml_channel_get(chanid);\n  chan.file.flags.text = !mode;\n  chan.file.flags.binary = mode;\n  return 0;\n}\n\n//Provides: caml_ml_is_binary_mode\n//Requires: caml_ml_channel_get\n//Version: >= 5.2\nfunction caml_ml_is_binary_mode(chanid) {\n  var chan = caml_ml_channel_get(chanid);\n  return chan.file.flags.binary;\n}\n\n//Input from in_channel\n\n//Provides: caml_ml_close_channel\n//Requires: caml_ml_flush, caml_ml_channel_get\n//Requires: caml_sys_close\n//Requires: caml_ml_channels\nfunction caml_ml_close_channel(chanid) {\n  var chan = caml_ml_channel_get(chanid);\n  if (chan.opened) {\n    chan.opened = false;\n    caml_ml_channels.close(chanid);\n    caml_sys_close(chan.fd);\n    chan.fd = -1;\n    chan.buffer = new Uint8Array(0);\n    chan.buffer_curr = 0;\n    chan.buffer_max = 0;\n  }\n  return 0;\n}\n\n//Provides: caml_ml_channel_size\n//Requires: caml_ml_channel_get\nfunction caml_ml_channel_size(chanid) {\n  var chan = caml_ml_channel_get(chanid);\n  return chan.file.length() | 0;\n}\n\n//Provides: caml_ml_channel_size_64\n//Requires: caml_int64_of_float,caml_ml_channel_get\nfunction caml_ml_channel_size_64(chanid) {\n  var chan = caml_ml_channel_get(chanid);\n  return caml_int64_of_float(chan.file.length());\n}\n\n//Provides: caml_ml_set_channel_output\n//Requires: caml_ml_channel_get\nfunction caml_ml_set_channel_output(chanid, f) {\n  var chan = caml_ml_channel_get(chanid);\n  chan.output = function (s) {\n    f(s);\n  };\n  return 0;\n}\n\n//Provides: caml_ml_set_channel_refill\n//Requires: caml_ml_channel_get\nfunction caml_ml_set_channel_refill(chanid, f) {\n  caml_ml_channel_get(chanid).refill = f;\n  return 0;\n}\n\n//Provides: caml_refill\n//Requires: caml_ml_string_length, caml_uint8_array_of_string\n//Requires: caml_raise_sys_error\nfunction caml_refill(chan) {\n  if (chan.refill != null) {\n    var str = chan.refill();\n    var str_a = caml_uint8_array_of_string(str);\n    if (str_a.length === 0) {\n      chan.refill = null;\n    } else {\n      if (chan.buffer.length < chan.buffer_max + str_a.length) {\n        var b = new Uint8Array(chan.buffer_max + str_a.length);\n        b.set(chan.buffer);\n        chan.buffer = b;\n      }\n      chan.buffer.set(str_a, chan.buffer_max);\n      chan.offset += str_a.length;\n      chan.buffer_max += str_a.length;\n    }\n  } else {\n    if (chan.fd === -1) {\n      caml_raise_sys_error(\"Bad file descriptor\");\n    }\n    var nread = chan.file.read(\n      chan.buffer,\n      chan.buffer_max,\n      chan.buffer.length - chan.buffer_max,\n    );\n    chan.offset += nread;\n    chan.buffer_max += nread;\n  }\n}\n\n//Provides: caml_ml_input\n//Requires: caml_ml_input_block\n//Requires: caml_uint8_array_of_bytes\nfunction caml_ml_input(chanid, b, i, l) {\n  var ba = caml_uint8_array_of_bytes(b);\n  return caml_ml_input_block(chanid, ba, i, l);\n}\n\n//Provides: caml_ml_input_bigarray\n//Requires: caml_ml_input_block\n//Requires: caml_ba_to_typed_array\n//Version: >= 5.2\nfunction caml_ml_input_bigarray(chanid, b, i, l) {\n  var ba = caml_ba_to_typed_array(b);\n  return caml_ml_input_block(chanid, ba, i, l);\n}\n\n//Provides: caml_ml_input_block\n//Requires: caml_refill, caml_ml_channel_get\nfunction caml_ml_input_block(chanid, ba, i, l) {\n  var chan = caml_ml_channel_get(chanid);\n  var n = l;\n  var avail = chan.buffer_max - chan.buffer_curr;\n  if (l <= avail) {\n    ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + l), i);\n    chan.buffer_curr += l;\n  } else if (avail > 0) {\n    ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + avail), i);\n    chan.buffer_curr += avail;\n    n = avail;\n  } else {\n    chan.buffer_curr = 0;\n    chan.buffer_max = 0;\n    caml_refill(chan);\n    var avail = chan.buffer_max - chan.buffer_curr;\n    if (n > avail) n = avail;\n    ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + n), i);\n    chan.buffer_curr += n;\n  }\n  return n | 0;\n}\n\n//Provides: caml_input_value\n//Requires: caml_marshal_data_size, caml_input_value_from_bytes, caml_create_bytes, caml_ml_channel_get, caml_bytes_of_uint8_array\n//Requires: caml_refill, caml_failwith, caml_raise_end_of_file\n//Requires: caml_marshal_header_size\nfunction caml_input_value(chanid) {\n  var chan = caml_ml_channel_get(chanid);\n  var header = new Uint8Array(caml_marshal_header_size);\n  function block(buffer, offset, n) {\n    var r = 0;\n    while (r < n) {\n      if (chan.buffer_curr >= chan.buffer_max) {\n        chan.buffer_curr = 0;\n        chan.buffer_max = 0;\n        caml_refill(chan);\n      }\n      if (chan.buffer_curr >= chan.buffer_max) break;\n      buffer[offset + r] = chan.buffer[chan.buffer_curr];\n      chan.buffer_curr++;\n      r++;\n    }\n    return r;\n  }\n  var r = block(header, 0, caml_marshal_header_size);\n  if (r === 0) caml_raise_end_of_file();\n  else if (r < caml_marshal_header_size)\n    caml_failwith(\"input_value: truncated object\");\n  var len = caml_marshal_data_size(caml_bytes_of_uint8_array(header), 0);\n  var buf = new Uint8Array(len + caml_marshal_header_size);\n  buf.set(header, 0);\n  var r = block(buf, caml_marshal_header_size, len);\n  if (r < len) caml_failwith(\"input_value: truncated object \" + r + \"  \" + len);\n  var res = caml_input_value_from_bytes(caml_bytes_of_uint8_array(buf), 0);\n  return res;\n}\n\n//Provides: caml_input_value_to_outside_heap\n//Requires: caml_input_value\n//Version: >= 5\nfunction caml_input_value_to_outside_heap(c) {\n  return caml_input_value(c);\n}\n\n//Provides: caml_ml_input_char\n//Requires: caml_raise_end_of_file, caml_array_bound_error\n//Requires: caml_ml_channel_get, caml_refill\nfunction caml_ml_input_char(chanid) {\n  var chan = caml_ml_channel_get(chanid);\n  if (chan.buffer_curr >= chan.buffer_max) {\n    chan.buffer_curr = 0;\n    chan.buffer_max = 0;\n    caml_refill(chan);\n  }\n  if (chan.buffer_curr >= chan.buffer_max) caml_raise_end_of_file();\n  var res = chan.buffer[chan.buffer_curr];\n  chan.buffer_curr++;\n  return res;\n}\n\n//Provides: caml_ml_input_int\n//Requires: caml_ml_input_char\nfunction caml_ml_input_int(chanid) {\n  var res = 0;\n  for (var i = 0; i < 4; i++) {\n    res = ((res << 8) + caml_ml_input_char(chanid)) | 0;\n  }\n  return res | 0;\n}\n\n//Provides: caml_seek_in\n//Requires: caml_raise_sys_error, caml_ml_channel_get\nfunction caml_seek_in(chanid, pos) {\n  var chan = caml_ml_channel_get(chanid);\n  if (chan.refill != null) caml_raise_sys_error(\"Illegal seek\");\n  if (\n    pos >= chan.offset - chan.buffer_max &&\n    pos <= chan.offset &&\n    chan.file.flags.binary\n  ) {\n    chan.buffer_curr = chan.buffer_max - (chan.offset - pos);\n  } else {\n    chan.file.seek(pos, 0);\n    chan.offset = pos;\n    chan.buffer_curr = 0;\n    chan.buffer_max = 0;\n  }\n  return 0;\n}\n\n//Provides: caml_ml_seek_in\n//Requires: caml_seek_in\nfunction caml_ml_seek_in(chanid, pos) {\n  return caml_seek_in(chanid, pos);\n}\n\n//Provides: caml_ml_seek_in_64\n//Requires: caml_int64_to_float, caml_seek_in\nfunction caml_ml_seek_in_64(chanid, pos) {\n  var pos = caml_int64_to_float(pos);\n  return caml_seek_in(chanid, pos);\n}\n\n//Provides: caml_pos_in\n//Requires: caml_ml_channel_get\nfunction caml_pos_in(chanid) {\n  var chan = caml_ml_channel_get(chanid);\n  return chan.offset - (chan.buffer_max - chan.buffer_curr);\n}\n\n//Provides: caml_ml_pos_in\n//Requires: caml_pos_in\nfunction caml_ml_pos_in(chanid) {\n  return caml_pos_in(chanid) | 0;\n}\n\n//Provides: caml_ml_pos_in_64\n//Requires: caml_int64_of_float, caml_pos_in\nfunction caml_ml_pos_in_64(chanid) {\n  return caml_int64_of_float(caml_pos_in(chanid));\n}\n\n//Provides: caml_ml_input_scan_line\n//Requires: caml_array_bound_error\n//Requires: caml_ml_channel_get, caml_refill\nfunction caml_ml_input_scan_line(chanid) {\n  var chan = caml_ml_channel_get(chanid);\n  var p = chan.buffer_curr;\n  do {\n    if (p >= chan.buffer_max) {\n      if (chan.buffer_curr > 0) {\n        chan.buffer.set(chan.buffer.subarray(chan.buffer_curr), 0);\n        p -= chan.buffer_curr;\n        chan.buffer_max -= chan.buffer_curr;\n        chan.buffer_curr = 0;\n      }\n      if (chan.buffer_max >= chan.buffer.length) {\n        return -chan.buffer_max | 0;\n      }\n      var prev_max = chan.buffer_max;\n      caml_refill(chan);\n      if (prev_max === chan.buffer_max) {\n        return -chan.buffer_max | 0;\n      }\n    }\n  } while (chan.buffer[p++] !== 10);\n  return (p - chan.buffer_curr) | 0;\n}\n\n//Provides: caml_ml_flush\n//Requires: caml_raise_sys_error, caml_ml_channel_get\n//Requires: caml_sub_uint8_array_to_jsbytes\nfunction caml_ml_flush(chanid) {\n  var chan = caml_ml_channel_get(chanid);\n  if (!chan.opened) caml_raise_sys_error(\"Cannot flush a closed channel\");\n  if (!chan.buffer || chan.buffer_curr === 0) return 0;\n  if (chan.output) {\n    chan.output(\n      caml_sub_uint8_array_to_jsbytes(chan.buffer, 0, chan.buffer_curr),\n    );\n  } else {\n    for (var pos = 0; pos < chan.buffer_curr; ) {\n      pos += chan.file.write(chan.buffer, pos, chan.buffer_curr - pos);\n    }\n  }\n  chan.offset += chan.buffer_curr;\n  chan.buffer_curr = 0;\n  return 0;\n}\n\n//output to out_channel\n\n//Provides: caml_ml_output_ta\n//Requires: caml_ml_flush,caml_ml_bytes_length\n//Requires: caml_raise_sys_error, caml_ml_channel_get\nfunction caml_ml_output_ta(chanid, buffer, offset, len) {\n  var chan = caml_ml_channel_get(chanid);\n  if (!chan.opened) caml_raise_sys_error(\"Cannot output to a closed channel\");\n  buffer = buffer.subarray(offset, offset + len);\n  if (chan.buffer_curr + buffer.length > chan.buffer.length) {\n    var b = new Uint8Array(chan.buffer_curr + buffer.length);\n    b.set(chan.buffer);\n    chan.buffer = b;\n  }\n  switch (chan.buffered) {\n    case 0: // Unbuffered\n      chan.buffer.set(buffer, chan.buffer_curr);\n      chan.buffer_curr += buffer.length;\n      caml_ml_flush(chanid);\n      break;\n    case 1: // Buffered (the default)\n      chan.buffer.set(buffer, chan.buffer_curr);\n      chan.buffer_curr += buffer.length;\n      if (chan.buffer_curr >= chan.buffer.length) caml_ml_flush(chanid);\n      break;\n    case 2: // Buffered (only for stdout and stderr)\n      var id = buffer.lastIndexOf(10);\n      if (id < 0) {\n        chan.buffer.set(buffer, chan.buffer_curr);\n        chan.buffer_curr += buffer.length;\n        if (chan.buffer_curr >= chan.buffer.length) caml_ml_flush(chanid);\n      } else {\n        chan.buffer.set(buffer.subarray(0, id + 1), chan.buffer_curr);\n        chan.buffer_curr += id + 1;\n        caml_ml_flush(chanid);\n        chan.buffer.set(buffer.subarray(id + 1), chan.buffer_curr);\n        chan.buffer_curr += buffer.length - id - 1;\n      }\n      break;\n  }\n  return 0;\n}\n\n//Provides: caml_ml_output_bytes\n//Requires: caml_uint8_array_of_bytes, caml_ml_output_ta\nfunction caml_ml_output_bytes(chanid, buffer, offset, len) {\n  var buffer = caml_uint8_array_of_bytes(buffer);\n  return caml_ml_output_ta(chanid, buffer, offset, len);\n}\n\n//Provides: caml_ml_output_bigarray\n//Requires: caml_ba_to_typed_array, caml_ml_output_ta\n//Version: >= 5.2\nfunction caml_ml_output_bigarray(chanid, buffer, offset, len) {\n  var buffer = caml_ba_to_typed_array(buffer);\n  return caml_ml_output_ta(chanid, buffer, offset, len);\n}\n\n//Provides: caml_ml_output\n//Requires: caml_ml_output_bytes, caml_bytes_of_string\nfunction caml_ml_output(chanid, buffer, offset, len) {\n  return caml_ml_output_bytes(\n    chanid,\n    caml_bytes_of_string(buffer),\n    offset,\n    len,\n  );\n}\n\n//Provides: caml_ml_output_char\n//Requires: caml_ml_output\n//Requires: caml_string_of_jsbytes\nfunction caml_ml_output_char(chanid, c) {\n  var s = caml_string_of_jsbytes(String.fromCharCode(c));\n  caml_ml_output(chanid, s, 0, 1);\n  return 0;\n}\n\n//Provides: caml_output_value\n//Requires: caml_output_value_to_string, caml_ml_output,caml_ml_string_length\nfunction caml_output_value(chanid, v, flags) {\n  var s = caml_output_value_to_string(v, flags);\n  caml_ml_output(chanid, s, 0, caml_ml_string_length(s));\n  return 0;\n}\n\n//Provides: caml_seek_out\n//Requires: caml_ml_channel_get, caml_ml_flush\nfunction caml_seek_out(chanid, pos) {\n  caml_ml_flush(chanid);\n  var chan = caml_ml_channel_get(chanid);\n  chan.file.seek(pos, 0);\n  chan.offset = pos;\n  return 0;\n}\n\n//Provides: caml_ml_seek_out\n//Requires: caml_seek_out\nfunction caml_ml_seek_out(chanid, pos) {\n  return caml_seek_out(chanid, pos);\n}\n//Provides: caml_ml_seek_out_64\n//Requires: caml_int64_to_float, caml_seek_out\nfunction caml_ml_seek_out_64(chanid, pos) {\n  var pos = caml_int64_to_float(pos);\n  return caml_seek_out(chanid, pos);\n}\n\n//Provides: caml_pos_out\n//Requires: caml_ml_channel_get, caml_ml_flush\nfunction caml_pos_out(chanid) {\n  var chan = caml_ml_channel_get(chanid);\n  return chan.offset + chan.buffer_curr;\n}\n\n//Provides: caml_ml_pos_out\n//Requires: caml_pos_out\nfunction caml_ml_pos_out(chanid) {\n  return caml_pos_out(chanid) | 0;\n}\n\n//Provides: caml_ml_pos_out_64\n//Requires: caml_int64_of_float, caml_pos_out\nfunction caml_ml_pos_out_64(chanid) {\n  return caml_int64_of_float(caml_pos_out(chanid));\n}\n\n//Provides: caml_ml_output_int\n//Requires: caml_ml_output_ta\nfunction caml_ml_output_int(chanid, i) {\n  var arr = [(i >> 24) & 0xff, (i >> 16) & 0xff, (i >> 8) & 0xff, i & 0xff];\n  caml_ml_output_ta(chanid, new Uint8Array(arr), 0, 4);\n  return 0;\n}\n\n//Provides: caml_ml_is_buffered\n//Requires: caml_ml_channel_get\nfunction caml_ml_is_buffered(chanid) {\n  return caml_ml_channel_get(chanid).buffered ? 1 : 0;\n}\n\n//Provides: caml_ml_set_buffered\n//Requires: caml_ml_channel_get, caml_ml_flush\nfunction caml_ml_set_buffered(chanid, v) {\n  caml_ml_channel_get(chanid).buffered = v;\n  if (!v) caml_ml_flush(chanid);\n  return 0;\n}\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*                          Benoit Vaugon, ENSTA                          *)\n(*                                                                        *)\n(*   Copyright 2014 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Padding position. *)\ntype padty =\n  | Left   (* Text is left justified ('-' option).               *)\n  | Right  (* Text is right justified (no '-' option).           *)\n  | Zeros  (* Text is right justified by zeros (see '0' option). *)\n\n(***)\n\n(* Integer conversion. *)\ntype int_conv =\n  | Int_d | Int_pd | Int_sd        (*  %d | %+d | % d  *)\n  | Int_i | Int_pi | Int_si        (*  %i | %+i | % i  *)\n  | Int_x | Int_Cx                 (*  %x | %#x        *)\n  | Int_X | Int_CX                 (*  %X | %#X        *)\n  | Int_o | Int_Co                 (*  %o | %#o        *)\n  | Int_u                          (*  %u              *)\n  | Int_Cd | Int_Ci | Int_Cu       (*  %#d | %#i | %#u *)\n\n(* Float conversion. *)\ntype float_flag_conv =\n  | Float_flag_                    (* %[feEgGFhH] *)\n  | Float_flag_p                   (* %+[feEgGFhH] *)\n  | Float_flag_s                   (* % [feEgGFhH] *)\ntype float_kind_conv =\n  | Float_f                        (*  %f | %+f | % f  *)\n  | Float_e                        (*  %e | %+e | % e  *)\n  | Float_E                        (*  %E | %+E | % E  *)\n  | Float_g                        (*  %g | %+g | % g  *)\n  | Float_G                        (*  %G | %+G | % G  *)\n  | Float_F                        (*  %F | %+F | % F  *)\n  | Float_h                        (*  %h | %+h | % h  *)\n  | Float_H                        (*  %H | %+H | % H  *)\n  | Float_CF                       (*  %#F| %+#F| % #F *)\ntype float_conv = float_flag_conv * float_kind_conv\n\n(***)\n\n(* Char sets (see %[...]) are bitmaps implemented as 32-char strings. *)\ntype char_set = string\n\n(***)\n\n(* Counter used in Scanf. *)\ntype counter =\n  | Line_counter     (*  %l      *)\n  | Char_counter     (*  %n      *)\n  | Token_counter    (*  %N, %L  *)\n\n(***)\n\n(* Padding of strings and numbers. *)\ntype ('a, 'b) padding =\n  (* No padding (ex: \"%d\") *)\n  | No_padding  : ('a, 'a) padding\n  (* Literal padding (ex: \"%8d\") *)\n  | Lit_padding : padty * int -> ('a, 'a) padding\n  (* Padding as extra argument (ex: \"%*d\") *)\n  | Arg_padding : padty -> (int -> 'a, 'a) padding\n\n(* Some formats, such as %_d,\n   only accept an optional number as padding option (no extra argument) *)\ntype pad_option = int option\n\n(* Precision of floats and '0'-padding of integers. *)\ntype ('a, 'b) precision =\n  (* No precision (ex: \"%f\") *)\n  | No_precision : ('a, 'a) precision\n  (* Literal precision (ex: \"%.3f\") *)\n  | Lit_precision : int -> ('a, 'a) precision\n  (* Precision as extra argument (ex: \"%.*f\") *)\n  | Arg_precision : (int -> 'a, 'a) precision\n\n(* Some formats, such as %_f,\n   only accept an optional number as precision option (no extra argument) *)\ntype prec_option = int option\n\n(* see the Custom format combinator *)\ntype ('a, 'b, 'c) custom_arity =\n  | Custom_zero : ('a, string, 'a) custom_arity\n  | Custom_succ : ('a, 'b, 'c) custom_arity ->\n    ('a, 'x -> 'b, 'x -> 'c) custom_arity\n\n(***)\n\n(*        Relational format types\n\nIn the first format+gadts implementation, the type for %(..%) in the\nfmt GADT was as follows:\n\n| Format_subst :                                           (* %(...%) *)\n    pad_option * ('d1, 'q1, 'd2, 'q2) reader_nb_unifier *\n    ('x, 'b, 'c, 'd1, 'q1, 'u) fmtty *\n    ('u, 'b, 'c, 'q1, 'e1, 'f) fmt ->\n      (('x, 'b, 'c, 'd2, 'q2, 'u) format6 -> 'x, 'b, 'c, 'd1, 'e1, 'f) fmt\n\nNotice that the 'u parameter in 'f position in the format argument\n(('x, .., 'u) format6 -> ..) is equal to the 'u parameter in 'a\nposition in the format tail (('u, .., 'f) fmt). This means that the\ntype of the expected format parameter depends of where the %(...%)\nare in the format string:\n\n  # Printf.printf \"%(%)\"\n  - : (unit, out_channel, unit, '_a, '_a, unit)\n      CamlinternalFormatBasics.format6 -> unit\n  = <fun>\n  # Printf.printf \"%(%)%d\"\n  - : (int -> unit, out_channel, unit, '_a, '_a, int -> unit)\n      CamlinternalFormatBasics.format6 -> int -> unit\n  = <fun>\n\nOn the contrary, the legacy typer gives a clever type that does not\ndepend on the position of %(..%) in the format string. For example,\n%(%) will have the polymorphic type ('a, 'b, 'c, 'd, 'd, 'a): it can\nbe concatenated to any format type, and only enforces the constraint\nthat its 'a and 'f parameters are equal (no format arguments) and 'd\nand 'e are equal (no reader argument).\n\nThe weakening of this parameter type in the GADT version broke user\ncode (in fact it essentially made %(...%) unusable except at the last\nposition of a format). In particular, the following would not work\nanymore:\n\n  fun sep ->\n    Format.printf \"foo%(%)bar%(%)baz\" sep sep\n\nAs the type-checker would require two *incompatible* types for the %(%)\nin different positions.\n\nThe solution to regain a general type for %(..%) is to generalize this\ntechnique, not only on the 'd, 'e parameters, but on all six\nparameters of a format: we introduce a \"relational\" type\n  ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n   'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\nwhose values are proofs that ('a1, .., 'f1) and ('a2, .., 'f2) morally\ncorrespond to the same format type: 'a1 is obtained from 'f1,'b1,'c1\nin the exact same way that 'a2 is obtained from 'f2,'b2,'c2, etc.\n\nFor example, the relation between two format types beginning with a Char\nparameter is as follows:\n\n| Char_ty :                                                 (* %c  *)\n    ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n     'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n    (char -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n     char -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n\nIn the general case, the term structure of fmtty_rel is (almost[1])\nisomorphic to the fmtty of the previous implementation: every\nconstructor is re-read with a binary, relational type, instead of the\nprevious unary typing. fmtty can then be re-defined as the diagonal of\nfmtty_rel:\n\n  type ('a, 'b, 'c, 'd, 'e, 'f) fmtty =\n       ('a, 'b, 'c, 'd, 'e, 'f,\n        'a, 'b, 'c, 'd, 'e, 'f) fmtty_rel\n\nOnce we have this fmtty_rel type in place, we can give the more\ngeneral type to %(...%):\n\n| Format_subst :                                           (* %(...%) *)\n    pad_option *\n    ('g, 'h, 'i, 'j, 'k, 'l,\n     'g2, 'b, 'c, 'j2, 'd, 'a) fmtty_rel *\n    ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n    (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g2, 'b, 'c, 'j2, 'e, 'f) fmt\n\nWe accept any format (('g, 'h, 'i, 'j, 'k, 'l) format6) (this is\ncompletely unrelated to the type of the current format), but also\nrequire a proof that this format is in relation to another format that\nis concatenable to the format tail. When executing a %(...%) format\n(in camlinternalFormat.ml:make_printf or scanf.ml:make_scanf), we\ntranstype the format along this relation using the 'recast' function\nto transpose between related format types.\n\n  val recast :\n     ('a1, 'b1, 'c1, 'd1, 'e1, 'f1) fmt\n  -> ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n      'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  -> ('a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmt\n\nNOTE [1]: the typing of Format_subst_ty requires not one format type, but\ntwo, one to establish the link between the format argument and the\nfirst six parameters, and the other for the link between the format\nargument and the last six parameters.\n\n| Format_subst_ty :                                         (* %(...%) *)\n    ('g, 'h, 'i, 'j, 'k, 'l,\n     'g1, 'b1, 'c1, 'j1, 'd1, 'a1) fmtty_rel *\n    ('g, 'h, 'i, 'j, 'k, 'l,\n     'g2, 'b2, 'c2, 'j2, 'd2, 'a2) fmtty_rel *\n    ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n     'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n    (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g1, 'b1, 'c1, 'j1, 'e1, 'f1,\n     ('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g2, 'b2, 'c2, 'j2, 'e2, 'f2) fmtty_rel\n\nWhen we generate a format AST, we generate exactly the same witness\nfor both relations, and the witness-conversion functions in\ncamlinternalFormat do rely on this invariant. For example, the\nfunction that proves that the relation is transitive\n\n  val trans :\n     ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n      'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  -> ('a2, 'b2, 'c2, 'd2, 'e2, 'f2,\n      'a3, 'b3, 'c3, 'd3, 'e3, 'f3) fmtty_rel\n  -> ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n      'a3, 'b3, 'c3, 'd3, 'e3, 'f3) fmtty_rel\n\ndoes assume that the two inputs have exactly the same term structure\n(and is only every used for argument witnesses of the\nFormat_subst_ty constructor).\n*)\n\n(* Type of a block used by the Format pretty-printer. *)\ntype block_type =\n  | Pp_hbox   (* Horizontal block no line breaking *)\n  | Pp_vbox   (* Vertical block each break leads to a new line *)\n  | Pp_hvbox  (* Horizontal-vertical block: same as vbox, except if this block\n                 is small enough to fit on a single line *)\n  | Pp_hovbox (* Horizontal or Vertical block: breaks lead to new line\n                 only when necessary to print the content of the block *)\n  | Pp_box    (* Horizontal or Indent block: breaks lead to new line\n                 only when necessary to print the content of the block, or\n                 when it leads to a new indentation of the current line *)\n  | Pp_fits   (* Internal usage: when a block fits on a single line *)\n\n(* Formatting element used by the Format pretty-printer. *)\ntype formatting_lit =\n  | Close_box                                           (* @]   *)\n  | Close_tag                                           (* @}   *)\n  | Break of string * int * int          (* @, | @  | @; | @;<> *)\n  | FFlush                                              (* @?   *)\n  | Force_newline                                       (* @\\n  *)\n  | Flush_newline                                       (* @.   *)\n  | Magic_size of string * int                          (* @<n> *)\n  | Escaped_at                                          (* @@   *)\n  | Escaped_percent                                     (* @%%  *)\n  | Scan_indic of char                                  (* @X   *)\n\n(* Formatting element used by the Format pretty-printer. *)\ntype ('a, 'b, 'c, 'd, 'e, 'f) formatting_gen =\n  | Open_tag : ('a, 'b, 'c, 'd, 'e, 'f) format6 ->      (* @{   *)\n    ('a, 'b, 'c, 'd, 'e, 'f) formatting_gen\n  | Open_box : ('a, 'b, 'c, 'd, 'e, 'f) format6 ->      (* @[   *)\n    ('a, 'b, 'c, 'd, 'e, 'f) formatting_gen\n\n(***)\n\n(* List of format type elements. *)\n(* In particular used to represent %(...%) and %{...%} contents. *)\nand ('a, 'b, 'c, 'd, 'e, 'f) fmtty =\n     ('a, 'b, 'c, 'd, 'e, 'f,\n      'a, 'b, 'c, 'd, 'e, 'f) fmtty_rel\nand ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n     'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel =\n  | Char_ty :                                                 (* %c  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (char -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       char -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | String_ty :                                               (* %s  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (string -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       string -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Int_ty :                                                  (* %d  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (int -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       int -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Int32_ty :                                                (* %ld *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (int32 -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       int32 -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Nativeint_ty :                                            (* %nd *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (nativeint -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       nativeint -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Int64_ty :                                                (* %Ld *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (int64 -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       int64 -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Float_ty :                                                (* %f  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (float -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       float -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Bool_ty :                                                 (* %B  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (bool -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       bool -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n\n  | Format_arg_ty :                                           (* %{...%} *)\n      ('g, 'h, 'i, 'j, 'k, 'l) fmtty *\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       ('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)\n           fmtty_rel\n  | Format_subst_ty :                                         (* %(...%) *)\n      ('g, 'h, 'i, 'j, 'k, 'l,\n       'g1, 'b1, 'c1, 'j1, 'd1, 'a1) fmtty_rel *\n      ('g, 'h, 'i, 'j, 'k, 'l,\n       'g2, 'b2, 'c2, 'j2, 'd2, 'a2) fmtty_rel *\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g1, 'b1, 'c1, 'j1, 'e1, 'f1,\n       ('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g2, 'b2, 'c2, 'j2, 'e2, 'f2)\n           fmtty_rel\n\n  (* Printf and Format specific constructors. *)\n  | Alpha_ty :                                                (* %a  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (('b1 -> 'x -> 'c1) -> 'x -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       ('b2 -> 'x -> 'c2) -> 'x -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Theta_ty :                                                (* %t  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (('b1 -> 'c1) -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       ('b2 -> 'c2) -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Any_ty :                                    (* Used for custom formats *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      ('x -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'x -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n\n  (* Scanf specific constructor. *)\n  | Reader_ty :                                               (* %r  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      ('x -> 'a1, 'b1, 'c1, ('b1 -> 'x) -> 'd1, 'e1, 'f1,\n       'x -> 'a2, 'b2, 'c2, ('b2 -> 'x) -> 'd2, 'e2, 'f2) fmtty_rel\n  | Ignored_reader_ty :                                       (* %_r  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      ('a1, 'b1, 'c1, ('b1 -> 'x) -> 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, ('b2 -> 'x) -> 'd2, 'e2, 'f2) fmtty_rel\n\n  | End_of_fmtty :\n      ('f1, 'b1, 'c1, 'd1, 'd1, 'f1,\n       'f2, 'b2, 'c2, 'd2, 'd2, 'f2) fmtty_rel\n\n(***)\n\n(* List of format elements. *)\nand ('a, 'b, 'c, 'd, 'e, 'f) fmt =\n  | Char :                                                   (* %c *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (char -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Caml_char :                                              (* %C *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (char -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | String :                                                 (* %s *)\n      ('x, string -> 'a) padding * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Caml_string :                                            (* %S *)\n      ('x, string -> 'a) padding * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Int :                                                    (* %[dixXuo] *)\n      int_conv * ('x, 'y) padding * ('y, int -> 'a) precision *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Int32 :                                                  (* %l[dixXuo] *)\n      int_conv * ('x, 'y) padding * ('y, int32 -> 'a) precision *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Nativeint :                                              (* %n[dixXuo] *)\n      int_conv * ('x, 'y) padding * ('y, nativeint -> 'a) precision *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Int64 :                                                  (* %L[dixXuo] *)\n      int_conv * ('x, 'y) padding * ('y, int64 -> 'a) precision *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Float :                                                  (* %[feEgGFhH] *)\n      float_conv * ('x, 'y) padding * ('y, float -> 'a) precision *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Bool :                                                   (* %[bB] *)\n      ('x, bool -> 'a) padding * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Flush :                                                  (* %! *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('a, 'b, 'c, 'd, 'e, 'f) fmt\n\n  | String_literal :                                         (* abc *)\n      string * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Char_literal :                                           (* x *)\n      char * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('a, 'b, 'c, 'd, 'e, 'f) fmt\n\n  | Format_arg :                                             (* %{...%} *)\n      pad_option * ('g, 'h, 'i, 'j, 'k, 'l) fmtty *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Format_subst :                                           (* %(...%) *)\n      pad_option *\n      ('g, 'h, 'i, 'j, 'k, 'l,\n       'g2, 'b, 'c, 'j2, 'd, 'a) fmtty_rel *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n      (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g2, 'b, 'c, 'j2, 'e, 'f) fmt\n\n  (* Printf and Format specific constructor. *)\n  | Alpha :                                                  (* %a *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (('b -> 'x -> 'c) -> 'x -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Theta :                                                  (* %t *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (('b -> 'c) -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n\n  (* Format specific constructor: *)\n  | Formatting_lit :                                         (* @_ *)\n      formatting_lit * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Formatting_gen :                                             (* @_ *)\n      ('a1, 'b, 'c, 'd1, 'e1, 'f1) formatting_gen *\n      ('f1, 'b, 'c, 'e1, 'e2, 'f2) fmt -> ('a1, 'b, 'c, 'd1, 'e2, 'f2) fmt\n\n  (* Scanf specific constructors: *)\n  | Reader :                                                 (* %r *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x -> 'a, 'b, 'c, ('b -> 'x) -> 'd, 'e, 'f) fmt\n  | Scan_char_set :                                          (* %[...] *)\n      pad_option * char_set * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (string -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Scan_get_counter :                                       (* %[nlNL] *)\n      counter * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (int -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Scan_next_char :                                         (* %0c *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n      (char -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Ignored_param :                                          (* %_ *)\n      ('a, 'b, 'c, 'd, 'y, 'x) ignored * ('x, 'b, 'c, 'y, 'e, 'f) fmt ->\n        ('a, 'b, 'c, 'd, 'e, 'f) fmt\n\n  (* Custom printing format (PR#6452, GPR#140)\n\n     We include a type Custom of \"custom converters\", where an\n     arbitrary function can be used to convert one or more\n     arguments. There is no syntax for custom converters, it is only\n     intended for custom processors that wish to rely on the\n     stdlib-defined format GADTs.\n\n     For instance a pre-processor could choose to interpret strings\n     prefixed with [\"!\"] as format strings where [%{{ ... }}] is\n     a special form to pass a to_string function, so that one could\n     write:\n\n     {[\n       type t = { x : int; y : int }\n\n       let string_of_t t = Printf.sprintf \"{ x = %d; y = %d }\" t.x t.y\n\n       Printf.printf !\"t = %{{string_of_t}}\" { x = 42; y = 42 }\n     ]}\n  *)\n  | Custom :\n      ('a, 'x, 'y) custom_arity * (unit -> 'x) * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n      ('y, 'b, 'c, 'd, 'e, 'f) fmt\n\n  (* end of a format specification *)\n  | End_of_format :\n        ('f, 'b, 'c, 'e, 'e, 'f) fmt\n\n(***)\n\n(* Type for ignored parameters (see \"%_\"). *)\nand ('a, 'b, 'c, 'd, 'e, 'f) ignored =\n  | Ignored_char :                                           (* %_c *)\n      ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_caml_char :                                      (* %_C *)\n      ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_string :                                         (* %_s *)\n      pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_caml_string :                                    (* %_S *)\n      pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_int :                                            (* %_d *)\n      int_conv * pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_int32 :                                          (* %_ld *)\n      int_conv * pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_nativeint :                                      (* %_nd *)\n      int_conv * pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_int64 :                                          (* %_Ld *)\n      int_conv * pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_float :                                          (* %_f *)\n      pad_option * prec_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_bool :                                           (* %_B *)\n      pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_format_arg :                                     (* %_{...%} *)\n      pad_option * ('g, 'h, 'i, 'j, 'k, 'l) fmtty ->\n        ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_format_subst :                                   (* %_(...%) *)\n      pad_option * ('a, 'b, 'c, 'd, 'e, 'f) fmtty ->\n        ('a, 'b, 'c, 'd, 'e, 'f) ignored\n  | Ignored_reader :                                         (* %_r *)\n      ('a, 'b, 'c, ('b -> 'x) -> 'd, 'd, 'a) ignored\n  | Ignored_scan_char_set :                                  (* %_[...] *)\n      pad_option * char_set -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_scan_get_counter :                               (* %_[nlNL] *)\n      counter -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_scan_next_char :                                 (* %_0c *)\n      ('a, 'b, 'c, 'd, 'd, 'a) ignored\n\nand ('a, 'b, 'c, 'd, 'e, 'f) format6 =\n  Format of ('a, 'b, 'c, 'd, 'e, 'f) fmt * string\n\nlet rec erase_rel : type a b c d e f g h i j k l .\n  (a, b, c, d, e, f,\n   g, h, i, j, k, l) fmtty_rel -> (a, b, c, d, e, f) fmtty\n= function\n  | Char_ty rest ->\n    Char_ty (erase_rel rest)\n  | String_ty rest ->\n    String_ty (erase_rel rest)\n  | Int_ty rest ->\n    Int_ty (erase_rel rest)\n  | Int32_ty rest ->\n    Int32_ty (erase_rel rest)\n  | Int64_ty rest ->\n    Int64_ty (erase_rel rest)\n  | Nativeint_ty rest ->\n    Nativeint_ty (erase_rel rest)\n  | Float_ty rest ->\n    Float_ty (erase_rel rest)\n  | Bool_ty rest ->\n    Bool_ty (erase_rel rest)\n  | Format_arg_ty (ty, rest) ->\n    Format_arg_ty (ty, erase_rel rest)\n  | Format_subst_ty (ty1, _ty2, rest) ->\n    Format_subst_ty (ty1, ty1, erase_rel rest)\n  | Alpha_ty rest ->\n    Alpha_ty (erase_rel rest)\n  | Theta_ty rest ->\n    Theta_ty (erase_rel rest)\n  | Any_ty rest ->\n    Any_ty (erase_rel rest)\n  | Reader_ty rest ->\n    Reader_ty (erase_rel rest)\n  | Ignored_reader_ty rest ->\n    Ignored_reader_ty (erase_rel rest)\n  | End_of_fmtty -> End_of_fmtty\n\n(******************************************************************************)\n                         (* Format type concatenation *)\n\n(* Concatenate two format types. *)\n(* Used by:\n   * reader_nb_unifier_of_fmtty to count readers in an fmtty,\n   * Scanf.take_fmtty_format_readers to extract readers inside %(...%),\n   * CamlinternalFormat.fmtty_of_ignored_format to extract format type. *)\n\n(*\nlet rec concat_fmtty : type a b c d e f g h .\n    (a, b, c, d, e, f) fmtty ->\n    (f, b, c, e, g, h) fmtty ->\n    (a, b, c, d, g, h) fmtty =\n*)\nlet rec concat_fmtty :\n  type a1 b1 c1 d1 e1 f1\n       a2 b2 c2 d2 e2 f2\n       g1 j1 g2 j2\n  .\n    (g1, b1, c1, j1, d1, a1,\n     g2, b2, c2, j2, d2, a2) fmtty_rel ->\n    (a1, b1, c1, d1, e1, f1,\n     a2, b2, c2, d2, e2, f2) fmtty_rel ->\n    (g1, b1, c1, j1, e1, f1,\n     g2, b2, c2, j2, e2, f2) fmtty_rel =\nfun fmtty1 fmtty2 -> match fmtty1 with\n  | Char_ty rest ->\n    Char_ty (concat_fmtty rest fmtty2)\n  | String_ty rest ->\n    String_ty (concat_fmtty rest fmtty2)\n  | Int_ty rest ->\n    Int_ty (concat_fmtty rest fmtty2)\n  | Int32_ty rest ->\n    Int32_ty (concat_fmtty rest fmtty2)\n  | Nativeint_ty rest ->\n    Nativeint_ty (concat_fmtty rest fmtty2)\n  | Int64_ty rest ->\n    Int64_ty (concat_fmtty rest fmtty2)\n  | Float_ty rest ->\n    Float_ty (concat_fmtty rest fmtty2)\n  | Bool_ty rest ->\n    Bool_ty (concat_fmtty rest fmtty2)\n  | Alpha_ty rest ->\n    Alpha_ty (concat_fmtty rest fmtty2)\n  | Theta_ty rest ->\n    Theta_ty (concat_fmtty rest fmtty2)\n  | Any_ty rest ->\n    Any_ty (concat_fmtty rest fmtty2)\n  | Reader_ty rest ->\n    Reader_ty (concat_fmtty rest fmtty2)\n  | Ignored_reader_ty rest ->\n    Ignored_reader_ty (concat_fmtty rest fmtty2)\n  | Format_arg_ty (ty, rest) ->\n    Format_arg_ty (ty, concat_fmtty rest fmtty2)\n  | Format_subst_ty (ty1, ty2, rest) ->\n    Format_subst_ty (ty1, ty2, concat_fmtty rest fmtty2)\n  | End_of_fmtty -> fmtty2\n\n(******************************************************************************)\n                           (* Format concatenation *)\n\n(* Concatenate two formats. *)\nlet rec concat_fmt : type a b c d e f g h .\n    (a, b, c, d, e, f) fmt ->\n    (f, b, c, e, g, h) fmt ->\n    (a, b, c, d, g, h) fmt =\nfun fmt1 fmt2 -> match fmt1 with\n  | String (pad, rest) ->\n    String (pad, concat_fmt rest fmt2)\n  | Caml_string (pad, rest) ->\n    Caml_string (pad, concat_fmt rest fmt2)\n\n  | Int (iconv, pad, prec, rest) ->\n    Int (iconv, pad, prec, concat_fmt rest fmt2)\n  | Int32 (iconv, pad, prec, rest) ->\n    Int32 (iconv, pad, prec, concat_fmt rest fmt2)\n  | Nativeint (iconv, pad, prec, rest) ->\n    Nativeint (iconv, pad, prec, concat_fmt rest fmt2)\n  | Int64 (iconv, pad, prec, rest) ->\n    Int64 (iconv, pad, prec, concat_fmt rest fmt2)\n  | Float (fconv, pad, prec, rest) ->\n    Float (fconv, pad, prec, concat_fmt rest fmt2)\n\n  | Char (rest) ->\n    Char (concat_fmt rest fmt2)\n  | Caml_char rest ->\n    Caml_char (concat_fmt rest fmt2)\n  | Bool (pad, rest) ->\n    Bool (pad, concat_fmt rest fmt2)\n  | Alpha rest ->\n    Alpha (concat_fmt rest fmt2)\n  | Theta rest ->\n    Theta (concat_fmt rest fmt2)\n  | Custom (arity, f, rest) ->\n    Custom (arity, f, concat_fmt rest fmt2)\n  | Reader rest ->\n    Reader (concat_fmt rest fmt2)\n  | Flush rest ->\n    Flush (concat_fmt rest fmt2)\n\n  | String_literal (str, rest) ->\n    String_literal (str, concat_fmt rest fmt2)\n  | Char_literal (chr, rest) ->\n    Char_literal   (chr, concat_fmt rest fmt2)\n\n  | Format_arg (pad, fmtty, rest) ->\n    Format_arg   (pad, fmtty, concat_fmt rest fmt2)\n  | Format_subst (pad, fmtty, rest) ->\n    Format_subst (pad, fmtty, concat_fmt rest fmt2)\n\n  | Scan_char_set (width_opt, char_set, rest) ->\n    Scan_char_set (width_opt, char_set, concat_fmt rest fmt2)\n  | Scan_get_counter (counter, rest) ->\n    Scan_get_counter (counter, concat_fmt rest fmt2)\n  | Scan_next_char (rest) ->\n    Scan_next_char (concat_fmt rest fmt2)\n  | Ignored_param (ign, rest) ->\n    Ignored_param (ign, concat_fmt rest fmt2)\n\n  | Formatting_lit (fmting_lit, rest) ->\n    Formatting_lit (fmting_lit, concat_fmt rest fmt2)\n  | Formatting_gen (fmting_gen, rest) ->\n    Formatting_gen (fmting_gen, concat_fmt rest fmt2)\n\n  | End_of_format ->\n    fmt2\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Gabriel Scherer, projet Partout, INRIA Paris-Saclay        *)\n(*                                                                        *)\n(*   Copyright 2020 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* CamlinternalAtomic is a dependency of Stdlib, so it is compiled with\n   -nopervasives. *)\nexternal ( == ) : 'a -> 'a -> bool = \"%eq\"\nexternal ( + ) : int -> int -> int = \"%addint\"\nexternal ignore : 'a -> unit = \"%ignore\"\n\n(* We are not reusing ('a ref) directly to make it easier to reason\n   about atomicity if we wish to: even in a sequential implementation,\n   signals and other asynchronous callbacks might break atomicity. *)\ntype 'a t = {mutable v: 'a}\n\nlet make v = {v}\nlet get r = r.v\nlet set r v = r.v <- v\n\n(* The following functions are set to never be inlined: Flambda is\n   allowed to move surrounding code inside the critical section,\n   including allocations. *)\n\nlet[@inline never] exchange r v =\n  (* BEGIN ATOMIC *)\n  let cur = r.v in\n  r.v <- v;\n  (* END ATOMIC *)\n  cur\n\nlet[@inline never] compare_and_set r seen v =\n  (* BEGIN ATOMIC *)\n  let cur = r.v in\n  if cur == seen then (\n    r.v <- v;\n    (* END ATOMIC *)\n    true\n  ) else\n    false\n\nlet[@inline never] fetch_and_add r n =\n  (* BEGIN ATOMIC *)\n  let cur = r.v in\n  r.v <- (cur + n);\n  (* END ATOMIC *)\n  cur\n\nlet incr r = ignore (fetch_and_add r 1)\nlet decr r = ignore (fetch_and_add r (-1))\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Exceptions *)\n\nexternal register_named_value : string -> 'a -> unit\n                              = \"caml_register_named_value\"\n\nlet () =\n  (* for runtime/fail_nat.c *)\n  register_named_value \"Pervasives.array_bound_error\"\n    (Invalid_argument \"index out of bounds\")\n\nexternal raise : exn -> 'a = \"%raise\"\nexternal raise_notrace : exn -> 'a = \"%raise_notrace\"\n\nlet failwith s = raise(Failure s)\nlet invalid_arg s = raise(Invalid_argument s)\n\nexception Exit\nexception Match_failure = Match_failure\nexception Assert_failure = Assert_failure\nexception Invalid_argument = Invalid_argument\nexception Failure = Failure\nexception Not_found = Not_found\nexception Out_of_memory = Out_of_memory\nexception Stack_overflow = Stack_overflow\nexception Sys_error = Sys_error\nexception End_of_file = End_of_file\nexception Division_by_zero = Division_by_zero\nexception Sys_blocked_io = Sys_blocked_io\nexception Undefined_recursive_module = Undefined_recursive_module\n\n(* Composition operators *)\n\nexternal ( |> ) : 'a -> ('a -> 'b) -> 'b = \"%revapply\"\nexternal ( @@ ) : ('a -> 'b) -> 'a -> 'b = \"%apply\"\n\n(* Debugging *)\n\nexternal __LOC__ : string = \"%loc_LOC\"\nexternal __FILE__ : string = \"%loc_FILE\"\nexternal __LINE__ : int = \"%loc_LINE\"\nexternal __MODULE__ : string = \"%loc_MODULE\"\nexternal __POS__ : string * int * int * int = \"%loc_POS\"\nexternal __FUNCTION__ : string = \"%loc_FUNCTION\"\n\nexternal __LOC_OF__ : 'a -> string * 'a = \"%loc_LOC\"\nexternal __LINE_OF__ : 'a -> int * 'a = \"%loc_LINE\"\nexternal __POS_OF__ : 'a -> (string * int * int * int) * 'a = \"%loc_POS\"\n\n(* Comparisons *)\n\nexternal ( = ) : 'a -> 'a -> bool = \"%equal\"\nexternal ( <> ) : 'a -> 'a -> bool = \"%notequal\"\nexternal ( < ) : 'a -> 'a -> bool = \"%lessthan\"\nexternal ( > ) : 'a -> 'a -> bool = \"%greaterthan\"\nexternal ( <= ) : 'a -> 'a -> bool = \"%lessequal\"\nexternal ( >= ) : 'a -> 'a -> bool = \"%greaterequal\"\nexternal compare : 'a -> 'a -> int = \"%compare\"\n\nlet min x y = if x <= y then x else y\nlet max x y = if x >= y then x else y\n\nexternal ( == ) : 'a -> 'a -> bool = \"%eq\"\nexternal ( != ) : 'a -> 'a -> bool = \"%noteq\"\n\n(* Boolean operations *)\n\nexternal not : bool -> bool = \"%boolnot\"\nexternal ( & ) : bool -> bool -> bool = \"%sequand\"\nexternal ( && ) : bool -> bool -> bool = \"%sequand\"\nexternal ( or ) : bool -> bool -> bool = \"%sequor\"\nexternal ( || ) : bool -> bool -> bool = \"%sequor\"\n\n(* Integer operations *)\n\nexternal ( ~- ) : int -> int = \"%negint\"\nexternal ( ~+ ) : int -> int = \"%identity\"\nexternal succ : int -> int = \"%succint\"\nexternal pred : int -> int = \"%predint\"\nexternal ( + ) : int -> int -> int = \"%addint\"\nexternal ( - ) : int -> int -> int = \"%subint\"\nexternal ( * ) : int -> int -> int = \"%mulint\"\nexternal ( / ) : int -> int -> int = \"%divint\"\nexternal ( mod ) : int -> int -> int = \"%modint\"\n\nlet abs x = if x >= 0 then x else -x\n\nexternal ( land ) : int -> int -> int = \"%andint\"\nexternal ( lor ) : int -> int -> int = \"%orint\"\nexternal ( lxor ) : int -> int -> int = \"%xorint\"\n\nlet lnot x = x lxor (-1)\n\nexternal ( lsl ) : int -> int -> int = \"%lslint\"\nexternal ( lsr ) : int -> int -> int = \"%lsrint\"\nexternal ( asr ) : int -> int -> int = \"%asrint\"\n\nlet max_int = (-1) lsr 1\nlet min_int = max_int + 1\n\n(* Floating-point operations *)\n\nexternal ( ~-. ) : float -> float = \"%negfloat\"\nexternal ( ~+. ) : float -> float = \"%identity\"\nexternal ( +. ) : float -> float -> float = \"%addfloat\"\nexternal ( -. ) : float -> float -> float = \"%subfloat\"\nexternal ( *. ) : float -> float -> float = \"%mulfloat\"\nexternal ( /. ) : float -> float -> float = \"%divfloat\"\nexternal ( ** ) : float -> float -> float = \"caml_power_float\" \"pow\"\n  [@@unboxed] [@@noalloc]\nexternal exp : float -> float = \"caml_exp_float\" \"exp\" [@@unboxed] [@@noalloc]\nexternal expm1 : float -> float = \"caml_expm1_float\" \"caml_expm1\"\n  [@@unboxed] [@@noalloc]\nexternal acos : float -> float = \"caml_acos_float\" \"acos\"\n  [@@unboxed] [@@noalloc]\nexternal asin : float -> float = \"caml_asin_float\" \"asin\"\n  [@@unboxed] [@@noalloc]\nexternal atan : float -> float = \"caml_atan_float\" \"atan\"\n  [@@unboxed] [@@noalloc]\nexternal atan2 : float -> float -> float = \"caml_atan2_float\" \"atan2\"\n  [@@unboxed] [@@noalloc]\nexternal hypot : float -> float -> float\n               = \"caml_hypot_float\" \"caml_hypot\" [@@unboxed] [@@noalloc]\nexternal cos : float -> float = \"caml_cos_float\" \"cos\" [@@unboxed] [@@noalloc]\nexternal cosh : float -> float = \"caml_cosh_float\" \"cosh\"\n  [@@unboxed] [@@noalloc]\nexternal acosh : float -> float = \"caml_acosh_float\" \"caml_acosh\"\n  [@@unboxed] [@@noalloc]\nexternal log : float -> float = \"caml_log_float\" \"log\" [@@unboxed] [@@noalloc]\nexternal log10 : float -> float = \"caml_log10_float\" \"log10\"\n  [@@unboxed] [@@noalloc]\nexternal log1p : float -> float = \"caml_log1p_float\" \"caml_log1p\"\n  [@@unboxed] [@@noalloc]\nexternal sin : float -> float = \"caml_sin_float\" \"sin\" [@@unboxed] [@@noalloc]\nexternal sinh : float -> float = \"caml_sinh_float\" \"sinh\"\n  [@@unboxed] [@@noalloc]\nexternal asinh : float -> float = \"caml_asinh_float\" \"caml_asinh\"\n  [@@unboxed] [@@noalloc]\nexternal sqrt : float -> float = \"caml_sqrt_float\" \"sqrt\"\n  [@@unboxed] [@@noalloc]\nexternal tan : float -> float = \"caml_tan_float\" \"tan\" [@@unboxed] [@@noalloc]\nexternal tanh : float -> float = \"caml_tanh_float\" \"tanh\"\n  [@@unboxed] [@@noalloc]\nexternal atanh : float -> float = \"caml_atanh_float\" \"caml_atanh\"\n  [@@unboxed] [@@noalloc]\nexternal ceil : float -> float = \"caml_ceil_float\" \"ceil\"\n  [@@unboxed] [@@noalloc]\nexternal floor : float -> float = \"caml_floor_float\" \"floor\"\n  [@@unboxed] [@@noalloc]\nexternal abs_float : float -> float = \"%absfloat\"\nexternal copysign : float -> float -> float\n                  = \"caml_copysign_float\" \"caml_copysign\"\n                  [@@unboxed] [@@noalloc]\nexternal mod_float : float -> float -> float = \"caml_fmod_float\" \"fmod\"\n  [@@unboxed] [@@noalloc]\nexternal frexp : float -> float * int = \"caml_frexp_float\"\nexternal ldexp : (float [@unboxed]) -> (int [@untagged]) -> (float [@unboxed]) =\n  \"caml_ldexp_float\" \"caml_ldexp_float_unboxed\" [@@noalloc]\nexternal modf : float -> float * float = \"caml_modf_float\"\nexternal float : int -> float = \"%floatofint\"\nexternal float_of_int : int -> float = \"%floatofint\"\nexternal truncate : float -> int = \"%intoffloat\"\nexternal int_of_float : float -> int = \"%intoffloat\"\nexternal float_of_bits : int64 -> float\n  = \"caml_int64_float_of_bits\" \"caml_int64_float_of_bits_unboxed\"\n  [@@unboxed] [@@noalloc]\nlet infinity =\n  float_of_bits 0x7F_F0_00_00_00_00_00_00L\nlet neg_infinity =\n  float_of_bits 0xFF_F0_00_00_00_00_00_00L\nlet nan =\n  float_of_bits 0x7F_F0_00_00_00_00_00_01L\nlet max_float =\n  float_of_bits 0x7F_EF_FF_FF_FF_FF_FF_FFL\nlet min_float =\n  float_of_bits 0x00_10_00_00_00_00_00_00L\nlet epsilon_float =\n  float_of_bits 0x3C_B0_00_00_00_00_00_00L\n\ntype fpclass =\n    FP_normal\n  | FP_subnormal\n  | FP_zero\n  | FP_infinite\n  | FP_nan\nexternal classify_float : (float [@unboxed]) -> fpclass =\n  \"caml_classify_float\" \"caml_classify_float_unboxed\" [@@noalloc]\n\n(* String and byte sequence operations -- more in modules String and Bytes *)\n\nexternal string_length : string -> int = \"%string_length\"\nexternal bytes_length : bytes -> int = \"%bytes_length\"\nexternal bytes_create : int -> bytes = \"caml_create_bytes\"\nexternal string_blit : string -> int -> bytes -> int -> int -> unit\n                     = \"caml_blit_string\" [@@noalloc]\nexternal bytes_blit : bytes -> int -> bytes -> int -> int -> unit\n                        = \"caml_blit_bytes\" [@@noalloc]\nexternal bytes_unsafe_to_string : bytes -> string = \"%bytes_to_string\"\n\nlet ( ^ ) s1 s2 =\n  let l1 = string_length s1 and l2 = string_length s2 in\n  let s = bytes_create (l1 + l2) in\n  string_blit s1 0 s 0 l1;\n  string_blit s2 0 s l1 l2;\n  bytes_unsafe_to_string s\n\n(* Character operations -- more in module Char *)\n\nexternal int_of_char : char -> int = \"%identity\"\nexternal unsafe_char_of_int : int -> char = \"%identity\"\nlet char_of_int n =\n  if n < 0 || n > 255 then invalid_arg \"char_of_int\" else unsafe_char_of_int n\n\n(* Unit operations *)\n\nexternal ignore : 'a -> unit = \"%ignore\"\n\n(* Pair operations *)\n\nexternal fst : 'a * 'b -> 'a = \"%field0\"\nexternal snd : 'a * 'b -> 'b = \"%field1\"\n\n(* References *)\n\ntype 'a ref = { mutable contents : 'a }\nexternal ref : 'a -> 'a ref = \"%makemutable\"\nexternal ( ! ) : 'a ref -> 'a = \"%field0\"\nexternal ( := ) : 'a ref -> 'a -> unit = \"%setfield0\"\nexternal incr : int ref -> unit = \"%incr\"\nexternal decr : int ref -> unit = \"%decr\"\n\n(* Result type *)\n\ntype ('a,'b) result = Ok of 'a | Error of 'b\n\n(* String conversion functions *)\n\nexternal format_int : string -> int -> string = \"caml_format_int\"\nexternal format_float : string -> float -> string = \"caml_format_float\"\n\nlet string_of_bool b =\n  if b then \"true\" else \"false\"\nlet bool_of_string = function\n  | \"true\" -> true\n  | \"false\" -> false\n  | _ -> invalid_arg \"bool_of_string\"\n\nlet bool_of_string_opt = function\n  | \"true\" -> Some true\n  | \"false\" -> Some false\n  | _ -> None\n\nlet string_of_int n =\n  format_int \"%d\" n\n\nexternal int_of_string : string -> int = \"caml_int_of_string\"\n\nlet int_of_string_opt s =\n  (* TODO: provide this directly as a non-raising primitive. *)\n  try Some (int_of_string s)\n  with Failure _ -> None\n\nexternal string_get : string -> int -> char = \"%string_safe_get\"\n\nlet valid_float_lexem s =\n  let l = string_length s in\n  let rec loop i =\n    if i >= l then s ^ \".\" else\n    match string_get s i with\n    | '0' .. '9' | '-' -> loop (i + 1)\n    | _ -> s\n  in\n  loop 0\n\nlet string_of_float f = valid_float_lexem (format_float \"%.12g\" f)\n\nexternal float_of_string : string -> float = \"caml_float_of_string\"\n\nlet float_of_string_opt s =\n  (* TODO: provide this directly as a non-raising primitive. *)\n  try Some (float_of_string s)\n  with Failure _ -> None\n\n(* List operations -- more in module List *)\n\nlet rec ( @ ) l1 l2 =\n  match l1 with\n    [] -> l2\n  | hd :: tl -> hd :: (tl @ l2)\n\n(* I/O operations *)\n\ntype in_channel\ntype out_channel\n\nexternal open_descriptor_out : int -> out_channel\n                             = \"caml_ml_open_descriptor_out\"\nexternal open_descriptor_in : int -> in_channel = \"caml_ml_open_descriptor_in\"\n\nlet stdin = open_descriptor_in 0\nlet stdout = open_descriptor_out 1\nlet stderr = open_descriptor_out 2\n\n(* General output functions *)\n\ntype open_flag =\n    Open_rdonly | Open_wronly | Open_append\n  | Open_creat | Open_trunc | Open_excl\n  | Open_binary | Open_text | Open_nonblock\n\nexternal open_desc : string -> open_flag list -> int -> int = \"caml_sys_open\"\n\nexternal set_out_channel_name: out_channel -> string -> unit =\n  \"caml_ml_set_channel_name\"\n\nlet open_out_gen mode perm name =\n  let c = open_descriptor_out(open_desc name mode perm) in\n  set_out_channel_name c name;\n  c\n\nlet open_out name =\n  open_out_gen [Open_wronly; Open_creat; Open_trunc; Open_text] 0o666 name\n\nlet open_out_bin name =\n  open_out_gen [Open_wronly; Open_creat; Open_trunc; Open_binary] 0o666 name\n\nexternal flush : out_channel -> unit = \"caml_ml_flush\"\n\nexternal out_channels_list : unit -> out_channel list\n                           = \"caml_ml_out_channels_list\"\n\nlet flush_all () =\n  let rec iter = function\n      [] -> ()\n    | a::l ->\n        begin try\n            flush a\n        with Sys_error _ ->\n          () (* ignore channels closed during a preceding flush. *)\n        end;\n        iter l\n  in iter (out_channels_list ())\n\nexternal unsafe_output : out_channel -> bytes -> int -> int -> unit\n                       = \"caml_ml_output_bytes\"\nexternal unsafe_output_string : out_channel -> string -> int -> int -> unit\n                              = \"caml_ml_output\"\n\nexternal output_char : out_channel -> char -> unit = \"caml_ml_output_char\"\n\nlet output_bytes oc s =\n  unsafe_output oc s 0 (bytes_length s)\n\nlet output_string oc s =\n  unsafe_output_string oc s 0 (string_length s)\n\nlet output oc s ofs len =\n  if ofs < 0 || len < 0 || ofs > bytes_length s - len\n  then invalid_arg \"output\"\n  else unsafe_output oc s ofs len\n\nlet output_substring oc s ofs len =\n  if ofs < 0 || len < 0 || ofs > string_length s - len\n  then invalid_arg \"output_substring\"\n  else unsafe_output_string oc s ofs len\n\nexternal output_byte : out_channel -> int -> unit = \"caml_ml_output_char\"\nexternal output_binary_int : out_channel -> int -> unit = \"caml_ml_output_int\"\n\nexternal marshal_to_channel : out_channel -> 'a -> unit list -> unit\n     = \"caml_output_value\"\nlet output_value chan v = marshal_to_channel chan v []\n\nexternal seek_out : out_channel -> int -> unit = \"caml_ml_seek_out\"\nexternal pos_out : out_channel -> int = \"caml_ml_pos_out\"\nexternal out_channel_length : out_channel -> int = \"caml_ml_channel_size\"\nexternal close_out_channel : out_channel -> unit = \"caml_ml_close_channel\"\nlet close_out oc = flush oc; close_out_channel oc\nlet close_out_noerr oc =\n  (try flush oc with _ -> ());\n  (try close_out_channel oc with _ -> ())\nexternal set_binary_mode_out : out_channel -> bool -> unit\n                             = \"caml_ml_set_binary_mode\"\n\n(* General input functions *)\n\nexternal set_in_channel_name: in_channel -> string -> unit =\n  \"caml_ml_set_channel_name\"\n\nlet open_in_gen mode perm name =\n  let c = open_descriptor_in(open_desc name mode perm) in\n  set_in_channel_name c name;\n  c\n\nlet open_in name =\n  open_in_gen [Open_rdonly; Open_text] 0 name\n\nlet open_in_bin name =\n  open_in_gen [Open_rdonly; Open_binary] 0 name\n\nexternal input_char : in_channel -> char = \"caml_ml_input_char\"\n\nexternal unsafe_input : in_channel -> bytes -> int -> int -> int\n                      = \"caml_ml_input\"\n\nlet input ic s ofs len =\n  if ofs < 0 || len < 0 || ofs > bytes_length s - len\n  then invalid_arg \"input\"\n  else unsafe_input ic s ofs len\n\nlet rec unsafe_really_input ic s ofs len =\n  if len <= 0 then () else begin\n    let r = unsafe_input ic s ofs len in\n    if r = 0\n    then raise End_of_file\n    else unsafe_really_input ic s (ofs + r) (len - r)\n  end\n\nlet really_input ic s ofs len =\n  if ofs < 0 || len < 0 || ofs > bytes_length s - len\n  then invalid_arg \"really_input\"\n  else unsafe_really_input ic s ofs len\n\nlet really_input_string ic len =\n  let s = bytes_create len in\n  really_input ic s 0 len;\n  bytes_unsafe_to_string s\n\nexternal input_scan_line : in_channel -> int = \"caml_ml_input_scan_line\"\n\nlet input_line chan =\n  let rec build_result buf pos = function\n    [] -> buf\n  | hd :: tl ->\n      let len = bytes_length hd in\n      bytes_blit hd 0 buf (pos - len) len;\n      build_result buf (pos - len) tl in\n  let rec scan accu len =\n    let n = input_scan_line chan in\n    if n = 0 then begin                   (* n = 0: we are at EOF *)\n      match accu with\n        [] -> raise End_of_file\n      | _  -> build_result (bytes_create len) len accu\n    end else if n > 0 then begin          (* n > 0: newline found in buffer *)\n      let res = bytes_create (n - 1) in\n      ignore (unsafe_input chan res 0 (n - 1));\n      ignore (input_char chan);           (* skip the newline *)\n      match accu with\n        [] -> res\n      |  _ -> let len = len + n - 1 in\n              build_result (bytes_create len) len (res :: accu)\n    end else begin                        (* n < 0: newline not found *)\n      let beg = bytes_create (-n) in\n      ignore(unsafe_input chan beg 0 (-n));\n      scan (beg :: accu) (len - n)\n    end\n  in bytes_unsafe_to_string (scan [] 0)\n\nexternal input_byte : in_channel -> int = \"caml_ml_input_char\"\nexternal input_binary_int : in_channel -> int = \"caml_ml_input_int\"\nexternal input_value : in_channel -> 'a = \"caml_input_value\"\nexternal seek_in : in_channel -> int -> unit = \"caml_ml_seek_in\"\nexternal pos_in : in_channel -> int = \"caml_ml_pos_in\"\nexternal in_channel_length : in_channel -> int = \"caml_ml_channel_size\"\nexternal close_in : in_channel -> unit = \"caml_ml_close_channel\"\nlet close_in_noerr ic = (try close_in ic with _ -> ())\nexternal set_binary_mode_in : in_channel -> bool -> unit\n                            = \"caml_ml_set_binary_mode\"\n\n(* Output functions on standard output *)\n\nlet print_char c = output_char stdout c\nlet print_string s = output_string stdout s\nlet print_bytes s = output_bytes stdout s\nlet print_int i = output_string stdout (string_of_int i)\nlet print_float f = output_string stdout (string_of_float f)\nlet print_endline s =\n  output_string stdout s; output_char stdout '\\n'; flush stdout\nlet print_newline () = output_char stdout '\\n'; flush stdout\n\n(* Output functions on standard error *)\n\nlet prerr_char c = output_char stderr c\nlet prerr_string s = output_string stderr s\nlet prerr_bytes s = output_bytes stderr s\nlet prerr_int i = output_string stderr (string_of_int i)\nlet prerr_float f = output_string stderr (string_of_float f)\nlet prerr_endline s =\n  output_string stderr s; output_char stderr '\\n'; flush stderr\nlet prerr_newline () = output_char stderr '\\n'; flush stderr\n\n(* Input functions on standard input *)\n\nlet read_line () = flush stdout; input_line stdin\nlet read_int () = int_of_string(read_line())\nlet read_int_opt () = int_of_string_opt(read_line())\nlet read_float () = float_of_string(read_line())\nlet read_float_opt () = float_of_string_opt(read_line())\n\n(* Operations on large files *)\n\nmodule LargeFile =\n  struct\n    external seek_out : out_channel -> int64 -> unit = \"caml_ml_seek_out_64\"\n    external pos_out : out_channel -> int64 = \"caml_ml_pos_out_64\"\n    external out_channel_length : out_channel -> int64\n                                = \"caml_ml_channel_size_64\"\n    external seek_in : in_channel -> int64 -> unit = \"caml_ml_seek_in_64\"\n    external pos_in : in_channel -> int64 = \"caml_ml_pos_in_64\"\n    external in_channel_length : in_channel -> int64 = \"caml_ml_channel_size_64\"\n  end\n\n(* Formats *)\n\ntype ('a, 'b, 'c, 'd, 'e, 'f) format6\n   = ('a, 'b, 'c, 'd, 'e, 'f) CamlinternalFormatBasics.format6\n   = Format of ('a, 'b, 'c, 'd, 'e, 'f) CamlinternalFormatBasics.fmt\n               * string\n\ntype ('a, 'b, 'c, 'd) format4 = ('a, 'b, 'c, 'c, 'c, 'd) format6\n\ntype ('a, 'b, 'c) format = ('a, 'b, 'c, 'c) format4\n\nlet string_of_format (Format (_fmt, str)) = str\n\nexternal format_of_string :\n ('a, 'b, 'c, 'd, 'e, 'f) format6 ->\n ('a, 'b, 'c, 'd, 'e, 'f) format6 = \"%identity\"\n\nlet ( ^^ ) (Format (fmt1, str1)) (Format (fmt2, str2)) =\n  Format (CamlinternalFormatBasics.concat_fmt fmt1 fmt2,\n          str1 ^ \"%,\" ^ str2)\n\n(* Miscellaneous *)\n\nexternal sys_exit : int -> 'a = \"caml_sys_exit\"\n\nlet exit_function = CamlinternalAtomic.make flush_all\n\nlet rec at_exit f =\n  let module Atomic = CamlinternalAtomic in\n  (* MPR#7253, MPR#7796: make sure \"f\" is executed only once *)\n  let f_yet_to_run = Atomic.make true in\n  let old_exit = Atomic.get exit_function in\n  let new_exit () =\n    if Atomic.compare_and_set f_yet_to_run true false then f () ;\n    old_exit ()\n  in\n  let success = Atomic.compare_and_set exit_function old_exit new_exit in\n  if not success then at_exit f\n\nlet do_at_exit () = (CamlinternalAtomic.get exit_function) ()\n\nlet exit retcode =\n  do_at_exit ();\n  sys_exit retcode\n\nlet _ = register_named_value \"Pervasives.do_at_exit\" do_at_exit\n\nexternal major : unit -> unit = \"caml_gc_major\"\nexternal naked_pointers_checked : unit -> bool\n  = \"caml_sys_const_naked_pointers_checked\"\nlet () = if naked_pointers_checked () then at_exit major\n\n(*MODULE_ALIASES*)\nmodule Arg          = Arg\nmodule Array        = Array\nmodule ArrayLabels  = ArrayLabels\nmodule Atomic       = Atomic\nmodule Bigarray     = Bigarray\nmodule Bool         = Bool\nmodule Buffer       = Buffer\nmodule Bytes        = Bytes\nmodule BytesLabels  = BytesLabels\nmodule Callback     = Callback\nmodule Char         = Char\nmodule Complex      = Complex\nmodule Digest       = Digest\nmodule Either       = Either\nmodule Ephemeron    = Ephemeron\nmodule Filename     = Filename\nmodule Float        = Float\nmodule Format       = Format\nmodule Fun          = Fun\nmodule Gc           = Gc\nmodule Genlex       = Genlex\nmodule Hashtbl      = Hashtbl\nmodule Int          = Int\nmodule Int32        = Int32\nmodule Int64        = Int64\nmodule Lazy         = Lazy\nmodule Lexing       = Lexing\nmodule List         = List\nmodule ListLabels   = ListLabels\nmodule Map          = Map\nmodule Marshal      = Marshal\nmodule MoreLabels   = MoreLabels\nmodule Nativeint    = Nativeint\nmodule Obj          = Obj\nmodule Oo           = Oo\nmodule Option       = Option\nmodule Parsing      = Parsing\nmodule Pervasives   = Pervasives\nmodule Printexc     = Printexc\nmodule Printf       = Printf\nmodule Queue        = Queue\nmodule Random       = Random\nmodule Result       = Result\nmodule Scanf        = Scanf\nmodule Seq          = Seq\nmodule Set          = Set\nmodule Stack        = Stack\nmodule StdLabels    = StdLabels\nmodule Stream       = Stream\nmodule String       = String\nmodule StringLabels = StringLabels\nmodule Sys          = Sys\nmodule Uchar        = Uchar\nmodule Unit         = Unit\nmodule Weak         = Weak\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*                         The OCaml programmers                          *)\n(*                                                                        *)\n(*   Copyright 2018 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\ntype 'a t = 'a option = None | Some of 'a\n\nlet none = None\nlet some v = Some v\nlet value o ~default = match o with Some v -> v | None -> default\nlet get = function Some v -> v | None -> invalid_arg \"option is None\"\nlet bind o f = match o with None -> None | Some v -> f v\nlet join = function Some o -> o | None -> None\nlet map f o = match o with None -> None | Some v -> Some (f v)\nlet fold ~none ~some = function Some v -> some v | None -> none\nlet iter f = function Some v -> f v | None -> ()\nlet is_none = function None -> true | Some _ -> false\nlet is_some = function None -> false | Some _ -> true\n\nlet equal eq o0 o1 = match o0, o1 with\n| Some v0, Some v1 -> eq v0 v1\n| None, None -> true\n| _ -> false\n\nlet compare cmp o0 o1 = match o0, o1 with\n| Some v0, Some v1 -> cmp v0 v1\n| None, None -> 0\n| None, Some _ -> -1\n| Some _, None -> 1\n\nlet to_result ~none = function None -> Error none | Some v -> Ok v\nlet to_list = function None -> [] | Some v -> [v]\nlet to_seq = function None -> Seq.empty | Some v -> Seq.return v\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*                         The OCaml programmers                          *)\n(*                                                                        *)\n(*   Copyright 2018 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\ntype t = bool = false | true\n\nexternal not : bool -> bool = \"%boolnot\"\nexternal ( && ) : bool -> bool -> bool = \"%sequand\"\nexternal ( || ) : bool -> bool -> bool = \"%sequor\"\nlet equal : bool -> bool -> bool = ( = )\nlet compare : bool -> bool -> int = Stdlib.compare\nexternal to_int : bool -> int = \"%identity\"\nlet to_float = function false -> 0. | true -> 1.\n\n(*\nlet of_string = function\n| \"false\" -> Some false\n| \"true\" -> Some true\n| _ -> None\n*)\n\nlet to_string = function false -> \"false\" | true -> \"true\"\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Character operations *)\n\nexternal code: char -> int = \"%identity\"\nexternal unsafe_chr: int -> char = \"%identity\"\n\nlet chr n =\n  if n < 0 || n > 255 then invalid_arg \"Char.chr\" else unsafe_chr n\n\nexternal bytes_create: int -> bytes = \"caml_create_bytes\"\nexternal bytes_unsafe_set : bytes -> int -> char -> unit\n                           = \"%bytes_unsafe_set\"\nexternal unsafe_to_string : bytes -> string = \"%bytes_to_string\"\n\nlet escaped = function\n  | '\\'' -> \"\\\\'\"\n  | '\\\\' -> \"\\\\\\\\\"\n  | '\\n' -> \"\\\\n\"\n  | '\\t' -> \"\\\\t\"\n  | '\\r' -> \"\\\\r\"\n  | '\\b' -> \"\\\\b\"\n  | ' ' .. '~' as c ->\n      let s = bytes_create 1 in\n      bytes_unsafe_set s 0 c;\n      unsafe_to_string s\n  | c ->\n      let n = code c in\n      let s = bytes_create 4 in\n      bytes_unsafe_set s 0 '\\\\';\n      bytes_unsafe_set s 1 (unsafe_chr (48 + n / 100));\n      bytes_unsafe_set s 2 (unsafe_chr (48 + (n / 10) mod 10));\n      bytes_unsafe_set s 3 (unsafe_chr (48 + n mod 10));\n      unsafe_to_string s\n\nlet lowercase = function\n  | 'A' .. 'Z'\n  | '\\192' .. '\\214'\n  | '\\216' .. '\\222' as c ->\n    unsafe_chr(code c + 32)\n  | c -> c\n\nlet uppercase = function\n  | 'a' .. 'z'\n  | '\\224' .. '\\246'\n  | '\\248' .. '\\254' as c ->\n    unsafe_chr(code c - 32)\n  | c -> c\n\nlet lowercase_ascii = function\n  | 'A' .. 'Z' as c -> unsafe_chr(code c + 32)\n  | c -> c\n\nlet uppercase_ascii = function\n  | 'a' .. 'z' as c -> unsafe_chr(code c - 32)\n  | c -> c\n\ntype t = char\n\nlet compare c1 c2 = code c1 - code c2\nlet equal (c1: t) (c2: t) = compare c1 c2 = 0\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* An alias for the type of lists. *)\ntype 'a t = 'a list = [] | (::) of 'a * 'a list\n\n(* List operations *)\n\nlet rec length_aux len = function\n    [] -> len\n  | _::l -> length_aux (len + 1) l\n\nlet length l = length_aux 0 l\n\nlet cons a l = a::l\n\nlet hd = function\n    [] -> failwith \"hd\"\n  | a::_ -> a\n\nlet tl = function\n    [] -> failwith \"tl\"\n  | _::l -> l\n\nlet nth l n =\n  if n < 0 then invalid_arg \"List.nth\" else\n  let rec nth_aux l n =\n    match l with\n    | [] -> failwith \"nth\"\n    | a::l -> if n = 0 then a else nth_aux l (n-1)\n  in nth_aux l n\n\nlet nth_opt l n =\n  if n < 0 then invalid_arg \"List.nth\" else\n  let rec nth_aux l n =\n    match l with\n    | [] -> None\n    | a::l -> if n = 0 then Some a else nth_aux l (n-1)\n  in nth_aux l n\n\nlet append = (@)\n\nlet rec rev_append l1 l2 =\n  match l1 with\n    [] -> l2\n  | a :: l -> rev_append l (a :: l2)\n\nlet rev l = rev_append l []\n\nlet rec init_tailrec_aux acc i n f =\n  if i >= n then acc\n  else init_tailrec_aux (f i :: acc) (i+1) n f\n\nlet rec init_aux i n f =\n  if i >= n then []\n  else\n    let r = f i in\n    r :: init_aux (i+1) n f\n\nlet rev_init_threshold =\n  match Sys.backend_type with\n  | Sys.Native | Sys.Bytecode -> 10_000\n  (* We don't know the size of the stack, better be safe and assume it's\n     small. *)\n  | Sys.Other _ -> 50\n\nlet init len f =\n  if len < 0 then invalid_arg \"List.init\" else\n  if len > rev_init_threshold then rev (init_tailrec_aux [] 0 len f)\n  else init_aux 0 len f\n\nlet rec flatten = function\n    [] -> []\n  | l::r -> l @ flatten r\n\nlet concat = flatten\n\nlet rec map f = function\n    [] -> []\n  | a::l -> let r = f a in r :: map f l\n\nlet rec mapi i f = function\n    [] -> []\n  | a::l -> let r = f i a in r :: mapi (i + 1) f l\n\nlet mapi f l = mapi 0 f l\n\nlet rev_map f l =\n  let rec rmap_f accu = function\n    | [] -> accu\n    | a::l -> rmap_f (f a :: accu) l\n  in\n  rmap_f [] l\n\n\nlet rec iter f = function\n    [] -> ()\n  | a::l -> f a; iter f l\n\nlet rec iteri i f = function\n    [] -> ()\n  | a::l -> f i a; iteri (i + 1) f l\n\nlet iteri f l = iteri 0 f l\n\nlet rec fold_left f accu l =\n  match l with\n    [] -> accu\n  | a::l -> fold_left f (f accu a) l\n\nlet rec fold_right f l accu =\n  match l with\n    [] -> accu\n  | a::l -> f a (fold_right f l accu)\n\nlet rec map2 f l1 l2 =\n  match (l1, l2) with\n    ([], []) -> []\n  | (a1::l1, a2::l2) -> let r = f a1 a2 in r :: map2 f l1 l2\n  | (_, _) -> invalid_arg \"List.map2\"\n\nlet rev_map2 f l1 l2 =\n  let rec rmap2_f accu l1 l2 =\n    match (l1, l2) with\n    | ([], []) -> accu\n    | (a1::l1, a2::l2) -> rmap2_f (f a1 a2 :: accu) l1 l2\n    | (_, _) -> invalid_arg \"List.rev_map2\"\n  in\n  rmap2_f [] l1 l2\n\n\nlet rec iter2 f l1 l2 =\n  match (l1, l2) with\n    ([], []) -> ()\n  | (a1::l1, a2::l2) -> f a1 a2; iter2 f l1 l2\n  | (_, _) -> invalid_arg \"List.iter2\"\n\nlet rec fold_left2 f accu l1 l2 =\n  match (l1, l2) with\n    ([], []) -> accu\n  | (a1::l1, a2::l2) -> fold_left2 f (f accu a1 a2) l1 l2\n  | (_, _) -> invalid_arg \"List.fold_left2\"\n\nlet rec fold_right2 f l1 l2 accu =\n  match (l1, l2) with\n    ([], []) -> accu\n  | (a1::l1, a2::l2) -> f a1 a2 (fold_right2 f l1 l2 accu)\n  | (_, _) -> invalid_arg \"List.fold_right2\"\n\nlet rec for_all p = function\n    [] -> true\n  | a::l -> p a && for_all p l\n\nlet rec exists p = function\n    [] -> false\n  | a::l -> p a || exists p l\n\nlet rec for_all2 p l1 l2 =\n  match (l1, l2) with\n    ([], []) -> true\n  | (a1::l1, a2::l2) -> p a1 a2 && for_all2 p l1 l2\n  | (_, _) -> invalid_arg \"List.for_all2\"\n\nlet rec exists2 p l1 l2 =\n  match (l1, l2) with\n    ([], []) -> false\n  | (a1::l1, a2::l2) -> p a1 a2 || exists2 p l1 l2\n  | (_, _) -> invalid_arg \"List.exists2\"\n\nlet rec mem x = function\n    [] -> false\n  | a::l -> compare a x = 0 || mem x l\n\nlet rec memq x = function\n    [] -> false\n  | a::l -> a == x || memq x l\n\nlet rec assoc x = function\n    [] -> raise Not_found\n  | (a,b)::l -> if compare a x = 0 then b else assoc x l\n\nlet rec assoc_opt x = function\n    [] -> None\n  | (a,b)::l -> if compare a x = 0 then Some b else assoc_opt x l\n\nlet rec assq x = function\n    [] -> raise Not_found\n  | (a,b)::l -> if a == x then b else assq x l\n\nlet rec assq_opt x = function\n    [] -> None\n  | (a,b)::l -> if a == x then Some b else assq_opt x l\n\nlet rec mem_assoc x = function\n  | [] -> false\n  | (a, _) :: l -> compare a x = 0 || mem_assoc x l\n\nlet rec mem_assq x = function\n  | [] -> false\n  | (a, _) :: l -> a == x || mem_assq x l\n\nlet rec remove_assoc x = function\n  | [] -> []\n  | (a, _ as pair) :: l ->\n      if compare a x = 0 then l else pair :: remove_assoc x l\n\nlet rec remove_assq x = function\n  | [] -> []\n  | (a, _ as pair) :: l -> if a == x then l else pair :: remove_assq x l\n\nlet rec find p = function\n  | [] -> raise Not_found\n  | x :: l -> if p x then x else find p l\n\nlet rec find_opt p = function\n  | [] -> None\n  | x :: l -> if p x then Some x else find_opt p l\n\nlet rec find_map f = function\n  | [] -> None\n  | x :: l ->\n     begin match f x with\n       | Some _ as result -> result\n       | None -> find_map f l\n     end\n\nlet find_all p =\n  let rec find accu = function\n  | [] -> rev accu\n  | x :: l -> if p x then find (x :: accu) l else find accu l in\n  find []\n\nlet filter = find_all\n\nlet filteri p l =\n  let rec aux i acc = function\n  | [] -> rev acc\n  | x::l -> aux (i + 1) (if p i x then x::acc else acc) l\n  in\n  aux 0 [] l\n\nlet filter_map f =\n  let rec aux accu = function\n    | [] -> rev accu\n    | x :: l ->\n        match f x with\n        | None -> aux accu l\n        | Some v -> aux (v :: accu) l\n  in\n  aux []\n\nlet concat_map f l =\n  let rec aux f acc = function\n    | [] -> rev acc\n    | x :: l ->\n       let xs = f x in\n       aux f (rev_append xs acc) l\n  in aux f [] l\n\nlet fold_left_map f accu l =\n  let rec aux accu l_accu = function\n    | [] -> accu, rev l_accu\n    | x :: l ->\n        let accu, x = f accu x in\n        aux accu (x :: l_accu) l in\n  aux accu [] l\n\nlet partition p l =\n  let rec part yes no = function\n  | [] -> (rev yes, rev no)\n  | x :: l -> if p x then part (x :: yes) no l else part yes (x :: no) l in\n  part [] [] l\n\nlet partition_map p l =\n  let rec part left right = function\n  | [] -> (rev left, rev right)\n  | x :: l ->\n     begin match p x with\n       | Either.Left v -> part (v :: left) right l\n       | Either.Right v -> part left (v :: right) l\n     end\n  in\n  part [] [] l\n\nlet rec split = function\n    [] -> ([], [])\n  | (x,y)::l ->\n      let (rx, ry) = split l in (x::rx, y::ry)\n\nlet rec combine l1 l2 =\n  match (l1, l2) with\n    ([], []) -> []\n  | (a1::l1, a2::l2) -> (a1, a2) :: combine l1 l2\n  | (_, _) -> invalid_arg \"List.combine\"\n\n(** sorting *)\n\nlet rec merge cmp l1 l2 =\n  match l1, l2 with\n  | [], l2 -> l2\n  | l1, [] -> l1\n  | h1 :: t1, h2 :: t2 ->\n      if cmp h1 h2 <= 0\n      then h1 :: merge cmp t1 l2\n      else h2 :: merge cmp l1 t2\n\n\nlet stable_sort cmp l =\n  let rec rev_merge l1 l2 accu =\n    match l1, l2 with\n    | [], l2 -> rev_append l2 accu\n    | l1, [] -> rev_append l1 accu\n    | h1::t1, h2::t2 ->\n        if cmp h1 h2 <= 0\n        then rev_merge t1 l2 (h1::accu)\n        else rev_merge l1 t2 (h2::accu)\n  in\n  let rec rev_merge_rev l1 l2 accu =\n    match l1, l2 with\n    | [], l2 -> rev_append l2 accu\n    | l1, [] -> rev_append l1 accu\n    | h1::t1, h2::t2 ->\n        if cmp h1 h2 > 0\n        then rev_merge_rev t1 l2 (h1::accu)\n        else rev_merge_rev l1 t2 (h2::accu)\n  in\n  let rec sort n l =\n    match n, l with\n    | 2, x1 :: x2 :: tl ->\n        let s = if cmp x1 x2 <= 0 then [x1; x2] else [x2; x1] in\n        (s, tl)\n    | 3, x1 :: x2 :: x3 :: tl ->\n        let s =\n          if cmp x1 x2 <= 0 then\n            if cmp x2 x3 <= 0 then [x1; x2; x3]\n            else if cmp x1 x3 <= 0 then [x1; x3; x2]\n            else [x3; x1; x2]\n          else if cmp x1 x3 <= 0 then [x2; x1; x3]\n          else if cmp x2 x3 <= 0 then [x2; x3; x1]\n          else [x3; x2; x1]\n        in\n        (s, tl)\n    | n, l ->\n        let n1 = n asr 1 in\n        let n2 = n - n1 in\n        let s1, l2 = rev_sort n1 l in\n        let s2, tl = rev_sort n2 l2 in\n        (rev_merge_rev s1 s2 [], tl)\n  and rev_sort n l =\n    match n, l with\n    | 2, x1 :: x2 :: tl ->\n        let s = if cmp x1 x2 > 0 then [x1; x2] else [x2; x1] in\n        (s, tl)\n    | 3, x1 :: x2 :: x3 :: tl ->\n        let s =\n          if cmp x1 x2 > 0 then\n            if cmp x2 x3 > 0 then [x1; x2; x3]\n            else if cmp x1 x3 > 0 then [x1; x3; x2]\n            else [x3; x1; x2]\n          else if cmp x1 x3 > 0 then [x2; x1; x3]\n          else if cmp x2 x3 > 0 then [x2; x3; x1]\n          else [x3; x2; x1]\n        in\n        (s, tl)\n    | n, l ->\n        let n1 = n asr 1 in\n        let n2 = n - n1 in\n        let s1, l2 = sort n1 l in\n        let s2, tl = sort n2 l2 in\n        (rev_merge s1 s2 [], tl)\n  in\n  let len = length l in\n  if len < 2 then l else fst (sort len l)\n\n\nlet sort = stable_sort\nlet fast_sort = stable_sort\n\n(* Note: on a list of length between about 100000 (depending on the minor\n   heap size and the type of the list) and Sys.max_array_size, it is\n   actually faster to use the following, but it might also use more memory\n   because the argument list cannot be deallocated incrementally.\n\n   Also, there seems to be a bug in this code or in the\n   implementation of obj_truncate.\n\nexternal obj_truncate : 'a array -> int -> unit = \"caml_obj_truncate\"\n\nlet array_to_list_in_place a =\n  let l = Array.length a in\n  let rec loop accu n p =\n    if p <= 0 then accu else begin\n      if p = n then begin\n        obj_truncate a p;\n        loop (a.(p-1) :: accu) (n-1000) (p-1)\n      end else begin\n        loop (a.(p-1) :: accu) n (p-1)\n      end\n    end\n  in\n  loop [] (l-1000) l\n\n\nlet stable_sort cmp l =\n  let a = Array.of_list l in\n  Array.stable_sort cmp a;\n  array_to_list_in_place a\n\n*)\n\n\n(** sorting + removing duplicates *)\n\nlet sort_uniq cmp l =\n  let rec rev_merge l1 l2 accu =\n    match l1, l2 with\n    | [], l2 -> rev_append l2 accu\n    | l1, [] -> rev_append l1 accu\n    | h1::t1, h2::t2 ->\n        let c = cmp h1 h2 in\n        if c = 0 then rev_merge t1 t2 (h1::accu)\n        else if c < 0\n        then rev_merge t1 l2 (h1::accu)\n        else rev_merge l1 t2 (h2::accu)\n  in\n  let rec rev_merge_rev l1 l2 accu =\n    match l1, l2 with\n    | [], l2 -> rev_append l2 accu\n    | l1, [] -> rev_append l1 accu\n    | h1::t1, h2::t2 ->\n        let c = cmp h1 h2 in\n        if c = 0 then rev_merge_rev t1 t2 (h1::accu)\n        else if c > 0\n        then rev_merge_rev t1 l2 (h1::accu)\n        else rev_merge_rev l1 t2 (h2::accu)\n  in\n  let rec sort n l =\n    match n, l with\n    | 2, x1 :: x2 :: tl ->\n        let s =\n          let c = cmp x1 x2 in\n          if c = 0 then [x1] else if c < 0 then [x1; x2] else [x2; x1]\n        in\n        (s, tl)\n    | 3, x1 :: x2 :: x3 :: tl ->\n        let s =\n          let c = cmp x1 x2 in\n          if c = 0 then\n            let c = cmp x2 x3 in\n            if c = 0 then [x2] else if c < 0 then [x2; x3] else [x3; x2]\n          else if c < 0 then\n            let c = cmp x2 x3 in\n            if c = 0 then [x1; x2]\n            else if c < 0 then [x1; x2; x3]\n            else\n              let c = cmp x1 x3 in\n              if c = 0 then [x1; x2]\n              else if c < 0 then [x1; x3; x2]\n              else [x3; x1; x2]\n          else\n            let c = cmp x1 x3 in\n            if c = 0 then [x2; x1]\n            else if c < 0 then [x2; x1; x3]\n            else\n              let c = cmp x2 x3 in\n              if c = 0 then [x2; x1]\n              else if c < 0 then [x2; x3; x1]\n              else [x3; x2; x1]\n        in\n        (s, tl)\n    | n, l ->\n        let n1 = n asr 1 in\n        let n2 = n - n1 in\n        let s1, l2 = rev_sort n1 l in\n        let s2, tl = rev_sort n2 l2 in\n        (rev_merge_rev s1 s2 [], tl)\n  and rev_sort n l =\n    match n, l with\n    | 2, x1 :: x2 :: tl ->\n        let s =\n          let c = cmp x1 x2 in\n          if c = 0 then [x1] else if c > 0 then [x1; x2] else [x2; x1]\n        in\n        (s, tl)\n    | 3, x1 :: x2 :: x3 :: tl ->\n        let s =\n          let c = cmp x1 x2 in\n          if c = 0 then\n            let c = cmp x2 x3 in\n            if c = 0 then [x2] else if c > 0 then [x2; x3] else [x3; x2]\n          else if c > 0 then\n            let c = cmp x2 x3 in\n            if c = 0 then [x1; x2]\n            else if c > 0 then [x1; x2; x3]\n            else\n              let c = cmp x1 x3 in\n              if c = 0 then [x1; x2]\n              else if c > 0 then [x1; x3; x2]\n              else [x3; x1; x2]\n          else\n            let c = cmp x1 x3 in\n            if c = 0 then [x2; x1]\n            else if c > 0 then [x2; x1; x3]\n            else\n              let c = cmp x2 x3 in\n              if c = 0 then [x2; x1]\n              else if c > 0 then [x2; x3; x1]\n              else [x3; x2; x1]\n        in\n        (s, tl)\n    | n, l ->\n        let n1 = n asr 1 in\n        let n2 = n - n1 in\n        let s1, l2 = sort n1 l in\n        let s2, tl = sort n2 l2 in\n        (rev_merge s1 s2 [], tl)\n  in\n  let len = length l in\n  if len < 2 then l else fst (sort len l)\n\n\nlet rec compare_lengths l1 l2 =\n  match l1, l2 with\n  | [], [] -> 0\n  | [], _ -> -1\n  | _, [] -> 1\n  | _ :: l1, _ :: l2 -> compare_lengths l1 l2\n;;\n\nlet rec compare_length_with l n =\n  match l with\n  | [] ->\n    if n = 0 then 0 else\n      if n > 0 then -1 else 1\n  | _ :: l ->\n    if n <= 0 then 1 else\n      compare_length_with l (n-1)\n;;\n\n(** {1 Comparison} *)\n\n(* Note: we are *not* shortcutting the list by using\n   [List.compare_lengths] first; this may be slower on long lists\n   immediately start with distinct elements. It is also incorrect for\n   [compare] below, and it is better (principle of least surprise) to\n   use the same approach for both functions. *)\nlet rec equal eq l1 l2 =\n  match l1, l2 with\n  | [], [] -> true\n  | [], _::_ | _::_, [] -> false\n  | a1::l1, a2::l2 -> eq a1 a2 && equal eq l1 l2\n\nlet rec compare cmp l1 l2 =\n  match l1, l2 with\n  | [], [] -> 0\n  | [], _::_ -> -1\n  | _::_, [] -> 1\n  | a1::l1, a2::l2 ->\n    let c = cmp a1 a2 in\n    if c <> 0 then c\n    else compare cmp l1 l2\n\n(** {1 Iterators} *)\n\nlet to_seq l =\n  let rec aux l () = match l with\n    | [] -> Seq.Nil\n    | x :: tail -> Seq.Cons (x, aux tail)\n  in\n  aux l\n\nlet of_seq seq =\n  let rec direct depth seq : _ list =\n    if depth=0\n    then\n      Seq.fold_left (fun acc x -> x::acc) [] seq\n      |> rev (* tailrec *)\n    else match seq() with\n      | Seq.Nil -> []\n      | Seq.Cons (x, next) -> x :: direct (depth-1) next\n  in\n  direct 500 seq\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*                         The OCaml programmers                          *)\n(*                                                                        *)\n(*   Copyright 2018 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\ntype t = int\n\nlet zero = 0\nlet one = 1\nlet minus_one = -1\nexternal neg : int -> int = \"%negint\"\nexternal add : int -> int -> int = \"%addint\"\nexternal sub : int -> int -> int = \"%subint\"\nexternal mul : int -> int -> int = \"%mulint\"\nexternal div : int -> int -> int = \"%divint\"\nexternal rem : int -> int -> int = \"%modint\"\nexternal succ : int -> int = \"%succint\"\nexternal pred : int -> int = \"%predint\"\nlet abs x = if x >= 0 then x else -x\nlet max_int = (-1) lsr 1\nlet min_int = max_int + 1\nexternal logand : int -> int -> int = \"%andint\"\nexternal logor : int -> int -> int = \"%orint\"\nexternal logxor : int -> int -> int = \"%xorint\"\nlet lognot x = logxor x (-1)\nexternal shift_left : int -> int -> int = \"%lslint\"\nexternal shift_right : int -> int -> int = \"%asrint\"\nexternal shift_right_logical : int -> int -> int = \"%lsrint\"\nlet equal : int -> int -> bool = ( = )\nlet compare : int -> int -> int = Stdlib.compare\nlet min x y : t = if x <= y then x else y\nlet max x y : t = if x >= y then x else y\nexternal to_float : int -> float = \"%floatofint\"\nexternal of_float : float -> int = \"%intoffloat\"\n\n(*\nexternal int_of_string : string -> int = \"caml_int_of_string\"\nlet of_string s = try Some (int_of_string s) with Failure _ -> None\n*)\n\nexternal format_int : string -> int -> string = \"caml_format_int\"\nlet to_string x = format_int \"%d\" x\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Byte sequence operations *)\n\n(* WARNING: Some functions in this file are duplicated in string.ml for\n   efficiency reasons. When you modify the one in this file you need to\n   modify its duplicate in string.ml.\n   These functions have a \"duplicated\" comment above their definition.\n*)\n\nexternal length : bytes -> int = \"%bytes_length\"\nexternal string_length : string -> int = \"%string_length\"\nexternal get : bytes -> int -> char = \"%bytes_safe_get\"\nexternal set : bytes -> int -> char -> unit = \"%bytes_safe_set\"\nexternal create : int -> bytes = \"caml_create_bytes\"\nexternal unsafe_get : bytes -> int -> char = \"%bytes_unsafe_get\"\nexternal unsafe_set : bytes -> int -> char -> unit = \"%bytes_unsafe_set\"\nexternal unsafe_fill : bytes -> int -> int -> char -> unit\n                     = \"caml_fill_bytes\" [@@noalloc]\nexternal unsafe_to_string : bytes -> string = \"%bytes_to_string\"\nexternal unsafe_of_string : string -> bytes = \"%bytes_of_string\"\n\nexternal unsafe_blit : bytes -> int -> bytes -> int -> int -> unit\n                     = \"caml_blit_bytes\" [@@noalloc]\nexternal unsafe_blit_string : string -> int -> bytes -> int -> int -> unit\n                     = \"caml_blit_string\" [@@noalloc]\n\nlet make n c =\n  let s = create n in\n  unsafe_fill s 0 n c;\n  s\n\nlet init n f =\n  let s = create n in\n  for i = 0 to n - 1 do\n    unsafe_set s i (f i)\n  done;\n  s\n\nlet empty = create 0\n\nlet copy s =\n  let len = length s in\n  let r = create len in\n  unsafe_blit s 0 r 0 len;\n  r\n\nlet to_string b = unsafe_to_string (copy b)\nlet of_string s = copy (unsafe_of_string s)\n\nlet sub s ofs len =\n  if ofs < 0 || len < 0 || ofs > length s - len\n  then invalid_arg \"String.sub / Bytes.sub\"\n  else begin\n    let r = create len in\n    unsafe_blit s ofs r 0 len;\n    r\n  end\n\nlet sub_string b ofs len = unsafe_to_string (sub b ofs len)\n\n(* addition with an overflow check *)\nlet (++) a b =\n  let c = a + b in\n  match a < 0, b < 0, c < 0 with\n  | true , true , false\n  | false, false, true  -> invalid_arg \"Bytes.extend\" (* overflow *)\n  | _ -> c\n\nlet extend s left right =\n  let len = length s ++ left ++ right in\n  let r = create len in\n  let (srcoff, dstoff) = if left < 0 then -left, 0 else 0, left in\n  let cpylen = Int.min (length s - srcoff) (len - dstoff) in\n  if cpylen > 0 then unsafe_blit s srcoff r dstoff cpylen;\n  r\n\nlet fill s ofs len c =\n  if ofs < 0 || len < 0 || ofs > length s - len\n  then invalid_arg \"String.fill / Bytes.fill\"\n  else unsafe_fill s ofs len c\n\nlet blit s1 ofs1 s2 ofs2 len =\n  if len < 0 || ofs1 < 0 || ofs1 > length s1 - len\n             || ofs2 < 0 || ofs2 > length s2 - len\n  then invalid_arg \"Bytes.blit\"\n  else unsafe_blit s1 ofs1 s2 ofs2 len\n\nlet blit_string s1 ofs1 s2 ofs2 len =\n  if len < 0 || ofs1 < 0 || ofs1 > string_length s1 - len\n             || ofs2 < 0 || ofs2 > length s2 - len\n  then invalid_arg \"String.blit / Bytes.blit_string\"\n  else unsafe_blit_string s1 ofs1 s2 ofs2 len\n\n(* duplicated in string.ml *)\nlet iter f a =\n  for i = 0 to length a - 1 do f(unsafe_get a i) done\n\n(* duplicated in string.ml *)\nlet iteri f a =\n  for i = 0 to length a - 1 do f i (unsafe_get a i) done\n\nlet ensure_ge (x:int) y = if x >= y then x else invalid_arg \"Bytes.concat\"\n\nlet rec sum_lengths acc seplen = function\n  | [] -> acc\n  | hd :: [] -> length hd + acc\n  | hd :: tl -> sum_lengths (ensure_ge (length hd + seplen + acc) acc) seplen tl\n\nlet rec unsafe_blits dst pos sep seplen = function\n    [] -> dst\n  | hd :: [] ->\n    unsafe_blit hd 0 dst pos (length hd); dst\n  | hd :: tl ->\n    unsafe_blit hd 0 dst pos (length hd);\n    unsafe_blit sep 0 dst (pos + length hd) seplen;\n    unsafe_blits dst (pos + length hd + seplen) sep seplen tl\n\nlet concat sep = function\n    [] -> empty\n  | l -> let seplen = length sep in\n          unsafe_blits\n            (create (sum_lengths 0 seplen l))\n            0 sep seplen l\n\nlet cat s1 s2 =\n  let l1 = length s1 in\n  let l2 = length s2 in\n  let r = create (l1 + l2) in\n  unsafe_blit s1 0 r 0 l1;\n  unsafe_blit s2 0 r l1 l2;\n  r\n\n\nexternal char_code: char -> int = \"%identity\"\nexternal char_chr: int -> char = \"%identity\"\n\nlet is_space = function\n  | ' ' | '\\012' | '\\n' | '\\r' | '\\t' -> true\n  | _ -> false\n\nlet trim s =\n  let len = length s in\n  let i = ref 0 in\n  while !i < len && is_space (unsafe_get s !i) do\n    incr i\n  done;\n  let j = ref (len - 1) in\n  while !j >= !i && is_space (unsafe_get s !j) do\n    decr j\n  done;\n  if !j >= !i then\n    sub s !i (!j - !i + 1)\n  else\n    empty\n\nlet escaped s =\n  let n = ref 0 in\n  for i = 0 to length s - 1 do\n    n := !n +\n      (match unsafe_get s i with\n       | '\\\"' | '\\\\' | '\\n' | '\\t' | '\\r' | '\\b' -> 2\n       | ' ' .. '~' -> 1\n       | _ -> 4)\n  done;\n  if !n = length s then copy s else begin\n    let s' = create !n in\n    n := 0;\n    for i = 0 to length s - 1 do\n      begin match unsafe_get s i with\n      | ('\\\"' | '\\\\') as c ->\n          unsafe_set s' !n '\\\\'; incr n; unsafe_set s' !n c\n      | '\\n' ->\n          unsafe_set s' !n '\\\\'; incr n; unsafe_set s' !n 'n'\n      | '\\t' ->\n          unsafe_set s' !n '\\\\'; incr n; unsafe_set s' !n 't'\n      | '\\r' ->\n          unsafe_set s' !n '\\\\'; incr n; unsafe_set s' !n 'r'\n      | '\\b' ->\n          unsafe_set s' !n '\\\\'; incr n; unsafe_set s' !n 'b'\n      | (' ' .. '~') as c -> unsafe_set s' !n c\n      | c ->\n          let a = char_code c in\n          unsafe_set s' !n '\\\\';\n          incr n;\n          unsafe_set s' !n (char_chr (48 + a / 100));\n          incr n;\n          unsafe_set s' !n (char_chr (48 + (a / 10) mod 10));\n          incr n;\n          unsafe_set s' !n (char_chr (48 + a mod 10));\n      end;\n      incr n\n    done;\n    s'\n  end\n\nlet map f s =\n  let l = length s in\n  if l = 0 then s else begin\n    let r = create l in\n    for i = 0 to l - 1 do unsafe_set r i (f (unsafe_get s i)) done;\n    r\n  end\n\nlet mapi f s =\n  let l = length s in\n  if l = 0 then s else begin\n    let r = create l in\n    for i = 0 to l - 1 do unsafe_set r i (f i (unsafe_get s i)) done;\n    r\n  end\n\nlet fold_left f x a =\n  let r = ref x in\n  for i = 0 to length a - 1 do\n    r := f !r (unsafe_get a i)\n  done;\n  !r\n\nlet fold_right f a x =\n  let r = ref x in\n  for i = length a - 1 downto 0 do\n    r := f (unsafe_get a i) !r\n  done;\n  !r\n\nlet exists p s =\n  let n = length s in\n  let rec loop i =\n    if i = n then false\n    else if p (unsafe_get s i) then true\n    else loop (succ i) in\n  loop 0\n\nlet for_all p s =\n  let n = length s in\n  let rec loop i =\n    if i = n then true\n    else if p (unsafe_get s i) then loop (succ i)\n    else false in\n  loop 0\n\nlet uppercase_ascii s = map Char.uppercase_ascii s\nlet lowercase_ascii s = map Char.lowercase_ascii s\n\nlet apply1 f s =\n  if length s = 0 then s else begin\n    let r = copy s in\n    unsafe_set r 0 (f(unsafe_get s 0));\n    r\n  end\n\nlet capitalize_ascii s = apply1 Char.uppercase_ascii s\nlet uncapitalize_ascii s = apply1 Char.lowercase_ascii s\n\n(* duplicated in string.ml *)\nlet starts_with ~prefix s =\n  let len_s = length s\n  and len_pre = length prefix in\n  let rec aux i =\n    if i = len_pre then true\n    else if unsafe_get s i <> unsafe_get prefix i then false\n    else aux (i + 1)\n  in len_s >= len_pre && aux 0\n\n(* duplicated in string.ml *)\nlet ends_with ~suffix s =\n  let len_s = length s\n  and len_suf = length suffix in\n  let diff = len_s - len_suf in\n  let rec aux i =\n    if i = len_suf then true\n    else if unsafe_get s (diff + i) <> unsafe_get suffix i then false\n    else aux (i + 1)\n  in diff >= 0 && aux 0\n\n(* duplicated in string.ml *)\nlet rec index_rec s lim i c =\n  if i >= lim then raise Not_found else\n  if unsafe_get s i = c then i else index_rec s lim (i + 1) c\n\n(* duplicated in string.ml *)\nlet index s c = index_rec s (length s) 0 c\n\n(* duplicated in string.ml *)\nlet rec index_rec_opt s lim i c =\n  if i >= lim then None else\n  if unsafe_get s i = c then Some i else index_rec_opt s lim (i + 1) c\n\n(* duplicated in string.ml *)\nlet index_opt s c = index_rec_opt s (length s) 0 c\n\n(* duplicated in string.ml *)\nlet index_from s i c =\n  let l = length s in\n  if i < 0 || i > l then invalid_arg \"String.index_from / Bytes.index_from\" else\n  index_rec s l i c\n\n(* duplicated in string.ml *)\nlet index_from_opt s i c =\n  let l = length s in\n  if i < 0 || i > l then\n    invalid_arg \"String.index_from_opt / Bytes.index_from_opt\"\n  else\n    index_rec_opt s l i c\n\n(* duplicated in string.ml *)\nlet rec rindex_rec s i c =\n  if i < 0 then raise Not_found else\n  if unsafe_get s i = c then i else rindex_rec s (i - 1) c\n\n(* duplicated in string.ml *)\nlet rindex s c = rindex_rec s (length s - 1) c\n\n(* duplicated in string.ml *)\nlet rindex_from s i c =\n  if i < -1 || i >= length s then\n    invalid_arg \"String.rindex_from / Bytes.rindex_from\"\n  else\n    rindex_rec s i c\n\n(* duplicated in string.ml *)\nlet rec rindex_rec_opt s i c =\n  if i < 0 then None else\n  if unsafe_get s i = c then Some i else rindex_rec_opt s (i - 1) c\n\n(* duplicated in string.ml *)\nlet rindex_opt s c = rindex_rec_opt s (length s - 1) c\n\n(* duplicated in string.ml *)\nlet rindex_from_opt s i c =\n  if i < -1 || i >= length s then\n    invalid_arg \"String.rindex_from_opt / Bytes.rindex_from_opt\"\n  else\n    rindex_rec_opt s i c\n\n\n(* duplicated in string.ml *)\nlet contains_from s i c =\n  let l = length s in\n  if i < 0 || i > l then\n    invalid_arg \"String.contains_from / Bytes.contains_from\"\n  else\n    try ignore (index_rec s l i c); true with Not_found -> false\n\n\n(* duplicated in string.ml *)\nlet contains s c = contains_from s 0 c\n\n(* duplicated in string.ml *)\nlet rcontains_from s i c =\n  if i < 0 || i >= length s then\n    invalid_arg \"String.rcontains_from / Bytes.rcontains_from\"\n  else\n    try ignore (rindex_rec s i c); true with Not_found -> false\n\n\ntype t = bytes\n\nlet compare (x: t) (y: t) = Stdlib.compare x y\nexternal equal : t -> t -> bool = \"caml_bytes_equal\" [@@noalloc]\n\n(* duplicated in string.ml *)\nlet split_on_char sep s =\n  let r = ref [] in\n  let j = ref (length s) in\n  for i = length s - 1 downto 0 do\n    if unsafe_get s i = sep then begin\n      r := sub s (i + 1) (!j - i - 1) :: !r;\n      j := i\n    end\n  done;\n  sub s 0 !j :: !r\n\n(* Deprecated functions implemented via other deprecated functions *)\n[@@@ocaml.warning \"-3\"]\nlet uppercase s = map Char.uppercase s\nlet lowercase s = map Char.lowercase s\n\nlet capitalize s = apply1 Char.uppercase s\nlet uncapitalize s = apply1 Char.lowercase s\n\n(** {1 Iterators} *)\n\nlet to_seq s =\n  let rec aux i () =\n    if i = length s then Seq.Nil\n    else\n      let x = get s i in\n      Seq.Cons (x, aux (i+1))\n  in\n  aux 0\n\nlet to_seqi s =\n  let rec aux i () =\n    if i = length s then Seq.Nil\n    else\n      let x = get s i in\n      Seq.Cons ((i,x), aux (i+1))\n  in\n  aux 0\n\nlet of_seq i =\n  let n = ref 0 in\n  let buf = ref (make 256 '\\000') in\n  let resize () =\n    (* resize *)\n    let new_len = Int.min (2 * length !buf) Sys.max_string_length in\n    if length !buf = new_len then failwith \"Bytes.of_seq: cannot grow bytes\";\n    let new_buf = make new_len '\\000' in\n    blit !buf 0 new_buf 0 !n;\n    buf := new_buf\n  in\n  Seq.iter\n    (fun c ->\n       if !n = length !buf then resize();\n       set !buf !n c;\n       incr n)\n    i;\n  sub !buf 0 !n\n\n(** {6 Binary encoding/decoding of integers} *)\n\n(* The get_ functions are all duplicated in string.ml *)\n\nexternal get_uint8 : bytes -> int -> int = \"%bytes_safe_get\"\nexternal get_uint16_ne : bytes -> int -> int = \"%caml_bytes_get16\"\nexternal get_int32_ne : bytes -> int -> int32 = \"%caml_bytes_get32\"\nexternal get_int64_ne : bytes -> int -> int64 = \"%caml_bytes_get64\"\nexternal set_int8 : bytes -> int -> int -> unit = \"%bytes_safe_set\"\nexternal set_int16_ne : bytes -> int -> int -> unit = \"%caml_bytes_set16\"\nexternal set_int32_ne : bytes -> int -> int32 -> unit = \"%caml_bytes_set32\"\nexternal set_int64_ne : bytes -> int -> int64 -> unit = \"%caml_bytes_set64\"\nexternal swap16 : int -> int = \"%bswap16\"\nexternal swap32 : int32 -> int32 = \"%bswap_int32\"\nexternal swap64 : int64 -> int64 = \"%bswap_int64\"\n\nlet get_int8 b i =\n  ((get_uint8 b i) lsl (Sys.int_size - 8)) asr (Sys.int_size - 8)\n\nlet get_uint16_le b i =\n  if Sys.big_endian then swap16 (get_uint16_ne b i)\n  else get_uint16_ne b i\n\nlet get_uint16_be b i =\n  if not Sys.big_endian then swap16 (get_uint16_ne b i)\n  else get_uint16_ne b i\n\nlet get_int16_ne b i =\n  ((get_uint16_ne b i) lsl (Sys.int_size - 16)) asr (Sys.int_size - 16)\n\nlet get_int16_le b i =\n  ((get_uint16_le b i) lsl (Sys.int_size - 16)) asr (Sys.int_size - 16)\n\nlet get_int16_be b i =\n  ((get_uint16_be b i) lsl (Sys.int_size - 16)) asr (Sys.int_size - 16)\n\nlet get_int32_le b i =\n  if Sys.big_endian then swap32 (get_int32_ne b i)\n  else get_int32_ne b i\n\nlet get_int32_be b i =\n  if not Sys.big_endian then swap32 (get_int32_ne b i)\n  else get_int32_ne b i\n\nlet get_int64_le b i =\n  if Sys.big_endian then swap64 (get_int64_ne b i)\n  else get_int64_ne b i\n\nlet get_int64_be b i =\n  if not Sys.big_endian then swap64 (get_int64_ne b i)\n  else get_int64_ne b i\n\nlet set_int16_le b i x =\n  if Sys.big_endian then set_int16_ne b i (swap16 x)\n  else set_int16_ne b i x\n\nlet set_int16_be b i x =\n  if not Sys.big_endian then set_int16_ne b i (swap16 x)\n  else set_int16_ne b i x\n\nlet set_int32_le b i x =\n  if Sys.big_endian then set_int32_ne b i (swap32 x)\n  else set_int32_ne b i x\n\nlet set_int32_be b i x =\n  if not Sys.big_endian then set_int32_ne b i (swap32 x)\n  else set_int32_ne b i x\n\nlet set_int64_le b i x =\n  if Sys.big_endian then set_int64_ne b i (swap64 x)\n  else set_int64_ne b i x\n\nlet set_int64_be b i x =\n  if not Sys.big_endian then set_int64_ne b i (swap64 x)\n  else set_int64_ne b i x\n\nlet set_uint8 = set_int8\nlet set_uint16_ne = set_int16_ne\nlet set_uint16_be = set_int16_be\nlet set_uint16_le = set_int16_le\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*           Damien Doligez, projet Gallium, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 2014 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* String operations, based on byte sequence operations *)\n\n(* WARNING: Some functions in this file are duplicated in bytes.ml for\n   efficiency reasons. When you modify the one in this file you need to\n   modify its duplicate in bytes.ml.\n   These functions have a \"duplicated\" comment above their definition.\n*)\n\nexternal length : string -> int = \"%string_length\"\nexternal get : string -> int -> char = \"%string_safe_get\"\nexternal set : bytes -> int -> char -> unit = \"%string_safe_set\"\nexternal create : int -> bytes = \"caml_create_string\"\nexternal unsafe_get : string -> int -> char = \"%string_unsafe_get\"\nexternal unsafe_set : bytes -> int -> char -> unit = \"%string_unsafe_set\"\nexternal unsafe_blit : string -> int ->  bytes -> int -> int -> unit\n                     = \"caml_blit_string\" [@@noalloc]\nexternal unsafe_fill : bytes -> int -> int -> char -> unit\n                     = \"caml_fill_string\" [@@noalloc]\n\nmodule B = Bytes\n\nlet bts = B.unsafe_to_string\nlet bos = B.unsafe_of_string\n\nlet make n c =\n  B.make n c |> bts\nlet init n f =\n  B.init n f |> bts\nlet empty = \"\"\nlet copy s =\n  B.copy (bos s) |> bts\nlet of_bytes = B.to_string\nlet to_bytes = B.of_string\nlet sub s ofs len =\n  B.sub (bos s) ofs len |> bts\nlet fill =\n  B.fill\nlet blit =\n  B.blit_string\n\nlet ensure_ge (x:int) y = if x >= y then x else invalid_arg \"String.concat\"\n\nlet rec sum_lengths acc seplen = function\n  | [] -> acc\n  | hd :: [] -> length hd + acc\n  | hd :: tl -> sum_lengths (ensure_ge (length hd + seplen + acc) acc) seplen tl\n\nlet rec unsafe_blits dst pos sep seplen = function\n    [] -> dst\n  | hd :: [] ->\n    unsafe_blit hd 0 dst pos (length hd); dst\n  | hd :: tl ->\n    unsafe_blit hd 0 dst pos (length hd);\n    unsafe_blit sep 0 dst (pos + length hd) seplen;\n    unsafe_blits dst (pos + length hd + seplen) sep seplen tl\n\nlet concat sep = function\n    [] -> \"\"\n  | l -> let seplen = length sep in bts @@\n          unsafe_blits\n            (B.create (sum_lengths 0 seplen l))\n            0 sep seplen l\n\nlet cat = ( ^ )\n\n(* duplicated in bytes.ml *)\nlet iter f s =\n  for i = 0 to length s - 1 do f (unsafe_get s i) done\n\n(* duplicated in bytes.ml *)\nlet iteri f s =\n  for i = 0 to length s - 1 do f i (unsafe_get s i) done\n\nlet map f s =\n  B.map f (bos s) |> bts\nlet mapi f s =\n  B.mapi f (bos s) |> bts\nlet fold_right f x a =\n  B.fold_right f (bos x) a\nlet fold_left f a x =\n  B.fold_left f a (bos x)\nlet exists f s =\n  B.exists f (bos s)\nlet for_all f s =\n  B.for_all f (bos s)\n\n(* Beware: we cannot use B.trim or B.escape because they always make a\n   copy, but String.mli spells out some cases where we are not allowed\n   to make a copy. *)\n\nlet is_space = function\n  | ' ' | '\\012' | '\\n' | '\\r' | '\\t' -> true\n  | _ -> false\n\nlet trim s =\n  if s = \"\" then s\n  else if is_space (unsafe_get s 0) || is_space (unsafe_get s (length s - 1))\n    then bts (B.trim (bos s))\n  else s\n\nlet escaped s =\n  let rec escape_if_needed s n i =\n    if i >= n then s else\n      match unsafe_get s i with\n      | '\\\"' | '\\\\' | '\\000'..'\\031' | '\\127'.. '\\255' ->\n          bts (B.escaped (bos s))\n      | _ -> escape_if_needed s n (i+1)\n  in\n  escape_if_needed s (length s) 0\n\n(* duplicated in bytes.ml *)\nlet rec index_rec s lim i c =\n  if i >= lim then raise Not_found else\n  if unsafe_get s i = c then i else index_rec s lim (i + 1) c\n\n(* duplicated in bytes.ml *)\nlet index s c = index_rec s (length s) 0 c\n\n(* duplicated in bytes.ml *)\nlet rec index_rec_opt s lim i c =\n  if i >= lim then None else\n  if unsafe_get s i = c then Some i else index_rec_opt s lim (i + 1) c\n\n(* duplicated in bytes.ml *)\nlet index_opt s c = index_rec_opt s (length s) 0 c\n\n(* duplicated in bytes.ml *)\nlet index_from s i c =\n  let l = length s in\n  if i < 0 || i > l then invalid_arg \"String.index_from / Bytes.index_from\" else\n    index_rec s l i c\n\n(* duplicated in bytes.ml *)\nlet index_from_opt s i c =\n  let l = length s in\n  if i < 0 || i > l then\n    invalid_arg \"String.index_from_opt / Bytes.index_from_opt\"\n  else\n    index_rec_opt s l i c\n\n(* duplicated in bytes.ml *)\nlet rec rindex_rec s i c =\n  if i < 0 then raise Not_found else\n  if unsafe_get s i = c then i else rindex_rec s (i - 1) c\n\n(* duplicated in bytes.ml *)\nlet rindex s c = rindex_rec s (length s - 1) c\n\n(* duplicated in bytes.ml *)\nlet rindex_from s i c =\n  if i < -1 || i >= length s then\n    invalid_arg \"String.rindex_from / Bytes.rindex_from\"\n  else\n    rindex_rec s i c\n\n(* duplicated in bytes.ml *)\nlet rec rindex_rec_opt s i c =\n  if i < 0 then None else\n  if unsafe_get s i = c then Some i else rindex_rec_opt s (i - 1) c\n\n(* duplicated in bytes.ml *)\nlet rindex_opt s c = rindex_rec_opt s (length s - 1) c\n\n(* duplicated in bytes.ml *)\nlet rindex_from_opt s i c =\n  if i < -1 || i >= length s then\n    invalid_arg \"String.rindex_from_opt / Bytes.rindex_from_opt\"\n  else\n    rindex_rec_opt s i c\n\n(* duplicated in bytes.ml *)\nlet contains_from s i c =\n  let l = length s in\n  if i < 0 || i > l then\n    invalid_arg \"String.contains_from / Bytes.contains_from\"\n  else\n    try ignore (index_rec s l i c); true with Not_found -> false\n\n(* duplicated in bytes.ml *)\nlet contains s c = contains_from s 0 c\n\n(* duplicated in bytes.ml *)\nlet rcontains_from s i c =\n  if i < 0 || i >= length s then\n    invalid_arg \"String.rcontains_from / Bytes.rcontains_from\"\n  else\n    try ignore (rindex_rec s i c); true with Not_found -> false\n\nlet uppercase_ascii s =\n  B.uppercase_ascii (bos s) |> bts\nlet lowercase_ascii s =\n  B.lowercase_ascii (bos s) |> bts\nlet capitalize_ascii s =\n  B.capitalize_ascii (bos s) |> bts\nlet uncapitalize_ascii s =\n  B.uncapitalize_ascii (bos s) |> bts\n\n(* duplicated in bytes.ml *)\nlet starts_with ~prefix s =\n  let len_s = length s\n  and len_pre = length prefix in\n  let rec aux i =\n    if i = len_pre then true\n    else if unsafe_get s i <> unsafe_get prefix i then false\n    else aux (i + 1)\n  in len_s >= len_pre && aux 0\n\n(* duplicated in bytes.ml *)\nlet ends_with ~suffix s =\n  let len_s = length s\n  and len_suf = length suffix in\n  let diff = len_s - len_suf in\n  let rec aux i =\n    if i = len_suf then true\n    else if unsafe_get s (diff + i) <> unsafe_get suffix i then false\n    else aux (i + 1)\n  in diff >= 0 && aux 0\n\n(* duplicated in bytes.ml *)\nlet split_on_char sep s =\n  let r = ref [] in\n  let j = ref (length s) in\n  for i = length s - 1 downto 0 do\n    if unsafe_get s i = sep then begin\n      r := sub s (i + 1) (!j - i - 1) :: !r;\n      j := i\n    end\n  done;\n  sub s 0 !j :: !r\n\n(* Deprecated functions implemented via other deprecated functions *)\n[@@@ocaml.warning \"-3\"]\nlet uppercase s =\n  B.uppercase (bos s) |> bts\nlet lowercase s =\n  B.lowercase (bos s) |> bts\nlet capitalize s =\n  B.capitalize (bos s) |> bts\nlet uncapitalize s =\n  B.uncapitalize (bos s) |> bts\n\ntype t = string\n\nlet compare (x: t) (y: t) = Stdlib.compare x y\nexternal equal : string -> string -> bool = \"caml_string_equal\" [@@noalloc]\n\n(** {1 Iterators} *)\n\nlet to_seq s = bos s |> B.to_seq\n\nlet to_seqi s = bos s |> B.to_seqi\n\nlet of_seq g = B.of_seq g |> bts\n\n(** {6 Binary encoding/decoding of integers} *)\n\nexternal get_uint8 : string -> int -> int = \"%string_safe_get\"\nexternal get_uint16_ne : string -> int -> int = \"%caml_string_get16\"\nexternal get_int32_ne : string -> int -> int32 = \"%caml_string_get32\"\nexternal get_int64_ne : string -> int -> int64 = \"%caml_string_get64\"\n\nlet get_int8 s i = B.get_int8 (bos s) i\nlet get_uint16_le s i = B.get_uint16_le (bos s) i\nlet get_uint16_be s i = B.get_uint16_be (bos s) i\nlet get_int16_ne s i = B.get_int16_ne (bos s) i\nlet get_int16_le s i = B.get_int16_le (bos s) i\nlet get_int16_be s i = B.get_int16_be (bos s) i\nlet get_int32_le s i = B.get_int32_le (bos s) i\nlet get_int32_be s i = B.get_int32_be (bos s) i\nlet get_int64_le s i = B.get_int64_le (bos s) i\nlet get_int64_be s i = B.get_int64_be (bos s) i\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Operations on internal representations of values *)\n\ntype t\n\ntype raw_data = nativeint\n\nexternal repr : 'a -> t = \"%identity\"\nexternal obj : t -> 'a = \"%identity\"\nexternal magic : 'a -> 'b = \"%identity\"\nexternal is_int : t -> bool = \"%obj_is_int\"\nlet [@inline always] is_block a = not (is_int a)\nexternal tag : t -> int = \"caml_obj_tag\" [@@noalloc]\nexternal set_tag : t -> int -> unit = \"caml_obj_set_tag\"\nexternal size : t -> int = \"%obj_size\"\nexternal reachable_words : t -> int = \"caml_obj_reachable_words\"\nexternal field : t -> int -> t = \"%obj_field\"\nexternal set_field : t -> int -> t -> unit = \"%obj_set_field\"\nexternal floatarray_get : floatarray -> int -> float = \"caml_floatarray_get\"\nexternal floatarray_set :\n    floatarray -> int -> float -> unit = \"caml_floatarray_set\"\nlet [@inline always] double_field x i = floatarray_get (obj x : floatarray) i\nlet [@inline always] set_double_field x i v =\n  floatarray_set (obj x : floatarray) i v\nexternal raw_field : t -> int -> raw_data = \"caml_obj_raw_field\"\nexternal set_raw_field : t -> int -> raw_data -> unit\n                                          = \"caml_obj_set_raw_field\"\n\nexternal new_block : int -> int -> t = \"caml_obj_block\"\nexternal dup : t -> t = \"caml_obj_dup\"\nexternal truncate : t -> int -> unit = \"caml_obj_truncate\"\nexternal add_offset : t -> Int32.t -> t = \"caml_obj_add_offset\"\nexternal with_tag : int -> t -> t = \"caml_obj_with_tag\"\n\nlet marshal (obj : t) =\n  Marshal.to_bytes obj []\nlet unmarshal str pos =\n  (Marshal.from_bytes str pos, pos + Marshal.total_size str pos)\n\nlet first_non_constant_constructor_tag = 0\nlet last_non_constant_constructor_tag = 245\n\nlet lazy_tag = 246\nlet closure_tag = 247\nlet object_tag = 248\nlet infix_tag = 249\nlet forward_tag = 250\n\nlet no_scan_tag = 251\n\nlet abstract_tag = 251\nlet string_tag = 252\nlet double_tag = 253\nlet double_array_tag = 254\nlet custom_tag = 255\nlet final_tag = custom_tag\n\n\nlet int_tag = 1000\nlet out_of_heap_tag = 1001\nlet unaligned_tag = 1002\n\nmodule Closure = struct\n  type info = {\n    arity: int;\n    start_env: int;\n  }\n\n  let info_of_raw (info : nativeint) =\n    let open Nativeint in\n    let arity =\n      (* signed: negative for tupled functions *)\n      if Sys.word_size = 64 then\n        to_int (shift_right info 56)\n      else\n        to_int (shift_right info 24)\n    in\n    let start_env =\n      (* start_env is unsigned, but we know it can always fit an OCaml\n         integer so we use [to_int] instead of [unsigned_to_int]. *)\n      to_int (shift_right_logical (shift_left info 8) 9) in\n    { arity; start_env }\n\n  (* note: we expect a closure, not an infix pointer *)\n  let info (obj : t) =\n    assert (tag obj = closure_tag);\n    info_of_raw (raw_field obj 1)\nend\n\nmodule Extension_constructor =\nstruct\n  type t = extension_constructor\n  let of_val x =\n    let x = repr x in\n    let slot =\n      if (is_block x) && (tag x) <> object_tag && (size x) >= 1 then field x 0\n      else x\n    in\n    let name =\n      if (is_block slot) && (tag slot) = object_tag then field slot 0\n      else invalid_arg \"Obj.extension_constructor\"\n    in\n      if (tag name) = string_tag then (obj slot : t)\n      else invalid_arg \"Obj.extension_constructor\"\n\n  let [@inline always] name (slot : t) =\n    (obj (field (repr slot) 0) : string)\n\n  let [@inline always] id (slot : t) =\n    (obj (field (repr slot) 1) : int)\nend\n\nlet extension_constructor = Extension_constructor.of_val\nlet extension_name = Extension_constructor.name\nlet extension_id = Extension_constructor.id\n\nmodule Ephemeron = struct\n  type obj_t = t\n\n  type t (** ephemeron *)\n\n   (** To change in sync with weak.h *)\n  let additional_values = 2\n  let max_ephe_length = Sys.max_array_length - additional_values\n\n  external create : int -> t = \"caml_ephe_create\";;\n  let create l =\n    if not (0 <= l && l <= max_ephe_length) then\n      invalid_arg \"Obj.Ephemeron.create\";\n    create l\n\n  let length x = size(repr x) - additional_values\n\n  let raise_if_invalid_offset e o msg =\n    if not (0 <= o && o < length e) then\n      invalid_arg msg\n\n  external get_key: t -> int -> obj_t option = \"caml_ephe_get_key\"\n  let get_key e o =\n    raise_if_invalid_offset e o \"Obj.Ephemeron.get_key\";\n    get_key e o\n\n  external get_key_copy: t -> int -> obj_t option = \"caml_ephe_get_key_copy\"\n  let get_key_copy e o =\n    raise_if_invalid_offset e o \"Obj.Ephemeron.get_key_copy\";\n    get_key_copy e o\n\n  external set_key: t -> int -> obj_t -> unit = \"caml_ephe_set_key\"\n  let set_key e o x =\n    raise_if_invalid_offset e o \"Obj.Ephemeron.set_key\";\n    set_key e o x\n\n  external unset_key: t -> int -> unit = \"caml_ephe_unset_key\"\n  let unset_key e o =\n    raise_if_invalid_offset e o \"Obj.Ephemeron.unset_key\";\n    unset_key e o\n\n  external check_key: t -> int -> bool = \"caml_ephe_check_key\"\n  let check_key e o =\n    raise_if_invalid_offset e o \"Obj.Ephemeron.check_key\";\n    check_key e o\n\n  external blit_key : t -> int -> t -> int -> int -> unit\n    = \"caml_ephe_blit_key\"\n\n  let blit_key e1 o1 e2 o2 l =\n    if l < 0 || o1 < 0 || o1 > length e1 - l\n       || o2 < 0 || o2 > length e2 - l\n    then invalid_arg \"Obj.Ephemeron.blit_key\"\n    else if l <> 0 then blit_key e1 o1 e2 o2 l\n\n  external get_data: t -> obj_t option = \"caml_ephe_get_data\"\n  external get_data_copy: t -> obj_t option = \"caml_ephe_get_data_copy\"\n  external set_data: t -> obj_t -> unit = \"caml_ephe_set_data\"\n  external unset_data: t -> unit = \"caml_ephe_unset_data\"\n  external check_data: t -> bool = \"caml_ephe_check_data\"\n  external blit_data : t -> t -> unit = \"caml_ephe_blit_data\"\n\nend\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* An alias for the type of arrays. *)\ntype 'a t = 'a array\n\n(* Array operations *)\n\nexternal length : 'a array -> int = \"%array_length\"\nexternal get: 'a array -> int -> 'a = \"%array_safe_get\"\nexternal set: 'a array -> int -> 'a -> unit = \"%array_safe_set\"\nexternal unsafe_get: 'a array -> int -> 'a = \"%array_unsafe_get\"\nexternal unsafe_set: 'a array -> int -> 'a -> unit = \"%array_unsafe_set\"\nexternal make: int -> 'a -> 'a array = \"caml_make_vect\"\nexternal create: int -> 'a -> 'a array = \"caml_make_vect\"\nexternal unsafe_sub : 'a array -> int -> int -> 'a array = \"caml_array_sub\"\nexternal append_prim : 'a array -> 'a array -> 'a array = \"caml_array_append\"\nexternal concat : 'a array list -> 'a array = \"caml_array_concat\"\nexternal unsafe_blit :\n  'a array -> int -> 'a array -> int -> int -> unit = \"caml_array_blit\"\nexternal unsafe_fill :\n  'a array -> int -> int -> 'a -> unit = \"caml_array_fill\"\nexternal create_float: int -> float array = \"caml_make_float_vect\"\nlet make_float = create_float\n\nmodule Floatarray = struct\n  external create : int -> floatarray = \"caml_floatarray_create\"\n  external length : floatarray -> int = \"%floatarray_length\"\n  external get : floatarray -> int -> float = \"%floatarray_safe_get\"\n  external set : floatarray -> int -> float -> unit = \"%floatarray_safe_set\"\n  external unsafe_get : floatarray -> int -> float = \"%floatarray_unsafe_get\"\n  external unsafe_set : floatarray -> int -> float -> unit\n      = \"%floatarray_unsafe_set\"\nend\n\nlet init l f =\n  if l = 0 then [||] else\n  if l < 0 then invalid_arg \"Array.init\"\n  (* See #6575. We could also check for maximum array size, but this depends\n     on whether we create a float array or a regular one... *)\n  else\n   let res = create l (f 0) in\n   for i = 1 to pred l do\n     unsafe_set res i (f i)\n   done;\n   res\n\nlet make_matrix sx sy init =\n  let res = create sx [||] in\n  for x = 0 to pred sx do\n    unsafe_set res x (create sy init)\n  done;\n  res\n\nlet create_matrix = make_matrix\n\nlet copy a =\n  let l = length a in if l = 0 then [||] else unsafe_sub a 0 l\n\nlet append a1 a2 =\n  let l1 = length a1 in\n  if l1 = 0 then copy a2\n  else if length a2 = 0 then unsafe_sub a1 0 l1\n  else append_prim a1 a2\n\nlet sub a ofs len =\n  if ofs < 0 || len < 0 || ofs > length a - len\n  then invalid_arg \"Array.sub\"\n  else unsafe_sub a ofs len\n\nlet fill a ofs len v =\n  if ofs < 0 || len < 0 || ofs > length a - len\n  then invalid_arg \"Array.fill\"\n  else unsafe_fill a ofs len v\n\nlet blit a1 ofs1 a2 ofs2 len =\n  if len < 0 || ofs1 < 0 || ofs1 > length a1 - len\n             || ofs2 < 0 || ofs2 > length a2 - len\n  then invalid_arg \"Array.blit\"\n  else unsafe_blit a1 ofs1 a2 ofs2 len\n\nlet iter f a =\n  for i = 0 to length a - 1 do f(unsafe_get a i) done\n\nlet iter2 f a b =\n  if length a <> length b then\n    invalid_arg \"Array.iter2: arrays must have the same length\"\n  else\n    for i = 0 to length a - 1 do f (unsafe_get a i) (unsafe_get b i) done\n\nlet map f a =\n  let l = length a in\n  if l = 0 then [||] else begin\n    let r = create l (f(unsafe_get a 0)) in\n    for i = 1 to l - 1 do\n      unsafe_set r i (f(unsafe_get a i))\n    done;\n    r\n  end\n\nlet map2 f a b =\n  let la = length a in\n  let lb = length b in\n  if la <> lb then\n    invalid_arg \"Array.map2: arrays must have the same length\"\n  else begin\n    if la = 0 then [||] else begin\n      let r = create la (f (unsafe_get a 0) (unsafe_get b 0)) in\n      for i = 1 to la - 1 do\n        unsafe_set r i (f (unsafe_get a i) (unsafe_get b i))\n      done;\n      r\n    end\n  end\n\nlet iteri f a =\n  for i = 0 to length a - 1 do f i (unsafe_get a i) done\n\nlet mapi f a =\n  let l = length a in\n  if l = 0 then [||] else begin\n    let r = create l (f 0 (unsafe_get a 0)) in\n    for i = 1 to l - 1 do\n      unsafe_set r i (f i (unsafe_get a i))\n    done;\n    r\n  end\n\nlet to_list a =\n  let rec tolist i res =\n    if i < 0 then res else tolist (i - 1) (unsafe_get a i :: res) in\n  tolist (length a - 1) []\n\n(* Cannot use List.length here because the List module depends on Array. *)\nlet rec list_length accu = function\n  | [] -> accu\n  | _::t -> list_length (succ accu) t\n\nlet of_list = function\n    [] -> [||]\n  | hd::tl as l ->\n      let a = create (list_length 0 l) hd in\n      let rec fill i = function\n          [] -> a\n        | hd::tl -> unsafe_set a i hd; fill (i+1) tl in\n      fill 1 tl\n\nlet fold_left f x a =\n  let r = ref x in\n  for i = 0 to length a - 1 do\n    r := f !r (unsafe_get a i)\n  done;\n  !r\n\nlet fold_left_map f acc input_array =\n  let len = length input_array in\n  if len = 0 then (acc, [||]) else begin\n    let acc, elt = f acc (unsafe_get input_array 0) in\n    let output_array = create len elt in\n    let acc = ref acc in\n    for i = 1 to len - 1 do\n      let acc', elt = f !acc (unsafe_get input_array i) in\n      acc := acc';\n      unsafe_set output_array i elt;\n    done;\n    !acc, output_array\n  end\n\nlet fold_right f a x =\n  let r = ref x in\n  for i = length a - 1 downto 0 do\n    r := f (unsafe_get a i) !r\n  done;\n  !r\n\nlet exists p a =\n  let n = length a in\n  let rec loop i =\n    if i = n then false\n    else if p (unsafe_get a i) then true\n    else loop (succ i) in\n  loop 0\n\nlet for_all p a =\n  let n = length a in\n  let rec loop i =\n    if i = n then true\n    else if p (unsafe_get a i) then loop (succ i)\n    else false in\n  loop 0\n\nlet for_all2 p l1 l2 =\n  let n1 = length l1\n  and n2 = length l2 in\n  if n1 <> n2 then invalid_arg \"Array.for_all2\"\n  else let rec loop i =\n    if i = n1 then true\n    else if p (unsafe_get l1 i) (unsafe_get l2 i) then loop (succ i)\n    else false in\n  loop 0\n\nlet exists2 p l1 l2 =\n  let n1 = length l1\n  and n2 = length l2 in\n  if n1 <> n2 then invalid_arg \"Array.exists2\"\n  else let rec loop i =\n    if i = n1 then false\n    else if p (unsafe_get l1 i) (unsafe_get l2 i) then true\n    else loop (succ i) in\n  loop 0\n\nlet mem x a =\n  let n = length a in\n  let rec loop i =\n    if i = n then false\n    else if compare (unsafe_get a i) x = 0 then true\n    else loop (succ i) in\n  loop 0\n\nlet memq x a =\n  let n = length a in\n  let rec loop i =\n    if i = n then false\n    else if x == (unsafe_get a i) then true\n    else loop (succ i) in\n  loop 0\n\nlet find_opt p a =\n  let n = length a in\n  let rec loop i =\n    if i = n then None\n    else\n      let x = unsafe_get a i in\n      if p x then Some x\n      else loop (succ i)\n  in\n  loop 0\n\nlet find_map f a =\n  let n = length a in\n  let rec loop i =\n    if i = n then None\n    else\n      match f (unsafe_get a i) with\n      | None -> loop (succ i)\n      | Some _ as r -> r\n  in\n  loop 0\n\nlet split x =\n  if x = [||] then [||], [||]\n  else begin\n    let a0, b0 = unsafe_get x 0 in\n    let n = length x in\n    let a = create n a0 in\n    let b = create n b0 in\n    for i = 1 to n - 1 do\n      let ai, bi = unsafe_get x i in\n      unsafe_set a i ai;\n      unsafe_set b i bi\n    done;\n    a, b\n  end\n\nlet combine a b =\n  let na = length a in\n  let nb = length b in\n  if na <> nb then invalid_arg \"Array.combine\";\n  if na = 0 then [||]\n  else begin\n    let x = create na (unsafe_get a 0, unsafe_get b 0) in\n    for i = 1 to na - 1 do\n      unsafe_set x i (unsafe_get a i, unsafe_get b i)\n    done;\n    x\n  end\n\nexception Bottom of int\nlet sort cmp a =\n  let maxson l i =\n    let i31 = i+i+i+1 in\n    let x = ref i31 in\n    if i31+2 < l then begin\n      if cmp (get a i31) (get a (i31+1)) < 0 then x := i31+1;\n      if cmp (get a !x) (get a (i31+2)) < 0 then x := i31+2;\n      !x\n    end else\n      if i31+1 < l && cmp (get a i31) (get a (i31+1)) < 0\n      then i31+1\n      else if i31 < l then i31 else raise (Bottom i)\n  in\n  let rec trickledown l i e =\n    let j = maxson l i in\n    if cmp (get a j) e > 0 then begin\n      set a i (get a j);\n      trickledown l j e;\n    end else begin\n      set a i e;\n    end;\n  in\n  let trickle l i e = try trickledown l i e with Bottom i -> set a i e in\n  let rec bubbledown l i =\n    let j = maxson l i in\n    set a i (get a j);\n    bubbledown l j\n  in\n  let bubble l i = try bubbledown l i with Bottom i -> i in\n  let rec trickleup i e =\n    let father = (i - 1) / 3 in\n    assert (i <> father);\n    if cmp (get a father) e < 0 then begin\n      set a i (get a father);\n      if father > 0 then trickleup father e else set a 0 e;\n    end else begin\n      set a i e;\n    end;\n  in\n  let l = length a in\n  for i = (l + 1) / 3 - 1 downto 0 do trickle l i (get a i); done;\n  for i = l - 1 downto 2 do\n    let e = (get a i) in\n    set a i (get a 0);\n    trickleup (bubble i 0) e;\n  done;\n  if l > 1 then (let e = (get a 1) in set a 1 (get a 0); set a 0 e)\n\n\nlet cutoff = 5\nlet stable_sort cmp a =\n  let merge src1ofs src1len src2 src2ofs src2len dst dstofs =\n    let src1r = src1ofs + src1len and src2r = src2ofs + src2len in\n    let rec loop i1 s1 i2 s2 d =\n      if cmp s1 s2 <= 0 then begin\n        set dst d s1;\n        let i1 = i1 + 1 in\n        if i1 < src1r then\n          loop i1 (get a i1) i2 s2 (d + 1)\n        else\n          blit src2 i2 dst (d + 1) (src2r - i2)\n      end else begin\n        set dst d s2;\n        let i2 = i2 + 1 in\n        if i2 < src2r then\n          loop i1 s1 i2 (get src2 i2) (d + 1)\n        else\n          blit a i1 dst (d + 1) (src1r - i1)\n      end\n    in loop src1ofs (get a src1ofs) src2ofs (get src2 src2ofs) dstofs;\n  in\n  let isortto srcofs dst dstofs len =\n    for i = 0 to len - 1 do\n      let e = (get a (srcofs + i)) in\n      let j = ref (dstofs + i - 1) in\n      while (!j >= dstofs && cmp (get dst !j) e > 0) do\n        set dst (!j + 1) (get dst !j);\n        decr j;\n      done;\n      set dst (!j + 1) e;\n    done;\n  in\n  let rec sortto srcofs dst dstofs len =\n    if len <= cutoff then isortto srcofs dst dstofs len else begin\n      let l1 = len / 2 in\n      let l2 = len - l1 in\n      sortto (srcofs + l1) dst (dstofs + l1) l2;\n      sortto srcofs a (srcofs + l2) l1;\n      merge (srcofs + l2) l1 dst (dstofs + l1) l2 dst dstofs;\n    end;\n  in\n  let l = length a in\n  if l <= cutoff then isortto 0 a 0 l else begin\n    let l1 = l / 2 in\n    let l2 = l - l1 in\n    let t = make l2 (get a 0) in\n    sortto l1 t 0 l2;\n    sortto 0 a l2 l1;\n    merge l2 l1 t 0 l2 a 0;\n  end\n\n\nlet fast_sort = stable_sort\n\n(** {1 Iterators} *)\n\nlet to_seq a =\n  let rec aux i () =\n    if i < length a\n    then\n      let x = unsafe_get a i in\n      Seq.Cons (x, aux (i+1))\n    else Seq.Nil\n  in\n  aux 0\n\nlet to_seqi a =\n  let rec aux i () =\n    if i < length a\n    then\n      let x = unsafe_get a i in\n      Seq.Cons ((i,x), aux (i+1))\n    else Seq.Nil\n  in\n  aux 0\n\nlet of_rev_list = function\n    [] -> [||]\n  | hd::tl as l ->\n      let len = list_length 0 l in\n      let a = create len hd in\n      let rec fill i = function\n          [] -> a\n        | hd::tl -> unsafe_set a i hd; fill (i-1) tl\n      in\n      fill (len-2) tl\n\nlet of_seq i =\n  let l = Seq.fold_left (fun acc x -> x::acc) [] i in\n  of_rev_list l\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Sets over ordered types *)\n\nmodule type OrderedType =\n  sig\n    type t\n    val compare: t -> t -> int\n  end\n\nmodule type S =\n  sig\n    type elt\n    type t\n    val empty: t\n    val is_empty: t -> bool\n    val mem: elt -> t -> bool\n    val add: elt -> t -> t\n    val singleton: elt -> t\n    val remove: elt -> t -> t\n    val union: t -> t -> t\n    val inter: t -> t -> t\n    val disjoint: t -> t -> bool\n    val diff: t -> t -> t\n    val compare: t -> t -> int\n    val equal: t -> t -> bool\n    val subset: t -> t -> bool\n    val iter: (elt -> unit) -> t -> unit\n    val map: (elt -> elt) -> t -> t\n    val fold: (elt -> 'a -> 'a) -> t -> 'a -> 'a\n    val for_all: (elt -> bool) -> t -> bool\n    val exists: (elt -> bool) -> t -> bool\n    val filter: (elt -> bool) -> t -> t\n    val filter_map: (elt -> elt option) -> t -> t\n    val partition: (elt -> bool) -> t -> t * t\n    val cardinal: t -> int\n    val elements: t -> elt list\n    val min_elt: t -> elt\n    val min_elt_opt: t -> elt option\n    val max_elt: t -> elt\n    val max_elt_opt: t -> elt option\n    val choose: t -> elt\n    val choose_opt: t -> elt option\n    val split: elt -> t -> t * bool * t\n    val find: elt -> t -> elt\n    val find_opt: elt -> t -> elt option\n    val find_first: (elt -> bool) -> t -> elt\n    val find_first_opt: (elt -> bool) -> t -> elt option\n    val find_last: (elt -> bool) -> t -> elt\n    val find_last_opt: (elt -> bool) -> t -> elt option\n    val of_list: elt list -> t\n    val to_seq_from : elt -> t -> elt Seq.t\n    val to_seq : t -> elt Seq.t\n    val to_rev_seq : t -> elt Seq.t\n    val add_seq : elt Seq.t -> t -> t\n    val of_seq : elt Seq.t -> t\n  end\n\nmodule Make(Ord: OrderedType) =\n  struct\n    type elt = Ord.t\n    type t = Empty | Node of {l:t; v:elt; r:t; h:int}\n\n    (* Sets are represented by balanced binary trees (the heights of the\n       children differ by at most 2 *)\n\n    let height = function\n        Empty -> 0\n      | Node {h} -> h\n\n    (* Creates a new node with left son l, value v and right son r.\n       We must have all elements of l < v < all elements of r.\n       l and r must be balanced and | height l - height r | <= 2.\n       Inline expansion of height for better speed. *)\n\n    let create l v r =\n      let hl = match l with Empty -> 0 | Node {h} -> h in\n      let hr = match r with Empty -> 0 | Node {h} -> h in\n      Node{l; v; r; h=(if hl >= hr then hl + 1 else hr + 1)}\n\n    (* Same as create, but performs one step of rebalancing if necessary.\n       Assumes l and r balanced and | height l - height r | <= 3.\n       Inline expansion of create for better speed in the most frequent case\n       where no rebalancing is required. *)\n\n    let bal l v r =\n      let hl = match l with Empty -> 0 | Node {h} -> h in\n      let hr = match r with Empty -> 0 | Node {h} -> h in\n      if hl > hr + 2 then begin\n        match l with\n          Empty -> invalid_arg \"Set.bal\"\n        | Node{l=ll; v=lv; r=lr} ->\n            if height ll >= height lr then\n              create ll lv (create lr v r)\n            else begin\n              match lr with\n                Empty -> invalid_arg \"Set.bal\"\n              | Node{l=lrl; v=lrv; r=lrr}->\n                  create (create ll lv lrl) lrv (create lrr v r)\n            end\n      end else if hr > hl + 2 then begin\n        match r with\n          Empty -> invalid_arg \"Set.bal\"\n        | Node{l=rl; v=rv; r=rr} ->\n            if height rr >= height rl then\n              create (create l v rl) rv rr\n            else begin\n              match rl with\n                Empty -> invalid_arg \"Set.bal\"\n              | Node{l=rll; v=rlv; r=rlr} ->\n                  create (create l v rll) rlv (create rlr rv rr)\n            end\n      end else\n        Node{l; v; r; h=(if hl >= hr then hl + 1 else hr + 1)}\n\n    (* Insertion of one element *)\n\n    let rec add x = function\n        Empty -> Node{l=Empty; v=x; r=Empty; h=1}\n      | Node{l; v; r} as t ->\n          let c = Ord.compare x v in\n          if c = 0 then t else\n          if c < 0 then\n            let ll = add x l in\n            if l == ll then t else bal ll v r\n          else\n            let rr = add x r in\n            if r == rr then t else bal l v rr\n\n    let singleton x = Node{l=Empty; v=x; r=Empty; h=1}\n\n    (* Beware: those two functions assume that the added v is *strictly*\n       smaller (or bigger) than all the present elements in the tree; it\n       does not test for equality with the current min (or max) element.\n       Indeed, they are only used during the \"join\" operation which\n       respects this precondition.\n    *)\n\n    let rec add_min_element x = function\n      | Empty -> singleton x\n      | Node {l; v; r} ->\n        bal (add_min_element x l) v r\n\n    let rec add_max_element x = function\n      | Empty -> singleton x\n      | Node {l; v; r} ->\n        bal l v (add_max_element x r)\n\n    (* Same as create and bal, but no assumptions are made on the\n       relative heights of l and r. *)\n\n    let rec join l v r =\n      match (l, r) with\n        (Empty, _) -> add_min_element v r\n      | (_, Empty) -> add_max_element v l\n      | (Node{l=ll; v=lv; r=lr; h=lh}, Node{l=rl; v=rv; r=rr; h=rh}) ->\n          if lh > rh + 2 then bal ll lv (join lr v r) else\n          if rh > lh + 2 then bal (join l v rl) rv rr else\n          create l v r\n\n    (* Smallest and greatest element of a set *)\n\n    let rec min_elt = function\n        Empty -> raise Not_found\n      | Node{l=Empty; v} -> v\n      | Node{l} -> min_elt l\n\n    let rec min_elt_opt = function\n        Empty -> None\n      | Node{l=Empty; v} -> Some v\n      | Node{l} -> min_elt_opt l\n\n    let rec max_elt = function\n        Empty -> raise Not_found\n      | Node{v; r=Empty} -> v\n      | Node{r} -> max_elt r\n\n    let rec max_elt_opt = function\n        Empty -> None\n      | Node{v; r=Empty} -> Some v\n      | Node{r} -> max_elt_opt r\n\n    (* Remove the smallest element of the given set *)\n\n    let rec remove_min_elt = function\n        Empty -> invalid_arg \"Set.remove_min_elt\"\n      | Node{l=Empty; r} -> r\n      | Node{l; v; r} -> bal (remove_min_elt l) v r\n\n    (* Merge two trees l and r into one.\n       All elements of l must precede the elements of r.\n       Assume | height l - height r | <= 2. *)\n\n    let merge t1 t2 =\n      match (t1, t2) with\n        (Empty, t) -> t\n      | (t, Empty) -> t\n      | (_, _) -> bal t1 (min_elt t2) (remove_min_elt t2)\n\n    (* Merge two trees l and r into one.\n       All elements of l must precede the elements of r.\n       No assumption on the heights of l and r. *)\n\n    let concat t1 t2 =\n      match (t1, t2) with\n        (Empty, t) -> t\n      | (t, Empty) -> t\n      | (_, _) -> join t1 (min_elt t2) (remove_min_elt t2)\n\n    (* Splitting.  split x s returns a triple (l, present, r) where\n        - l is the set of elements of s that are < x\n        - r is the set of elements of s that are > x\n        - present is false if s contains no element equal to x,\n          or true if s contains an element equal to x. *)\n\n    let rec split x = function\n        Empty ->\n          (Empty, false, Empty)\n      | Node{l; v; r} ->\n          let c = Ord.compare x v in\n          if c = 0 then (l, true, r)\n          else if c < 0 then\n            let (ll, pres, rl) = split x l in (ll, pres, join rl v r)\n          else\n            let (lr, pres, rr) = split x r in (join l v lr, pres, rr)\n\n    (* Implementation of the set operations *)\n\n    let empty = Empty\n\n    let is_empty = function Empty -> true | _ -> false\n\n    let rec mem x = function\n        Empty -> false\n      | Node{l; v; r} ->\n          let c = Ord.compare x v in\n          c = 0 || mem x (if c < 0 then l else r)\n\n    let rec remove x = function\n        Empty -> Empty\n      | (Node{l; v; r} as t) ->\n          let c = Ord.compare x v in\n          if c = 0 then merge l r\n          else\n            if c < 0 then\n              let ll = remove x l in\n              if l == ll then t\n              else bal ll v r\n            else\n              let rr = remove x r in\n              if r == rr then t\n              else bal l v rr\n\n    let rec union s1 s2 =\n      match (s1, s2) with\n        (Empty, t2) -> t2\n      | (t1, Empty) -> t1\n      | (Node{l=l1; v=v1; r=r1; h=h1}, Node{l=l2; v=v2; r=r2; h=h2}) ->\n          if h1 >= h2 then\n            if h2 = 1 then add v2 s1 else begin\n              let (l2, _, r2) = split v1 s2 in\n              join (union l1 l2) v1 (union r1 r2)\n            end\n          else\n            if h1 = 1 then add v1 s2 else begin\n              let (l1, _, r1) = split v2 s1 in\n              join (union l1 l2) v2 (union r1 r2)\n            end\n\n    let rec inter s1 s2 =\n      match (s1, s2) with\n        (Empty, _) -> Empty\n      | (_, Empty) -> Empty\n      | (Node{l=l1; v=v1; r=r1}, t2) ->\n          match split v1 t2 with\n            (l2, false, r2) ->\n              concat (inter l1 l2) (inter r1 r2)\n          | (l2, true, r2) ->\n              join (inter l1 l2) v1 (inter r1 r2)\n\n    (* Same as split, but compute the left and right subtrees\n       only if the pivot element is not in the set.  The right subtree\n       is computed on demand. *)\n\n    type split_bis =\n      | Found\n      | NotFound of t * (unit -> t)\n\n    let rec split_bis x = function\n        Empty ->\n          NotFound (Empty, (fun () -> Empty))\n      | Node{l; v; r; _} ->\n          let c = Ord.compare x v in\n          if c = 0 then Found\n          else if c < 0 then\n            match split_bis x l with\n            | Found -> Found\n            | NotFound (ll, rl) -> NotFound (ll, (fun () -> join (rl ()) v r))\n          else\n            match split_bis x r with\n            | Found -> Found\n            | NotFound (lr, rr) -> NotFound (join l v lr, rr)\n\n    let rec disjoint s1 s2 =\n      match (s1, s2) with\n        (Empty, _) | (_, Empty) -> true\n      | (Node{l=l1; v=v1; r=r1}, t2) ->\n          if s1 == s2 then false\n          else match split_bis v1 t2 with\n              NotFound(l2, r2) -> disjoint l1 l2 && disjoint r1 (r2 ())\n            | Found -> false\n\n    let rec diff s1 s2 =\n      match (s1, s2) with\n        (Empty, _) -> Empty\n      | (t1, Empty) -> t1\n      | (Node{l=l1; v=v1; r=r1}, t2) ->\n          match split v1 t2 with\n            (l2, false, r2) ->\n              join (diff l1 l2) v1 (diff r1 r2)\n          | (l2, true, r2) ->\n              concat (diff l1 l2) (diff r1 r2)\n\n    type enumeration = End | More of elt * t * enumeration\n\n    let rec cons_enum s e =\n      match s with\n        Empty -> e\n      | Node{l; v; r} -> cons_enum l (More(v, r, e))\n\n    let rec compare_aux e1 e2 =\n        match (e1, e2) with\n        (End, End) -> 0\n      | (End, _)  -> -1\n      | (_, End) -> 1\n      | (More(v1, r1, e1), More(v2, r2, e2)) ->\n          let c = Ord.compare v1 v2 in\n          if c <> 0\n          then c\n          else compare_aux (cons_enum r1 e1) (cons_enum r2 e2)\n\n    let compare s1 s2 =\n      compare_aux (cons_enum s1 End) (cons_enum s2 End)\n\n    let equal s1 s2 =\n      compare s1 s2 = 0\n\n    let rec subset s1 s2 =\n      match (s1, s2) with\n        Empty, _ ->\n          true\n      | _, Empty ->\n          false\n      | Node {l=l1; v=v1; r=r1}, (Node {l=l2; v=v2; r=r2} as t2) ->\n          let c = Ord.compare v1 v2 in\n          if c = 0 then\n            subset l1 l2 && subset r1 r2\n          else if c < 0 then\n            subset (Node {l=l1; v=v1; r=Empty; h=0}) l2 && subset r1 t2\n          else\n            subset (Node {l=Empty; v=v1; r=r1; h=0}) r2 && subset l1 t2\n\n    let rec iter f = function\n        Empty -> ()\n      | Node{l; v; r} -> iter f l; f v; iter f r\n\n    let rec fold f s accu =\n      match s with\n        Empty -> accu\n      | Node{l; v; r} -> fold f r (f v (fold f l accu))\n\n    let rec for_all p = function\n        Empty -> true\n      | Node{l; v; r} -> p v && for_all p l && for_all p r\n\n    let rec exists p = function\n        Empty -> false\n      | Node{l; v; r} -> p v || exists p l || exists p r\n\n    let rec filter p = function\n        Empty -> Empty\n      | (Node{l; v; r}) as t ->\n          (* call [p] in the expected left-to-right order *)\n          let l' = filter p l in\n          let pv = p v in\n          let r' = filter p r in\n          if pv then\n            if l==l' && r==r' then t else join l' v r'\n          else concat l' r'\n\n    let rec partition p = function\n        Empty -> (Empty, Empty)\n      | Node{l; v; r} ->\n          (* call [p] in the expected left-to-right order *)\n          let (lt, lf) = partition p l in\n          let pv = p v in\n          let (rt, rf) = partition p r in\n          if pv\n          then (join lt v rt, concat lf rf)\n          else (concat lt rt, join lf v rf)\n\n    let rec cardinal = function\n        Empty -> 0\n      | Node{l; r} -> cardinal l + 1 + cardinal r\n\n    let rec elements_aux accu = function\n        Empty -> accu\n      | Node{l; v; r} -> elements_aux (v :: elements_aux accu r) l\n\n    let elements s =\n      elements_aux [] s\n\n    let choose = min_elt\n\n    let choose_opt = min_elt_opt\n\n    let rec find x = function\n        Empty -> raise Not_found\n      | Node{l; v; r} ->\n          let c = Ord.compare x v in\n          if c = 0 then v\n          else find x (if c < 0 then l else r)\n\n    let rec find_first_aux v0 f = function\n        Empty ->\n          v0\n      | Node{l; v; r} ->\n          if f v then\n            find_first_aux v f l\n          else\n            find_first_aux v0 f r\n\n    let rec find_first f = function\n        Empty ->\n          raise Not_found\n      | Node{l; v; r} ->\n          if f v then\n            find_first_aux v f l\n          else\n            find_first f r\n\n    let rec find_first_opt_aux v0 f = function\n        Empty ->\n          Some v0\n      | Node{l; v; r} ->\n          if f v then\n            find_first_opt_aux v f l\n          else\n            find_first_opt_aux v0 f r\n\n    let rec find_first_opt f = function\n        Empty ->\n          None\n      | Node{l; v; r} ->\n          if f v then\n            find_first_opt_aux v f l\n          else\n            find_first_opt f r\n\n    let rec find_last_aux v0 f = function\n        Empty ->\n          v0\n      | Node{l; v; r} ->\n          if f v then\n            find_last_aux v f r\n          else\n            find_last_aux v0 f l\n\n    let rec find_last f = function\n        Empty ->\n          raise Not_found\n      | Node{l; v; r} ->\n          if f v then\n            find_last_aux v f r\n          else\n            find_last f l\n\n    let rec find_last_opt_aux v0 f = function\n        Empty ->\n          Some v0\n      | Node{l; v; r} ->\n          if f v then\n            find_last_opt_aux v f r\n          else\n            find_last_opt_aux v0 f l\n\n    let rec find_last_opt f = function\n        Empty ->\n          None\n      | Node{l; v; r} ->\n          if f v then\n            find_last_opt_aux v f r\n          else\n            find_last_opt f l\n\n    let rec find_opt x = function\n        Empty -> None\n      | Node{l; v; r} ->\n          let c = Ord.compare x v in\n          if c = 0 then Some v\n          else find_opt x (if c < 0 then l else r)\n\n    let try_join l v r =\n      (* [join l v r] can only be called when (elements of l < v <\n         elements of r); use [try_join l v r] when this property may\n         not hold, but you hope it does hold in the common case *)\n      if (l = Empty || Ord.compare (max_elt l) v < 0)\n      && (r = Empty || Ord.compare v (min_elt r) < 0)\n      then join l v r\n      else union l (add v r)\n\n    let rec map f = function\n      | Empty -> Empty\n      | Node{l; v; r} as t ->\n         (* enforce left-to-right evaluation order *)\n         let l' = map f l in\n         let v' = f v in\n         let r' = map f r in\n         if l == l' && v == v' && r == r' then t\n         else try_join l' v' r'\n\n    let try_concat t1 t2 =\n      match (t1, t2) with\n        (Empty, t) -> t\n      | (t, Empty) -> t\n      | (_, _) -> try_join t1 (min_elt t2) (remove_min_elt t2)\n\n    let rec filter_map f = function\n      | Empty -> Empty\n      | Node{l; v; r} as t ->\n         (* enforce left-to-right evaluation order *)\n         let l' = filter_map f l in\n         let v' = f v in\n         let r' = filter_map f r in\n         begin match v' with\n           | Some v' ->\n              if l == l' && v == v' && r == r' then t\n              else try_join l' v' r'\n           | None ->\n              try_concat l' r'\n         end\n\n    let of_sorted_list l =\n      let rec sub n l =\n        match n, l with\n        | 0, l -> Empty, l\n        | 1, x0 :: l -> Node {l=Empty; v=x0; r=Empty; h=1}, l\n        | 2, x0 :: x1 :: l ->\n            Node{l=Node{l=Empty; v=x0; r=Empty; h=1}; v=x1; r=Empty; h=2}, l\n        | 3, x0 :: x1 :: x2 :: l ->\n            Node{l=Node{l=Empty; v=x0; r=Empty; h=1}; v=x1;\n                 r=Node{l=Empty; v=x2; r=Empty; h=1}; h=2}, l\n        | n, l ->\n          let nl = n / 2 in\n          let left, l = sub nl l in\n          match l with\n          | [] -> assert false\n          | mid :: l ->\n            let right, l = sub (n - nl - 1) l in\n            create left mid right, l\n      in\n      fst (sub (List.length l) l)\n\n    let of_list l =\n      match l with\n      | [] -> empty\n      | [x0] -> singleton x0\n      | [x0; x1] -> add x1 (singleton x0)\n      | [x0; x1; x2] -> add x2 (add x1 (singleton x0))\n      | [x0; x1; x2; x3] -> add x3 (add x2 (add x1 (singleton x0)))\n      | [x0; x1; x2; x3; x4] -> add x4 (add x3 (add x2 (add x1 (singleton x0))))\n      | _ -> of_sorted_list (List.sort_uniq Ord.compare l)\n\n    let add_seq i m =\n      Seq.fold_left (fun s x -> add x s) m i\n\n    let of_seq i = add_seq i empty\n\n    let rec seq_of_enum_ c () = match c with\n      | End -> Seq.Nil\n      | More (x, t, rest) -> Seq.Cons (x, seq_of_enum_ (cons_enum t rest))\n\n    let to_seq c = seq_of_enum_ (cons_enum c End)\n\n    let rec snoc_enum s e =\n      match s with\n        Empty -> e\n      | Node{l; v; r} -> snoc_enum r (More(v, l, e))\n\n    let rec rev_seq_of_enum_ c () = match c with\n      | End -> Seq.Nil\n      | More (x, t, rest) -> Seq.Cons (x, rev_seq_of_enum_ (snoc_enum t rest))\n\n    let to_rev_seq c = rev_seq_of_enum_ (snoc_enum c End)\n\n    let to_seq_from low s =\n      let rec aux low s c = match s with\n        | Empty -> c\n        | Node {l; r; v; _} ->\n            begin match Ord.compare v low with\n              | 0 -> More (v, r, c)\n              | n when n<0 -> aux low r c\n              | _ -> aux low l (More (v, r, c))\n            end\n      in\n      seq_of_enum_ (aux low s End)\n  end\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nmodule type OrderedType =\n  sig\n    type t\n    val compare: t -> t -> int\n  end\n\nmodule type S =\n  sig\n    type key\n    type !+'a t\n    val empty: 'a t\n    val is_empty: 'a t -> bool\n    val mem:  key -> 'a t -> bool\n    val add: key -> 'a -> 'a t -> 'a t\n    val update: key -> ('a option -> 'a option) -> 'a t -> 'a t\n    val singleton: key -> 'a -> 'a t\n    val remove: key -> 'a t -> 'a t\n    val merge:\n          (key -> 'a option -> 'b option -> 'c option) -> 'a t -> 'b t -> 'c t\n    val union: (key -> 'a -> 'a -> 'a option) -> 'a t -> 'a t -> 'a t\n    val compare: ('a -> 'a -> int) -> 'a t -> 'a t -> int\n    val equal: ('a -> 'a -> bool) -> 'a t -> 'a t -> bool\n    val iter: (key -> 'a -> unit) -> 'a t -> unit\n    val fold: (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b\n    val for_all: (key -> 'a -> bool) -> 'a t -> bool\n    val exists: (key -> 'a -> bool) -> 'a t -> bool\n    val filter: (key -> 'a -> bool) -> 'a t -> 'a t\n    val filter_map: (key -> 'a -> 'b option) -> 'a t -> 'b t\n    val partition: (key -> 'a -> bool) -> 'a t -> 'a t * 'a t\n    val cardinal: 'a t -> int\n    val bindings: 'a t -> (key * 'a) list\n    val min_binding: 'a t -> (key * 'a)\n    val min_binding_opt: 'a t -> (key * 'a) option\n    val max_binding: 'a t -> (key * 'a)\n    val max_binding_opt: 'a t -> (key * 'a) option\n    val choose: 'a t -> (key * 'a)\n    val choose_opt: 'a t -> (key * 'a) option\n    val split: key -> 'a t -> 'a t * 'a option * 'a t\n    val find: key -> 'a t -> 'a\n    val find_opt: key -> 'a t -> 'a option\n    val find_first: (key -> bool) -> 'a t -> key * 'a\n    val find_first_opt: (key -> bool) -> 'a t -> (key * 'a) option\n    val find_last: (key -> bool) -> 'a t -> key * 'a\n    val find_last_opt: (key -> bool) -> 'a t -> (key * 'a) option\n    val map: ('a -> 'b) -> 'a t -> 'b t\n    val mapi: (key -> 'a -> 'b) -> 'a t -> 'b t\n    val to_seq : 'a t -> (key * 'a) Seq.t\n    val to_rev_seq : 'a t -> (key * 'a) Seq.t\n    val to_seq_from : key -> 'a t -> (key * 'a) Seq.t\n    val add_seq : (key * 'a) Seq.t -> 'a t -> 'a t\n    val of_seq : (key * 'a) Seq.t -> 'a t\n  end\n\nmodule Make(Ord: OrderedType) = struct\n\n    type key = Ord.t\n\n    type 'a t =\n        Empty\n      | Node of {l:'a t; v:key; d:'a; r:'a t; h:int}\n\n    let height = function\n        Empty -> 0\n      | Node {h} -> h\n\n    let create l x d r =\n      let hl = height l and hr = height r in\n      Node{l; v=x; d; r; h=(if hl >= hr then hl + 1 else hr + 1)}\n\n    let singleton x d = Node{l=Empty; v=x; d; r=Empty; h=1}\n\n    let bal l x d r =\n      let hl = match l with Empty -> 0 | Node {h} -> h in\n      let hr = match r with Empty -> 0 | Node {h} -> h in\n      if hl > hr + 2 then begin\n        match l with\n          Empty -> invalid_arg \"Map.bal\"\n        | Node{l=ll; v=lv; d=ld; r=lr} ->\n            if height ll >= height lr then\n              create ll lv ld (create lr x d r)\n            else begin\n              match lr with\n                Empty -> invalid_arg \"Map.bal\"\n              | Node{l=lrl; v=lrv; d=lrd; r=lrr}->\n                  create (create ll lv ld lrl) lrv lrd (create lrr x d r)\n            end\n      end else if hr > hl + 2 then begin\n        match r with\n          Empty -> invalid_arg \"Map.bal\"\n        | Node{l=rl; v=rv; d=rd; r=rr} ->\n            if height rr >= height rl then\n              create (create l x d rl) rv rd rr\n            else begin\n              match rl with\n                Empty -> invalid_arg \"Map.bal\"\n              | Node{l=rll; v=rlv; d=rld; r=rlr} ->\n                  create (create l x d rll) rlv rld (create rlr rv rd rr)\n            end\n      end else\n        Node{l; v=x; d; r; h=(if hl >= hr then hl + 1 else hr + 1)}\n\n    let empty = Empty\n\n    let is_empty = function Empty -> true | _ -> false\n\n    let rec add x data = function\n        Empty ->\n          Node{l=Empty; v=x; d=data; r=Empty; h=1}\n      | Node {l; v; d; r; h} as m ->\n          let c = Ord.compare x v in\n          if c = 0 then\n            if d == data then m else Node{l; v=x; d=data; r; h}\n          else if c < 0 then\n            let ll = add x data l in\n            if l == ll then m else bal ll v d r\n          else\n            let rr = add x data r in\n            if r == rr then m else bal l v d rr\n\n    let rec find x = function\n        Empty ->\n          raise Not_found\n      | Node {l; v; d; r} ->\n          let c = Ord.compare x v in\n          if c = 0 then d\n          else find x (if c < 0 then l else r)\n\n    let rec find_first_aux v0 d0 f = function\n        Empty ->\n          (v0, d0)\n      | Node {l; v; d; r} ->\n          if f v then\n            find_first_aux v d f l\n          else\n            find_first_aux v0 d0 f r\n\n    let rec find_first f = function\n        Empty ->\n          raise Not_found\n      | Node {l; v; d; r} ->\n          if f v then\n            find_first_aux v d f l\n          else\n            find_first f r\n\n    let rec find_first_opt_aux v0 d0 f = function\n        Empty ->\n          Some (v0, d0)\n      | Node {l; v; d; r} ->\n          if f v then\n            find_first_opt_aux v d f l\n          else\n            find_first_opt_aux v0 d0 f r\n\n    let rec find_first_opt f = function\n        Empty ->\n          None\n      | Node {l; v; d; r} ->\n          if f v then\n            find_first_opt_aux v d f l\n          else\n            find_first_opt f r\n\n    let rec find_last_aux v0 d0 f = function\n        Empty ->\n          (v0, d0)\n      | Node {l; v; d; r} ->\n          if f v then\n            find_last_aux v d f r\n          else\n            find_last_aux v0 d0 f l\n\n    let rec find_last f = function\n        Empty ->\n          raise Not_found\n      | Node {l; v; d; r} ->\n          if f v then\n            find_last_aux v d f r\n          else\n            find_last f l\n\n    let rec find_last_opt_aux v0 d0 f = function\n        Empty ->\n          Some (v0, d0)\n      | Node {l; v; d; r} ->\n          if f v then\n            find_last_opt_aux v d f r\n          else\n            find_last_opt_aux v0 d0 f l\n\n    let rec find_last_opt f = function\n        Empty ->\n          None\n      | Node {l; v; d; r} ->\n          if f v then\n            find_last_opt_aux v d f r\n          else\n            find_last_opt f l\n\n    let rec find_opt x = function\n        Empty ->\n          None\n      | Node {l; v; d; r} ->\n          let c = Ord.compare x v in\n          if c = 0 then Some d\n          else find_opt x (if c < 0 then l else r)\n\n    let rec mem x = function\n        Empty ->\n          false\n      | Node {l; v; r} ->\n          let c = Ord.compare x v in\n          c = 0 || mem x (if c < 0 then l else r)\n\n    let rec min_binding = function\n        Empty -> raise Not_found\n      | Node {l=Empty; v; d} -> (v, d)\n      | Node {l} -> min_binding l\n\n    let rec min_binding_opt = function\n        Empty -> None\n      | Node {l=Empty; v; d} -> Some (v, d)\n      | Node {l}-> min_binding_opt l\n\n    let rec max_binding = function\n        Empty -> raise Not_found\n      | Node {v; d; r=Empty} -> (v, d)\n      | Node {r} -> max_binding r\n\n    let rec max_binding_opt = function\n        Empty -> None\n      | Node {v; d; r=Empty} -> Some (v, d)\n      | Node {r} -> max_binding_opt r\n\n    let rec remove_min_binding = function\n        Empty -> invalid_arg \"Map.remove_min_elt\"\n      | Node {l=Empty; r} -> r\n      | Node {l; v; d; r} -> bal (remove_min_binding l) v d r\n\n    let merge t1 t2 =\n      match (t1, t2) with\n        (Empty, t) -> t\n      | (t, Empty) -> t\n      | (_, _) ->\n          let (x, d) = min_binding t2 in\n          bal t1 x d (remove_min_binding t2)\n\n    let rec remove x = function\n        Empty ->\n          Empty\n      | (Node {l; v; d; r} as m) ->\n          let c = Ord.compare x v in\n          if c = 0 then merge l r\n          else if c < 0 then\n            let ll = remove x l in if l == ll then m else bal ll v d r\n          else\n            let rr = remove x r in if r == rr then m else bal l v d rr\n\n    let rec update x f = function\n        Empty ->\n          begin match f None with\n          | None -> Empty\n          | Some data -> Node{l=Empty; v=x; d=data; r=Empty; h=1}\n          end\n      | Node {l; v; d; r; h} as m ->\n          let c = Ord.compare x v in\n          if c = 0 then begin\n            match f (Some d) with\n            | None -> merge l r\n            | Some data ->\n                if d == data then m else Node{l; v=x; d=data; r; h}\n          end else if c < 0 then\n            let ll = update x f l in\n            if l == ll then m else bal ll v d r\n          else\n            let rr = update x f r in\n            if r == rr then m else bal l v d rr\n\n    let rec iter f = function\n        Empty -> ()\n      | Node {l; v; d; r} ->\n          iter f l; f v d; iter f r\n\n    let rec map f = function\n        Empty ->\n          Empty\n      | Node {l; v; d; r; h} ->\n          let l' = map f l in\n          let d' = f d in\n          let r' = map f r in\n          Node{l=l'; v; d=d'; r=r'; h}\n\n    let rec mapi f = function\n        Empty ->\n          Empty\n      | Node {l; v; d; r; h} ->\n          let l' = mapi f l in\n          let d' = f v d in\n          let r' = mapi f r in\n          Node{l=l'; v; d=d'; r=r'; h}\n\n    let rec fold f m accu =\n      match m with\n        Empty -> accu\n      | Node {l; v; d; r} ->\n          fold f r (f v d (fold f l accu))\n\n    let rec for_all p = function\n        Empty -> true\n      | Node {l; v; d; r} -> p v d && for_all p l && for_all p r\n\n    let rec exists p = function\n        Empty -> false\n      | Node {l; v; d; r} -> p v d || exists p l || exists p r\n\n    (* Beware: those two functions assume that the added k is *strictly*\n       smaller (or bigger) than all the present keys in the tree; it\n       does not test for equality with the current min (or max) key.\n\n       Indeed, they are only used during the \"join\" operation which\n       respects this precondition.\n    *)\n\n    let rec add_min_binding k x = function\n      | Empty -> singleton k x\n      | Node {l; v; d; r} ->\n        bal (add_min_binding k x l) v d r\n\n    let rec add_max_binding k x = function\n      | Empty -> singleton k x\n      | Node {l; v; d; r} ->\n        bal l v d (add_max_binding k x r)\n\n    (* Same as create and bal, but no assumptions are made on the\n       relative heights of l and r. *)\n\n    let rec join l v d r =\n      match (l, r) with\n        (Empty, _) -> add_min_binding v d r\n      | (_, Empty) -> add_max_binding v d l\n      | (Node{l=ll; v=lv; d=ld; r=lr; h=lh},\n         Node{l=rl; v=rv; d=rd; r=rr; h=rh}) ->\n          if lh > rh + 2 then bal ll lv ld (join lr v d r) else\n          if rh > lh + 2 then bal (join l v d rl) rv rd rr else\n          create l v d r\n\n    (* Merge two trees l and r into one.\n       All elements of l must precede the elements of r.\n       No assumption on the heights of l and r. *)\n\n    let concat t1 t2 =\n      match (t1, t2) with\n        (Empty, t) -> t\n      | (t, Empty) -> t\n      | (_, _) ->\n          let (x, d) = min_binding t2 in\n          join t1 x d (remove_min_binding t2)\n\n    let concat_or_join t1 v d t2 =\n      match d with\n      | Some d -> join t1 v d t2\n      | None -> concat t1 t2\n\n    let rec split x = function\n        Empty ->\n          (Empty, None, Empty)\n      | Node {l; v; d; r} ->\n          let c = Ord.compare x v in\n          if c = 0 then (l, Some d, r)\n          else if c < 0 then\n            let (ll, pres, rl) = split x l in (ll, pres, join rl v d r)\n          else\n            let (lr, pres, rr) = split x r in (join l v d lr, pres, rr)\n\n    let rec merge f s1 s2 =\n      match (s1, s2) with\n        (Empty, Empty) -> Empty\n      | (Node {l=l1; v=v1; d=d1; r=r1; h=h1}, _) when h1 >= height s2 ->\n          let (l2, d2, r2) = split v1 s2 in\n          concat_or_join (merge f l1 l2) v1 (f v1 (Some d1) d2) (merge f r1 r2)\n      | (_, Node {l=l2; v=v2; d=d2; r=r2}) ->\n          let (l1, d1, r1) = split v2 s1 in\n          concat_or_join (merge f l1 l2) v2 (f v2 d1 (Some d2)) (merge f r1 r2)\n      | _ ->\n          assert false\n\n    let rec union f s1 s2 =\n      match (s1, s2) with\n      | (Empty, s) | (s, Empty) -> s\n      | (Node {l=l1; v=v1; d=d1; r=r1; h=h1},\n         Node {l=l2; v=v2; d=d2; r=r2; h=h2}) ->\n          if h1 >= h2 then\n            let (l2, d2, r2) = split v1 s2 in\n            let l = union f l1 l2 and r = union f r1 r2 in\n            match d2 with\n            | None -> join l v1 d1 r\n            | Some d2 -> concat_or_join l v1 (f v1 d1 d2) r\n          else\n            let (l1, d1, r1) = split v2 s1 in\n            let l = union f l1 l2 and r = union f r1 r2 in\n            match d1 with\n            | None -> join l v2 d2 r\n            | Some d1 -> concat_or_join l v2 (f v2 d1 d2) r\n\n    let rec filter p = function\n        Empty -> Empty\n      | Node {l; v; d; r} as m ->\n          (* call [p] in the expected left-to-right order *)\n          let l' = filter p l in\n          let pvd = p v d in\n          let r' = filter p r in\n          if pvd then if l==l' && r==r' then m else join l' v d r'\n          else concat l' r'\n\n    let rec filter_map f = function\n        Empty -> Empty\n      | Node {l; v; d; r} ->\n          (* call [f] in the expected left-to-right order *)\n          let l' = filter_map f l in\n          let fvd = f v d in\n          let r' = filter_map f r in\n          begin match fvd with\n            | Some d' -> join l' v d' r'\n            | None -> concat l' r'\n          end\n\n    let rec partition p = function\n        Empty -> (Empty, Empty)\n      | Node {l; v; d; r} ->\n          (* call [p] in the expected left-to-right order *)\n          let (lt, lf) = partition p l in\n          let pvd = p v d in\n          let (rt, rf) = partition p r in\n          if pvd\n          then (join lt v d rt, concat lf rf)\n          else (concat lt rt, join lf v d rf)\n\n    type 'a enumeration = End | More of key * 'a * 'a t * 'a enumeration\n\n    let rec cons_enum m e =\n      match m with\n        Empty -> e\n      | Node {l; v; d; r} -> cons_enum l (More(v, d, r, e))\n\n    let compare cmp m1 m2 =\n      let rec compare_aux e1 e2 =\n          match (e1, e2) with\n          (End, End) -> 0\n        | (End, _)  -> -1\n        | (_, End) -> 1\n        | (More(v1, d1, r1, e1), More(v2, d2, r2, e2)) ->\n            let c = Ord.compare v1 v2 in\n            if c <> 0 then c else\n            let c = cmp d1 d2 in\n            if c <> 0 then c else\n            compare_aux (cons_enum r1 e1) (cons_enum r2 e2)\n      in compare_aux (cons_enum m1 End) (cons_enum m2 End)\n\n    let equal cmp m1 m2 =\n      let rec equal_aux e1 e2 =\n          match (e1, e2) with\n          (End, End) -> true\n        | (End, _)  -> false\n        | (_, End) -> false\n        | (More(v1, d1, r1, e1), More(v2, d2, r2, e2)) ->\n            Ord.compare v1 v2 = 0 && cmp d1 d2 &&\n            equal_aux (cons_enum r1 e1) (cons_enum r2 e2)\n      in equal_aux (cons_enum m1 End) (cons_enum m2 End)\n\n    let rec cardinal = function\n        Empty -> 0\n      | Node {l; r} -> cardinal l + 1 + cardinal r\n\n    let rec bindings_aux accu = function\n        Empty -> accu\n      | Node {l; v; d; r} -> bindings_aux ((v, d) :: bindings_aux accu r) l\n\n    let bindings s =\n      bindings_aux [] s\n\n    let choose = min_binding\n\n    let choose_opt = min_binding_opt\n\n    let add_seq i m =\n      Seq.fold_left (fun m (k,v) -> add k v m) m i\n\n    let of_seq i = add_seq i empty\n\n    let rec seq_of_enum_ c () = match c with\n      | End -> Seq.Nil\n      | More (k,v,t,rest) -> Seq.Cons ((k,v), seq_of_enum_ (cons_enum t rest))\n\n    let to_seq m =\n      seq_of_enum_ (cons_enum m End)\n\n    let rec snoc_enum s e =\n      match s with\n        Empty -> e\n      | Node{l; v; d; r} -> snoc_enum r (More(v, d, l, e))\n\n    let rec rev_seq_of_enum_ c () = match c with\n      | End -> Seq.Nil\n      | More (k,v,t,rest) ->\n          Seq.Cons ((k,v), rev_seq_of_enum_ (snoc_enum t rest))\n\n    let to_rev_seq c =\n      rev_seq_of_enum_ (snoc_enum c End)\n\n    let to_seq_from low m =\n      let rec aux low m c = match m with\n        | Empty -> c\n        | Node {l; v; d; r; _} ->\n            begin match Ord.compare v low with\n              | 0 -> More (v, d, r, c)\n              | n when n<0 -> aux low r c\n              | _ -> aux low l (More (v, d, r, c))\n            end\n      in\n      seq_of_enum_ (aux low m End)\nend\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\ntype 'a t = { mutable c : 'a list; mutable len : int; }\n\nexception Empty\n\nlet create () = { c = []; len = 0; }\n\nlet clear s = s.c <- []; s.len <- 0\n\nlet copy s = { c = s.c; len = s.len; }\n\nlet push x s = s.c <- x :: s.c; s.len <- s.len + 1\n\nlet pop s =\n  match s.c with\n  | hd::tl -> s.c <- tl; s.len <- s.len - 1; hd\n  | []     -> raise Empty\n\nlet pop_opt s =\n  match s.c with\n  | hd::tl -> s.c <- tl; s.len <- s.len - 1; Some hd\n  | []     -> None\n\nlet top s =\n  match s.c with\n  | hd::_ -> hd\n  | []    -> raise Empty\n\nlet top_opt s =\n  match s.c with\n  | hd::_ -> Some hd\n  | []    -> None\n\nlet is_empty s = (s.c = [])\n\nlet length s = s.len\n\nlet iter f s = List.iter f s.c\n\nlet fold f acc s = List.fold_left f acc s.c\n\n(** {1 Iterators} *)\n\nlet to_seq s = List.to_seq s.c\n\nlet add_seq q i = Seq.iter (fun x -> push x q) i\n\nlet of_seq g =\n  let s = create() in\n  add_seq s g;\n  s\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*         Francois Pottier, projet Cristal, INRIA Rocquencourt           *)\n(*                  Jeremie Dimino, Jane Street Europe                    *)\n(*                                                                        *)\n(*   Copyright 2002 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nexception Empty\n\ntype 'a cell =\n  | Nil\n  | Cons of { content: 'a; mutable next: 'a cell }\n\ntype 'a t = {\n  mutable length: int;\n  mutable first: 'a cell;\n  mutable last: 'a cell\n}\n\nlet create () = {\n  length = 0;\n  first = Nil;\n  last = Nil\n}\n\nlet clear q =\n  q.length <- 0;\n  q.first <- Nil;\n  q.last <- Nil\n\nlet add x q =\n  let cell = Cons {\n    content = x;\n    next = Nil\n  } in\n  match q.last with\n  | Nil ->\n    q.length <- 1;\n    q.first <- cell;\n    q.last <- cell\n  | Cons last ->\n    q.length <- q.length + 1;\n    last.next <- cell;\n    q.last <- cell\n\nlet push =\n  add\n\nlet peek q =\n  match q.first with\n  | Nil -> raise Empty\n  | Cons { content } -> content\n\nlet peek_opt q =\n  match q.first with\n  | Nil -> None\n  | Cons { content } -> Some content\n\nlet top =\n  peek\n\nlet take q =\n  match q.first with\n  | Nil -> raise Empty\n  | Cons { content; next = Nil } ->\n    clear q;\n    content\n  | Cons { content; next } ->\n    q.length <- q.length - 1;\n    q.first <- next;\n    content\n\nlet take_opt q =\n  match q.first with\n  | Nil -> None\n  | Cons { content; next = Nil } ->\n    clear q;\n    Some content\n  | Cons { content; next } ->\n    q.length <- q.length - 1;\n    q.first <- next;\n    Some content\n\nlet pop =\n  take\n\nlet copy =\n  let rec copy q_res prev cell =\n    match cell with\n    | Nil -> q_res.last <- prev; q_res\n    | Cons { content; next } ->\n      let res = Cons { content; next = Nil } in\n      begin match prev with\n      | Nil -> q_res.first <- res\n      | Cons p -> p.next <- res\n      end;\n      copy q_res res next\n  in\n  fun q -> copy { length = q.length; first = Nil; last = Nil } Nil q.first\n\nlet is_empty q =\n  q.length = 0\n\nlet length q =\n  q.length\n\nlet iter =\n  let rec iter f cell =\n    match cell with\n    | Nil -> ()\n    | Cons { content; next } ->\n      f content;\n      iter f next\n  in\n  fun f q -> iter f q.first\n\nlet fold =\n  let rec fold f accu cell =\n    match cell with\n    | Nil -> accu\n    | Cons { content; next } ->\n      let accu = f accu content in\n      fold f accu next\n  in\n  fun f accu q -> fold f accu q.first\n\nlet transfer q1 q2 =\n  if q1.length > 0 then\n    match q2.last with\n    | Nil ->\n      q2.length <- q1.length;\n      q2.first <- q1.first;\n      q2.last <- q1.last;\n      clear q1\n    | Cons last ->\n      q2.length <- q2.length + q1.length;\n      last.next <- q1.first;\n      q2.last <- q1.last;\n      clear q1\n\n(** {1 Iterators} *)\n\nlet to_seq q =\n  let rec aux c () = match c with\n    | Nil -> Seq.Nil\n    | Cons { content=x; next; } -> Seq.Cons (x, aux next)\n  in\n  aux q.first\n\nlet add_seq q i = Seq.iter (fun x -> push x q) i\n\nlet of_seq g =\n  let q = create() in\n  add_seq q g;\n  q\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Damien Doligez, projet Para, INRIA Rocquencourt            *)\n(*                                                                        *)\n(*   Copyright 1997 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Internals of forcing lazy values. *)\n\ntype 'a t = 'a lazy_t\n\nexception Undefined\n\nlet raise_undefined = Obj.repr (fun () -> raise Undefined)\n\nexternal make_forward : Obj.t -> Obj.t -> unit = \"caml_obj_make_forward\"\n\n(* Assume [blk] is a block with tag lazy *)\nlet force_lazy_block (blk : 'arg lazy_t) =\n  let closure = (Obj.obj (Obj.field (Obj.repr blk) 0) : unit -> 'arg) in\n  Obj.set_field (Obj.repr blk) 0 raise_undefined;\n  try\n    let result = closure () in\n    make_forward (Obj.repr blk) (Obj.repr result);\n    result\n  with e ->\n    Obj.set_field (Obj.repr blk) 0 (Obj.repr (fun () -> raise e));\n    raise e\n\n\n(* Assume [blk] is a block with tag lazy *)\nlet force_val_lazy_block (blk : 'arg lazy_t) =\n  let closure = (Obj.obj (Obj.field (Obj.repr blk) 0) : unit -> 'arg) in\n  Obj.set_field (Obj.repr blk) 0 raise_undefined;\n  let result = closure () in\n  make_forward (Obj.repr blk) (Obj.repr result);\n  result\n\n\n(* [force] is not used, since [Lazy.force] is declared as a primitive\n   whose code inlines the tag tests of its argument, except when afl\n   instrumentation is turned on. *)\n\nlet force (lzv : 'arg lazy_t) =\n  (* Using [Sys.opaque_identity] prevents two potential problems:\n     - If the value is known to have Forward_tag, then its tag could have\n       changed during GC, so that information must be forgotten (see GPR#713\n       and issue #7301)\n     - If the value is known to be immutable, then if the compiler\n       cannot prove that the last branch is not taken it will issue a\n       warning 59 (modification of an immutable value) *)\n  let lzv = Sys.opaque_identity lzv in\n  let x = Obj.repr lzv in\n  let t = Obj.tag x in\n  if t = Obj.forward_tag then (Obj.obj (Obj.field x 0) : 'arg) else\n  if t <> Obj.lazy_tag then (Obj.obj x : 'arg)\n  else force_lazy_block lzv\n\n\nlet force_val (lzv : 'arg lazy_t) =\n  let x = Obj.repr lzv in\n  let t = Obj.tag x in\n  if t = Obj.forward_tag then (Obj.obj (Obj.field x 0) : 'arg) else\n  if t <> Obj.lazy_tag then (Obj.obj x : 'arg)\n  else force_val_lazy_block lzv\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*    Pierre Weis and Xavier Leroy, projet Cristal, INRIA Rocquencourt    *)\n(*                                                                        *)\n(*   Copyright 1999 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Extensible buffers *)\n\ntype t =\n {mutable buffer : bytes;\n  mutable position : int;\n  mutable length : int;\n  initial_buffer : bytes}\n(* Invariants: all parts of the code preserve the invariants that:\n   - [0 <= b.position <= b.length]\n   - [b.length = Bytes.length b.buffer]\n\n   Note in particular that [b.position = b.length] is legal,\n   it means that the buffer is full and will have to be extended\n   before any further addition. *)\n\nlet create n =\n let n = if n < 1 then 1 else n in\n let n = if n > Sys.max_string_length then Sys.max_string_length else n in\n let s = Bytes.create n in\n {buffer = s; position = 0; length = n; initial_buffer = s}\n\nlet contents b = Bytes.sub_string b.buffer 0 b.position\nlet to_bytes b = Bytes.sub b.buffer 0 b.position\n\nlet sub b ofs len =\n  if ofs < 0 || len < 0 || ofs > b.position - len\n  then invalid_arg \"Buffer.sub\"\n  else Bytes.sub_string b.buffer ofs len\n\n\nlet blit src srcoff dst dstoff len =\n  if len < 0 || srcoff < 0 || srcoff > src.position - len\n             || dstoff < 0 || dstoff > (Bytes.length dst) - len\n  then invalid_arg \"Buffer.blit\"\n  else\n    Bytes.unsafe_blit src.buffer srcoff dst dstoff len\n\n\nlet nth b ofs =\n  if ofs < 0 || ofs >= b.position then\n   invalid_arg \"Buffer.nth\"\n  else Bytes.unsafe_get b.buffer ofs\n\n\nlet length b = b.position\n\nlet clear b = b.position <- 0\n\nlet reset b =\n  b.position <- 0;\n  b.buffer <- b.initial_buffer;\n  b.length <- Bytes.length b.buffer\n\n(* [resize b more] ensures that [b.position + more <= b.length] holds\n   by dynamically extending [b.buffer] if necessary -- and thus\n   increasing [b.length].\n\n   In particular, after [resize b more] is called, a direct access of\n   size [more] at [b.position] will always be in-bounds, so that\n   (unsafe_{get,set}) may be used for performance.\n*)\nlet resize b more =\n  let old_pos = b.position in\n  let old_len = b.length in\n  let new_len = ref old_len in\n  while old_pos + more > !new_len do new_len := 2 * !new_len done;\n  if !new_len > Sys.max_string_length then begin\n    if old_pos + more <= Sys.max_string_length\n    then new_len := Sys.max_string_length\n    else failwith \"Buffer.add: cannot grow buffer\"\n  end;\n  let new_buffer = Bytes.create !new_len in\n  (* PR#6148: let's keep using [blit] rather than [unsafe_blit] in\n     this tricky function that is slow anyway. *)\n  Bytes.blit b.buffer 0 new_buffer 0 b.position;\n  b.buffer <- new_buffer;\n  b.length <- !new_len;\n  assert (b.position + more <= b.length);\n  assert (old_pos + more <= b.length);\n  ()\n  (* Note: there are various situations (preemptive threads, signals and\n     gc finalizers) where OCaml code may be run asynchronously; in\n     particular, there may be a race with another user of [b], changing\n     its mutable fields in the middle of the [resize] call. The Buffer\n     module does not provide any correctness guarantee if that happens,\n     but we must still ensure that the datastructure invariants hold for\n     memory-safety -- as we plan to use [unsafe_{get,set}].\n\n     There are two potential allocation points in this function,\n     [ref] and [Bytes.create], but all reads and writes to the fields\n     of [b] happen before both of them or after both of them.\n\n     We therefore assume that [b.position] may change at these allocations,\n     and check that the [b.position + more <= b.length] postcondition\n     holds for both values of [b.position], before or after the function\n     is called. More precisely, the following invariants must hold if the\n     function returns correctly, in addition to the usual buffer invariants:\n     - [old(b.position) + more <= new(b.length)]\n     - [new(b.position) + more <= new(b.length)]\n     - [old(b.length) <= new(b.length)]\n\n     Note: [b.position + more <= old(b.length)] does *not*\n     hold in general, as it is precisely the case where you need\n     to call [resize] to increase [b.length].\n\n     Note: [assert] above does not mean that we know the conditions\n     always hold, but that the function may return correctly\n     only if they hold.\n\n     Note: the other functions in this module does not need\n     to be checked with this level of scrutiny, given that they\n     read/write the buffer immediately after checking that\n     [b.position + more <= b.length] hold or calling [resize].\n  *)\n\nlet add_char b c =\n  let pos = b.position in\n  if pos >= b.length then resize b 1;\n  Bytes.unsafe_set b.buffer pos c;\n  b.position <- pos + 1\n\n let add_utf_8_uchar b u = match Uchar.to_int u with\n | u when u < 0 -> assert false\n | u when u <= 0x007F ->\n     add_char b (Char.unsafe_chr u)\n | u when u <= 0x07FF ->\n     let pos = b.position in\n     if pos + 2 > b.length then resize b 2;\n     Bytes.unsafe_set b.buffer (pos    )\n       (Char.unsafe_chr (0xC0 lor (u lsr 6)));\n     Bytes.unsafe_set b.buffer (pos + 1)\n       (Char.unsafe_chr (0x80 lor (u land 0x3F)));\n     b.position <- pos + 2\n | u when u <= 0xFFFF ->\n     let pos = b.position in\n     if pos + 3 > b.length then resize b 3;\n     Bytes.unsafe_set b.buffer (pos    )\n       (Char.unsafe_chr (0xE0 lor (u lsr 12)));\n     Bytes.unsafe_set b.buffer (pos + 1)\n       (Char.unsafe_chr (0x80 lor ((u lsr 6) land 0x3F)));\n     Bytes.unsafe_set b.buffer (pos + 2)\n       (Char.unsafe_chr (0x80 lor (u land 0x3F)));\n     b.position <- pos + 3\n | u when u <= 0x10FFFF ->\n     let pos = b.position in\n     if pos + 4 > b.length then resize b 4;\n     Bytes.unsafe_set b.buffer (pos    )\n       (Char.unsafe_chr (0xF0 lor (u lsr 18)));\n     Bytes.unsafe_set b.buffer (pos + 1)\n       (Char.unsafe_chr (0x80 lor ((u lsr 12) land 0x3F)));\n     Bytes.unsafe_set b.buffer (pos + 2)\n       (Char.unsafe_chr (0x80 lor ((u lsr 6) land 0x3F)));\n     Bytes.unsafe_set b.buffer (pos + 3)\n       (Char.unsafe_chr (0x80 lor (u land 0x3F)));\n     b.position <- pos + 4\n | _ -> assert false\n\n let add_utf_16be_uchar b u = match Uchar.to_int u with\n | u when u < 0 -> assert false\n | u when u <= 0xFFFF ->\n     let pos = b.position in\n     if pos + 2 > b.length then resize b 2;\n     Bytes.unsafe_set b.buffer (pos    ) (Char.unsafe_chr (u lsr 8));\n     Bytes.unsafe_set b.buffer (pos + 1) (Char.unsafe_chr (u land 0xFF));\n     b.position <- pos + 2\n | u when u <= 0x10FFFF ->\n     let u' = u - 0x10000 in\n     let hi = 0xD800 lor (u' lsr 10) in\n     let lo = 0xDC00 lor (u' land 0x3FF) in\n     let pos = b.position in\n     if pos + 4 > b.length then resize b 4;\n     Bytes.unsafe_set b.buffer (pos    ) (Char.unsafe_chr (hi lsr 8));\n     Bytes.unsafe_set b.buffer (pos + 1) (Char.unsafe_chr (hi land 0xFF));\n     Bytes.unsafe_set b.buffer (pos + 2) (Char.unsafe_chr (lo lsr 8));\n     Bytes.unsafe_set b.buffer (pos + 3) (Char.unsafe_chr (lo land 0xFF));\n     b.position <- pos + 4\n | _ -> assert false\n\n let add_utf_16le_uchar b u = match Uchar.to_int u with\n | u when u < 0 -> assert false\n | u when u <= 0xFFFF ->\n     let pos = b.position in\n     if pos + 2 > b.length then resize b 2;\n     Bytes.unsafe_set b.buffer (pos    ) (Char.unsafe_chr (u land 0xFF));\n     Bytes.unsafe_set b.buffer (pos + 1) (Char.unsafe_chr (u lsr 8));\n     b.position <- pos + 2\n | u when u <= 0x10FFFF ->\n     let u' = u - 0x10000 in\n     let hi = 0xD800 lor (u' lsr 10) in\n     let lo = 0xDC00 lor (u' land 0x3FF) in\n     let pos = b.position in\n     if pos + 4 > b.length then resize b 4;\n     Bytes.unsafe_set b.buffer (pos    ) (Char.unsafe_chr (hi land 0xFF));\n     Bytes.unsafe_set b.buffer (pos + 1) (Char.unsafe_chr (hi lsr 8));\n     Bytes.unsafe_set b.buffer (pos + 2) (Char.unsafe_chr (lo land 0xFF));\n     Bytes.unsafe_set b.buffer (pos + 3) (Char.unsafe_chr (lo lsr 8));\n     b.position <- pos + 4\n | _ -> assert false\n\nlet add_substring b s offset len =\n  if offset < 0 || len < 0 || offset > String.length s - len\n  then invalid_arg \"Buffer.add_substring/add_subbytes\";\n  let new_position = b.position + len in\n  if new_position > b.length then resize b len;\n  Bytes.unsafe_blit_string s offset b.buffer b.position len;\n  b.position <- new_position\n\nlet add_subbytes b s offset len =\n  add_substring b (Bytes.unsafe_to_string s) offset len\n\nlet add_string b s =\n  let len = String.length s in\n  let new_position = b.position + len in\n  if new_position > b.length then resize b len;\n  Bytes.unsafe_blit_string s 0 b.buffer b.position len;\n  b.position <- new_position\n\nlet add_bytes b s = add_string b (Bytes.unsafe_to_string s)\n\nlet add_buffer b bs =\n  add_subbytes b bs.buffer 0 bs.position\n\n(* this (private) function could move into the standard library *)\nlet really_input_up_to ic buf ofs len =\n  let rec loop ic buf ~already_read ~ofs ~to_read =\n    if to_read = 0 then already_read\n    else begin\n      let r = input ic buf ofs to_read in\n      if r = 0 then already_read\n      else begin\n        let already_read = already_read + r in\n        let ofs = ofs + r in\n        let to_read = to_read - r in\n        loop ic buf ~already_read ~ofs ~to_read\n      end\n    end\n  in loop ic buf ~already_read:0 ~ofs ~to_read:len\n\n\nlet unsafe_add_channel_up_to b ic len =\n  if b.position + len > b.length then resize b len;\n  let n = really_input_up_to ic b.buffer b.position len in\n  (* The assertion below may fail in weird scenario where\n     threaded/finalizer code, run asynchronously during the\n     [really_input_up_to] call, races on the buffer; we don't ensure\n     correctness in this case, but need to preserve the invariants for\n     memory-safety (see discussion of [resize]). *)\n  assert (b.position + n <= b.length);\n  b.position <- b.position + n;\n  n\n\nlet add_channel b ic len =\n  if len < 0 || len > Sys.max_string_length then   (* PR#5004 *)\n    invalid_arg \"Buffer.add_channel\";\n  let n = unsafe_add_channel_up_to b ic len in\n  (* It is intentional that a consumer catching End_of_file\n     will see the data written (see #6719, #7136). *)\n  if n < len then raise End_of_file;\n  ()\n\nlet output_buffer oc b =\n  output oc b.buffer 0 b.position\n\nlet closing = function\n  | '(' -> ')'\n  | '{' -> '}'\n  | _ -> assert false\n\n(* opening and closing: open and close characters, typically ( and )\n   k: balance of opening and closing chars\n   s: the string where we are searching\n   start: the index where we start the search. *)\nlet advance_to_closing opening closing k s start =\n  let rec advance k i lim =\n    if i >= lim then raise Not_found else\n    if s.[i] = opening then advance (k + 1) (i + 1) lim else\n    if s.[i] = closing then\n      if k = 0 then i else advance (k - 1) (i + 1) lim\n    else advance k (i + 1) lim in\n  advance k start (String.length s)\n\nlet advance_to_non_alpha s start =\n  let rec advance i lim =\n    if i >= lim then lim else\n    match s.[i] with\n    | 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' -> advance (i + 1) lim\n    | _ -> i in\n  advance start (String.length s)\n\n(* We are just at the beginning of an ident in s, starting at start. *)\nlet find_ident s start lim =\n  if start >= lim then raise Not_found else\n  match s.[start] with\n  (* Parenthesized ident ? *)\n  | '(' | '{' as c ->\n     let new_start = start + 1 in\n     let stop = advance_to_closing c (closing c) 0 s new_start in\n     String.sub s new_start (stop - start - 1), stop + 1\n  (* Regular ident *)\n  | _ ->\n     let stop = advance_to_non_alpha s (start + 1) in\n     String.sub s start (stop - start), stop\n\n(* Substitute $ident, $(ident), or ${ident} in s,\n    according to the function mapping f. *)\nlet add_substitute b f s =\n  let lim = String.length s in\n  let rec subst previous i =\n    if i < lim then begin\n      match s.[i] with\n      | '$' as current when previous = '\\\\' ->\n         add_char b current;\n         subst ' ' (i + 1)\n      | '$' ->\n         let j = i + 1 in\n         let ident, next_i = find_ident s j lim in\n         add_string b (f ident);\n         subst ' ' next_i\n      | current when previous == '\\\\' ->\n         add_char b '\\\\';\n         add_char b current;\n         subst ' ' (i + 1)\n      | '\\\\' as current ->\n         subst current (i + 1)\n      | current ->\n         add_char b current;\n         subst current (i + 1)\n    end else\n    if previous = '\\\\' then add_char b previous in\n  subst ' ' 0\n\nlet truncate b len =\n    if len < 0 || len > length b then\n      invalid_arg \"Buffer.truncate\"\n    else\n      b.position <- len\n\n(** {1 Iterators} *)\n\nlet to_seq b =\n  let rec aux i () =\n    (* Note that b.position is not a constant and cannot be lifted out of aux *)\n    if i >= b.position then Seq.Nil\n    else\n      let x = Bytes.unsafe_get b.buffer i in\n      Seq.Cons (x, aux (i+1))\n  in\n  aux 0\n\nlet to_seqi b =\n  let rec aux i () =\n    (* Note that b.position is not a constant and cannot be lifted out of aux *)\n    if i >= b.position then Seq.Nil\n    else\n      let x = Bytes.unsafe_get b.buffer i in\n      Seq.Cons ((i,x), aux (i+1))\n  in\n  aux 0\n\nlet add_seq b seq = Seq.iter (add_char b) seq\n\nlet of_seq i =\n  let b = create 32 in\n  add_seq b i;\n  b\n\n(** {6 Binary encoding of integers} *)\n\nexternal unsafe_set_int8 : bytes -> int -> int -> unit = \"%bytes_unsafe_set\"\nexternal unsafe_set_int16 : bytes -> int -> int -> unit = \"%caml_bytes_set16u\"\nexternal unsafe_set_int32 : bytes -> int -> int32 -> unit = \"%caml_bytes_set32u\"\nexternal unsafe_set_int64 : bytes -> int -> int64 -> unit = \"%caml_bytes_set64u\"\nexternal swap16 : int -> int = \"%bswap16\"\nexternal swap32 : int32 -> int32 = \"%bswap_int32\"\nexternal swap64 : int64 -> int64 = \"%bswap_int64\"\n\n\nlet add_int8 b x =\n  let new_position = b.position + 1 in\n  if new_position > b.length then resize b 1;\n  unsafe_set_int8 b.buffer b.position x;\n  b.position <- new_position\n\nlet add_int16_ne b x =\n  let new_position = b.position + 2 in\n  if new_position > b.length then resize b 2;\n  unsafe_set_int16 b.buffer b.position x;\n  b.position <- new_position\n\nlet add_int32_ne b x =\n  let new_position = b.position + 4 in\n  if new_position > b.length then resize b 4;\n  unsafe_set_int32 b.buffer b.position x;\n  b.position <- new_position\n\nlet add_int64_ne b x =\n  let new_position = b.position + 8 in\n  if new_position > b.length then resize b 8;\n  unsafe_set_int64 b.buffer b.position x;\n  b.position <- new_position\n\nlet add_int16_le b x =\n  add_int16_ne b (if Sys.big_endian then swap16 x else x)\n\nlet add_int16_be b x =\n  add_int16_ne b (if Sys.big_endian then x else swap16 x)\n\nlet add_int32_le b x =\n  add_int32_ne b (if Sys.big_endian then swap32 x else x)\n\nlet add_int32_be b x =\n  add_int32_ne b (if Sys.big_endian then x else swap32 x)\n\nlet add_int64_le b x =\n  add_int64_ne b (if Sys.big_endian then swap64 x else x)\n\nlet add_int64_be b x =\n  add_int64_ne b (if Sys.big_endian then x else swap64 x)\n\nlet add_uint8 = add_int8\nlet add_uint16_ne = add_int16_ne\nlet add_uint16_le = add_int16_le\nlet add_uint16_be = add_int16_be\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*                          Benoit Vaugon, ENSTA                          *)\n(*                                                                        *)\n(*   Copyright 2014 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nopen CamlinternalFormatBasics\n\n(******************************************************************************)\n           (* Tools to manipulate scanning set of chars (see %[...]) *)\n\ntype mutable_char_set = bytes\n\n(* Create a fresh, empty, mutable char set. *)\nlet create_char_set () = Bytes.make 32 '\\000'\n\n(* Add a char in a mutable char set. *)\nlet add_in_char_set char_set c =\n  let ind = int_of_char c in\n  let str_ind = ind lsr 3 and mask = 1 lsl (ind land 0b111) in\n  Bytes.set char_set str_ind\n    (char_of_int (int_of_char (Bytes.get char_set str_ind) lor mask))\n\nlet freeze_char_set char_set =\n  Bytes.to_string char_set\n\n(* Compute the complement of a char set. *)\nlet rev_char_set char_set =\n  let char_set' = create_char_set () in\n  for i = 0 to 31 do\n    Bytes.set char_set' i\n      (char_of_int (int_of_char (String.get char_set i) lxor 0xFF));\n  done;\n  Bytes.unsafe_to_string char_set'\n\n(* Return true if a `c' is in `char_set'. *)\nlet is_in_char_set char_set c =\n  let ind = int_of_char c in\n  let str_ind = ind lsr 3 and mask = 1 lsl (ind land 0b111) in\n  (int_of_char (String.get char_set str_ind) land mask) <> 0\n\n\n(******************************************************************************)\n                         (* Ignored param conversion *)\n\n(* GADT used to abstract an existential type parameter. *)\n(* See param_format_of_ignored_format. *)\ntype ('a, 'b, 'c, 'd, 'e, 'f) param_format_ebb = Param_format_EBB :\n    ('x -> 'a, 'b, 'c, 'd, 'e, 'f) fmt ->\n    ('a, 'b, 'c, 'd, 'e, 'f) param_format_ebb\n\n(* Compute a padding associated to a pad_option (see \"%_42d\"). *)\nlet pad_of_pad_opt pad_opt = match pad_opt with\n  | None -> No_padding\n  | Some width -> Lit_padding (Right, width)\n\n(* Compute a precision associated to a prec_option (see \"%_.42f\"). *)\nlet prec_of_prec_opt prec_opt = match prec_opt with\n  | None -> No_precision\n  | Some ndec -> Lit_precision ndec\n\n(* Turn an ignored param into its equivalent not-ignored format node. *)\n(* Used for format pretty-printing and Scanf. *)\nlet param_format_of_ignored_format : type a b c d e f x y .\n    (a, b, c, d, y, x) ignored -> (x, b, c, y, e, f) fmt ->\n      (a, b, c, d, e, f) param_format_ebb =\nfun ign fmt -> match ign with\n  | Ignored_char ->\n    Param_format_EBB (Char fmt)\n  | Ignored_caml_char ->\n    Param_format_EBB (Caml_char fmt)\n  | Ignored_string pad_opt ->\n    Param_format_EBB (String (pad_of_pad_opt pad_opt, fmt))\n  | Ignored_caml_string pad_opt ->\n    Param_format_EBB (Caml_string (pad_of_pad_opt pad_opt, fmt))\n  | Ignored_int (iconv, pad_opt) ->\n    Param_format_EBB (Int (iconv, pad_of_pad_opt pad_opt, No_precision, fmt))\n  | Ignored_int32 (iconv, pad_opt) ->\n    Param_format_EBB\n      (Int32 (iconv, pad_of_pad_opt pad_opt, No_precision, fmt))\n  | Ignored_nativeint (iconv, pad_opt) ->\n    Param_format_EBB\n      (Nativeint (iconv, pad_of_pad_opt pad_opt, No_precision, fmt))\n  | Ignored_int64 (iconv, pad_opt) ->\n    Param_format_EBB\n      (Int64 (iconv, pad_of_pad_opt pad_opt, No_precision, fmt))\n  | Ignored_float (pad_opt, prec_opt) ->\n    Param_format_EBB\n      (Float ((Float_flag_, Float_f),\n              pad_of_pad_opt pad_opt, prec_of_prec_opt prec_opt, fmt))\n  | Ignored_bool pad_opt ->\n    Param_format_EBB (Bool (pad_of_pad_opt pad_opt, fmt))\n  | Ignored_format_arg (pad_opt, fmtty) ->\n    Param_format_EBB (Format_arg (pad_opt, fmtty, fmt))\n  | Ignored_format_subst (pad_opt, fmtty) ->\n    Param_format_EBB\n      (Format_subst (pad_opt, fmtty, fmt))\n  | Ignored_reader ->\n    Param_format_EBB (Reader fmt)\n  | Ignored_scan_char_set (width_opt, char_set) ->\n    Param_format_EBB (Scan_char_set (width_opt, char_set, fmt))\n  | Ignored_scan_get_counter counter ->\n    Param_format_EBB (Scan_get_counter (counter, fmt))\n  | Ignored_scan_next_char ->\n    Param_format_EBB (Scan_next_char fmt)\n\n\n(******************************************************************************)\n                                 (* Types *)\n\ntype ('b, 'c) acc_formatting_gen =\n  | Acc_open_tag of ('b, 'c) acc\n  | Acc_open_box of ('b, 'c) acc\n\n(* Reversed list of printing atoms. *)\n(* Used to accumulate printf arguments. *)\nand ('b, 'c) acc =\n  | Acc_formatting_lit of ('b, 'c) acc * formatting_lit\n      (* Special fmtting (box) *)\n  | Acc_formatting_gen of ('b, 'c) acc * ('b, 'c) acc_formatting_gen\n      (* Special fmtting (box) *)\n  | Acc_string_literal of ('b, 'c) acc * string     (* Literal string *)\n  | Acc_char_literal   of ('b, 'c) acc * char       (* Literal char *)\n  | Acc_data_string    of ('b, 'c) acc * string     (* Generated string *)\n  | Acc_data_char      of ('b, 'c) acc * char       (* Generated char *)\n  | Acc_delay          of ('b, 'c) acc * ('b -> 'c)\n                                                (* Delayed printing (%a, %t) *)\n  | Acc_flush          of ('b, 'c) acc              (* Flush *)\n  | Acc_invalid_arg    of ('b, 'c) acc * string\n      (* Raise Invalid_argument msg *)\n  | End_of_acc\n\n(* List of heterogeneous values. *)\n(* Used to accumulate scanf callback arguments. *)\ntype ('a, 'b) heter_list =\n  | Cons : 'c * ('a, 'b) heter_list -> ('c -> 'a, 'b) heter_list\n  | Nil : ('b, 'b) heter_list\n\n(* Existential Black Boxes. *)\n(* Used to abstract some existential type parameters. *)\n\n(* GADT type associating a padding and an fmtty. *)\n(* See the type_padding function. *)\ntype ('a, 'b, 'c, 'd, 'e, 'f) padding_fmtty_ebb = Padding_fmtty_EBB :\n     ('x, 'y) padding * ('y, 'b, 'c, 'd, 'e, 'f) fmtty ->\n     ('x, 'b, 'c, 'd, 'e, 'f) padding_fmtty_ebb\n\n(* GADT type associating a padding, a precision and an fmtty. *)\n(* See the type_padprec function. *)\ntype ('a, 'b, 'c, 'd, 'e, 'f) padprec_fmtty_ebb = Padprec_fmtty_EBB :\n     ('x, 'y) padding * ('y, 'z) precision * ('z, 'b, 'c, 'd, 'e, 'f) fmtty ->\n     ('x, 'b, 'c, 'd, 'e, 'f) padprec_fmtty_ebb\n\n(* GADT type associating a padding and an fmt. *)\n(* See make_padding_fmt_ebb and parse_format functions. *)\ntype ('a, 'b, 'c, 'e, 'f) padding_fmt_ebb = Padding_fmt_EBB :\n     (_, 'x -> 'a) padding *\n     ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n     ('x, 'b, 'c, 'e, 'f) padding_fmt_ebb\n\n(* GADT type associating a precision and an fmt. *)\n(* See make_precision_fmt_ebb and parse_format functions. *)\ntype ('a, 'b, 'c, 'e, 'f) precision_fmt_ebb = Precision_fmt_EBB :\n     (_, 'x -> 'a) precision *\n     ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n     ('x, 'b, 'c, 'e, 'f) precision_fmt_ebb\n\n(* GADT type associating a padding, a precision and an fmt. *)\n(* See make_padprec_fmt_ebb and parse_format functions. *)\ntype ('p, 'b, 'c, 'e, 'f) padprec_fmt_ebb = Padprec_fmt_EBB :\n     ('x, 'y) padding * ('y, 'p -> 'a) precision *\n     ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n     ('p, 'b, 'c, 'e, 'f) padprec_fmt_ebb\n\n(* Abstract the 'a and 'd parameters of an fmt. *)\n(* Output type of the format parsing function. *)\ntype ('b, 'c, 'e, 'f) fmt_ebb = Fmt_EBB :\n     ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n     ('b, 'c, 'e, 'f) fmt_ebb\n\n(* GADT type associating an fmtty and an fmt. *)\n(* See the type_format_gen function. *)\ntype ('a, 'b, 'c, 'd, 'e, 'f) fmt_fmtty_ebb = Fmt_fmtty_EBB :\n     ('a, 'b, 'c, 'd, 'y, 'x) fmt *\n     ('x, 'b, 'c, 'y, 'e, 'f) fmtty ->\n     ('a, 'b, 'c, 'd, 'e, 'f) fmt_fmtty_ebb\n\n(* GADT type associating an fmtty and an fmt. *)\n(* See the type_ignored_format_substitution function. *)\ntype ('a, 'b, 'c, 'd, 'e, 'f) fmtty_fmt_ebb = Fmtty_fmt_EBB :\n     ('a, 'b, 'c, 'd, 'y, 'x) fmtty *\n     ('x, 'b, 'c, 'y, 'e, 'f) fmt_fmtty_ebb ->\n     ('a, 'b, 'c, 'd, 'e, 'f) fmtty_fmt_ebb\n\n(* Abstract all fmtty type parameters. *)\n(* Used to compare format types. *)\ntype fmtty_ebb = Fmtty_EBB : ('a, 'b, 'c, 'd, 'e, 'f) fmtty -> fmtty_ebb\n\n(* Abstract all padding type parameters. *)\n(* Used to compare paddings. *)\ntype padding_ebb = Padding_EBB : ('a, 'b) padding -> padding_ebb\n\n(* Abstract all precision type parameters. *)\n(* Used to compare precisions. *)\ntype precision_ebb = Precision_EBB : ('a, 'b) precision -> precision_ebb\n\n(******************************************************************************)\n                               (* Constants *)\n\n(* Default precision for float printing. *)\nlet default_float_precision fconv =\n  match snd fconv with\n  | Float_f | Float_e | Float_E | Float_g | Float_G | Float_h | Float_H\n  | Float_CF -> -6\n  (* For %h %H and %#F formats, a negative precision means \"as many digits as\n     necessary\".  For the other FP formats, we take the absolute value\n     of the precision, hence 6 digits by default. *)\n  | Float_F -> 12\n  (* Default precision for OCaml float printing (%F). *)\n\n(******************************************************************************)\n                               (* Externals *)\n\nexternal format_float: string -> float -> string\n  = \"caml_format_float\"\nexternal format_int: string -> int -> string\n  = \"caml_format_int\"\nexternal format_int32: string -> int32 -> string\n  = \"caml_int32_format\"\nexternal format_nativeint: string -> nativeint -> string\n  = \"caml_nativeint_format\"\nexternal format_int64: string -> int64 -> string\n  = \"caml_int64_format\"\nexternal hexstring_of_float: float -> int -> char -> string\n  = \"caml_hexstring_of_float\"\n\n(******************************************************************************)\n                     (* Tools to pretty-print formats *)\n\n(* Type of extensible character buffers. *)\ntype buffer = {\n  mutable ind : int;\n  mutable bytes : bytes;\n}\n\n(* Create a fresh buffer. *)\nlet buffer_create init_size = { ind = 0; bytes = Bytes.create init_size }\n\n(* Check size of the buffer and grow it if needed. *)\nlet buffer_check_size buf overhead =\n  let len = Bytes.length buf.bytes in\n  let min_len = buf.ind + overhead in\n  if min_len > len then (\n    let new_len = Int.max (len * 2) min_len in\n    let new_str = Bytes.create new_len in\n    Bytes.blit buf.bytes 0 new_str 0 len;\n    buf.bytes <- new_str;\n  )\n\n(* Add the character `c' to the buffer `buf'. *)\nlet buffer_add_char buf c =\n  buffer_check_size buf 1;\n  Bytes.set buf.bytes buf.ind c;\n  buf.ind <- buf.ind + 1\n\n(* Add the string `s' to the buffer `buf'. *)\nlet buffer_add_string buf s =\n  let str_len = String.length s in\n  buffer_check_size buf str_len;\n  String.blit s 0 buf.bytes buf.ind str_len;\n  buf.ind <- buf.ind + str_len\n\n(* Get the content of the buffer. *)\nlet buffer_contents buf =\n  Bytes.sub_string buf.bytes 0 buf.ind\n\n(***)\n\n(* Convert an integer conversion to char. *)\nlet char_of_iconv iconv = match iconv with\n  | Int_d | Int_pd | Int_sd | Int_Cd -> 'd' | Int_i | Int_pi | Int_si\n  | Int_Ci -> 'i' | Int_x | Int_Cx -> 'x' | Int_X | Int_CX -> 'X' | Int_o\n  | Int_Co -> 'o' | Int_u | Int_Cu -> 'u'\n\n(* Convert a float conversion to char. *)\n(* `cF' will be 'F' for displaying format and 'g' to call libc printf *)\nlet char_of_fconv ?(cF='F') fconv = match snd fconv with\n  | Float_f -> 'f' | Float_e -> 'e'\n  | Float_E -> 'E' | Float_g -> 'g'\n  | Float_G -> 'G' | Float_F -> cF\n  | Float_h -> 'h' | Float_H -> 'H'\n  | Float_CF -> 'F'\n\n\n(* Convert a scanning counter to char. *)\nlet char_of_counter counter = match counter with\n  | Line_counter  -> 'l'\n  | Char_counter  -> 'n'\n  | Token_counter -> 'N'\n\n(***)\n\n(* Print a char_set in a buffer with the OCaml format lexical convention. *)\nlet bprint_char_set buf char_set =\n  let rec print_start set =\n    let is_alone c =\n      let before, after = Char.(chr (code c - 1), chr (code c + 1)) in\n      is_in_char_set set c\n      && not (is_in_char_set set before && is_in_char_set set after) in\n    if is_alone ']' then buffer_add_char buf ']';\n    print_out set 1;\n    if is_alone '-' then buffer_add_char buf '-';\n  and print_out set i =\n    if i < 256 then\n      if is_in_char_set set (char_of_int i) then print_first set i\n      else print_out set (i + 1)\n  and print_first set i =\n    match char_of_int i with\n    | '\\255' -> print_char buf 255;\n    | ']' | '-' -> print_out set (i + 1);\n    | _ -> print_second set (i + 1);\n  and print_second set i =\n    if is_in_char_set set (char_of_int i) then\n      match char_of_int i with\n      | '\\255' ->\n        print_char buf 254;\n        print_char buf 255;\n      | ']' | '-' when not (is_in_char_set set (char_of_int (i + 1))) ->\n        print_char buf (i - 1);\n        print_out set (i + 1);\n      | _ when not (is_in_char_set set (char_of_int (i + 1))) ->\n        print_char buf (i - 1);\n        print_char buf i;\n        print_out set (i + 2);\n      | _ ->\n        print_in set (i - 1) (i + 2);\n    else (\n      print_char buf (i - 1);\n      print_out set (i + 1);\n    )\n  and print_in set i j =\n    if j = 256 || not (is_in_char_set set (char_of_int j)) then (\n      print_char buf i;\n      print_char buf (int_of_char '-');\n      print_char buf (j - 1);\n      if j < 256 then print_out set (j + 1);\n    ) else\n      print_in set i (j + 1);\n  and print_char buf i = match char_of_int i with\n    | '%' -> buffer_add_char buf '%'; buffer_add_char buf '%';\n    | '@' -> buffer_add_char buf '%'; buffer_add_char buf '@';\n    | c   -> buffer_add_char buf c;\n  in\n  buffer_add_char buf '[';\n  print_start (\n    if is_in_char_set char_set '\\000'\n    then ( buffer_add_char buf '^'; rev_char_set char_set )\n    else char_set\n  );\n  buffer_add_char buf ']'\n\n(***)\n\n(* Print a padty in a buffer with the format-like syntax. *)\nlet bprint_padty buf padty = match padty with\n  | Left  -> buffer_add_char buf '-'\n  | Right -> ()\n  | Zeros -> buffer_add_char buf '0'\n\n(* Print the '_' of an ignored flag if needed. *)\nlet bprint_ignored_flag buf ign_flag =\n  if ign_flag then buffer_add_char buf '_'\n\n(***)\n\nlet bprint_pad_opt buf pad_opt = match pad_opt with\n  | None -> ()\n  | Some width -> buffer_add_string buf (Int.to_string width)\n\n(***)\n\n(* Print padding in a buffer with the format-like syntax. *)\nlet bprint_padding : type a b . buffer -> (a, b) padding -> unit =\nfun buf pad -> match pad with\n  | No_padding -> ()\n  | Lit_padding (padty, n) ->\n    bprint_padty buf padty;\n    buffer_add_string buf (Int.to_string n);\n  | Arg_padding padty ->\n    bprint_padty buf padty;\n    buffer_add_char buf '*'\n\n(* Print precision in a buffer with the format-like syntax. *)\nlet bprint_precision : type a b . buffer -> (a, b) precision -> unit =\n  fun buf prec -> match prec with\n  | No_precision -> ()\n  | Lit_precision n ->\n    buffer_add_char buf '.';\n    buffer_add_string buf (Int.to_string n);\n  | Arg_precision ->\n    buffer_add_string buf \".*\"\n\n(***)\n\n(* Print the optional '+', ' ' or '#' associated to an int conversion. *)\nlet bprint_iconv_flag buf iconv = match iconv with\n  | Int_pd | Int_pi -> buffer_add_char buf '+'\n  | Int_sd | Int_si -> buffer_add_char buf ' '\n  | Int_Cx | Int_CX | Int_Co | Int_Cd | Int_Ci | Int_Cu ->\n      buffer_add_char buf '#'\n  | Int_d | Int_i | Int_x | Int_X | Int_o | Int_u -> ()\n\n(* Print an complete int format in a buffer (ex: \"%3.*d\"). *)\nlet bprint_int_fmt buf ign_flag iconv pad prec =\n  buffer_add_char buf '%';\n  bprint_ignored_flag buf ign_flag;\n  bprint_iconv_flag buf iconv;\n  bprint_padding buf pad;\n  bprint_precision buf prec;\n  buffer_add_char buf (char_of_iconv iconv)\n\n(* Print a complete int32, nativeint or int64 format in a buffer. *)\nlet bprint_altint_fmt buf ign_flag iconv pad prec c =\n  buffer_add_char buf '%';\n  bprint_ignored_flag buf ign_flag;\n  bprint_iconv_flag buf iconv;\n  bprint_padding buf pad;\n  bprint_precision buf prec;\n  buffer_add_char buf c;\n  buffer_add_char buf (char_of_iconv iconv)\n\n(***)\n\n(* Print the optional '+', ' ' and/or '#' associated to a float conversion. *)\nlet bprint_fconv_flag buf fconv =\n  begin match fst fconv with\n  | Float_flag_p -> buffer_add_char buf '+'\n  | Float_flag_s -> buffer_add_char buf ' '\n  | Float_flag_ -> () end;\n  match snd fconv with\n  | Float_CF -> buffer_add_char buf '#'\n  | Float_f | Float_e | Float_E | Float_g | Float_G\n  | Float_F | Float_h | Float_H -> ()\n\n(* Print a complete float format in a buffer (ex: \"%+*.3f\"). *)\nlet bprint_float_fmt buf ign_flag fconv pad prec =\n  buffer_add_char buf '%';\n  bprint_ignored_flag buf ign_flag;\n  bprint_fconv_flag buf fconv;\n  bprint_padding buf pad;\n  bprint_precision buf prec;\n  buffer_add_char buf (char_of_fconv fconv)\n\n(* Compute the literal string representation of a Formatting_lit. *)\n(* Used by Printf and Scanf where formatting is not interpreted. *)\nlet string_of_formatting_lit formatting_lit = match formatting_lit with\n  | Close_box            -> \"@]\"\n  | Close_tag            -> \"@}\"\n  | Break (str, _, _)    -> str\n  | FFlush               -> \"@?\"\n  | Force_newline        -> \"@\\n\"\n  | Flush_newline        -> \"@.\"\n  | Magic_size (str, _)  -> str\n  | Escaped_at           -> \"@@\"\n  | Escaped_percent      -> \"@%\"\n  | Scan_indic c -> \"@\" ^ (String.make 1 c)\n\n(***)\n\n(* Print a literal char in a buffer, escape '%' by \"%%\". *)\nlet bprint_char_literal buf chr = match chr with\n  | '%' -> buffer_add_string buf \"%%\"\n  | _ -> buffer_add_char buf chr\n\n(* Print a literal string in a buffer, escape all '%' by \"%%\". *)\nlet bprint_string_literal buf str =\n  for i = 0 to String.length str - 1 do\n    bprint_char_literal buf str.[i]\n  done\n\n(******************************************************************************)\n                          (* Format pretty-printing *)\n\n(* Print a complete format type (an fmtty) in a buffer. *)\nlet rec bprint_fmtty : type a b c d e f g h i j k l .\n    buffer -> (a, b, c, d, e, f, g, h, i, j, k, l) fmtty_rel -> unit =\nfun buf fmtty -> match fmtty with\n  | Char_ty rest      -> buffer_add_string buf \"%c\";  bprint_fmtty buf rest;\n  | String_ty rest    -> buffer_add_string buf \"%s\";  bprint_fmtty buf rest;\n  | Int_ty rest       -> buffer_add_string buf \"%i\";  bprint_fmtty buf rest;\n  | Int32_ty rest     -> buffer_add_string buf \"%li\"; bprint_fmtty buf rest;\n  | Nativeint_ty rest -> buffer_add_string buf \"%ni\"; bprint_fmtty buf rest;\n  | Int64_ty rest     -> buffer_add_string buf \"%Li\"; bprint_fmtty buf rest;\n  | Float_ty rest     -> buffer_add_string buf \"%f\";  bprint_fmtty buf rest;\n  | Bool_ty rest      -> buffer_add_string buf \"%B\";  bprint_fmtty buf rest;\n  | Alpha_ty rest     -> buffer_add_string buf \"%a\";  bprint_fmtty buf rest;\n  | Theta_ty rest     -> buffer_add_string buf \"%t\";  bprint_fmtty buf rest;\n  | Any_ty rest       -> buffer_add_string buf \"%?\";  bprint_fmtty buf rest;\n  | Reader_ty rest    -> buffer_add_string buf \"%r\";  bprint_fmtty buf rest;\n\n  | Ignored_reader_ty rest ->\n    buffer_add_string buf \"%_r\";\n    bprint_fmtty buf rest;\n\n  | Format_arg_ty (sub_fmtty, rest) ->\n    buffer_add_string buf \"%{\"; bprint_fmtty buf sub_fmtty;\n    buffer_add_string buf \"%}\"; bprint_fmtty buf rest;\n  | Format_subst_ty (sub_fmtty, _, rest) ->\n    buffer_add_string buf \"%(\"; bprint_fmtty buf sub_fmtty;\n    buffer_add_string buf \"%)\"; bprint_fmtty buf rest;\n\n  | End_of_fmtty -> ()\n\n(***)\n\nlet rec int_of_custom_arity : type a b c .\n  (a, b, c) custom_arity -> int =\n  function\n  | Custom_zero -> 0\n  | Custom_succ x -> 1 + int_of_custom_arity x\n\n(* Print a complete format in a buffer. *)\nlet bprint_fmt buf fmt =\n  let rec fmtiter : type a b c d e f .\n      (a, b, c, d, e, f) fmt -> bool -> unit =\n  fun fmt ign_flag -> match fmt with\n    | String (pad, rest) ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      bprint_padding buf pad; buffer_add_char buf 's';\n      fmtiter rest false;\n    | Caml_string (pad, rest) ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      bprint_padding buf pad; buffer_add_char buf 'S';\n      fmtiter rest false;\n\n    | Int (iconv, pad, prec, rest) ->\n      bprint_int_fmt buf ign_flag iconv pad prec;\n      fmtiter rest false;\n    | Int32 (iconv, pad, prec, rest) ->\n      bprint_altint_fmt buf ign_flag iconv pad prec 'l';\n      fmtiter rest false;\n    | Nativeint (iconv, pad, prec, rest) ->\n      bprint_altint_fmt buf ign_flag iconv pad prec 'n';\n      fmtiter rest false;\n    | Int64 (iconv, pad, prec, rest) ->\n      bprint_altint_fmt buf ign_flag iconv pad prec 'L';\n      fmtiter rest false;\n    | Float (fconv, pad, prec, rest) ->\n      bprint_float_fmt buf ign_flag fconv pad prec;\n      fmtiter rest false;\n\n    | Char rest ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      buffer_add_char buf 'c'; fmtiter rest false;\n    | Caml_char rest ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      buffer_add_char buf 'C'; fmtiter rest false;\n    | Bool (pad, rest) ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      bprint_padding buf pad; buffer_add_char buf 'B';\n      fmtiter rest false;\n    | Alpha rest ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      buffer_add_char buf 'a'; fmtiter rest false;\n    | Theta rest ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      buffer_add_char buf 't'; fmtiter rest false;\n    | Custom (arity, _, rest) ->\n      for _i = 1 to int_of_custom_arity arity do\n        buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n        buffer_add_char buf '?';\n      done;\n      fmtiter rest false;\n    | Reader rest ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      buffer_add_char buf 'r'; fmtiter rest false;\n    | Flush rest ->\n      buffer_add_string buf \"%!\";\n      fmtiter rest ign_flag;\n\n    | String_literal (str, rest) ->\n      bprint_string_literal buf str;\n      fmtiter rest ign_flag;\n    | Char_literal (chr, rest) ->\n      bprint_char_literal buf chr;\n      fmtiter rest ign_flag;\n\n    | Format_arg (pad_opt, fmtty, rest) ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      bprint_pad_opt buf pad_opt; buffer_add_char buf '{';\n      bprint_fmtty buf fmtty; buffer_add_char buf '%'; buffer_add_char buf '}';\n      fmtiter rest false;\n    | Format_subst (pad_opt, fmtty, rest) ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      bprint_pad_opt buf pad_opt; buffer_add_char buf '(';\n      bprint_fmtty buf fmtty; buffer_add_char buf '%'; buffer_add_char buf ')';\n      fmtiter rest false;\n\n    | Scan_char_set (width_opt, char_set, rest) ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      bprint_pad_opt buf width_opt; bprint_char_set buf char_set;\n      fmtiter rest false;\n    | Scan_get_counter (counter, rest) ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      buffer_add_char buf (char_of_counter counter);\n      fmtiter rest false;\n    | Scan_next_char rest ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      bprint_string_literal buf \"0c\"; fmtiter rest false;\n\n    | Ignored_param (ign, rest) ->\n      let Param_format_EBB fmt' = param_format_of_ignored_format ign rest in\n      fmtiter fmt' true;\n\n    | Formatting_lit (fmting_lit, rest) ->\n      bprint_string_literal buf (string_of_formatting_lit fmting_lit);\n      fmtiter rest ign_flag;\n    | Formatting_gen (fmting_gen, rest) ->\n      begin match fmting_gen with\n      | Open_tag (Format (_, str)) ->\n        buffer_add_string buf \"@{\"; buffer_add_string buf str\n      | Open_box (Format (_, str)) ->\n        buffer_add_string buf \"@[\"; buffer_add_string buf str\n      end;\n      fmtiter rest ign_flag;\n\n    | End_of_format -> ()\n\n  in fmtiter fmt false\n\n(***)\n\n(* Convert a format to string. *)\nlet string_of_fmt fmt =\n  let buf = buffer_create 16 in\n  bprint_fmt buf fmt;\n  buffer_contents buf\n\n(******************************************************************************)\n                          (* Type extraction *)\n\ntype (_, _) eq = Refl : ('a, 'a) eq\n\n(* Invariant: this function is the identity on values.\n\n   In particular, if (ty1, ty2) have equal values, then\n   (trans (symm ty1) ty2) respects the 'trans' precondition. *)\nlet rec symm : type a1 b1 c1 d1 e1 f1 a2 b2 c2 d2 e2 f2 .\n   (a1, b1, c1, d1, e1, f1,\n    a2, b2, c2, d2, e2, f2) fmtty_rel\n-> (a2, b2, c2, d2, e2, f2,\n    a1, b1, c1, d1, e1, f1) fmtty_rel\n= function\n  | Char_ty rest -> Char_ty (symm rest)\n  | Int_ty rest -> Int_ty (symm rest)\n  | Int32_ty rest -> Int32_ty (symm rest)\n  | Int64_ty rest -> Int64_ty (symm rest)\n  | Nativeint_ty rest -> Nativeint_ty (symm rest)\n  | Float_ty rest -> Float_ty (symm rest)\n  | Bool_ty rest -> Bool_ty (symm rest)\n  | String_ty rest -> String_ty (symm rest)\n  | Theta_ty rest -> Theta_ty (symm rest)\n  | Alpha_ty rest -> Alpha_ty (symm rest)\n  | Any_ty rest -> Any_ty (symm rest)\n  | Reader_ty rest -> Reader_ty (symm rest)\n  | Ignored_reader_ty rest -> Ignored_reader_ty (symm rest)\n  | Format_arg_ty (ty, rest) ->\n    Format_arg_ty (ty, symm rest)\n  | Format_subst_ty (ty1, ty2, rest) ->\n    Format_subst_ty (ty2, ty1, symm rest)\n  | End_of_fmtty -> End_of_fmtty\n\nlet rec fmtty_rel_det : type a1 b c d1 e1 f1 a2 d2 e2 f2 .\n  (a1, b, c, d1, e1, f1,\n   a2, b, c, d2, e2, f2) fmtty_rel ->\n    ((f1, f2) eq -> (a1, a2) eq)\n  * ((a1, a2) eq -> (f1, f2) eq)\n  * ((e1, e2) eq -> (d1, d2) eq)\n  * ((d1, d2) eq -> (e1, e2) eq)\n= function\n  | End_of_fmtty ->\n    (fun Refl -> Refl),\n    (fun Refl -> Refl),\n    (fun Refl -> Refl),\n    (fun Refl -> Refl)\n  | Char_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | String_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Int_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Int32_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Int64_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Nativeint_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Float_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Bool_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n\n  | Theta_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Alpha_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Any_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Reader_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    (fun Refl -> let Refl = ed Refl in Refl),\n    (fun Refl -> let Refl = de Refl in Refl)\n  | Ignored_reader_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    (fun Refl -> let Refl = ed Refl in Refl),\n    (fun Refl -> let Refl = de Refl in Refl)\n  | Format_arg_ty (_ty, rest) ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Format_subst_ty (ty1, ty2, rest) ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    let ty = trans (symm ty1) ty2 in\n    let ag, ga, dj, jd = fmtty_rel_det ty in\n    (fun Refl -> let Refl = fa Refl in let Refl = ag Refl in Refl),\n    (fun Refl -> let Refl = ga Refl in let Refl = af Refl in Refl),\n    (fun Refl -> let Refl = ed Refl in let Refl = dj Refl in Refl),\n    (fun Refl -> let Refl = jd Refl in let Refl = de Refl in Refl)\n\n(* Precondition: we assume that the two fmtty_rel arguments have equal\n   values (at possibly distinct types); this invariant comes from the way\n   fmtty_rel witnesses are produced by the type-checker\n\n   The code below uses (assert false) when this assumption is broken. The\n   code pattern is the following:\n\n     | Foo x, Foo y ->\n       (* case where indeed both values\n          start with constructor Foo *)\n     | Foo _, _\n     | _, Foo _ ->\n       (* different head constructors: broken precondition *)\n       assert false\n*)\nand trans : type\n  a1 b1 c1 d1 e1 f1\n  a2 b2 c2 d2 e2 f2\n  a3 b3 c3 d3 e3 f3\n.\n   (a1, b1, c1, d1, e1, f1,\n    a2, b2, c2, d2, e2, f2) fmtty_rel\n-> (a2, b2, c2, d2, e2, f2,\n    a3, b3, c3, d3, e3, f3) fmtty_rel\n-> (a1, b1, c1, d1, e1, f1,\n    a3, b3, c3, d3, e3, f3) fmtty_rel\n= fun ty1 ty2 -> match ty1, ty2 with\n  | Char_ty rest1, Char_ty rest2 -> Char_ty (trans rest1 rest2)\n  | String_ty rest1, String_ty rest2 -> String_ty (trans rest1 rest2)\n  | Bool_ty rest1, Bool_ty rest2 -> Bool_ty (trans rest1 rest2)\n  | Int_ty rest1, Int_ty rest2 -> Int_ty (trans rest1 rest2)\n  | Int32_ty rest1, Int32_ty rest2 -> Int32_ty (trans rest1 rest2)\n  | Int64_ty rest1, Int64_ty rest2 -> Int64_ty (trans rest1 rest2)\n  | Nativeint_ty rest1, Nativeint_ty rest2 -> Nativeint_ty (trans rest1 rest2)\n  | Float_ty rest1, Float_ty rest2 -> Float_ty (trans rest1 rest2)\n\n  | Alpha_ty rest1, Alpha_ty rest2 -> Alpha_ty (trans rest1 rest2)\n  | Alpha_ty _, _ -> assert false\n  | _, Alpha_ty _ -> assert false\n\n  | Theta_ty rest1, Theta_ty rest2 -> Theta_ty (trans rest1 rest2)\n  | Theta_ty _, _ -> assert false\n  | _, Theta_ty _ -> assert false\n\n  | Any_ty rest1, Any_ty rest2 -> Any_ty (trans rest1 rest2)\n  | Any_ty _, _ -> assert false\n  | _, Any_ty _ -> assert false\n\n  | Reader_ty rest1, Reader_ty rest2 -> Reader_ty (trans rest1 rest2)\n  | Reader_ty _, _ -> assert false\n  | _, Reader_ty _ -> assert false\n\n  | Ignored_reader_ty rest1, Ignored_reader_ty rest2 ->\n    Ignored_reader_ty (trans rest1 rest2)\n  | Ignored_reader_ty _, _ -> assert false\n  | _, Ignored_reader_ty _ -> assert false\n\n  | Format_arg_ty (ty1, rest1), Format_arg_ty (ty2, rest2) ->\n    Format_arg_ty (trans ty1 ty2, trans rest1 rest2)\n  | Format_arg_ty _, _ -> assert false\n  | _, Format_arg_ty _ -> assert false\n\n  | Format_subst_ty (ty11, ty12, rest1),\n    Format_subst_ty (ty21, ty22, rest2) ->\n    let ty = trans (symm ty12) ty21 in\n    let _, f2, _, f4 = fmtty_rel_det ty in\n    let Refl = f2 Refl in\n    let Refl = f4 Refl in\n    Format_subst_ty (ty11, ty22, trans rest1 rest2)\n  | Format_subst_ty _, _ -> assert false\n  | _, Format_subst_ty _ -> assert false\n\n  | End_of_fmtty, End_of_fmtty -> End_of_fmtty\n  | End_of_fmtty, _ -> assert false\n  | _, End_of_fmtty -> assert false\n\nlet rec fmtty_of_formatting_gen : type a b c d e f .\n  (a, b, c, d, e, f) formatting_gen ->\n    (a, b, c, d, e, f) fmtty =\nfun formatting_gen -> match formatting_gen with\n  | Open_tag (Format (fmt, _)) -> fmtty_of_fmt fmt\n  | Open_box (Format (fmt, _)) -> fmtty_of_fmt fmt\n\n(* Extract the type representation (an fmtty) of a format. *)\nand fmtty_of_fmt : type a b c d e f .\n  (a, b, c, d, e, f) fmt -> (a, b, c, d, e, f) fmtty =\nfun fmtty -> match fmtty with\n  | String (pad, rest) ->\n    fmtty_of_padding_fmtty pad (String_ty (fmtty_of_fmt rest))\n  | Caml_string (pad, rest) ->\n    fmtty_of_padding_fmtty pad (String_ty (fmtty_of_fmt rest))\n\n  | Int (_, pad, prec, rest) ->\n    let ty_rest = fmtty_of_fmt rest in\n    let prec_ty = fmtty_of_precision_fmtty prec (Int_ty ty_rest) in\n    fmtty_of_padding_fmtty pad prec_ty\n  | Int32 (_, pad, prec, rest) ->\n    let ty_rest = fmtty_of_fmt rest in\n    let prec_ty = fmtty_of_precision_fmtty prec (Int32_ty ty_rest) in\n    fmtty_of_padding_fmtty pad prec_ty\n  | Nativeint (_, pad, prec, rest) ->\n    let ty_rest = fmtty_of_fmt rest in\n    let prec_ty = fmtty_of_precision_fmtty prec (Nativeint_ty ty_rest) in\n    fmtty_of_padding_fmtty pad prec_ty\n  | Int64 (_, pad, prec, rest) ->\n    let ty_rest = fmtty_of_fmt rest in\n    let prec_ty = fmtty_of_precision_fmtty prec (Int64_ty ty_rest) in\n    fmtty_of_padding_fmtty pad prec_ty\n  | Float (_, pad, prec, rest) ->\n    let ty_rest = fmtty_of_fmt rest in\n    let prec_ty = fmtty_of_precision_fmtty prec (Float_ty ty_rest) in\n    fmtty_of_padding_fmtty pad prec_ty\n\n  | Char rest                  -> Char_ty (fmtty_of_fmt rest)\n  | Caml_char rest             -> Char_ty (fmtty_of_fmt rest)\n  | Bool (pad, rest)           ->\n      fmtty_of_padding_fmtty pad (Bool_ty (fmtty_of_fmt rest))\n  | Alpha rest                 -> Alpha_ty (fmtty_of_fmt rest)\n  | Theta rest                 -> Theta_ty (fmtty_of_fmt rest)\n  | Custom (arity, _, rest)    -> fmtty_of_custom arity (fmtty_of_fmt rest)\n  | Reader rest                -> Reader_ty (fmtty_of_fmt rest)\n\n  | Format_arg (_, ty, rest) ->\n    Format_arg_ty (ty, fmtty_of_fmt rest)\n  | Format_subst (_, ty, rest) ->\n    Format_subst_ty (ty, ty, fmtty_of_fmt rest)\n\n  | Flush rest                 -> fmtty_of_fmt rest\n  | String_literal (_, rest)   -> fmtty_of_fmt rest\n  | Char_literal (_, rest)     -> fmtty_of_fmt rest\n\n  | Scan_char_set (_, _, rest) -> String_ty (fmtty_of_fmt rest)\n  | Scan_get_counter (_, rest) -> Int_ty (fmtty_of_fmt rest)\n  | Scan_next_char rest        -> Char_ty (fmtty_of_fmt rest)\n  | Ignored_param (ign, rest)  -> fmtty_of_ignored_format ign rest\n  | Formatting_lit (_, rest)   -> fmtty_of_fmt rest\n  | Formatting_gen (fmting_gen, rest)  ->\n    concat_fmtty (fmtty_of_formatting_gen fmting_gen) (fmtty_of_fmt rest)\n\n  | End_of_format              -> End_of_fmtty\n\nand fmtty_of_custom : type x y a b c d e f .\n  (a, x, y) custom_arity -> (a, b, c, d, e, f) fmtty ->\n  (y, b, c, d, e, f) fmtty =\nfun arity fmtty -> match arity with\n  | Custom_zero -> fmtty\n  | Custom_succ arity -> Any_ty (fmtty_of_custom arity fmtty)\n\n(* Extract the fmtty of an ignored parameter followed by the rest of\n   the format. *)\nand fmtty_of_ignored_format : type x y a b c d e f .\n    (a, b, c, d, y, x) ignored ->\n    (x, b, c, y, e, f) fmt ->\n    (a, b, c, d, e, f) fmtty =\nfun ign fmt -> match ign with\n  | Ignored_char                    -> fmtty_of_fmt fmt\n  | Ignored_caml_char               -> fmtty_of_fmt fmt\n  | Ignored_string _                -> fmtty_of_fmt fmt\n  | Ignored_caml_string _           -> fmtty_of_fmt fmt\n  | Ignored_int (_, _)              -> fmtty_of_fmt fmt\n  | Ignored_int32 (_, _)            -> fmtty_of_fmt fmt\n  | Ignored_nativeint (_, _)        -> fmtty_of_fmt fmt\n  | Ignored_int64 (_, _)            -> fmtty_of_fmt fmt\n  | Ignored_float (_, _)            -> fmtty_of_fmt fmt\n  | Ignored_bool _                  -> fmtty_of_fmt fmt\n  | Ignored_format_arg _            -> fmtty_of_fmt fmt\n  | Ignored_format_subst (_, fmtty) -> concat_fmtty fmtty (fmtty_of_fmt fmt)\n  | Ignored_reader                  -> Ignored_reader_ty (fmtty_of_fmt fmt)\n  | Ignored_scan_char_set _         -> fmtty_of_fmt fmt\n  | Ignored_scan_get_counter _      -> fmtty_of_fmt fmt\n  | Ignored_scan_next_char          -> fmtty_of_fmt fmt\n\n(* Add an Int_ty node if padding is taken as an extra argument (ex: \"%*s\"). *)\nand fmtty_of_padding_fmtty : type x a b c d e f .\n    (x, a) padding -> (a, b, c, d, e, f) fmtty -> (x, b, c, d, e, f) fmtty =\n  fun pad fmtty -> match pad with\n    | No_padding    -> fmtty\n    | Lit_padding _ -> fmtty\n    | Arg_padding _ -> Int_ty fmtty\n\n(* Add an Int_ty node if precision is taken as an extra argument (ex: \"%.*f\").*)\nand fmtty_of_precision_fmtty : type x a b c d e f .\n    (x, a) precision -> (a, b, c, d, e, f) fmtty -> (x, b, c, d, e, f) fmtty =\n  fun prec fmtty -> match prec with\n    | No_precision    -> fmtty\n    | Lit_precision _ -> fmtty\n    | Arg_precision   -> Int_ty fmtty\n\n(******************************************************************************)\n                            (* Format typing *)\n\n(* Exception raised when a format does not match a given format type. *)\nexception Type_mismatch\n\n(* Type a padding. *)\n(* Take an Int_ty from the fmtty if the integer should be kept as argument. *)\n(* Raise Type_mismatch in case of type mismatch. *)\nlet type_padding : type a b c d e f x y .\n    (x, y) padding -> (a, b, c, d, e, f) fmtty ->\n      (a, b, c, d, e, f) padding_fmtty_ebb =\nfun pad fmtty -> match pad, fmtty with\n  | No_padding, _ -> Padding_fmtty_EBB (No_padding, fmtty)\n  | Lit_padding (padty, w), _ -> Padding_fmtty_EBB (Lit_padding (padty,w),fmtty)\n  | Arg_padding padty, Int_ty rest -> Padding_fmtty_EBB (Arg_padding padty,rest)\n  | _ -> raise Type_mismatch\n\n(* Convert a (upadding, uprecision) to a (padding, precision). *)\n(* Take one or two Int_ty from the fmtty if needed. *)\n(* Raise Type_mismatch in case of type mismatch. *)\nlet type_padprec : type a b c d e f x y z .\n  (x, y) padding -> (y, z) precision -> (a, b, c, d, e, f) fmtty ->\n    (a, b, c, d, e, f) padprec_fmtty_ebb =\nfun pad prec fmtty -> match prec, type_padding pad fmtty with\n  | No_precision, Padding_fmtty_EBB (pad, rest) ->\n    Padprec_fmtty_EBB (pad, No_precision, rest)\n  | Lit_precision p, Padding_fmtty_EBB (pad, rest) ->\n    Padprec_fmtty_EBB (pad, Lit_precision p, rest)\n  | Arg_precision, Padding_fmtty_EBB (pad, Int_ty rest) ->\n    Padprec_fmtty_EBB (pad, Arg_precision, rest)\n  | _, Padding_fmtty_EBB (_, _) -> raise Type_mismatch\n\n(* Type a format according to an fmtty. *)\n(* If typing succeed, generate a copy of the format with the same\n    type parameters as the fmtty. *)\n(* Raise [Failure] with an error message in case of type mismatch. *)\nlet rec type_format :\n  type a1 b1 c1 d1 e1 f1\n       a2 b2 c2 d2 e2 f2  .\n     (a1, b1, c1, d1, e1, f1) fmt\n  -> (a2, b2, c2, d2, e2, f2) fmtty\n  -> (a2, b2, c2, d2, e2, f2) fmt\n= fun fmt fmtty -> match type_format_gen fmt fmtty with\n  | Fmt_fmtty_EBB (fmt', End_of_fmtty) -> fmt'\n  | _ -> raise Type_mismatch\n\nand type_format_gen :\n  type a1 b1 c1 d1 e1 f1\n       a2 b2 c2 d2 e2 f2  .\n     (a1, b1, c1, d1, e1, f1) fmt\n  -> (a2, b2, c2, d2, e2, f2) fmtty\n  -> (a2, b2, c2, d2, e2, f2) fmt_fmtty_ebb\n= fun fmt fmtty -> match fmt, fmtty with\n  | Char fmt_rest, Char_ty fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Char fmt', fmtty')\n  | Caml_char fmt_rest, Char_ty fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Caml_char fmt', fmtty')\n  | String (pad, fmt_rest), _ -> (\n    match type_padding pad fmtty with\n    | Padding_fmtty_EBB (pad, String_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (String (pad, fmt'), fmtty')\n    | Padding_fmtty_EBB (_, _) -> raise Type_mismatch\n  )\n  | Caml_string (pad, fmt_rest), _ -> (\n    match type_padding pad fmtty with\n    | Padding_fmtty_EBB (pad, String_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (Caml_string (pad, fmt'), fmtty')\n    | Padding_fmtty_EBB (_, _) -> raise Type_mismatch\n  )\n  | Int (iconv, pad, prec, fmt_rest), _ -> (\n    match type_padprec pad prec fmtty with\n    | Padprec_fmtty_EBB (pad, prec, Int_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (Int (iconv, pad, prec, fmt'), fmtty')\n    | Padprec_fmtty_EBB (_, _, _) -> raise Type_mismatch\n  )\n  | Int32 (iconv, pad, prec, fmt_rest), _ -> (\n    match type_padprec pad prec fmtty with\n    | Padprec_fmtty_EBB (pad, prec, Int32_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (Int32 (iconv, pad, prec, fmt'), fmtty')\n    | Padprec_fmtty_EBB (_, _, _) -> raise Type_mismatch\n  )\n  | Nativeint (iconv, pad, prec, fmt_rest), _ -> (\n    match type_padprec pad prec fmtty with\n    | Padprec_fmtty_EBB (pad, prec, Nativeint_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (Nativeint (iconv, pad, prec, fmt'), fmtty')\n    | Padprec_fmtty_EBB (_, _, _) -> raise Type_mismatch\n  )\n  | Int64 (iconv, pad, prec, fmt_rest), _ -> (\n    match type_padprec pad prec fmtty with\n    | Padprec_fmtty_EBB (pad, prec, Int64_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (Int64 (iconv, pad, prec, fmt'), fmtty')\n    | Padprec_fmtty_EBB (_, _, _) -> raise Type_mismatch\n  )\n  | Float (fconv, pad, prec, fmt_rest), _ -> (\n    match type_padprec pad prec fmtty with\n    | Padprec_fmtty_EBB (pad, prec, Float_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (Float (fconv, pad, prec, fmt'), fmtty')\n    | Padprec_fmtty_EBB (_, _, _) -> raise Type_mismatch\n  )\n  | Bool (pad, fmt_rest), _ -> (\n    match type_padding pad fmtty with\n    | Padding_fmtty_EBB (pad, Bool_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (Bool (pad, fmt'), fmtty')\n    | Padding_fmtty_EBB (_, _) -> raise Type_mismatch\n  )\n  | Flush fmt_rest, fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Flush fmt', fmtty')\n\n  | String_literal (str, fmt_rest), fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (String_literal (str, fmt'), fmtty')\n  | Char_literal (chr, fmt_rest), fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Char_literal (chr, fmt'), fmtty')\n\n  | Format_arg (pad_opt, sub_fmtty, fmt_rest),\n    Format_arg_ty (sub_fmtty', fmtty_rest) ->\n    if Fmtty_EBB sub_fmtty <> Fmtty_EBB sub_fmtty' then raise Type_mismatch;\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Format_arg (pad_opt, sub_fmtty', fmt'), fmtty')\n  | Format_subst (pad_opt, sub_fmtty, fmt_rest),\n    Format_subst_ty (sub_fmtty1, _sub_fmtty2, fmtty_rest) ->\n    if Fmtty_EBB (erase_rel sub_fmtty) <> Fmtty_EBB (erase_rel sub_fmtty1) then\n      raise Type_mismatch;\n    let Fmt_fmtty_EBB (fmt', fmtty') =\n      type_format_gen fmt_rest (erase_rel fmtty_rest)\n    in\n    Fmt_fmtty_EBB (Format_subst (pad_opt, sub_fmtty1, fmt'), fmtty')\n  (* Printf and Format specific constructors: *)\n  | Alpha fmt_rest, Alpha_ty fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Alpha fmt', fmtty')\n  | Theta fmt_rest, Theta_ty fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Theta fmt', fmtty')\n\n  (* Format specific constructors: *)\n  | Formatting_lit (formatting_lit, fmt_rest), fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Formatting_lit (formatting_lit, fmt'), fmtty')\n  | Formatting_gen (formatting_gen, fmt_rest), fmtty_rest ->\n    type_formatting_gen formatting_gen fmt_rest fmtty_rest\n\n  (* Scanf specific constructors: *)\n  | Reader fmt_rest, Reader_ty fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Reader fmt', fmtty')\n  | Scan_char_set (width_opt, char_set, fmt_rest), String_ty fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Scan_char_set (width_opt, char_set, fmt'), fmtty')\n  | Scan_get_counter (counter, fmt_rest), Int_ty fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Scan_get_counter (counter, fmt'), fmtty')\n  | Ignored_param (ign, rest), fmtty_rest ->\n    type_ignored_param ign rest fmtty_rest\n\n  | End_of_format, fmtty_rest -> Fmt_fmtty_EBB (End_of_format, fmtty_rest)\n\n  | _ -> raise Type_mismatch\n\nand type_formatting_gen : type a1 a3 b1 b3 c1 c3 d1 d3 e1 e2 e3 f1 f2 f3 .\n    (a1, b1, c1, d1, e1, f1) formatting_gen ->\n    (f1, b1, c1, e1, e2, f2) fmt ->\n    (a3, b3, c3, d3, e3, f3) fmtty ->\n    (a3, b3, c3, d3, e3, f3) fmt_fmtty_ebb =\nfun formatting_gen fmt0 fmtty0 -> match formatting_gen with\n  | Open_tag (Format (fmt1, str)) ->\n    let Fmt_fmtty_EBB (fmt2, fmtty2) = type_format_gen fmt1 fmtty0 in\n    let Fmt_fmtty_EBB (fmt3, fmtty3) = type_format_gen fmt0 fmtty2 in\n    Fmt_fmtty_EBB (Formatting_gen (Open_tag (Format (fmt2, str)), fmt3), fmtty3)\n  | Open_box (Format (fmt1, str)) ->\n    let Fmt_fmtty_EBB (fmt2, fmtty2) = type_format_gen fmt1 fmtty0 in\n    let Fmt_fmtty_EBB (fmt3, fmtty3) = type_format_gen fmt0 fmtty2 in\n    Fmt_fmtty_EBB (Formatting_gen (Open_box (Format (fmt2, str)), fmt3), fmtty3)\n\n(* Type an Ignored_param node according to an fmtty. *)\nand type_ignored_param : type p q x y z t u v a b c d e f .\n    (x, y, z, t, q, p) ignored ->\n    (p, y, z, q, u, v) fmt ->\n    (a, b, c, d, e, f) fmtty ->\n    (a, b, c, d, e, f) fmt_fmtty_ebb =\nfun ign fmt fmtty -> match ign with\n  | Ignored_char               as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_caml_char          as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_string _           as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_caml_string _      as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_int _              as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_int32 _            as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_nativeint _        as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_int64 _            as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_float _            as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_bool _             as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_scan_char_set _    as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_scan_get_counter _ as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_scan_next_char     as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_format_arg (pad_opt, sub_fmtty) ->\n    type_ignored_param_one (Ignored_format_arg (pad_opt, sub_fmtty)) fmt fmtty\n  | Ignored_format_subst (pad_opt, sub_fmtty) ->\n    let Fmtty_fmt_EBB (sub_fmtty', Fmt_fmtty_EBB (fmt', fmtty')) =\n      type_ignored_format_substitution sub_fmtty fmt fmtty in\n    Fmt_fmtty_EBB (Ignored_param (Ignored_format_subst (pad_opt, sub_fmtty'),\n                                  fmt'),\n                   fmtty')\n  | Ignored_reader -> (\n    match fmtty with\n    | Ignored_reader_ty fmtty_rest ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt fmtty_rest in\n      Fmt_fmtty_EBB (Ignored_param (Ignored_reader, fmt'), fmtty')\n    | _ -> raise Type_mismatch\n  )\n\nand type_ignored_param_one : type a1 a2 b1 b2 c1 c2 d1 d2 e1 e2 f1 f2 .\n    (a2, b2, c2, d2, d2, a2) ignored ->\n    (a1, b1, c1, d1, e1, f1) fmt ->\n    (a2, b2, c2, d2, e2, f2) fmtty ->\n    (a2, b2, c2, d2, e2, f2) fmt_fmtty_ebb\n= fun ign fmt fmtty ->\n  let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt fmtty in\n  Fmt_fmtty_EBB (Ignored_param (ign, fmt'), fmtty')\n\n(* Typing of the complex case: \"%_(...%)\". *)\nand type_ignored_format_substitution : type w x y z p s t u a b c d e f .\n    (w, x, y, z, s, p) fmtty ->\n    (p, x, y, s, t, u) fmt ->\n    (a, b, c, d, e, f) fmtty -> (a, b, c, d, e, f) fmtty_fmt_ebb =\nfun sub_fmtty fmt fmtty -> match sub_fmtty, fmtty with\n  | Char_ty sub_fmtty_rest, Char_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Char_ty sub_fmtty_rest', fmt')\n  | String_ty sub_fmtty_rest, String_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (String_ty sub_fmtty_rest', fmt')\n  | Int_ty sub_fmtty_rest, Int_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Int_ty sub_fmtty_rest', fmt')\n  | Int32_ty sub_fmtty_rest, Int32_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Int32_ty sub_fmtty_rest', fmt')\n  | Nativeint_ty sub_fmtty_rest, Nativeint_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Nativeint_ty sub_fmtty_rest', fmt')\n  | Int64_ty sub_fmtty_rest, Int64_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Int64_ty sub_fmtty_rest', fmt')\n  | Float_ty sub_fmtty_rest, Float_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Float_ty sub_fmtty_rest', fmt')\n  | Bool_ty sub_fmtty_rest, Bool_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Bool_ty sub_fmtty_rest', fmt')\n  | Alpha_ty sub_fmtty_rest, Alpha_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Alpha_ty sub_fmtty_rest', fmt')\n  | Theta_ty sub_fmtty_rest, Theta_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Theta_ty sub_fmtty_rest', fmt')\n  | Reader_ty sub_fmtty_rest, Reader_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Reader_ty sub_fmtty_rest', fmt')\n  | Ignored_reader_ty sub_fmtty_rest, Ignored_reader_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Ignored_reader_ty sub_fmtty_rest', fmt')\n\n  | Format_arg_ty (sub2_fmtty, sub_fmtty_rest),\n    Format_arg_ty (sub2_fmtty', fmtty_rest) ->\n    if Fmtty_EBB sub2_fmtty <> Fmtty_EBB sub2_fmtty' then raise Type_mismatch;\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Format_arg_ty (sub2_fmtty', sub_fmtty_rest'), fmt')\n  | Format_subst_ty (sub1_fmtty,  sub2_fmtty,  sub_fmtty_rest),\n    Format_subst_ty (sub1_fmtty', sub2_fmtty', fmtty_rest) ->\n    (* TODO define Fmtty_rel_EBB to remove those erase_rel *)\n    if Fmtty_EBB (erase_rel sub1_fmtty) <> Fmtty_EBB (erase_rel sub1_fmtty')\n    then raise Type_mismatch;\n    if Fmtty_EBB (erase_rel sub2_fmtty) <> Fmtty_EBB (erase_rel sub2_fmtty')\n    then raise Type_mismatch;\n    let sub_fmtty' = trans (symm sub1_fmtty') sub2_fmtty' in\n    let _, f2, _, f4 = fmtty_rel_det sub_fmtty' in\n    let Refl = f2 Refl in\n    let Refl = f4 Refl in\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution (erase_rel sub_fmtty_rest) fmt fmtty_rest\n    in\n    Fmtty_fmt_EBB (Format_subst_ty (sub1_fmtty', sub2_fmtty',\n                                    symm sub_fmtty_rest'),\n                   fmt')\n  | End_of_fmtty, fmtty ->\n    Fmtty_fmt_EBB (End_of_fmtty, type_format_gen fmt fmtty)\n  | _ -> raise Type_mismatch\n\n(* This implementation of `recast` is a bit disappointing. The\n   invariant provided by the type are very strong: the input format's\n   type is in relation to the output type's as witnessed by the\n   fmtty_rel argument. One would at first expect this function to be\n   total, and implementable by exhaustive pattern matching. Instead,\n   we reuse the highly partial and much less well-defined function\n   `type_format` that has lost all knowledge of the correspondence\n   between the argument's types.\n\n   Besides the fact that this function reuses a lot of the\n   `type_format` logic (eg.: seeing Int_ty in the fmtty parameter does\n   not let you match on Int only, as you may in fact have Float\n   (Arg_padding, ...) (\"%.*d\") beginning with an Int_ty), it is also\n   a partial function, because the typing information in a format is\n   not quite enough to reconstruct it unambiguously. For example, the\n   format types of \"%d%_r\" and \"%_r%d\" have the same format6\n   parameters, but they are not at all exchangeable, and putting one\n   in place of the other must result in a dynamic failure.\n\n   Given that:\n   - we'd have to duplicate a lot of non-trivial typing logic from type_format\n   - this wouldn't even eliminate (all) the dynamic failures\n   we decided to just reuse type_format directly for now.\n*)\nlet recast :\n  type a1 b1 c1 d1 e1 f1\n       a2 b2 c2 d2 e2 f2\n  .\n     (a1, b1, c1, d1, e1, f1) fmt\n  -> (a1, b1, c1, d1, e1, f1,\n      a2, b2, c2, d2, e2, f2) fmtty_rel\n  -> (a2, b2, c2, d2, e2, f2) fmt\n= fun fmt fmtty ->\n  type_format fmt (erase_rel (symm fmtty))\n\n(******************************************************************************)\n                             (* Printing tools *)\n\n(* Add padding spaces around a string. *)\nlet fix_padding padty width str =\n  let len = String.length str in\n  let width, padty =\n    abs width,\n    (* while literal padding widths are always non-negative,\n       dynamically-set widths (Arg_padding, eg. %*d) may be negative;\n       we interpret those as specifying a padding-to-the-left; this\n       means that '0' may get dropped even if it was explicitly set,\n       but:\n       - this is what the legacy implementation does, and\n         we preserve compatibility if possible\n       - we could only signal this issue by failing at runtime,\n         which is not very nice... *)\n    if width < 0 then Left else padty in\n  if width <= len then str else\n    let res = Bytes.make width (if padty = Zeros then '0' else ' ') in\n    begin match padty with\n    | Left  -> String.blit str 0 res 0 len\n    | Right -> String.blit str 0 res (width - len) len\n    | Zeros when len > 0 && (str.[0] = '+' || str.[0] = '-' || str.[0] = ' ') ->\n      Bytes.set res 0 str.[0];\n      String.blit str 1 res (width - len + 1) (len - 1)\n    | Zeros when len > 1 && str.[0] = '0' && (str.[1] = 'x' || str.[1] = 'X') ->\n      Bytes.set res 1 str.[1];\n      String.blit str 2 res (width - len + 2) (len - 2)\n    | Zeros ->\n      String.blit str 0 res (width - len) len\n    end;\n    Bytes.unsafe_to_string res\n\n(* Add '0' padding to int, int32, nativeint or int64 string representation. *)\nlet fix_int_precision prec str =\n  let prec = abs prec in\n  let len = String.length str in\n  match str.[0] with\n  | ('+' | '-' | ' ') as c when prec + 1 > len ->\n    let res = Bytes.make (prec + 1) '0' in\n    Bytes.set res 0 c;\n    String.blit str 1 res (prec - len + 2) (len - 1);\n    Bytes.unsafe_to_string res\n  | '0' when prec + 2 > len && len > 1 && (str.[1] = 'x' || str.[1] = 'X') ->\n    let res = Bytes.make (prec + 2) '0' in\n    Bytes.set res 1 str.[1];\n    String.blit str 2 res (prec - len + 4) (len - 2);\n    Bytes.unsafe_to_string res\n  | '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' when prec > len ->\n    let res = Bytes.make prec '0' in\n    String.blit str 0 res (prec - len) len;\n    Bytes.unsafe_to_string res\n  | _ ->\n    str\n\n(* Escape a string according to the OCaml lexing convention. *)\nlet string_to_caml_string str =\n  let str = String.escaped str in\n  let l = String.length str in\n  let res = Bytes.make (l + 2) '\\\"' in\n  String.unsafe_blit str 0 res 1 l;\n  Bytes.unsafe_to_string res\n\n(* Generate the format_int/int32/nativeint/int64 first argument\n   from an int_conv. *)\nlet format_of_iconv = function\n  | Int_d | Int_Cd -> \"%d\" | Int_pd -> \"%+d\" | Int_sd -> \"% d\"\n  | Int_i | Int_Ci -> \"%i\" | Int_pi -> \"%+i\" | Int_si -> \"% i\"\n  | Int_x -> \"%x\" | Int_Cx -> \"%#x\"\n  | Int_X -> \"%X\" | Int_CX -> \"%#X\"\n  | Int_o -> \"%o\" | Int_Co -> \"%#o\"\n  | Int_u | Int_Cu -> \"%u\"\n\nlet format_of_iconvL = function\n  | Int_d | Int_Cd -> \"%Ld\" | Int_pd -> \"%+Ld\" | Int_sd -> \"% Ld\"\n  | Int_i | Int_Ci -> \"%Li\" | Int_pi -> \"%+Li\" | Int_si -> \"% Li\"\n  | Int_x -> \"%Lx\" | Int_Cx -> \"%#Lx\"\n  | Int_X -> \"%LX\" | Int_CX -> \"%#LX\"\n  | Int_o -> \"%Lo\" | Int_Co -> \"%#Lo\"\n  | Int_u | Int_Cu -> \"%Lu\"\n\nlet format_of_iconvl = function\n  | Int_d | Int_Cd -> \"%ld\" | Int_pd -> \"%+ld\" | Int_sd -> \"% ld\"\n  | Int_i | Int_Ci -> \"%li\" | Int_pi -> \"%+li\" | Int_si -> \"% li\"\n  | Int_x -> \"%lx\" | Int_Cx -> \"%#lx\"\n  | Int_X -> \"%lX\" | Int_CX -> \"%#lX\"\n  | Int_o -> \"%lo\" | Int_Co -> \"%#lo\"\n  | Int_u | Int_Cu -> \"%lu\"\n\nlet format_of_iconvn = function\n  | Int_d | Int_Cd -> \"%nd\" | Int_pd -> \"%+nd\" | Int_sd -> \"% nd\"\n  | Int_i | Int_Ci -> \"%ni\" | Int_pi -> \"%+ni\" | Int_si -> \"% ni\"\n  | Int_x -> \"%nx\" | Int_Cx -> \"%#nx\"\n  | Int_X -> \"%nX\" | Int_CX -> \"%#nX\"\n  | Int_o -> \"%no\" | Int_Co -> \"%#no\"\n  | Int_u | Int_Cu -> \"%nu\"\n\n(* Generate the format_float first argument from a float_conv. *)\nlet format_of_fconv fconv prec =\n    let prec = abs prec in\n    let symb = char_of_fconv ~cF:'g' fconv in\n    let buf = buffer_create 16 in\n    buffer_add_char buf '%';\n    bprint_fconv_flag buf fconv;\n    buffer_add_char buf '.';\n    buffer_add_string buf (Int.to_string prec);\n    buffer_add_char buf symb;\n    buffer_contents buf\n\nlet transform_int_alt iconv s =\n  match iconv with\n  | Int_Cd | Int_Ci | Int_Cu ->\n    let digits =\n      let n = ref 0 in\n      for i = 0 to String.length s - 1 do\n        match String.unsafe_get s i with\n        | '0'..'9' -> incr n\n        | _ -> ()\n      done;\n      !n\n    in\n    let buf = Bytes.create (String.length s + (digits - 1) / 3) in\n    let pos = ref 0 in\n    let put c = Bytes.set buf !pos c; incr pos in\n    let left = ref ((digits - 1) mod 3 + 1) in\n    for i = 0 to String.length s - 1 do\n      match String.unsafe_get s i with\n      | '0'..'9' as c ->\n          if !left = 0 then (put '_'; left := 3); decr left; put c\n      | c -> put c\n    done;\n    Bytes.unsafe_to_string buf\n  | _ -> s\n\n(* Convert an integer to a string according to a conversion. *)\nlet convert_int iconv n =\n  transform_int_alt iconv (format_int (format_of_iconv iconv) n)\nlet convert_int32 iconv n =\n  transform_int_alt iconv (format_int32 (format_of_iconvl iconv) n)\nlet convert_nativeint iconv n =\n  transform_int_alt iconv (format_nativeint (format_of_iconvn iconv) n)\nlet convert_int64 iconv n =\n  transform_int_alt iconv (format_int64 (format_of_iconvL iconv) n)\n\n(* Convert a float to string. *)\n(* Fix special case of \"OCaml float format\". *)\nlet convert_float fconv prec x =\n  let hex () =\n    let sign =\n      match fst fconv with\n      | Float_flag_p -> '+'\n      | Float_flag_s -> ' '\n      | _ -> '-' in\n    hexstring_of_float x prec sign in\n  let add_dot_if_needed str =\n    let len = String.length str in\n    let rec is_valid i =\n      if i = len then false else\n        match str.[i] with\n        | '.' | 'e' | 'E' -> true\n        | _ -> is_valid (i + 1) in\n    if is_valid 0 then str else str ^ \".\" in\n  let caml_special_val str = match classify_float x with\n    | FP_normal | FP_subnormal | FP_zero -> str\n    | FP_infinite -> if x < 0.0 then \"neg_infinity\" else \"infinity\"\n    | FP_nan -> \"nan\" in\n  match snd fconv with\n  | Float_h -> hex ()\n  | Float_H -> String.uppercase_ascii (hex ())\n  | Float_CF -> caml_special_val (hex ())\n  | Float_F ->\n    let str = format_float (format_of_fconv fconv prec) x in\n    caml_special_val (add_dot_if_needed str)\n  | Float_f | Float_e | Float_E | Float_g | Float_G ->\n    format_float (format_of_fconv fconv prec) x\n\n(* Convert a char to a string according to the OCaml lexical convention. *)\nlet format_caml_char c =\n  let str = Char.escaped c in\n  let l = String.length str in\n  let res = Bytes.make (l + 2) '\\'' in\n  String.unsafe_blit str 0 res 1 l;\n  Bytes.unsafe_to_string res\n\n(* Convert a format type to string *)\nlet string_of_fmtty fmtty =\n  let buf = buffer_create 16 in\n  bprint_fmtty buf fmtty;\n  buffer_contents buf\n\n(******************************************************************************)\n                        (* Generic printing function *)\n\n(* Make a generic printing function. *)\n(* Used to generate Printf and Format printing functions. *)\n(* Parameters:\n     k: a continuation finally applied to the output stream and the accumulator.\n     o: the output stream (see k, %a and %t).\n     acc: rev list of printing entities (string, char, flush, formatting, ...).\n     fmt: the format. *)\nlet rec make_printf : type a b c d e f .\n    ((b, c) acc -> f) -> (b, c) acc ->\n    (a, b, c, d, e, f) fmt -> a =\nfun k acc fmt -> match fmt with\n  | Char rest ->\n    fun c ->\n      let new_acc = Acc_data_char (acc, c) in\n      make_printf k new_acc rest\n  | Caml_char rest ->\n    fun c ->\n      let new_acc = Acc_data_string (acc, format_caml_char c) in\n      make_printf k new_acc rest\n  | String (pad, rest) ->\n    make_padding k acc rest pad (fun str -> str)\n  | Caml_string (pad, rest) ->\n    make_padding k acc rest pad string_to_caml_string\n  | Int (iconv, pad, prec, rest) ->\n    make_int_padding_precision k acc rest pad prec convert_int iconv\n  | Int32 (iconv, pad, prec, rest) ->\n    make_int_padding_precision k acc rest pad prec convert_int32 iconv\n  | Nativeint (iconv, pad, prec, rest) ->\n    make_int_padding_precision k acc rest pad prec convert_nativeint iconv\n  | Int64 (iconv, pad, prec, rest) ->\n    make_int_padding_precision k acc rest pad prec convert_int64 iconv\n  | Float (fconv, pad, prec, rest) ->\n    make_float_padding_precision k acc rest pad prec fconv\n  | Bool (pad, rest) ->\n    make_padding k acc rest pad string_of_bool\n  | Alpha rest ->\n    fun f x -> make_printf k (Acc_delay (acc, fun o -> f o x)) rest\n  | Theta rest ->\n    fun f -> make_printf k (Acc_delay (acc, f)) rest\n  | Custom (arity, f, rest) ->\n    make_custom k acc rest arity (f ())\n  | Reader _ ->\n    (* This case is impossible, by typing of formats. *)\n    (* Indeed, since printf and co. take a format4 as argument, the 'd and 'e\n       type parameters of fmt are obviously equals. The Reader is the\n       only constructor which touch 'd and 'e type parameters of the format\n       type, it adds an (->) to the 'd parameters. Consequently, a format4\n       cannot contain a Reader node, except in the sub-format associated to\n       an %{...%}. It's not a problem because make_printf do not call\n       itself recursively on the sub-format associated to %{...%}. *)\n    assert false\n  | Flush rest ->\n    make_printf k (Acc_flush acc) rest\n\n  | String_literal (str, rest) ->\n    make_printf k (Acc_string_literal (acc, str)) rest\n  | Char_literal (chr, rest) ->\n    make_printf k (Acc_char_literal (acc, chr)) rest\n\n  | Format_arg (_, sub_fmtty, rest) ->\n    let ty = string_of_fmtty sub_fmtty in\n    (fun str ->\n      ignore str;\n      make_printf k (Acc_data_string (acc, ty)) rest)\n  | Format_subst (_, fmtty, rest) ->\n    fun (Format (fmt, _)) -> make_printf k acc\n      (concat_fmt (recast fmt fmtty) rest)\n\n  | Scan_char_set (_, _, rest) ->\n    let new_acc = Acc_invalid_arg (acc, \"Printf: bad conversion %[\") in\n    fun _ -> make_printf k new_acc rest\n  | Scan_get_counter (_, rest) ->\n    (* This case should be refused for Printf. *)\n    (* Accepted for backward compatibility. *)\n    (* Interpret %l, %n and %L as %u. *)\n    fun n ->\n      let new_acc = Acc_data_string (acc, format_int \"%u\" n) in\n      make_printf k new_acc rest\n  | Scan_next_char rest ->\n    fun c ->\n      let new_acc = Acc_data_char (acc, c) in\n      make_printf k new_acc rest\n  | Ignored_param (ign, rest) ->\n    make_ignored_param k acc ign rest\n\n  | Formatting_lit (fmting_lit, rest) ->\n    make_printf k (Acc_formatting_lit (acc, fmting_lit)) rest\n  | Formatting_gen (Open_tag (Format (fmt', _)), rest) ->\n    let k' kacc =\n      make_printf k (Acc_formatting_gen (acc, Acc_open_tag kacc)) rest in\n    make_printf k' End_of_acc fmt'\n  | Formatting_gen (Open_box (Format (fmt', _)), rest) ->\n    let k' kacc =\n      make_printf k (Acc_formatting_gen (acc, Acc_open_box kacc)) rest in\n    make_printf k' End_of_acc fmt'\n\n  | End_of_format ->\n    k acc\n\n(* Delay the error (Invalid_argument \"Printf: bad conversion %_\"). *)\n(* Generate functions to take remaining arguments (after the \"%_\"). *)\nand make_ignored_param : type x y a b c d e f .\n    ((b, c) acc -> f) -> (b, c) acc ->\n    (a, b, c, d, y, x) ignored ->\n    (x, b, c, y, e, f) fmt -> a =\nfun k acc ign fmt -> match ign with\n  | Ignored_char                    -> make_invalid_arg k acc fmt\n  | Ignored_caml_char               -> make_invalid_arg k acc fmt\n  | Ignored_string _                -> make_invalid_arg k acc fmt\n  | Ignored_caml_string _           -> make_invalid_arg k acc fmt\n  | Ignored_int (_, _)              -> make_invalid_arg k acc fmt\n  | Ignored_int32 (_, _)            -> make_invalid_arg k acc fmt\n  | Ignored_nativeint (_, _)        -> make_invalid_arg k acc fmt\n  | Ignored_int64 (_, _)            -> make_invalid_arg k acc fmt\n  | Ignored_float (_, _)            -> make_invalid_arg k acc fmt\n  | Ignored_bool _                  -> make_invalid_arg k acc fmt\n  | Ignored_format_arg _            -> make_invalid_arg k acc fmt\n  | Ignored_format_subst (_, fmtty) -> make_from_fmtty k acc fmtty fmt\n  | Ignored_reader                  -> assert false\n  | Ignored_scan_char_set _         -> make_invalid_arg k acc fmt\n  | Ignored_scan_get_counter _      -> make_invalid_arg k acc fmt\n  | Ignored_scan_next_char          -> make_invalid_arg k acc fmt\n\n\n(* Special case of printf \"%_(\". *)\nand make_from_fmtty : type x y a b c d e f .\n    ((b, c) acc -> f) -> (b, c) acc ->\n    (a, b, c, d, y, x) fmtty ->\n    (x, b, c, y, e, f) fmt -> a =\nfun k acc fmtty fmt -> match fmtty with\n  | Char_ty rest            -> fun _ -> make_from_fmtty k acc rest fmt\n  | String_ty rest          -> fun _ -> make_from_fmtty k acc rest fmt\n  | Int_ty rest             -> fun _ -> make_from_fmtty k acc rest fmt\n  | Int32_ty rest           -> fun _ -> make_from_fmtty k acc rest fmt\n  | Nativeint_ty rest       -> fun _ -> make_from_fmtty k acc rest fmt\n  | Int64_ty rest           -> fun _ -> make_from_fmtty k acc rest fmt\n  | Float_ty rest           -> fun _ -> make_from_fmtty k acc rest fmt\n  | Bool_ty rest            -> fun _ -> make_from_fmtty k acc rest fmt\n  | Alpha_ty rest           -> fun _ _ -> make_from_fmtty k acc rest fmt\n  | Theta_ty rest           -> fun _ -> make_from_fmtty k acc rest fmt\n  | Any_ty rest             -> fun _ -> make_from_fmtty k acc rest fmt\n  | Reader_ty _             -> assert false\n  | Ignored_reader_ty _     -> assert false\n  | Format_arg_ty (_, rest) -> fun _ -> make_from_fmtty k acc rest fmt\n  | End_of_fmtty            -> make_invalid_arg k acc fmt\n  | Format_subst_ty (ty1, ty2, rest) ->\n    let ty = trans (symm ty1) ty2 in\n    fun _ -> make_from_fmtty k acc (concat_fmtty ty rest) fmt\n\n(* Insert an Acc_invalid_arg in the accumulator and continue to generate\n   closures to get the remaining arguments. *)\nand make_invalid_arg : type a b c d e f .\n    ((b, c) acc -> f) -> (b, c) acc ->\n    (a, b, c, d, e, f) fmt -> a =\nfun k acc fmt ->\n  make_printf k (Acc_invalid_arg (acc, \"Printf: bad conversion %_\")) fmt\n\n(* Fix padding, take it as an extra integer argument if needed. *)\nand make_padding : type x z a b c d e f .\n    ((b, c) acc -> f) -> (b, c) acc ->\n    (a, b, c, d, e, f) fmt ->\n    (x, z -> a) padding -> (z -> string) -> x =\n  fun k acc fmt pad trans -> match pad with\n  | No_padding ->\n    fun x ->\n      let new_acc = Acc_data_string (acc, trans x) in\n      make_printf k new_acc fmt\n  | Lit_padding (padty, width) ->\n    fun x ->\n      let new_acc = Acc_data_string (acc, fix_padding padty width (trans x)) in\n      make_printf k new_acc fmt\n  | Arg_padding padty ->\n    fun w x ->\n      let new_acc = Acc_data_string (acc, fix_padding padty w (trans x)) in\n      make_printf k new_acc fmt\n\n(* Fix padding and precision for int, int32, nativeint or int64. *)\n(* Take one or two extra integer arguments if needed. *)\nand make_int_padding_precision : type x y z a b c d e f .\n    ((b, c) acc -> f) -> (b, c) acc ->\n    (a, b, c, d, e, f) fmt ->\n    (x, y) padding -> (y, z -> a) precision -> (int_conv -> z -> string) ->\n    int_conv -> x =\n  fun k acc fmt pad prec trans iconv -> match pad, prec with\n  | No_padding, No_precision ->\n    fun x ->\n      let str = trans iconv x in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | No_padding, Lit_precision p ->\n    fun x ->\n      let str = fix_int_precision p (trans iconv x) in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | No_padding, Arg_precision ->\n    fun p x ->\n      let str = fix_int_precision p (trans iconv x) in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | Lit_padding (padty, w), No_precision ->\n    fun x ->\n      let str = fix_padding padty w (trans iconv x) in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | Lit_padding (padty, w), Lit_precision p ->\n    fun x ->\n      let str = fix_padding padty w (fix_int_precision p (trans iconv x)) in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | Lit_padding (padty, w), Arg_precision ->\n    fun p x ->\n      let str = fix_padding padty w (fix_int_precision p (trans iconv x)) in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | Arg_padding padty, No_precision ->\n    fun w x ->\n      let str = fix_padding padty w (trans iconv x) in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | Arg_padding padty, Lit_precision p ->\n    fun w x ->\n      let str = fix_padding padty w (fix_int_precision p (trans iconv x)) in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | Arg_padding padty, Arg_precision ->\n    fun w p x ->\n      let str = fix_padding padty w (fix_int_precision p (trans iconv x)) in\n      make_printf k (Acc_data_string (acc, str)) fmt\n\n(* Convert a float, fix padding and precision if needed. *)\n(* Take the float argument and one or two extra integer arguments if needed. *)\nand make_float_padding_precision : type x y a b c d e f .\n    ((b, c) acc -> f) -> (b, c) acc ->\n    (a, b, c, d, e, f) fmt ->\n    (x, y) padding -> (y, float -> a) precision -> float_conv -> x =\n  fun k acc fmt pad prec fconv -> match pad, prec with\n  | No_padding, No_precision ->\n    fun x ->\n      let str = convert_float fconv (default_float_precision fconv) x in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | No_padding, Lit_precision p ->\n    fun x ->\n      let str = convert_float fconv p x in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | No_padding, Arg_precision ->\n    fun p x ->\n      let str = convert_float fconv p x in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | Lit_padding (padty, w), No_precision ->\n    fun x ->\n      let str = convert_float fconv (default_float_precision fconv) x in\n      let str' = fix_padding padty w str in\n      make_printf k (Acc_data_string (acc, str')) fmt\n  | Lit_padding (padty, w), Lit_precision p ->\n    fun x ->\n      let str = fix_padding padty w (convert_float fconv p x) in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | Lit_padding (padty, w), Arg_precision ->\n    fun p x ->\n      let str = fix_padding padty w (convert_float fconv p x) in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | Arg_padding padty, No_precision ->\n    fun w x ->\n      let str = convert_float fconv (default_float_precision fconv) x in\n      let str' = fix_padding padty w str in\n      make_printf k (Acc_data_string (acc, str')) fmt\n  | Arg_padding padty, Lit_precision p ->\n    fun w x ->\n      let str = fix_padding padty w (convert_float fconv p x) in\n      make_printf k (Acc_data_string (acc, str)) fmt\n  | Arg_padding padty, Arg_precision ->\n    fun w p x ->\n      let str = fix_padding padty w (convert_float fconv p x) in\n      make_printf k (Acc_data_string (acc, str)) fmt\nand make_custom : type x y a b c d e f .\n  ((b, c) acc -> f) -> (b, c) acc ->\n  (a, b, c, d, e, f) fmt ->\n  (a, x, y) custom_arity -> x -> y =\n  fun k acc rest arity f -> match arity with\n  | Custom_zero -> make_printf k (Acc_data_string (acc, f)) rest\n  | Custom_succ arity ->\n    fun x ->\n      make_custom k acc rest arity (f x)\n\nlet const x _ = x\n\nlet rec make_iprintf : type a b c d e f state.\n  (state -> f) -> state -> (a, b, c, d, e, f) fmt -> a =\n  fun k o fmt -> match fmt with\n    | Char rest ->\n        const (make_iprintf k o rest)\n    | Caml_char rest ->\n        const (make_iprintf k o rest)\n    | String (No_padding, rest) ->\n        const (make_iprintf k o rest)\n    | String (Lit_padding _, rest) ->\n        const (make_iprintf k o rest)\n    | String (Arg_padding _, rest) ->\n        const (const (make_iprintf k o rest))\n    | Caml_string (No_padding, rest) ->\n        const (make_iprintf k o rest)\n    | Caml_string (Lit_padding _, rest) ->\n        const (make_iprintf k o rest)\n    | Caml_string (Arg_padding _, rest) ->\n        const (const (make_iprintf k o rest))\n    | Int (_, pad, prec, rest) ->\n        fn_of_padding_precision k o rest pad prec\n    | Int32 (_, pad, prec, rest) ->\n        fn_of_padding_precision k o rest pad prec\n    | Nativeint (_, pad, prec, rest) ->\n        fn_of_padding_precision k o rest pad prec\n    | Int64 (_, pad, prec, rest) ->\n        fn_of_padding_precision k o rest pad prec\n    | Float (_, pad, prec, rest) ->\n        fn_of_padding_precision k o rest pad prec\n    | Bool (No_padding, rest) ->\n        const (make_iprintf k o rest)\n    | Bool (Lit_padding _, rest) ->\n        const (make_iprintf k o rest)\n    | Bool (Arg_padding _, rest) ->\n        const (const (make_iprintf k o rest))\n    | Alpha rest ->\n        const (const (make_iprintf k o rest))\n    | Theta rest ->\n        const (make_iprintf k o rest)\n    | Custom (arity, _, rest) ->\n        fn_of_custom_arity k o rest arity\n    | Reader _ ->\n        (* This case is impossible, by typing of formats.  See the\n           note in the corresponding case for make_printf. *)\n        assert false\n    | Flush rest ->\n        make_iprintf k o rest\n    | String_literal (_, rest) ->\n        make_iprintf k o rest\n    | Char_literal (_, rest) ->\n        make_iprintf k o rest\n    | Format_arg (_, _, rest) ->\n        const (make_iprintf k o rest)\n    | Format_subst (_, fmtty, rest) ->\n        fun (Format (fmt, _)) ->\n          make_iprintf k o\n            (concat_fmt (recast fmt fmtty) rest)\n    | Scan_char_set (_, _, rest) ->\n        const (make_iprintf k o rest)\n    | Scan_get_counter (_, rest) ->\n        const (make_iprintf k o rest)\n    | Scan_next_char rest ->\n        const (make_iprintf k o rest)\n    | Ignored_param (ign, rest) ->\n        make_ignored_param (fun _ -> k o) (End_of_acc) ign rest\n    | Formatting_lit (_, rest) ->\n        make_iprintf k o rest\n    | Formatting_gen (Open_tag (Format (fmt', _)), rest) ->\n        make_iprintf (fun koc -> make_iprintf k koc rest) o fmt'\n    | Formatting_gen (Open_box (Format (fmt', _)), rest) ->\n        make_iprintf (fun koc -> make_iprintf k koc rest) o fmt'\n    | End_of_format ->\n        k o\nand fn_of_padding_precision :\n  type x y z a b c d e f state.\n  (state -> f) -> state -> (a, b, c, d, e, f) fmt ->\n  (x, y) padding -> (y, z -> a) precision -> x =\n  fun k o fmt pad prec -> match pad, prec with\n    | No_padding   , No_precision    ->\n        const (make_iprintf k o fmt)\n    | No_padding   , Lit_precision _ ->\n        const (make_iprintf k o fmt)\n    | No_padding   , Arg_precision   ->\n        const (const (make_iprintf k o fmt))\n    | Lit_padding _, No_precision    ->\n        const (make_iprintf k o fmt)\n    | Lit_padding _, Lit_precision _ ->\n        const (make_iprintf k o fmt)\n    | Lit_padding _, Arg_precision   ->\n        const (const (make_iprintf k o fmt))\n    | Arg_padding _, No_precision    ->\n        const (const (make_iprintf k o fmt))\n    | Arg_padding _, Lit_precision _ ->\n        const (const (make_iprintf k o fmt))\n    | Arg_padding _, Arg_precision   ->\n        const (const (const (make_iprintf k o fmt)))\nand fn_of_custom_arity : type x y a b c d e f state.\n  (state -> f) ->\n  state -> (a, b, c, d, e, f) fmt -> (a, x, y) custom_arity -> y =\n  fun k o fmt -> function\n    | Custom_zero ->\n        make_iprintf k o fmt\n    | Custom_succ arity ->\n        const (fn_of_custom_arity k o fmt arity)\n\n(******************************************************************************)\n                          (* Continuations for make_printf *)\n\n(* Recursively output an \"accumulator\" containing a reversed list of\n   printing entities (string, char, flus, ...) in an output_stream. *)\n(* Used as a continuation of make_printf. *)\nlet rec output_acc o acc = match acc with\n  | Acc_formatting_lit (p, fmting_lit) ->\n    let s = string_of_formatting_lit fmting_lit in\n    output_acc o p; output_string o s;\n  | Acc_formatting_gen (p, Acc_open_tag acc') ->\n    output_acc o p; output_string o \"@{\"; output_acc o acc';\n  | Acc_formatting_gen (p, Acc_open_box acc') ->\n    output_acc o p; output_string o \"@[\"; output_acc o acc';\n  | Acc_string_literal (p, s)\n  | Acc_data_string (p, s)   -> output_acc o p; output_string o s\n  | Acc_char_literal (p, c)\n  | Acc_data_char (p, c)     -> output_acc o p; output_char o c\n  | Acc_delay (p, f)         -> output_acc o p; f o\n  | Acc_flush p              -> output_acc o p; flush o\n  | Acc_invalid_arg (p, msg) -> output_acc o p; invalid_arg msg;\n  | End_of_acc               -> ()\n\n(* Recursively output an \"accumulator\" containing a reversed list of\n   printing entities (string, char, flus, ...) in a buffer. *)\n(* Used as a continuation of make_printf. *)\nlet rec bufput_acc b acc = match acc with\n  | Acc_formatting_lit (p, fmting_lit) ->\n    let s = string_of_formatting_lit fmting_lit in\n    bufput_acc b p; Buffer.add_string b s;\n  | Acc_formatting_gen (p, Acc_open_tag acc') ->\n    bufput_acc b p; Buffer.add_string b \"@{\"; bufput_acc b acc';\n  | Acc_formatting_gen (p, Acc_open_box acc') ->\n    bufput_acc b p; Buffer.add_string b \"@[\"; bufput_acc b acc';\n  | Acc_string_literal (p, s)\n  | Acc_data_string (p, s)   -> bufput_acc b p; Buffer.add_string b s\n  | Acc_char_literal (p, c)\n  | Acc_data_char (p, c)     -> bufput_acc b p; Buffer.add_char b c\n  | Acc_delay (p, f)         -> bufput_acc b p; f b\n  | Acc_flush p              -> bufput_acc b p;\n  | Acc_invalid_arg (p, msg) -> bufput_acc b p; invalid_arg msg;\n  | End_of_acc               -> ()\n\n(* Recursively output an \"accumulator\" containing a reversed list of\n   printing entities (string, char, flus, ...) in a buffer. *)\n(* Differ from bufput_acc by the interpretation of %a and %t. *)\n(* Used as a continuation of make_printf. *)\nlet rec strput_acc b acc = match acc with\n  | Acc_formatting_lit (p, fmting_lit) ->\n    let s = string_of_formatting_lit fmting_lit in\n    strput_acc b p; Buffer.add_string b s;\n  | Acc_formatting_gen (p, Acc_open_tag acc') ->\n    strput_acc b p; Buffer.add_string b \"@{\"; strput_acc b acc';\n  | Acc_formatting_gen (p, Acc_open_box acc') ->\n    strput_acc b p; Buffer.add_string b \"@[\"; strput_acc b acc';\n  | Acc_string_literal (p, s)\n  | Acc_data_string (p, s)   -> strput_acc b p; Buffer.add_string b s\n  | Acc_char_literal (p, c)\n  | Acc_data_char (p, c)     -> strput_acc b p; Buffer.add_char b c\n  | Acc_delay (p, f)         -> strput_acc b p; Buffer.add_string b (f ())\n  | Acc_flush p              -> strput_acc b p;\n  | Acc_invalid_arg (p, msg) -> strput_acc b p; invalid_arg msg;\n  | End_of_acc               -> ()\n\n(******************************************************************************)\n                          (* Error management *)\n\n(* Raise [Failure] with a pretty-printed error message. *)\nlet failwith_message (Format (fmt, _)) =\n  let buf = Buffer.create 256 in\n  let k acc = strput_acc buf acc; failwith (Buffer.contents buf) in\n  make_printf k End_of_acc fmt\n\n(******************************************************************************)\n                            (* Formatting tools *)\n\n(* Convert a string to an open block description (indent, block_type) *)\nlet open_box_of_string str =\n  if str = \"\" then (0, Pp_box) else\n    let len = String.length str in\n    let invalid_box () = failwith_message \"invalid box description %S\" str in\n    let rec parse_spaces i =\n      if i = len then i else\n        match str.[i] with\n        | ' ' | '\\t' -> parse_spaces (i + 1)\n        | _ -> i\n    and parse_lword i j =\n      if j = len then j else\n        match str.[j] with\n        | 'a' .. 'z' -> parse_lword i (j + 1)\n        | _ -> j\n    and parse_int i j =\n      if j = len then j else\n        match str.[j] with\n        | '0' .. '9' | '-' -> parse_int i (j + 1)\n        | _ -> j in\n    let wstart = parse_spaces 0 in\n    let wend = parse_lword wstart wstart in\n    let box_name = String.sub str wstart (wend - wstart) in\n    let nstart = parse_spaces wend in\n    let nend = parse_int nstart nstart in\n    let indent =\n      if nstart = nend then 0 else\n        try int_of_string (String.sub str nstart (nend - nstart))\n        with Failure _ -> invalid_box () in\n    let exp_end = parse_spaces nend in\n    if exp_end <> len then invalid_box ();\n    let box_type = match box_name with\n      | \"\" | \"b\" -> Pp_box\n      | \"h\"      -> Pp_hbox\n      | \"v\"      -> Pp_vbox\n      | \"hv\"     -> Pp_hvbox\n      | \"hov\"    -> Pp_hovbox\n      | _        -> invalid_box () in\n    (indent, box_type)\n\n(******************************************************************************)\n                            (* Parsing tools *)\n\n(* Create a padding_fmt_ebb from a padding and a format. *)\n(* Copy the padding to disjoin the type parameters of argument and result. *)\nlet make_padding_fmt_ebb : type x y .\n    (x, y) padding -> (_, _, _, _, _, _) fmt ->\n      (_, _, _, _, _) padding_fmt_ebb =\nfun pad fmt -> match pad with\n  | No_padding         -> Padding_fmt_EBB (No_padding, fmt)\n  | Lit_padding (s, w) -> Padding_fmt_EBB (Lit_padding (s, w), fmt)\n  | Arg_padding s      -> Padding_fmt_EBB (Arg_padding s, fmt)\n\n(* Create a precision_fmt_ebb from a precision and a format. *)\n(* Copy the precision to disjoin the type parameters of argument and result. *)\nlet make_precision_fmt_ebb : type x y .\n    (x, y) precision -> (_, _, _, _, _, _) fmt ->\n      (_, _, _, _, _) precision_fmt_ebb =\nfun prec fmt -> match prec with\n  | No_precision    -> Precision_fmt_EBB (No_precision, fmt)\n  | Lit_precision p -> Precision_fmt_EBB (Lit_precision p, fmt)\n  | Arg_precision   -> Precision_fmt_EBB (Arg_precision, fmt)\n\n(* Create a padprec_fmt_ebb from a padding, a precision and a format. *)\n(* Copy the padding and the precision to disjoin type parameters of arguments\n   and result. *)\nlet make_padprec_fmt_ebb : type x y z t .\n    (x, y) padding -> (z, t) precision ->\n    (_, _, _, _, _, _) fmt ->\n    (_, _, _, _, _) padprec_fmt_ebb =\nfun pad prec fmt ->\n  let Precision_fmt_EBB (prec, fmt') = make_precision_fmt_ebb prec fmt in\n  match pad with\n  | No_padding         -> Padprec_fmt_EBB (No_padding, prec, fmt')\n  | Lit_padding (s, w) -> Padprec_fmt_EBB (Lit_padding (s, w), prec, fmt')\n  | Arg_padding s      -> Padprec_fmt_EBB (Arg_padding s, prec, fmt')\n\n(******************************************************************************)\n                             (* Format parsing *)\n\n(* Parse a string representing a format and create a fmt_ebb. *)\n(* Raise [Failure] in case of invalid format. *)\nlet fmt_ebb_of_string ?legacy_behavior str =\n  (* Parameters naming convention:                                    *)\n  (*   - lit_start: start of the literal sequence.                    *)\n  (*   - str_ind: current index in the string.                        *)\n  (*   - end_ind: end of the current (sub-)format.                    *)\n  (*   - pct_ind: index of the '%' in the current micro-format.       *)\n  (*   - zero:  is the '0' flag defined in the current micro-format.  *)\n  (*   - minus: is the '-' flag defined in the current micro-format.  *)\n  (*   - plus:  is the '+' flag defined in the current micro-format.  *)\n  (*   - hash:  is the '#' flag defined in the current micro-format.  *)\n  (*   - space: is the ' ' flag defined in the current micro-format.  *)\n  (*   - ign:   is the '_' flag defined in the current micro-format.  *)\n  (*   - pad: padding of the current micro-format.                    *)\n  (*   - prec: precision of the current micro-format.                 *)\n  (*   - symb: char representing the conversion ('c', 's', 'd', ...). *)\n  (*   - char_set: set of characters as bitmap (see scanf %[...]).    *)\n\n  let legacy_behavior = match legacy_behavior with\n    | Some flag -> flag\n    | None -> true\n  (*  When this flag is enabled, the format parser tries to behave as\n      the <4.02 implementations, in particular it ignores most benine\n      nonsensical format. When the flag is disabled, it will reject any\n      format that is not accepted by the specification.\n\n      A typical example would be \"%+ d\": specifying both '+' (if the\n      number is positive, pad with a '+' to get the same width as\n      negative numbers) and ' ' (if the number is positive, pad with\n      a space) does not make sense, but the legacy (< 4.02)\n      implementation was happy to just ignore the space.\n  *)\n  in\n\n  (* Raise [Failure] with a friendly error message. *)\n  let invalid_format_message str_ind msg =\n    failwith_message\n      \"invalid format %S: at character number %d, %s\"\n      str str_ind msg\n  in\n\n  (* Used when the end of the format (or the current sub-format) was encountered\n      unexpectedly. *)\n  let unexpected_end_of_format end_ind =\n    invalid_format_message end_ind\n      \"unexpected end of format\"\n  in\n\n  (* Used for %0c: no other widths are implemented *)\n  let invalid_nonnull_char_width str_ind =\n    invalid_format_message str_ind\n      \"non-zero widths are unsupported for %c conversions\"\n  in\n  (* Raise [Failure] with a friendly error message about an option dependency\n     problem. *)\n  let invalid_format_without str_ind c s =\n    failwith_message\n      \"invalid format %S: at character number %d, '%c' without %s\"\n      str str_ind c s\n  in\n\n  (* Raise [Failure] with a friendly error message about an unexpected\n     character. *)\n  let expected_character str_ind expected read =\n    failwith_message\n     \"invalid format %S: at character number %d, %s expected, read %C\"\n      str str_ind expected read\n  in\n\n  (* Parse the string from beg_ind (included) to end_ind (excluded). *)\n  let rec parse : type e f . int -> int -> (_, _, e, f) fmt_ebb =\n  fun beg_ind end_ind -> parse_literal beg_ind beg_ind end_ind\n\n  (* Read literal characters up to '%' or '@' special characters. *)\n  and parse_literal : type e f . int -> int -> int -> (_, _, e, f) fmt_ebb =\n  fun lit_start str_ind end_ind ->\n    if str_ind = end_ind then add_literal lit_start str_ind End_of_format else\n      match str.[str_ind] with\n      | '%' ->\n        let Fmt_EBB fmt_rest = parse_format str_ind end_ind in\n        add_literal lit_start str_ind fmt_rest\n      | '@' ->\n        let Fmt_EBB fmt_rest = parse_after_at (str_ind + 1) end_ind in\n        add_literal lit_start str_ind fmt_rest\n      | _ ->\n        parse_literal lit_start (str_ind + 1) end_ind\n\n  (* Parse a format after '%' *)\n  and parse_format : type e f . int -> int -> (_, _, e, f) fmt_ebb =\n  fun pct_ind end_ind -> parse_ign pct_ind (pct_ind + 1) end_ind\n\n  and parse_ign : type e f . int -> int -> int -> (_, _, e, f) fmt_ebb =\n  fun pct_ind str_ind end_ind ->\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    match str.[str_ind] with\n      | '_' -> parse_flags pct_ind (str_ind+1) end_ind true\n      | _ -> parse_flags pct_ind str_ind end_ind false\n\n  and parse_flags : type e f . int -> int -> int -> bool -> (_, _, e, f) fmt_ebb\n  =\n  fun pct_ind str_ind end_ind ign ->\n    let zero = ref false and minus = ref false\n    and plus = ref false and space = ref false\n    and hash = ref false in\n    let set_flag str_ind flag =\n      (* in legacy mode, duplicate flags are accepted *)\n      if !flag && not legacy_behavior then\n        failwith_message\n          \"invalid format %S: at character number %d, duplicate flag %C\"\n          str str_ind str.[str_ind];\n      flag := true;\n    in\n    let rec read_flags str_ind =\n      if str_ind = end_ind then unexpected_end_of_format end_ind;\n      begin match str.[str_ind] with\n      | '0' -> set_flag str_ind zero;  read_flags (str_ind + 1)\n      | '-' -> set_flag str_ind minus; read_flags (str_ind + 1)\n      | '+' -> set_flag str_ind plus;  read_flags (str_ind + 1)\n      | '#' -> set_flag str_ind hash; read_flags (str_ind + 1)\n      | ' ' -> set_flag str_ind space; read_flags (str_ind + 1)\n      | _ ->\n        parse_padding pct_ind str_ind end_ind\n          !zero !minus !plus !hash !space ign\n      end\n    in\n    read_flags str_ind\n\n  (* Try to read a digital or a '*' padding. *)\n  and parse_padding : type e f .\n      int -> int -> int -> bool -> bool -> bool -> bool -> bool -> bool ->\n        (_, _, e, f) fmt_ebb =\n  fun pct_ind str_ind end_ind zero minus plus hash space ign ->\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    let padty = match zero, minus with\n      | false, false -> Right\n      | false, true  -> Left\n      |  true, false -> Zeros\n      |  true, true  ->\n        if legacy_behavior then Left\n        else incompatible_flag pct_ind str_ind '-' \"0\" in\n    match str.[str_ind] with\n    | '0' .. '9' ->\n      let new_ind, width = parse_positive str_ind end_ind 0 in\n      parse_after_padding pct_ind new_ind end_ind minus plus hash space ign\n        (Lit_padding (padty, width))\n    | '*' ->\n      parse_after_padding pct_ind (str_ind + 1) end_ind minus plus hash space\n        ign (Arg_padding padty)\n    | _ ->\n      begin match padty with\n      | Left  ->\n        if not legacy_behavior then\n          invalid_format_without (str_ind - 1) '-' \"padding\";\n        parse_after_padding pct_ind str_ind end_ind minus plus hash space ign\n          No_padding\n      | Zeros ->\n         (* a '0' padding indication not followed by anything should\n           be interpreted as a Right padding of width 0. This is used\n           by scanning conversions %0s and %0c *)\n        parse_after_padding pct_ind str_ind end_ind minus plus hash space ign\n          (Lit_padding (Right, 0))\n      | Right ->\n        parse_after_padding pct_ind str_ind end_ind minus plus hash space ign\n          No_padding\n      end\n\n  (* Is precision defined? *)\n  and parse_after_padding : type x e f .\n      int -> int -> int -> bool -> bool -> bool -> bool -> bool ->\n        (x, _) padding -> (_, _, e, f) fmt_ebb =\n  fun pct_ind str_ind end_ind minus plus hash space ign pad ->\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    match str.[str_ind] with\n    | '.' ->\n      parse_precision pct_ind (str_ind + 1) end_ind minus plus hash space ign\n        pad\n    | symb ->\n      parse_conversion pct_ind (str_ind + 1) end_ind plus hash space ign pad\n        No_precision pad symb\n\n  (* Read the digital or '*' precision. *)\n  and parse_precision : type x e f .\n      int -> int -> int -> bool -> bool -> bool -> bool -> bool ->\n        (x, _) padding -> (_, _, e, f) fmt_ebb =\n  fun pct_ind str_ind end_ind minus plus hash space ign pad ->\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    let parse_literal minus str_ind =\n      let new_ind, prec = parse_positive str_ind end_ind 0 in\n      parse_after_precision pct_ind new_ind end_ind minus plus hash space ign\n        pad (Lit_precision prec) in\n    match str.[str_ind] with\n    | '0' .. '9' -> parse_literal minus str_ind\n    | ('+' | '-') as symb when legacy_behavior ->\n      (* Legacy mode would accept and ignore '+' or '-' before the\n         integer describing the desired precision; note that this\n         cannot happen for padding width, as '+' and '-' already have\n         a semantics there.\n\n         That said, the idea (supported by this tweak) that width and\n         precision literals are \"integer literals\" in the OCaml sense is\n         still blatantly wrong, as 123_456 or 0xFF are rejected. *)\n      parse_literal (minus || symb = '-') (str_ind + 1)\n    | '*' ->\n      parse_after_precision pct_ind (str_ind + 1) end_ind minus plus hash space\n        ign pad Arg_precision\n    | _ ->\n      if legacy_behavior then\n        (* note that legacy implementation did not ignore '.' without\n           a number (as it does for padding indications), but\n           interprets it as '.0' *)\n        parse_after_precision pct_ind str_ind end_ind minus plus hash space ign\n          pad (Lit_precision 0)\n      else\n        invalid_format_without (str_ind - 1) '.' \"precision\"\n\n  (* Try to read the conversion. *)\n  and parse_after_precision : type x y z t e f .\n      int -> int -> int -> bool -> bool -> bool -> bool -> bool ->\n        (x, y) padding -> (z, t) precision -> (_, _, e, f) fmt_ebb =\n  fun pct_ind str_ind end_ind minus plus hash space ign pad prec ->\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    let parse_conv (type u) (type v) (padprec : (u, v) padding) =\n      parse_conversion pct_ind (str_ind + 1) end_ind plus hash space ign pad\n        prec padprec str.[str_ind] in\n    (* in legacy mode, some formats (%s and %S) accept a weird mix of\n       padding and precision, which is merged as a single padding\n       information. For example, in %.10s the precision is implicitly\n       understood as padding %10s, but the left-padding component may\n       be specified either as a left padding or a negative precision:\n       %-.3s and %.-3s are equivalent to %-3s *)\n    match pad with\n    | No_padding -> (\n      match minus, prec with\n        | _, No_precision -> parse_conv No_padding\n        | false, Lit_precision n -> parse_conv (Lit_padding (Right, n))\n        | true, Lit_precision n -> parse_conv (Lit_padding (Left, n))\n        | false, Arg_precision -> parse_conv (Arg_padding Right)\n        | true, Arg_precision -> parse_conv (Arg_padding Left)\n    )\n    | pad -> parse_conv pad\n\n  (* Case analysis on conversion. *)\n  and parse_conversion : type x y z t u v e f .\n      int -> int -> int -> bool -> bool -> bool -> bool -> (x, y) padding ->\n        (z, t) precision -> (u, v) padding -> char -> (_, _, e, f) fmt_ebb =\n  fun pct_ind str_ind end_ind plus hash space ign pad prec padprec symb ->\n    (* Flags used to check option usages/compatibilities. *)\n    let plus_used  = ref false and hash_used = ref false\n    and space_used = ref false and ign_used   = ref false\n    and pad_used   = ref false and prec_used  = ref false in\n\n    (* Access to options, update flags. *)\n    let get_plus    () = plus_used  := true; plus\n    and get_hash   () = hash_used := true; hash\n    and get_space   () = space_used := true; space\n    and get_ign     () = ign_used   := true; ign\n    and get_pad     () = pad_used   := true; pad\n    and get_prec    () = prec_used  := true; prec\n    and get_padprec () = pad_used   := true; padprec in\n\n    let get_int_pad () : (x,y) padding =\n      (* %5.3d is accepted and meaningful: pad to length 5 with\n         spaces, but first pad with zeros upto length 3 (0-padding\n         is the interpretation of \"precision\" for integer formats).\n\n         %05.3d is redundant: pad to length 5 *with zeros*, but\n         first pad with zeros... To add insult to the injury, the\n         legacy implementation ignores the 0-padding indication and\n         does the 5 padding with spaces instead. We reuse this\n         interpretation for compatibility, but statically reject this\n         format when the legacy mode is disabled, to protect strict\n         users from this corner case. *)\n       match get_pad (), get_prec () with\n         | pad, No_precision -> pad\n         | No_padding, _     -> No_padding\n         | Lit_padding (Zeros, n), _ ->\n           if legacy_behavior then Lit_padding (Right, n)\n           else incompatible_flag pct_ind str_ind '0' \"precision\"\n         | Arg_padding Zeros, _ ->\n           if legacy_behavior then Arg_padding Right\n           else incompatible_flag pct_ind str_ind '0' \"precision\"\n         | Lit_padding _ as pad, _ -> pad\n         | Arg_padding _ as pad, _ -> pad in\n\n    (* Check that padty <> Zeros. *)\n    let check_no_0 symb (type a b) (pad : (a, b) padding) : (a,b) padding =\n      match pad with\n      | No_padding -> pad\n      | Lit_padding ((Left | Right), _) -> pad\n      | Arg_padding (Left | Right) -> pad\n      | Lit_padding (Zeros, width) ->\n        if legacy_behavior then Lit_padding (Right, width)\n        else incompatible_flag pct_ind str_ind symb \"0\"\n      | Arg_padding Zeros ->\n        if legacy_behavior then Arg_padding Right\n        else incompatible_flag pct_ind str_ind symb \"0\"\n    in\n\n    (* Get padding as a pad_option (see \"%_\", \"%{\", \"%(\" and \"%[\").\n       (no need for legacy mode tweaking, those were rejected by the\n       legacy parser as well) *)\n    let opt_of_pad c (type a) (type b) (pad : (a, b) padding) = match pad with\n      | No_padding -> None\n      | Lit_padding (Right, width) -> Some width\n      | Lit_padding (Zeros, width) ->\n        if legacy_behavior then Some width\n        else incompatible_flag pct_ind str_ind c \"'0'\"\n      | Lit_padding (Left, width) ->\n        if legacy_behavior then Some width\n        else incompatible_flag pct_ind str_ind c \"'-'\"\n      | Arg_padding _ -> incompatible_flag pct_ind str_ind c \"'*'\"\n    in\n    let get_pad_opt c = opt_of_pad c (get_pad ()) in\n    let get_padprec_opt c = opt_of_pad c (get_padprec ()) in\n\n    (* Get precision as a prec_option (see \"%_f\").\n       (no need for legacy mode tweaking, those were rejected by the\n       legacy parser as well) *)\n    let get_prec_opt () = match get_prec () with\n      | No_precision       -> None\n      | Lit_precision ndec -> Some ndec\n      | Arg_precision      -> incompatible_flag pct_ind str_ind '_' \"'*'\"\n    in\n\n    let fmt_result = match symb with\n    | ',' ->\n      parse str_ind end_ind\n    | 'c' ->\n      let char_format fmt_rest = (* %c *)\n        if get_ign ()\n        then Fmt_EBB (Ignored_param (Ignored_char, fmt_rest))\n        else Fmt_EBB (Char fmt_rest)\n      in\n      let scan_format fmt_rest = (* %0c *)\n        if get_ign ()\n        then Fmt_EBB (Ignored_param (Ignored_scan_next_char, fmt_rest))\n        else Fmt_EBB (Scan_next_char fmt_rest)\n      in\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      begin match get_pad_opt 'c' with\n        | None -> char_format fmt_rest\n        | Some 0 -> scan_format fmt_rest\n        | Some _n ->\n           if not legacy_behavior\n           then invalid_nonnull_char_width str_ind\n           else (* legacy ignores %c widths *) char_format fmt_rest\n      end\n    | 'C' ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      if get_ign () then Fmt_EBB (Ignored_param (Ignored_caml_char,fmt_rest))\n      else Fmt_EBB (Caml_char fmt_rest)\n    | 's' ->\n      let pad = check_no_0 symb (get_padprec ()) in\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      if get_ign () then\n        let ignored = Ignored_string (get_padprec_opt '_') in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padding_fmt_EBB (pad', fmt_rest') =\n          make_padding_fmt_ebb pad fmt_rest in\n        Fmt_EBB (String (pad', fmt_rest'))\n    | 'S' ->\n      let pad = check_no_0 symb (get_padprec ()) in\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      if get_ign () then\n        let ignored = Ignored_caml_string (get_padprec_opt '_') in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padding_fmt_EBB (pad', fmt_rest') =\n          make_padding_fmt_ebb pad fmt_rest in\n        Fmt_EBB (Caml_string (pad', fmt_rest'))\n    | 'd' | 'i' | 'x' | 'X' | 'o' | 'u' ->\n      let iconv = compute_int_conv pct_ind str_ind (get_plus ()) (get_hash ())\n        (get_space ()) symb in\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      if get_ign () then\n        let ignored = Ignored_int (iconv, get_pad_opt '_') in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padprec_fmt_EBB (pad', prec', fmt_rest') =\n          make_padprec_fmt_ebb (get_int_pad ()) (get_prec ()) fmt_rest in\n        Fmt_EBB (Int (iconv, pad', prec', fmt_rest'))\n    | 'N' ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      let counter = Token_counter in\n      if get_ign () then\n        let ignored = Ignored_scan_get_counter counter in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        Fmt_EBB (Scan_get_counter (counter, fmt_rest))\n    | 'l' | 'n' | 'L' when str_ind=end_ind || not (is_int_base str.[str_ind]) ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      let counter = counter_of_char symb in\n      if get_ign () then\n        let ignored = Ignored_scan_get_counter counter in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        Fmt_EBB (Scan_get_counter (counter, fmt_rest))\n    | 'l' ->\n      let iconv =\n        compute_int_conv pct_ind (str_ind + 1) (get_plus ()) (get_hash ())\n          (get_space ()) str.[str_ind] in\n      let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n      if get_ign () then\n        let ignored = Ignored_int32 (iconv, get_pad_opt '_') in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padprec_fmt_EBB (pad', prec', fmt_rest') =\n          make_padprec_fmt_ebb (get_int_pad ()) (get_prec ()) fmt_rest in\n        Fmt_EBB (Int32 (iconv, pad', prec', fmt_rest'))\n    | 'n' ->\n      let iconv =\n        compute_int_conv pct_ind (str_ind + 1) (get_plus ())\n          (get_hash ()) (get_space ()) str.[str_ind] in\n      let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n      if get_ign () then\n        let ignored = Ignored_nativeint (iconv, get_pad_opt '_') in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padprec_fmt_EBB (pad', prec', fmt_rest') =\n          make_padprec_fmt_ebb (get_int_pad ()) (get_prec ()) fmt_rest in\n        Fmt_EBB (Nativeint (iconv, pad', prec', fmt_rest'))\n    | 'L' ->\n      let iconv =\n        compute_int_conv pct_ind (str_ind + 1) (get_plus ()) (get_hash ())\n          (get_space ()) str.[str_ind] in\n      let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n      if get_ign () then\n        let ignored = Ignored_int64 (iconv, get_pad_opt '_') in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padprec_fmt_EBB (pad', prec', fmt_rest') =\n          make_padprec_fmt_ebb (get_int_pad ()) (get_prec ()) fmt_rest in\n        Fmt_EBB (Int64 (iconv, pad', prec', fmt_rest'))\n    | 'f' | 'e' | 'E' | 'g' | 'G' | 'F' | 'h' | 'H' ->\n      let fconv =\n        compute_float_conv pct_ind str_ind\n          (get_plus ()) (get_hash ()) (get_space ()) symb in\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      if get_ign () then\n        let ignored = Ignored_float (get_pad_opt '_', get_prec_opt ()) in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padprec_fmt_EBB (pad', prec', fmt_rest') =\n          make_padprec_fmt_ebb (get_pad ()) (get_prec ()) fmt_rest in\n        Fmt_EBB (Float (fconv, pad', prec', fmt_rest'))\n    | 'b' | 'B' ->\n      let pad = check_no_0 symb (get_padprec ()) in\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      if get_ign () then\n        let ignored = Ignored_bool (get_padprec_opt '_') in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padding_fmt_EBB (pad', fmt_rest') =\n          make_padding_fmt_ebb pad fmt_rest in\n        Fmt_EBB (Bool (pad', fmt_rest'))\n    | 'a' ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      Fmt_EBB (Alpha fmt_rest)\n    | 't' ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      Fmt_EBB (Theta fmt_rest)\n    | 'r' ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      if get_ign () then Fmt_EBB (Ignored_param (Ignored_reader, fmt_rest))\n      else Fmt_EBB (Reader fmt_rest)\n    | '!' ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      Fmt_EBB (Flush fmt_rest)\n    | ('%' | '@') as c ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      Fmt_EBB (Char_literal (c, fmt_rest))\n    | '{' ->\n      let sub_end = search_subformat_end str_ind end_ind '}' in\n      let Fmt_EBB sub_fmt = parse str_ind sub_end in\n      let Fmt_EBB fmt_rest = parse (sub_end + 2) end_ind in\n      let sub_fmtty = fmtty_of_fmt sub_fmt in\n      if get_ign () then\n        let ignored = Ignored_format_arg (get_pad_opt '_', sub_fmtty) in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        Fmt_EBB (Format_arg (get_pad_opt '{', sub_fmtty, fmt_rest))\n    | '(' ->\n      let sub_end = search_subformat_end str_ind end_ind ')' in\n      let Fmt_EBB fmt_rest = parse (sub_end + 2) end_ind in\n      let Fmt_EBB sub_fmt = parse str_ind sub_end in\n      let sub_fmtty = fmtty_of_fmt sub_fmt in\n      if get_ign () then\n        let ignored = Ignored_format_subst (get_pad_opt '_', sub_fmtty) in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        Fmt_EBB (Format_subst (get_pad_opt '(', sub_fmtty, fmt_rest))\n    | '[' ->\n      let next_ind, char_set = parse_char_set str_ind end_ind in\n      let Fmt_EBB fmt_rest = parse next_ind end_ind in\n      if get_ign () then\n        let ignored = Ignored_scan_char_set (get_pad_opt '_', char_set) in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        Fmt_EBB (Scan_char_set (get_pad_opt '[', char_set, fmt_rest))\n    | '-' | '+' | '#' | ' ' | '_' ->\n      failwith_message\n        \"invalid format %S: at character number %d, \\\n         flag %C is only allowed after the '%%', before padding and precision\"\n        str pct_ind symb\n    | _ ->\n      failwith_message\n        \"invalid format %S: at character number %d, \\\n         invalid conversion \\\"%%%c\\\"\" str (str_ind - 1) symb\n    in\n    (* Check for unused options, and reject them as incompatible.\n\n       Such checks need to be disabled in legacy mode, as the legacy\n       parser silently ignored incompatible flags. *)\n    if not legacy_behavior then begin\n    if not !plus_used && plus then\n      incompatible_flag pct_ind str_ind symb \"'+'\";\n    if not !hash_used && hash then\n      incompatible_flag pct_ind str_ind symb \"'#'\";\n    if not !space_used && space then\n      incompatible_flag pct_ind str_ind symb \"' '\";\n    if not !pad_used  && Padding_EBB pad <> Padding_EBB No_padding then\n      incompatible_flag pct_ind str_ind symb \"`padding'\";\n    if not !prec_used && Precision_EBB prec <> Precision_EBB No_precision then\n      incompatible_flag pct_ind str_ind (if ign then '_' else symb)\n        \"`precision'\";\n    if ign && plus then incompatible_flag pct_ind str_ind '_' \"'+'\";\n    end;\n    (* this last test must not be disabled in legacy mode,\n       as ignoring it would typically result in a different typing\n       than what the legacy parser used *)\n    if not !ign_used && ign then\n      begin match symb with\n        (* argument-less formats can safely be ignored in legacy mode *)\n        | ('@' | '%' | '!' | ',') when legacy_behavior -> ()\n        | _ ->\n          incompatible_flag pct_ind str_ind symb \"'_'\"\n      end;\n    fmt_result\n\n  (* Parse formatting information (after '@'). *)\n  and parse_after_at : type e f . int -> int -> (_, _, e, f) fmt_ebb =\n  fun str_ind end_ind ->\n    if str_ind = end_ind then Fmt_EBB (Char_literal ('@', End_of_format))\n    else\n      match str.[str_ind] with\n      | '[' ->\n        parse_tag false (str_ind + 1) end_ind\n      | ']' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Close_box, fmt_rest))\n      | '{' ->\n        parse_tag true (str_ind + 1) end_ind\n      | '}' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Close_tag, fmt_rest))\n      | ',' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Break (\"@,\", 0, 0), fmt_rest))\n      | ' ' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Break (\"@ \", 1, 0), fmt_rest))\n      | ';' ->\n        parse_good_break (str_ind + 1) end_ind\n      | '?' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (FFlush, fmt_rest))\n      | '\\n' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Force_newline, fmt_rest))\n      | '.' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Flush_newline, fmt_rest))\n      | '<' ->\n        parse_magic_size (str_ind + 1) end_ind\n      | '@' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Escaped_at, fmt_rest))\n      | '%' when str_ind + 1 < end_ind && str.[str_ind + 1] = '%' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 2) end_ind in\n        Fmt_EBB (Formatting_lit (Escaped_percent, fmt_rest))\n      | '%' ->\n        let Fmt_EBB fmt_rest = parse str_ind end_ind in\n        Fmt_EBB (Char_literal ('@', fmt_rest))\n      | c ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Scan_indic c, fmt_rest))\n\n  (* Try to read the optional <name> after \"@{\" or \"@[\". *)\n  and parse_tag : type e f . bool -> int -> int -> (_, _, e, f) fmt_ebb =\n  fun is_open_tag str_ind end_ind ->\n    try\n      if str_ind = end_ind then raise Not_found;\n      match str.[str_ind] with\n      | '<' ->\n        let ind = String.index_from str (str_ind + 1) '>' in\n        if ind >= end_ind then raise Not_found;\n        let sub_str = String.sub str str_ind (ind - str_ind + 1) in\n        let Fmt_EBB fmt_rest = parse (ind + 1) end_ind in\n        let Fmt_EBB sub_fmt = parse str_ind (ind + 1) in\n        let sub_format = Format (sub_fmt, sub_str) in\n        let formatting =\n          if is_open_tag then Open_tag sub_format else Open_box sub_format in\n        Fmt_EBB (Formatting_gen (formatting, fmt_rest))\n      | _ ->\n        raise Not_found\n    with Not_found ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      let sub_format = Format (End_of_format, \"\") in\n      let formatting =\n        if is_open_tag then Open_tag sub_format else Open_box sub_format in\n      Fmt_EBB (Formatting_gen (formatting, fmt_rest))\n\n  (* Try to read the optional <width offset> after \"@;\". *)\n  and parse_good_break : type e f . int -> int -> (_, _, e, f) fmt_ebb =\n  fun str_ind end_ind ->\n    let next_ind, formatting_lit =\n      try\n        if str_ind = end_ind || str.[str_ind] <> '<' then raise Not_found;\n        let str_ind_1 = parse_spaces (str_ind + 1) end_ind in\n        match str.[str_ind_1] with\n        | '0' .. '9' | '-' -> (\n          let str_ind_2, width = parse_integer str_ind_1 end_ind in\n            let str_ind_3 = parse_spaces str_ind_2 end_ind in\n            match str.[str_ind_3] with\n              | '>' ->\n                let s = String.sub str (str_ind-2) (str_ind_3-str_ind+3) in\n                str_ind_3 + 1, Break (s, width, 0)\n              | '0' .. '9' | '-' ->\n                let str_ind_4, offset = parse_integer str_ind_3 end_ind in\n                let str_ind_5 = parse_spaces str_ind_4 end_ind in\n                if str.[str_ind_5] <> '>' then raise Not_found;\n                let s = String.sub str (str_ind-2) (str_ind_5-str_ind+3) in\n                str_ind_5 + 1, Break (s, width, offset)\n              | _ -> raise Not_found\n        )\n        | _ -> raise Not_found\n      with Not_found | Failure _ ->\n        str_ind, Break (\"@;\", 1, 0)\n    in\n    let Fmt_EBB fmt_rest = parse next_ind end_ind in\n    Fmt_EBB (Formatting_lit (formatting_lit, fmt_rest))\n\n  (* Parse the size in a <n>. *)\n  and parse_magic_size : type e f . int -> int -> (_, _, e, f) fmt_ebb =\n  fun str_ind end_ind ->\n    match\n      try\n        let str_ind_1 = parse_spaces str_ind end_ind in\n        match str.[str_ind_1] with\n        | '0' .. '9' | '-' ->\n          let str_ind_2, size = parse_integer str_ind_1 end_ind in\n          let str_ind_3 = parse_spaces str_ind_2 end_ind in\n          if str.[str_ind_3] <> '>' then raise Not_found;\n          let s = String.sub str (str_ind - 2) (str_ind_3 - str_ind + 3) in\n          Some (str_ind_3 + 1, Magic_size (s, size))\n        | _ -> None\n      with Not_found | Failure _ ->\n        None\n    with\n    | Some (next_ind, formatting_lit) ->\n      let Fmt_EBB fmt_rest = parse next_ind end_ind in\n      Fmt_EBB (Formatting_lit (formatting_lit, fmt_rest))\n    | None ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      Fmt_EBB (Formatting_lit (Scan_indic '<', fmt_rest))\n\n  (* Parse and construct a char set. *)\n  and parse_char_set str_ind end_ind =\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n\n    let char_set = create_char_set () in\n    let add_char c =\n      add_in_char_set char_set c;\n    in\n    let add_range c c' =\n      for i = int_of_char c to int_of_char c' do\n        add_in_char_set char_set (char_of_int i);\n      done;\n    in\n\n    let fail_single_percent str_ind =\n      failwith_message\n        \"invalid format %S: '%%' alone is not accepted in character sets, \\\n         use %%%% instead at position %d.\" str str_ind\n    in\n\n    (* Parse the first character of a char set. *)\n    let rec parse_char_set_start str_ind end_ind =\n      if str_ind = end_ind then unexpected_end_of_format end_ind;\n      let c = str.[str_ind] in\n      parse_char_set_after_char (str_ind + 1) end_ind c\n\n    (* Parse the content of a char set until the first ']'. *)\n    and parse_char_set_content str_ind end_ind =\n      if str_ind = end_ind then unexpected_end_of_format end_ind;\n      match str.[str_ind] with\n      | ']' ->\n        str_ind + 1\n      | '-' ->\n        add_char '-';\n        parse_char_set_content (str_ind + 1) end_ind\n      | c ->\n        parse_char_set_after_char (str_ind + 1) end_ind c\n\n    (* Test for range in char set. *)\n    and parse_char_set_after_char str_ind end_ind c =\n      if str_ind = end_ind then unexpected_end_of_format end_ind;\n      match str.[str_ind] with\n      | ']' ->\n        add_char c;\n        str_ind + 1\n      | '-' ->\n        parse_char_set_after_minus (str_ind + 1) end_ind c\n      | ('%' | '@') as c' when c = '%' ->\n        add_char c';\n        parse_char_set_content (str_ind + 1) end_ind\n      | c' ->\n        if c = '%' then fail_single_percent str_ind;\n        (* note that '@' alone is accepted, as done by the legacy\n           implementation; the documentation specifically requires %@\n           so we could warn on that *)\n        add_char c;\n        parse_char_set_after_char (str_ind + 1) end_ind c'\n\n    (* Manage range in char set (except if the '-' the last char before ']') *)\n    and parse_char_set_after_minus str_ind end_ind c =\n      if str_ind = end_ind then unexpected_end_of_format end_ind;\n      match str.[str_ind] with\n      | ']' ->\n        add_char c;\n        add_char '-';\n        str_ind + 1\n      | '%' ->\n        if str_ind + 1 = end_ind then unexpected_end_of_format end_ind;\n        begin match str.[str_ind + 1] with\n          | ('%' | '@') as c' ->\n            add_range c c';\n            parse_char_set_content (str_ind + 2) end_ind\n          | _ -> fail_single_percent str_ind\n        end\n      | c' ->\n        add_range c c';\n        parse_char_set_content (str_ind + 1) end_ind\n    in\n    let str_ind, reverse =\n      if str_ind = end_ind then unexpected_end_of_format end_ind;\n      match str.[str_ind] with\n        | '^' -> str_ind + 1, true\n        | _ -> str_ind, false in\n    let next_ind = parse_char_set_start str_ind end_ind in\n    let char_set = freeze_char_set char_set in\n    next_ind, (if reverse then rev_char_set char_set else char_set)\n\n  (* Consume all next spaces, raise an Failure if end_ind is reached. *)\n  and parse_spaces str_ind end_ind =\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    if str.[str_ind] = ' ' then parse_spaces (str_ind + 1) end_ind else str_ind\n\n  (* Read a positive integer from the string, raise a Failure if end_ind is\n     reached. *)\n  and parse_positive str_ind end_ind acc =\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    match str.[str_ind] with\n    | '0' .. '9' as c ->\n      let new_acc = acc * 10 + (int_of_char c - int_of_char '0') in\n      if new_acc > Sys.max_string_length then\n        failwith_message\n          \"invalid format %S: integer %d is greater than the limit %d\"\n          str new_acc Sys.max_string_length\n      else\n        parse_positive (str_ind + 1) end_ind new_acc\n    | _ -> str_ind, acc\n\n  (* Read a positive or negative integer from the string, raise a Failure\n     if end_ind is reached. *)\n  and parse_integer str_ind end_ind =\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    match str.[str_ind] with\n    | '0' .. '9' -> parse_positive str_ind end_ind 0\n    | '-' -> (\n      if str_ind + 1 = end_ind then unexpected_end_of_format end_ind;\n      match str.[str_ind + 1] with\n      | '0' .. '9' ->\n        let next_ind, n = parse_positive (str_ind + 1) end_ind 0 in\n        next_ind, -n\n      | c ->\n        expected_character (str_ind + 1) \"digit\" c\n    )\n    | _ -> assert false\n\n  (* Add a literal to a format from a literal character sub-sequence. *)\n  and add_literal : type a d e f .\n      int -> int -> (a, _, _, d, e, f) fmt ->\n      (_, _, e, f) fmt_ebb =\n  fun lit_start str_ind fmt -> match str_ind - lit_start with\n    | 0    -> Fmt_EBB fmt\n    | 1    -> Fmt_EBB (Char_literal (str.[lit_start], fmt))\n    | size -> Fmt_EBB (String_literal (String.sub str lit_start size, fmt))\n\n  (* Search the end of the current sub-format\n     (i.e. the corresponding \"%}\" or \"%)\") *)\n  and search_subformat_end str_ind end_ind c =\n    if str_ind = end_ind then\n      failwith_message\n        \"invalid format %S: unclosed sub-format, \\\n         expected \\\"%%%c\\\" at character number %d\" str c end_ind;\n    match str.[str_ind] with\n    | '%' ->\n      if str_ind + 1 = end_ind then unexpected_end_of_format end_ind;\n      if str.[str_ind + 1] = c then (* End of format found *) str_ind else\n        begin match str.[str_ind + 1] with\n        | '_' ->\n          (* Search for \"%_(\" or \"%_{\". *)\n          if str_ind + 2 = end_ind then unexpected_end_of_format end_ind;\n          begin match str.[str_ind + 2] with\n          | '{' ->\n            let sub_end = search_subformat_end (str_ind + 3) end_ind '}' in\n            search_subformat_end (sub_end + 2) end_ind c\n          | '(' ->\n            let sub_end = search_subformat_end (str_ind + 3) end_ind ')' in\n            search_subformat_end (sub_end + 2) end_ind c\n          | _ -> search_subformat_end (str_ind + 3) end_ind c\n          end\n        | '{' ->\n          (* %{...%} sub-format found. *)\n          let sub_end = search_subformat_end (str_ind + 2) end_ind '}' in\n          search_subformat_end (sub_end + 2) end_ind c\n        | '(' ->\n          (* %(...%) sub-format found. *)\n          let sub_end = search_subformat_end (str_ind + 2) end_ind ')' in\n          search_subformat_end (sub_end + 2) end_ind c\n        | '}' ->\n          (* Error: %(...%}. *)\n          expected_character (str_ind + 1) \"character ')'\" '}'\n        | ')' ->\n          (* Error: %{...%). *)\n          expected_character (str_ind + 1) \"character '}'\" ')'\n        | _ ->\n          search_subformat_end (str_ind + 2) end_ind c\n        end\n    | _ -> search_subformat_end (str_ind + 1) end_ind c\n\n  (* Check if symb is a valid int conversion after \"%l\", \"%n\" or \"%L\" *)\n  and is_int_base symb = match symb with\n    | 'd' | 'i' | 'x' | 'X' | 'o' | 'u' -> true\n    | _ -> false\n\n  (* Convert a char (l, n or L) to its associated counter. *)\n  and counter_of_char symb = match symb with\n    | 'l' -> Line_counter  | 'n' -> Char_counter\n    | 'L' -> Token_counter | _ -> assert false\n\n  (* Convert (plus, symb) to its associated int_conv. *)\n  and compute_int_conv pct_ind str_ind plus hash space symb =\n    match plus, hash, space, symb with\n    | false, false, false, 'd' -> Int_d  | false, false, false, 'i' -> Int_i\n    | false, false,  true, 'd' -> Int_sd | false, false,  true, 'i' -> Int_si\n    |  true, false, false, 'd' -> Int_pd |  true, false, false, 'i' -> Int_pi\n    | false, false, false, 'x' -> Int_x  | false, false, false, 'X' -> Int_X\n    | false,  true, false, 'x' -> Int_Cx | false,  true, false, 'X' -> Int_CX\n    | false, false, false, 'o' -> Int_o\n    | false,  true, false, 'o' -> Int_Co\n    | false, false, false, 'u' -> Int_u\n    | false,  true, false, 'd' -> Int_Cd\n    | false,  true, false, 'i' -> Int_Ci\n    | false,  true, false, 'u' -> Int_Cu\n    | _, true, _, 'x' when legacy_behavior -> Int_Cx\n    | _, true, _, 'X' when legacy_behavior -> Int_CX\n    | _, true, _, 'o' when legacy_behavior -> Int_Co\n    | _, true, _, ('d' | 'i' | 'u') ->\n      if legacy_behavior then (* ignore *)\n        compute_int_conv pct_ind str_ind plus false space symb\n      else incompatible_flag pct_ind str_ind symb \"'#'\"\n    | true, _, true, _ ->\n      if legacy_behavior then\n        (* plus and space: legacy implementation prefers plus *)\n        compute_int_conv pct_ind str_ind plus hash false symb\n      else incompatible_flag pct_ind str_ind ' ' \"'+'\"\n    | false, _, true, _    ->\n      if legacy_behavior then (* ignore *)\n        compute_int_conv pct_ind str_ind plus hash false symb\n      else incompatible_flag pct_ind str_ind symb \"' '\"\n    | true, _, false, _    ->\n      if legacy_behavior then (* ignore *)\n        compute_int_conv pct_ind str_ind false hash space symb\n      else incompatible_flag pct_ind str_ind symb \"'+'\"\n    | false, _, false, _ -> assert false\n\n  (* Convert (plus, space, symb) to its associated float_conv. *)\n  and compute_float_conv pct_ind str_ind plus hash space symb =\n    let flag = match plus, space with\n    | false, false -> Float_flag_\n    | false,  true -> Float_flag_s\n    |  true, false -> Float_flag_p\n    |  true,  true ->\n      (* plus and space: legacy implementation prefers plus *)\n      if legacy_behavior then Float_flag_p\n      else incompatible_flag pct_ind str_ind ' ' \"'+'\" in\n    let kind = match hash, symb with\n    | _, 'f' -> Float_f\n    | _, 'e' -> Float_e\n    | _, 'E' -> Float_E\n    | _, 'g' -> Float_g\n    | _, 'G' -> Float_G\n    | _, 'h' -> Float_h\n    | _, 'H' -> Float_H\n    | false, 'F' -> Float_F\n    | true, 'F' -> Float_CF\n    | _ -> assert false in\n    flag, kind\n\n  (* Raise [Failure] with a friendly error message about incompatible options.*)\n  and incompatible_flag : type a . int -> int -> char -> string -> a =\n    fun pct_ind str_ind symb option ->\n      let subfmt = String.sub str pct_ind (str_ind - pct_ind) in\n      failwith_message\n        \"invalid format %S: at character number %d, \\\n         %s is incompatible with '%c' in sub-format %S\"\n        str pct_ind option symb subfmt\n\n  in parse 0 (String.length str)\n\n(******************************************************************************)\n                  (* Guarded string to format conversions *)\n\n(* Convert a string to a format according to an fmtty. *)\n(* Raise [Failure] with an error message in case of type mismatch. *)\nlet format_of_string_fmtty str fmtty =\n  let Fmt_EBB fmt = fmt_ebb_of_string str in\n  try Format (type_format fmt fmtty, str)\n  with Type_mismatch ->\n    failwith_message\n      \"bad input: format type mismatch between %S and %S\"\n      str (string_of_fmtty fmtty)\n\n(* Convert a string to a format compatible with an other format. *)\n(* Raise [Failure] with an error message in case of type mismatch. *)\nlet format_of_string_format str (Format (fmt', str')) =\n  let Fmt_EBB fmt = fmt_ebb_of_string str in\n  try Format (type_format fmt (fmtty_of_fmt fmt'), str)\n  with Type_mismatch ->\n    failwith_message\n      \"bad input: format type mismatch between %S and %S\" str str'\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*   Xavier Leroy and Pierre Weis, projet Cristal, INRIA Rocquencourt     *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nopen CamlinternalFormatBasics\nopen CamlinternalFormat\n\nlet kfprintf k o (Format (fmt, _)) =\n  make_printf (fun acc -> output_acc o acc; k o) End_of_acc fmt\nlet kbprintf k b (Format (fmt, _)) =\n  make_printf (fun acc -> bufput_acc b acc; k b) End_of_acc fmt\nlet ikfprintf k oc (Format (fmt, _)) =\n  make_iprintf k oc fmt\nlet ikbprintf = ikfprintf\n\nlet fprintf oc fmt = kfprintf ignore oc fmt\nlet bprintf b fmt = kbprintf ignore b fmt\nlet ifprintf oc fmt = ikfprintf ignore oc fmt\nlet ibprintf b fmt = ikbprintf ignore b fmt\nlet printf fmt = fprintf stdout fmt\nlet eprintf fmt = fprintf stderr fmt\n\nlet ksprintf k (Format (fmt, _)) =\n  let k' acc =\n    let buf = Buffer.create 64 in\n    strput_acc buf acc;\n    k (Buffer.contents buf) in\n  make_printf k' End_of_acc fmt\n\nlet sprintf fmt = ksprintf (fun s -> s) fmt\n\nlet kprintf = ksprintf\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nopen Printf\n\ntype t = exn = ..\n\nlet printers = Atomic.make []\n\nlet locfmt = format_of_string \"File \\\"%s\\\", line %d, characters %d-%d: %s\"\n\nlet field x i =\n  let f = Obj.field x i in\n  if not (Obj.is_block f) then\n    sprintf \"%d\" (Obj.magic f : int)           (* can also be a char *)\n  else if Obj.tag f = Obj.string_tag then\n    sprintf \"%S\" (Obj.magic f : string)\n  else if Obj.tag f = Obj.double_tag then\n    string_of_float (Obj.magic f : float)\n  else\n    \"_\"\n\nlet rec other_fields x i =\n  if i >= Obj.size x then \"\"\n  else sprintf \", %s%s\" (field x i) (other_fields x (i+1))\n\nlet fields x =\n  match Obj.size x with\n  | 0 -> \"\"\n  | 1 -> \"\"\n  | 2 -> sprintf \"(%s)\" (field x 1)\n  | _ -> sprintf \"(%s%s)\" (field x 1) (other_fields x 2)\n\nlet use_printers x =\n  let rec conv = function\n    | hd :: tl ->\n        (match hd x with\n         | None | exception _ -> conv tl\n         | Some s -> Some s)\n    | [] -> None in\n  conv (Atomic.get printers)\n\nlet to_string_default = function\n  | Out_of_memory -> \"Out of memory\"\n  | Stack_overflow -> \"Stack overflow\"\n  | Match_failure(file, line, char) ->\n      sprintf locfmt file line char (char+5) \"Pattern matching failed\"\n  | Assert_failure(file, line, char) ->\n      sprintf locfmt file line char (char+6) \"Assertion failed\"\n  | Undefined_recursive_module(file, line, char) ->\n      sprintf locfmt file line char (char+6) \"Undefined recursive module\"\n  | x ->\n      let x = Obj.repr x in\n      if Obj.tag x <> 0 then\n        (Obj.magic (Obj.field x 0) : string)\n      else\n        let constructor =\n          (Obj.magic (Obj.field (Obj.field x 0) 0) : string) in\n        constructor ^ (fields x)\n\nlet to_string e =\n  match use_printers e with\n  | Some s -> s\n  | None -> to_string_default e\n\nlet print fct arg =\n  try\n    fct arg\n  with x ->\n    eprintf \"Uncaught exception: %s\\n\" (to_string x);\n    flush stderr;\n    raise x\n\nlet catch fct arg =\n  try\n    fct arg\n  with x ->\n    flush stdout;\n    eprintf \"Uncaught exception: %s\\n\" (to_string x);\n    exit 2\n\ntype raw_backtrace_slot\ntype raw_backtrace_entry = private int\ntype raw_backtrace = raw_backtrace_entry array\n\nlet raw_backtrace_entries bt = bt\n\nexternal get_raw_backtrace:\n  unit -> raw_backtrace = \"caml_get_exception_raw_backtrace\"\n\nexternal raise_with_backtrace: exn -> raw_backtrace -> 'a\n  = \"%raise_with_backtrace\"\n\ntype backtrace_slot =\n  | Known_location of {\n      is_raise    : bool;\n      filename    : string;\n      line_number : int;\n      start_char  : int;\n      end_char    : int;\n      is_inline   : bool;\n      defname     : string;\n    }\n  | Unknown_location of {\n      is_raise : bool\n    }\n\n(* to avoid warning *)\nlet _ = [Known_location { is_raise = false; filename = \"\";\n                          line_number = 0; start_char = 0; end_char = 0;\n                          is_inline = false; defname = \"\" };\n         Unknown_location { is_raise = false }]\n\nexternal convert_raw_backtrace_slot:\n  raw_backtrace_slot -> backtrace_slot = \"caml_convert_raw_backtrace_slot\"\n\nexternal convert_raw_backtrace:\n  raw_backtrace -> backtrace_slot array = \"caml_convert_raw_backtrace\"\n\nlet convert_raw_backtrace bt =\n  try Some (convert_raw_backtrace bt)\n  with Failure _ -> None\n\nlet format_backtrace_slot pos slot =\n  let info is_raise =\n    if is_raise then\n      if pos = 0 then \"Raised at\" else \"Re-raised at\"\n    else\n      if pos = 0 then \"Raised by primitive operation at\" else \"Called from\"\n  in\n  match slot with\n  | Unknown_location l ->\n      if l.is_raise then\n        (* compiler-inserted re-raise, skipped *) None\n      else\n        Some (sprintf \"%s unknown location\" (info false))\n  | Known_location l ->\n      Some (sprintf \"%s %s in file \\\"%s\\\"%s, line %d, characters %d-%d\"\n              (info l.is_raise) l.defname l.filename\n              (if l.is_inline then \" (inlined)\" else \"\")\n              l.line_number l.start_char l.end_char)\n\nlet print_exception_backtrace outchan backtrace =\n  match backtrace with\n  | None ->\n      fprintf outchan\n        \"(Program not linked with -g, cannot print stack backtrace)\\n\"\n  | Some a ->\n      for i = 0 to Array.length a - 1 do\n        match format_backtrace_slot i a.(i) with\n          | None -> ()\n          | Some str -> fprintf outchan \"%s\\n\" str\n      done\n\nlet print_raw_backtrace outchan raw_backtrace =\n  print_exception_backtrace outchan (convert_raw_backtrace raw_backtrace)\n\n(* confusingly named: prints the global current backtrace *)\nlet print_backtrace outchan =\n  print_raw_backtrace outchan (get_raw_backtrace ())\n\nlet backtrace_to_string backtrace =\n  match backtrace with\n  | None ->\n     \"(Program not linked with -g, cannot print stack backtrace)\\n\"\n  | Some a ->\n      let b = Buffer.create 1024 in\n      for i = 0 to Array.length a - 1 do\n        match format_backtrace_slot i a.(i) with\n          | None -> ()\n          | Some str -> bprintf b \"%s\\n\" str\n      done;\n      Buffer.contents b\n\nlet raw_backtrace_to_string raw_backtrace =\n  backtrace_to_string (convert_raw_backtrace raw_backtrace)\n\nlet backtrace_slot_is_raise = function\n  | Known_location l -> l.is_raise\n  | Unknown_location l -> l.is_raise\n\nlet backtrace_slot_is_inline = function\n  | Known_location l -> l.is_inline\n  | Unknown_location _ -> false\n\ntype location = {\n  filename : string;\n  line_number : int;\n  start_char : int;\n  end_char : int;\n}\n\nlet backtrace_slot_location = function\n  | Unknown_location _ -> None\n  | Known_location l ->\n    Some {\n      filename    = l.filename;\n      line_number = l.line_number;\n      start_char  = l.start_char;\n      end_char    = l.end_char;\n    }\n\nlet backtrace_slot_defname = function\n  | Unknown_location _\n  | Known_location { defname = \"\" } -> None\n  | Known_location l -> Some l.defname\n\nlet backtrace_slots raw_backtrace =\n  (* The documentation of this function guarantees that Some is\n     returned only if a part of the trace is usable. This gives us\n     a bit more work than just convert_raw_backtrace, but it makes the\n     API more user-friendly -- otherwise most users would have to\n     reimplement the \"Program not linked with -g, sorry\" logic\n     themselves. *)\n  match convert_raw_backtrace raw_backtrace with\n    | None -> None\n    | Some backtrace ->\n      let usable_slot = function\n        | Unknown_location _ -> false\n        | Known_location _ -> true in\n      let rec exists_usable = function\n        | (-1) -> false\n        | i -> usable_slot backtrace.(i) || exists_usable (i - 1) in\n      if exists_usable (Array.length backtrace - 1)\n      then Some backtrace\n      else None\n\nlet backtrace_slots_of_raw_entry entry =\n  backtrace_slots [| entry |]\n\nmodule Slot = struct\n  type t = backtrace_slot\n  let format = format_backtrace_slot\n  let is_raise = backtrace_slot_is_raise\n  let is_inline = backtrace_slot_is_inline\n  let location = backtrace_slot_location\n  let name = backtrace_slot_defname\nend\n\nlet raw_backtrace_length bt = Array.length bt\n\nexternal get_raw_backtrace_slot :\n  raw_backtrace -> int -> raw_backtrace_slot = \"caml_raw_backtrace_slot\"\n\nexternal get_raw_backtrace_next_slot :\n  raw_backtrace_slot -> raw_backtrace_slot option\n  = \"caml_raw_backtrace_next_slot\"\n\n(* confusingly named:\n   returns the *string* corresponding to the global current backtrace *)\nlet get_backtrace () = raw_backtrace_to_string (get_raw_backtrace ())\n\nexternal record_backtrace: bool -> unit = \"caml_record_backtrace\"\nexternal backtrace_status: unit -> bool = \"caml_backtrace_status\"\n\nlet rec register_printer fn =\n  let old_printers = Atomic.get printers in\n  let new_printers = fn :: old_printers in\n  let success = Atomic.compare_and_set printers old_printers new_printers in\n  if not success then register_printer fn\n\nexternal get_callstack: int -> raw_backtrace = \"caml_get_current_callstack\"\n\nlet exn_slot x =\n  let x = Obj.repr x in\n  if Obj.tag x = 0 then Obj.field x 0 else x\n\nlet exn_slot_id x =\n  let slot = exn_slot x in\n  (Obj.obj (Obj.field slot 1) : int)\n\nlet exn_slot_name x =\n  let slot = exn_slot x in\n  (Obj.obj (Obj.field slot 0) : string)\n\nexternal get_debug_info_status : unit -> int = \"caml_ml_debug_info_status\"\n\n(* Descriptions for errors in startup.h. See also backtrace.c *)\nlet errors = [| \"\";\n  (* FILE_NOT_FOUND *)\n  \"(Cannot print locations:\\n \\\n      bytecode executable program file not found)\";\n  (* BAD_BYTECODE *)\n  \"(Cannot print locations:\\n \\\n      bytecode executable program file appears to be corrupt)\";\n  (* WRONG_MAGIC *)\n  \"(Cannot print locations:\\n \\\n      bytecode executable program file has wrong magic number)\";\n  (* NO_FDS *)\n  \"(Cannot print locations:\\n \\\n      bytecode executable program file cannot be opened;\\n \\\n      -- too many open files. Try running with OCAMLRUNPARAM=b=2)\"\n|]\n\nlet default_uncaught_exception_handler exn raw_backtrace =\n  eprintf \"Fatal error: exception %s\\n\" (to_string exn);\n  print_raw_backtrace stderr raw_backtrace;\n  let status = get_debug_info_status () in\n  if status < 0 then\n    prerr_endline errors.(abs status);\n  flush stderr\n\nlet uncaught_exception_handler = ref default_uncaught_exception_handler\n\nlet set_uncaught_exception_handler fn = uncaught_exception_handler := fn\n\nlet empty_backtrace : raw_backtrace = [| |]\n\nlet try_get_raw_backtrace () =\n  try\n    get_raw_backtrace ()\n  with _ (* Out_of_memory? *) ->\n    empty_backtrace\n\nlet handle_uncaught_exception' exn debugger_in_use =\n  try\n    (* Get the backtrace now, in case one of the [at_exit] function\n       destroys it. *)\n    let raw_backtrace =\n      if debugger_in_use (* Same test as in [runtime/printexc.c] *) then\n        empty_backtrace\n      else\n        try_get_raw_backtrace ()\n    in\n    (try Stdlib.do_at_exit () with _ -> ());\n    try\n      !uncaught_exception_handler exn raw_backtrace\n    with exn' ->\n      let raw_backtrace' = try_get_raw_backtrace () in\n      eprintf \"Fatal error: exception %s\\n\" (to_string exn);\n      print_raw_backtrace stderr raw_backtrace;\n      eprintf \"Fatal error in uncaught exception handler: exception %s\\n\"\n        (to_string exn');\n      print_raw_backtrace stderr raw_backtrace';\n      flush stderr\n  with\n    | Out_of_memory ->\n        prerr_endline\n          \"Fatal error: out of memory in uncaught exception handler\"\n\n(* This function is called by [caml_fatal_uncaught_exception] in\n   [runtime/printexc.c] which expects no exception is raised. *)\nlet handle_uncaught_exception exn debugger_in_use =\n  try\n    handle_uncaught_exception' exn debugger_in_use\n  with _ ->\n    (* There is not much we can do at this point *)\n    ()\n\nexternal register_named_value : string -> 'a -> unit\n  = \"caml_register_named_value\"\n\nlet () =\n  register_named_value \"Printexc.handle_uncaught_exception\"\n    handle_uncaught_exception\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Message digest (MD5) *)\n\ntype t = string\n\nlet compare = String.compare\nlet equal = String.equal\n\nexternal unsafe_string: string -> int -> int -> t = \"caml_md5_string\"\nexternal channel: in_channel -> int -> t = \"caml_md5_chan\"\n\nlet string str =\n  unsafe_string str 0 (String.length str)\n\nlet bytes b = string (Bytes.unsafe_to_string b)\n\nlet substring str ofs len =\n  if ofs < 0 || len < 0 || ofs > String.length str - len\n  then invalid_arg \"Digest.substring\"\n  else unsafe_string str ofs len\n\nlet subbytes b ofs len = substring (Bytes.unsafe_to_string b) ofs len\n\nlet file filename =\n  let ic = open_in_bin filename in\n  match channel ic (-1) with\n    | d -> close_in ic; d\n    | exception e -> close_in ic; raise e\n\nlet output chan digest =\n  output_string chan digest\n\nlet input chan = really_input_string chan 16\n\nlet char_hex n =\n  Char.unsafe_chr (n + if n < 10 then Char.code '0' else (Char.code 'a' - 10))\n\nlet to_hex d =\n  if String.length d <> 16 then invalid_arg \"Digest.to_hex\";\n  let result = Bytes.create 32 in\n  for i = 0 to 15 do\n    let x = Char.code d.[i] in\n    Bytes.unsafe_set result (i*2) (char_hex (x lsr 4));\n    Bytes.unsafe_set result (i*2+1) (char_hex (x land 0x0f));\n  done;\n  Bytes.unsafe_to_string result\n\nlet from_hex s =\n  if String.length s <> 32 then invalid_arg \"Digest.from_hex\";\n  let digit c =\n    match c with\n    | '0'..'9' -> Char.code c - Char.code '0'\n    | 'A'..'F' -> Char.code c - Char.code 'A' + 10\n    | 'a'..'f' -> Char.code c - Char.code 'a' + 10\n    | _ -> raise (Invalid_argument \"Digest.from_hex\")\n  in\n  let byte i = digit s.[i] lsl 4 + digit s.[i+1] in\n  let result = Bytes.create 16 in\n  for i = 0 to 15 do\n    Bytes.set result i (Char.chr (byte (2 * i)));\n  done;\n  Bytes.unsafe_to_string result\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*               Damien Doligez, projet Para, INRIA Rocquencourt          *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Pseudo-random number generator\n   This is a lagged-Fibonacci F(55, 24, +) with a modified addition\n   function to enhance the mixing of bits.\n   If we use normal addition, the low-order bit fails tests 1 and 7\n   of the Diehard test suite, and bits 1 and 2 also fail test 7.\n   If we use multiplication as suggested by Marsaglia, it doesn't fare\n   much better.\n   By mixing the bits of one of the numbers before addition (XOR the\n   5 high-order bits into the low-order bits), we get a generator that\n   passes all the Diehard tests.\n*)\n\nexternal random_seed: unit -> int array = \"caml_sys_random_seed\"\n\nmodule State = struct\n\n  type t = { st : int array; mutable idx : int }\n\n  let new_state () = { st = Array.make 55 0; idx = 0 }\n  let assign st1 st2 =\n    Array.blit st2.st 0 st1.st 0 55;\n    st1.idx <- st2.idx\n\n\n  let full_init s seed =\n    let combine accu x = Digest.string (accu ^ Int.to_string x) in\n    let extract d =\n      Char.code d.[0] + (Char.code d.[1] lsl 8) + (Char.code d.[2] lsl 16)\n      + (Char.code d.[3] lsl 24)\n    in\n    let seed = if Array.length seed = 0 then [| 0 |] else seed in\n    let l = Array.length seed in\n    for i = 0 to 54 do\n      s.st.(i) <- i;\n    done;\n    let accu = ref \"x\" in\n    for i = 0 to 54 + Int.max 55 l do\n      let j = i mod 55 in\n      let k = i mod l in\n      accu := combine !accu seed.(k);\n      s.st.(j) <- (s.st.(j) lxor extract !accu) land 0x3FFFFFFF;  (* PR#5575 *)\n    done;\n    s.idx <- 0\n\n\n  let make seed =\n    let result = new_state () in\n    full_init result seed;\n    result\n\n\n  let make_self_init () = make (random_seed ())\n\n  let copy s =\n    let result = new_state () in\n    assign result s;\n    result\n\n\n  (* Returns 30 random bits as an integer 0 <= x < 1073741824 *)\n  let bits s =\n    s.idx <- (s.idx + 1) mod 55;\n    let curval = s.st.(s.idx) in\n    let newval = s.st.((s.idx + 24) mod 55)\n                 + (curval lxor ((curval lsr 25) land 0x1F)) in\n    let newval30 = newval land 0x3FFFFFFF in  (* PR#5575 *)\n    s.st.(s.idx) <- newval30;\n    newval30\n\n\n  let rec intaux s n =\n    let r = bits s in\n    let v = r mod n in\n    if r - v > 0x3FFFFFFF - n + 1 then intaux s n else v\n\n  let int s bound =\n    if bound > 0x3FFFFFFF || bound <= 0\n    then invalid_arg \"Random.int\"\n    else intaux s bound\n\n  let rec int63aux s n =\n    let max_int_32 = (1 lsl 30) + 0x3FFFFFFF in (* 0x7FFFFFFF *)\n    let b1 = bits s in\n    let b2 = bits s in\n    let (r, max_int) =\n      if n <= max_int_32 then\n        (* 31 random bits on both 64-bit OCaml and JavaScript.\n           Use upper 15 bits of b1 and 16 bits of b2. *)\n        let bpos =\n          (((b2 land 0x3FFFC000) lsl 1) lor (b1 lsr 15))\n        in\n          (bpos, max_int_32)\n      else\n        let b3 = bits s in\n        (* 62 random bits on 64-bit OCaml; unreachable on JavaScript.\n           Use upper 20 bits of b1 and 21 bits of b2 and b3. *)\n        let bpos =\n          ((((b3 land 0x3FFFFE00) lsl 12) lor (b2 lsr 9)) lsl 20)\n            lor (b1 lsr 10)\n        in\n          (bpos, max_int)\n    in\n    let v = r mod n in\n    if r - v > max_int - n + 1 then int63aux s n else v\n\n  let full_int s bound =\n    if bound <= 0 then\n      invalid_arg \"Random.full_int\"\n    else if bound > 0x3FFFFFFF then\n      int63aux s bound\n    else\n      intaux s bound\n\n\n  let rec int32aux s n =\n    let b1 = Int32.of_int (bits s) in\n    let b2 = Int32.shift_left (Int32.of_int (bits s land 1)) 30 in\n    let r = Int32.logor b1 b2 in\n    let v = Int32.rem r n in\n    if Int32.sub r v > Int32.add (Int32.sub Int32.max_int n) 1l\n    then int32aux s n\n    else v\n\n  let int32 s bound =\n    if bound <= 0l\n    then invalid_arg \"Random.int32\"\n    else int32aux s bound\n\n\n  let rec int64aux s n =\n    let b1 = Int64.of_int (bits s) in\n    let b2 = Int64.shift_left (Int64.of_int (bits s)) 30 in\n    let b3 = Int64.shift_left (Int64.of_int (bits s land 7)) 60 in\n    let r = Int64.logor b1 (Int64.logor b2 b3) in\n    let v = Int64.rem r n in\n    if Int64.sub r v > Int64.add (Int64.sub Int64.max_int n) 1L\n    then int64aux s n\n    else v\n\n  let int64 s bound =\n    if bound <= 0L\n    then invalid_arg \"Random.int64\"\n    else int64aux s bound\n\n\n  let nativeint =\n    if Nativeint.size = 32\n    then fun s bound -> Nativeint.of_int32 (int32 s (Nativeint.to_int32 bound))\n    else fun s bound -> Int64.to_nativeint (int64 s (Int64.of_nativeint bound))\n\n\n  (* Returns a float 0 <= x <= 1 with at most 60 bits of precision. *)\n  let rawfloat s =\n    let scale = 1073741824.0  (* 2^30 *)\n    and r1 = Stdlib.float (bits s)\n    and r2 = Stdlib.float (bits s)\n    in (r1 /. scale +. r2) /. scale\n\n\n  let float s bound = rawfloat s *. bound\n\n  let bool s = (bits s land 1 = 0)\n\nend\n\n(* This is the state you get with [init 27182818] and then applying\n   the \"land 0x3FFFFFFF\" filter to them.  See #5575, #5793, #5977. *)\nlet default = {\n  State.st = [|\n      0x3ae2522b; 0x1d8d4634; 0x15b4fad0; 0x18b14ace; 0x12f8a3c4; 0x3b086c47;\n      0x16d467d6; 0x101d91c7; 0x321df177; 0x0176c193; 0x1ff72bf1; 0x1e889109;\n      0x0b464b18; 0x2b86b97c; 0x0891da48; 0x03137463; 0x085ac5a1; 0x15d61f2f;\n      0x3bced359; 0x29c1c132; 0x3a86766e; 0x366d8c86; 0x1f5b6222; 0x3ce1b59f;\n      0x2ebf78e1; 0x27cd1b86; 0x258f3dc3; 0x389a8194; 0x02e4c44c; 0x18c43f7d;\n      0x0f6e534f; 0x1e7df359; 0x055d0b7e; 0x10e84e7e; 0x126198e4; 0x0e7722cb;\n      0x1cbede28; 0x3391b964; 0x3d40e92a; 0x0c59933d; 0x0b8cd0b7; 0x24efff1c;\n      0x2803fdaa; 0x08ebc72e; 0x0f522e32; 0x05398edc; 0x2144a04c; 0x0aef3cbd;\n      0x01ad4719; 0x35b93cd6; 0x2a559d4f; 0x1e6fd768; 0x26e27f36; 0x186f18c3;\n      0x2fbf967a;\n    |];\n  State.idx = 0;\n}\n\nlet bits () = State.bits default\nlet int bound = State.int default bound\nlet full_int bound = State.full_int default bound\nlet int32 bound = State.int32 default bound\nlet nativeint bound = State.nativeint default bound\nlet int64 bound = State.int64 default bound\nlet float scale = State.float default scale\nlet bool () = State.bool default\n\nlet full_init seed = State.full_init default seed\nlet init seed = State.full_init default [| seed |]\nlet self_init () = full_init (random_seed())\n\n(* Manipulating the current state. *)\n\nlet get_state () = State.copy default\nlet set_state s = State.assign default s\n\n(********************\n\n(* Test functions.  Not included in the library.\n   The [chisquare] function should be called with n > 10r.\n   It returns a triple (low, actual, high).\n   If low <= actual <= high, the [g] function passed the test,\n   otherwise it failed.\n\n  Some results:\n\ninit 27182818; chisquare int 100000 1000\ninit 27182818; chisquare int 100000 100\ninit 27182818; chisquare int 100000 5000\ninit 27182818; chisquare int 1000000 1000\ninit 27182818; chisquare int 100000 1024\ninit 299792643; chisquare int 100000 1024\ninit 14142136; chisquare int 100000 1024\ninit 27182818; init_diff 1024; chisquare diff 100000 1024\ninit 27182818; init_diff 100; chisquare diff 100000 100\ninit 27182818; init_diff2 1024; chisquare diff2 100000 1024\ninit 27182818; init_diff2 100; chisquare diff2 100000 100\ninit 14142136; init_diff2 100; chisquare diff2 100000 100\ninit 299792643; init_diff2 100; chisquare diff2 100000 100\n- : float * float * float = (936.754446796632465, 997.5, 1063.24555320336754)\n# - : float * float * float = (80., 89.7400000000052387, 120.)\n# - : float * float * float = (4858.57864376269, 5045.5, 5141.42135623731)\n# - : float * float * float =\n(936.754446796632465, 944.805999999982305, 1063.24555320336754)\n# - : float * float * float = (960., 1019.19744000000355, 1088.)\n# - : float * float * float = (960., 1059.31776000000536, 1088.)\n# - : float * float * float = (960., 1039.98463999999512, 1088.)\n# - : float * float * float = (960., 1054.38207999999577, 1088.)\n# - : float * float * float = (80., 90.096000000005, 120.)\n# - : float * float * float = (960., 1076.78720000000612, 1088.)\n# - : float * float * float = (80., 85.1760000000067521, 120.)\n# - : float * float * float = (80., 85.2160000000003492, 120.)\n# - : float * float * float = (80., 80.6220000000030268, 120.)\n\n*)\n\n(* Return the sum of the squares of v[i0,i1[ *)\nlet rec sumsq v i0 i1 =\n  if i0 >= i1 then 0.0\n  else if i1 = i0 + 1 then Stdlib.float v.(i0) *. Stdlib.float v.(i0)\n  else sumsq v i0 ((i0+i1)/2) +. sumsq v ((i0+i1)/2) i1\n\n\nlet chisquare g n r =\n  if n <= 10 * r then invalid_arg \"chisquare\";\n  let f = Array.make r 0 in\n  for i = 1 to n do\n    let t = g r in\n    f.(t) <- f.(t) + 1\n  done;\n  let t = sumsq f 0 r\n  and r = Stdlib.float r\n  and n = Stdlib.float n in\n  let sr = 2.0 *. sqrt r in\n  (r -. sr,   (r *. t /. n) -. n,   r +. sr)\n\n\n(* This is to test for linear dependencies between successive random numbers.\n*)\nlet st = ref 0\nlet init_diff r = st := int r\nlet diff r =\n  let x1 = !st\n  and x2 = int r\n  in\n  st := x2;\n  if x1 >= x2 then\n    x1 - x2\n  else\n    r + x1 - x2\n\n\nlet st1 = ref 0\nand st2 = ref 0\n\n\n(* This is to test for quadratic dependencies between successive random\n   numbers.\n*)\nlet init_diff2 r = st1 := int r; st2 := int r\nlet diff2 r =\n  let x1 = !st1\n  and x2 = !st2\n  and x3 = int r\n  in\n  st1 := x2;\n  st2 := x3;\n  (x3 - x2 - x2 + x1 + 2*r) mod r\n\n\n********************)\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Hash tables *)\n\n(* We do dynamic hashing, and resize the table and rehash the elements\n   when buckets become too long. *)\n\ntype ('a, 'b) t =\n  { mutable size: int;                        (* number of entries *)\n    mutable data: ('a, 'b) bucketlist array;  (* the buckets *)\n    seed: int;                        (* for randomization *)\n    mutable initial_size: int;                (* initial array size *)\n  }\n\nand ('a, 'b) bucketlist =\n    Empty\n  | Cons of { mutable key: 'a;\n              mutable data: 'b;\n              mutable next: ('a, 'b) bucketlist }\n\n(* The sign of initial_size encodes the fact that a traversal is\n   ongoing or not.\n\n   This disables the efficient in place implementation of resizing.\n*)\n\nlet ongoing_traversal h =\n  Obj.size (Obj.repr h) < 4 (* compatibility with old hash tables *)\n  || h.initial_size < 0\n\nlet flip_ongoing_traversal h =\n  h.initial_size <- - h.initial_size\n\n(* To pick random seeds if requested *)\n\nlet randomized_default =\n  let params =\n    try Sys.getenv \"OCAMLRUNPARAM\" with Not_found ->\n    try Sys.getenv \"CAMLRUNPARAM\" with Not_found -> \"\" in\n  String.contains params 'R'\n\nlet randomized = ref randomized_default\n\nlet randomize () = randomized := true\nlet is_randomized () = !randomized\n\nlet prng = lazy (Random.State.make_self_init())\n\n(* Functions which appear before the functorial interface must either be\n   independent of the hash function or take it as a parameter (see #2202 and\n   code below the functor definitions. *)\n\n(* Creating a fresh, empty table *)\n\nlet rec power_2_above x n =\n  if x >= n then x\n  else if x * 2 > Sys.max_array_length then x\n  else power_2_above (x * 2) n\n\nlet create ?(random = !randomized) initial_size =\n  let s = power_2_above 16 initial_size in\n  let seed = if random then Random.State.bits (Lazy.force prng) else 0 in\n  { initial_size = s; size = 0; seed = seed; data = Array.make s Empty }\n\nlet clear h =\n  if h.size > 0 then begin\n    h.size <- 0;\n    Array.fill h.data 0 (Array.length h.data) Empty\n  end\n\nlet reset h =\n  let len = Array.length h.data in\n  if Obj.size (Obj.repr h) < 4 (* compatibility with old hash tables *)\n    || len = abs h.initial_size then\n    clear h\n  else begin\n    h.size <- 0;\n    h.data <- Array.make (abs h.initial_size) Empty\n  end\n\nlet copy_bucketlist = function\n  | Empty -> Empty\n  | Cons {key; data; next} ->\n      let rec loop prec = function\n        | Empty -> ()\n        | Cons {key; data; next} ->\n            let r = Cons {key; data; next} in\n            begin match prec with\n            | Empty -> assert false\n            | Cons prec ->  prec.next <- r\n            end;\n            loop r next\n      in\n      let r = Cons {key; data; next} in\n      loop r next;\n      r\n\nlet copy h = { h with data = Array.map copy_bucketlist h.data }\n\nlet length h = h.size\n\nlet insert_all_buckets indexfun inplace odata ndata =\n  let nsize = Array.length ndata in\n  let ndata_tail = Array.make nsize Empty in\n  let rec insert_bucket = function\n    | Empty -> ()\n    | Cons {key; data; next} as cell ->\n        let cell =\n          if inplace then cell\n          else Cons {key; data; next = Empty}\n        in\n        let nidx = indexfun key in\n        begin match ndata_tail.(nidx) with\n        | Empty -> ndata.(nidx) <- cell;\n        | Cons tail -> tail.next <- cell;\n        end;\n        ndata_tail.(nidx) <- cell;\n        insert_bucket next\n  in\n  for i = 0 to Array.length odata - 1 do\n    insert_bucket odata.(i)\n  done;\n  if inplace then\n    for i = 0 to nsize - 1 do\n      match ndata_tail.(i) with\n      | Empty -> ()\n      | Cons tail -> tail.next <- Empty\n    done\n\nlet resize indexfun h =\n  let odata = h.data in\n  let osize = Array.length odata in\n  let nsize = osize * 2 in\n  if nsize < Sys.max_array_length then begin\n    let ndata = Array.make nsize Empty in\n    let inplace = not (ongoing_traversal h) in\n    h.data <- ndata;          (* so that indexfun sees the new bucket count *)\n    insert_all_buckets (indexfun h) inplace odata ndata\n  end\n\nlet iter f h =\n  let rec do_bucket = function\n    | Empty ->\n        ()\n    | Cons{key; data; next} ->\n        f key data; do_bucket next in\n  let old_trav = ongoing_traversal h in\n  if not old_trav then flip_ongoing_traversal h;\n  try\n    let d = h.data in\n    for i = 0 to Array.length d - 1 do\n      do_bucket d.(i)\n    done;\n    if not old_trav then flip_ongoing_traversal h;\n  with exn when not old_trav ->\n    flip_ongoing_traversal h;\n    raise exn\n\nlet rec filter_map_inplace_bucket f h i prec = function\n  | Empty ->\n      begin match prec with\n      | Empty -> h.data.(i) <- Empty\n      | Cons c -> c.next <- Empty\n      end\n  | (Cons ({key; data; next} as c)) as slot ->\n      begin match f key data with\n      | None ->\n          h.size <- h.size - 1;\n          filter_map_inplace_bucket f h i prec next\n      | Some data ->\n          begin match prec with\n          | Empty -> h.data.(i) <- slot\n          | Cons c -> c.next <- slot\n          end;\n          c.data <- data;\n          filter_map_inplace_bucket f h i slot next\n      end\n\nlet filter_map_inplace f h =\n  let d = h.data in\n  let old_trav = ongoing_traversal h in\n  if not old_trav then flip_ongoing_traversal h;\n  try\n    for i = 0 to Array.length d - 1 do\n      filter_map_inplace_bucket f h i Empty h.data.(i)\n    done;\n    if not old_trav then flip_ongoing_traversal h\n  with exn when not old_trav ->\n    flip_ongoing_traversal h;\n    raise exn\n\nlet fold f h init =\n  let rec do_bucket b accu =\n    match b with\n      Empty ->\n        accu\n    | Cons{key; data; next} ->\n        do_bucket next (f key data accu) in\n  let old_trav = ongoing_traversal h in\n  if not old_trav then flip_ongoing_traversal h;\n  try\n    let d = h.data in\n    let accu = ref init in\n    for i = 0 to Array.length d - 1 do\n      accu := do_bucket d.(i) !accu\n    done;\n    if not old_trav then flip_ongoing_traversal h;\n    !accu\n  with exn when not old_trav ->\n    flip_ongoing_traversal h;\n    raise exn\n\ntype statistics = {\n  num_bindings: int;\n  num_buckets: int;\n  max_bucket_length: int;\n  bucket_histogram: int array\n}\n\nlet rec bucket_length accu = function\n  | Empty -> accu\n  | Cons{next} -> bucket_length (accu + 1) next\n\nlet stats h =\n  let mbl =\n    Array.fold_left (fun m b -> Int.max m (bucket_length 0 b)) 0 h.data in\n  let histo = Array.make (mbl + 1) 0 in\n  Array.iter\n    (fun b ->\n      let l = bucket_length 0 b in\n      histo.(l) <- histo.(l) + 1)\n    h.data;\n  { num_bindings = h.size;\n    num_buckets = Array.length h.data;\n    max_bucket_length = mbl;\n    bucket_histogram = histo }\n\n(** {1 Iterators} *)\n\nlet to_seq tbl =\n  (* capture current array, so that even if the table is resized we\n     keep iterating on the same array *)\n  let tbl_data = tbl.data in\n  (* state: index * next bucket to traverse *)\n  let rec aux i buck () = match buck with\n    | Empty ->\n        if i = Array.length tbl_data\n        then Seq.Nil\n        else aux(i+1) tbl_data.(i) ()\n    | Cons {key; data; next} ->\n        Seq.Cons ((key, data), aux i next)\n  in\n  aux 0 Empty\n\nlet to_seq_keys m = Seq.map fst (to_seq m)\n\nlet to_seq_values m = Seq.map snd (to_seq m)\n\n(* Functorial interface *)\n\nmodule type HashedType =\n  sig\n    type t\n    val equal: t -> t -> bool\n    val hash: t -> int\n  end\n\nmodule type SeededHashedType =\n  sig\n    type t\n    val equal: t -> t -> bool\n    val hash: int -> t -> int\n  end\n\nmodule type S =\n  sig\n    type key\n    type !'a t\n    val create: int -> 'a t\n    val clear : 'a t -> unit\n    val reset : 'a t -> unit\n    val copy: 'a t -> 'a t\n    val add: 'a t -> key -> 'a -> unit\n    val remove: 'a t -> key -> unit\n    val find: 'a t -> key -> 'a\n    val find_opt: 'a t -> key -> 'a option\n    val find_all: 'a t -> key -> 'a list\n    val replace : 'a t -> key -> 'a -> unit\n    val mem : 'a t -> key -> bool\n    val iter: (key -> 'a -> unit) -> 'a t -> unit\n    val filter_map_inplace: (key -> 'a -> 'a option) -> 'a t -> unit\n    val fold: (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b\n    val length: 'a t -> int\n    val stats: 'a t -> statistics\n    val to_seq : 'a t -> (key * 'a) Seq.t\n    val to_seq_keys : _ t -> key Seq.t\n    val to_seq_values : 'a t -> 'a Seq.t\n    val add_seq : 'a t -> (key * 'a) Seq.t -> unit\n    val replace_seq : 'a t -> (key * 'a) Seq.t -> unit\n    val of_seq : (key * 'a) Seq.t -> 'a t\n  end\n\nmodule type SeededS =\n  sig\n    type key\n    type !'a t\n    val create : ?random:bool -> int -> 'a t\n    val clear : 'a t -> unit\n    val reset : 'a t -> unit\n    val copy : 'a t -> 'a t\n    val add : 'a t -> key -> 'a -> unit\n    val remove : 'a t -> key -> unit\n    val find : 'a t -> key -> 'a\n    val find_opt: 'a t -> key -> 'a option\n    val find_all : 'a t -> key -> 'a list\n    val replace : 'a t -> key -> 'a -> unit\n    val mem : 'a t -> key -> bool\n    val iter : (key -> 'a -> unit) -> 'a t -> unit\n    val filter_map_inplace: (key -> 'a -> 'a option) -> 'a t -> unit\n    val fold : (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b\n    val length : 'a t -> int\n    val stats: 'a t -> statistics\n    val to_seq : 'a t -> (key * 'a) Seq.t\n    val to_seq_keys : _ t -> key Seq.t\n    val to_seq_values : 'a t -> 'a Seq.t\n    val add_seq : 'a t -> (key * 'a) Seq.t -> unit\n    val replace_seq : 'a t -> (key * 'a) Seq.t -> unit\n    val of_seq : (key * 'a) Seq.t -> 'a t\n  end\n\nmodule MakeSeeded(H: SeededHashedType): (SeededS with type key = H.t) =\n  struct\n    type key = H.t\n    type 'a hashtbl = (key, 'a) t\n    type 'a t = 'a hashtbl\n    let create = create\n    let clear = clear\n    let reset = reset\n    let copy = copy\n\n    let key_index h key =\n      (H.hash h.seed key) land (Array.length h.data - 1)\n\n    let add h key data =\n      let i = key_index h key in\n      let bucket = Cons{key; data; next=h.data.(i)} in\n      h.data.(i) <- bucket;\n      h.size <- h.size + 1;\n      if h.size > Array.length h.data lsl 1 then resize key_index h\n\n    let rec remove_bucket h i key prec = function\n      | Empty ->\n          ()\n      | (Cons {key=k; next}) as c ->\n          if H.equal k key\n          then begin\n            h.size <- h.size - 1;\n            match prec with\n            | Empty -> h.data.(i) <- next\n            | Cons c -> c.next <- next\n          end\n          else remove_bucket h i key c next\n\n    let remove h key =\n      let i = key_index h key in\n      remove_bucket h i key Empty h.data.(i)\n\n    let rec find_rec key = function\n      | Empty ->\n          raise Not_found\n      | Cons{key=k; data; next} ->\n          if H.equal key k then data else find_rec key next\n\n    let find h key =\n      match h.data.(key_index h key) with\n      | Empty -> raise Not_found\n      | Cons{key=k1; data=d1; next=next1} ->\n          if H.equal key k1 then d1 else\n          match next1 with\n          | Empty -> raise Not_found\n          | Cons{key=k2; data=d2; next=next2} ->\n              if H.equal key k2 then d2 else\n              match next2 with\n              | Empty -> raise Not_found\n              | Cons{key=k3; data=d3; next=next3} ->\n                  if H.equal key k3 then d3 else find_rec key next3\n\n    let rec find_rec_opt key = function\n      | Empty ->\n          None\n      | Cons{key=k; data; next} ->\n          if H.equal key k then Some data else find_rec_opt key next\n\n    let find_opt h key =\n      match h.data.(key_index h key) with\n      | Empty -> None\n      | Cons{key=k1; data=d1; next=next1} ->\n          if H.equal key k1 then Some d1 else\n          match next1 with\n          | Empty -> None\n          | Cons{key=k2; data=d2; next=next2} ->\n              if H.equal key k2 then Some d2 else\n              match next2 with\n              | Empty -> None\n              | Cons{key=k3; data=d3; next=next3} ->\n                  if H.equal key k3 then Some d3 else find_rec_opt key next3\n\n    let find_all h key =\n      let rec find_in_bucket = function\n      | Empty ->\n          []\n      | Cons{key=k; data=d; next} ->\n          if H.equal k key\n          then d :: find_in_bucket next\n          else find_in_bucket next in\n      find_in_bucket h.data.(key_index h key)\n\n    let rec replace_bucket key data = function\n      | Empty ->\n          true\n      | Cons ({key=k; next} as slot) ->\n          if H.equal k key\n          then (slot.key <- key; slot.data <- data; false)\n          else replace_bucket key data next\n\n    let replace h key data =\n      let i = key_index h key in\n      let l = h.data.(i) in\n      if replace_bucket key data l then begin\n        h.data.(i) <- Cons{key; data; next=l};\n        h.size <- h.size + 1;\n        if h.size > Array.length h.data lsl 1 then resize key_index h\n      end\n\n    let mem h key =\n      let rec mem_in_bucket = function\n      | Empty ->\n          false\n      | Cons{key=k; next} ->\n          H.equal k key || mem_in_bucket next in\n      mem_in_bucket h.data.(key_index h key)\n\n    let add_seq tbl i =\n      Seq.iter (fun (k,v) -> add tbl k v) i\n\n    let replace_seq tbl i =\n      Seq.iter (fun (k,v) -> replace tbl k v) i\n\n    let of_seq i =\n      let tbl = create 16 in\n      replace_seq tbl i;\n      tbl\n\n    let iter = iter\n    let filter_map_inplace = filter_map_inplace\n    let fold = fold\n    let length = length\n    let stats = stats\n    let to_seq = to_seq\n    let to_seq_keys = to_seq_keys\n    let to_seq_values = to_seq_values\n  end\n\nmodule Make(H: HashedType): (S with type key = H.t) =\n  struct\n    include MakeSeeded(struct\n        type t = H.t\n        let equal = H.equal\n        let hash (_seed: int) x = H.hash x\n      end)\n    let create sz = create ~random:false sz\n    let of_seq i =\n      let tbl = create 16 in\n      replace_seq tbl i;\n      tbl\n  end\n\n(* Polymorphic hash function-based tables *)\n(* Code included below the functorial interface to guard against accidental\n   use - see #2202 *)\n\nexternal seeded_hash_param :\n  int -> int -> int -> 'a -> int = \"caml_hash\" [@@noalloc]\n\nlet hash x = seeded_hash_param 10 100 0 x\nlet hash_param n1 n2 x = seeded_hash_param n1 n2 0 x\nlet seeded_hash seed x = seeded_hash_param 10 100 seed x\n\nlet key_index h key =\n  if Obj.size (Obj.repr h) >= 4\n  then (seeded_hash_param 10 100 h.seed key) land (Array.length h.data - 1)\n  else invalid_arg \"Hashtbl: unsupported hash table format\"\n\nlet add h key data =\n  let i = key_index h key in\n  let bucket = Cons{key; data; next=h.data.(i)} in\n  h.data.(i) <- bucket;\n  h.size <- h.size + 1;\n  if h.size > Array.length h.data lsl 1 then resize key_index h\n\nlet rec remove_bucket h i key prec = function\n  | Empty ->\n      ()\n  | (Cons {key=k; next}) as c ->\n      if compare k key = 0\n      then begin\n        h.size <- h.size - 1;\n        match prec with\n        | Empty -> h.data.(i) <- next\n        | Cons c -> c.next <- next\n      end\n      else remove_bucket h i key c next\n\nlet remove h key =\n  let i = key_index h key in\n  remove_bucket h i key Empty h.data.(i)\n\nlet rec find_rec key = function\n  | Empty ->\n      raise Not_found\n  | Cons{key=k; data; next} ->\n      if compare key k = 0 then data else find_rec key next\n\nlet find h key =\n  match h.data.(key_index h key) with\n  | Empty -> raise Not_found\n  | Cons{key=k1; data=d1; next=next1} ->\n      if compare key k1 = 0 then d1 else\n      match next1 with\n      | Empty -> raise Not_found\n      | Cons{key=k2; data=d2; next=next2} ->\n          if compare key k2 = 0 then d2 else\n          match next2 with\n          | Empty -> raise Not_found\n          | Cons{key=k3; data=d3; next=next3} ->\n              if compare key k3 = 0 then d3 else find_rec key next3\n\nlet rec find_rec_opt key = function\n  | Empty ->\n      None\n  | Cons{key=k; data; next} ->\n      if compare key k = 0 then Some data else find_rec_opt key next\n\nlet find_opt h key =\n  match h.data.(key_index h key) with\n  | Empty -> None\n  | Cons{key=k1; data=d1; next=next1} ->\n      if compare key k1 = 0 then Some d1 else\n      match next1 with\n      | Empty -> None\n      | Cons{key=k2; data=d2; next=next2} ->\n          if compare key k2 = 0 then Some d2 else\n          match next2 with\n          | Empty -> None\n          | Cons{key=k3; data=d3; next=next3} ->\n              if compare key k3 = 0 then Some d3 else find_rec_opt key next3\n\nlet find_all h key =\n  let rec find_in_bucket = function\n  | Empty ->\n      []\n  | Cons{key=k; data; next} ->\n      if compare k key = 0\n      then data :: find_in_bucket next\n      else find_in_bucket next in\n  find_in_bucket h.data.(key_index h key)\n\nlet rec replace_bucket key data = function\n  | Empty ->\n      true\n  | Cons ({key=k; next} as slot) ->\n      if compare k key = 0\n      then (slot.key <- key; slot.data <- data; false)\n      else replace_bucket key data next\n\nlet replace h key data =\n  let i = key_index h key in\n  let l = h.data.(i) in\n  if replace_bucket key data l then begin\n    h.data.(i) <- Cons{key; data; next=l};\n    h.size <- h.size + 1;\n    if h.size > Array.length h.data lsl 1 then resize key_index h\n  end\n\nlet mem h key =\n  let rec mem_in_bucket = function\n  | Empty ->\n      false\n  | Cons{key=k; next} ->\n      compare k key = 0 || mem_in_bucket next in\n  mem_in_bucket h.data.(key_index h key)\n\nlet add_seq tbl i =\n  Seq.iter (fun (k,v) -> add tbl k v) i\n\nlet replace_seq tbl i =\n  Seq.iter (fun (k,v) -> replace tbl k v) i\n\nlet of_seq i =\n  let tbl = create 16 in\n  replace_seq tbl i;\n  tbl\n\nlet rebuild ?(random = !randomized) h =\n  let s = power_2_above 16 (Array.length h.data) in\n  let seed =\n    if random then Random.State.bits (Lazy.force prng)\n    else if Obj.size (Obj.repr h) >= 4 then h.seed\n    else 0 in\n  let h' = {\n    size = h.size;\n    data = Array.make s Empty;\n    seed = seed;\n    initial_size = if Obj.size (Obj.repr h) >= 4 then h.initial_size else s\n  } in\n  insert_all_buckets (key_index h') false h.data h'.data;\n  h'\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Pierre Weis, projet Cristal, INRIA Rocquencourt            *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* A pretty-printing facility and definition of formatters for 'parallel'\n   (i.e. unrelated or independent) pretty-printing on multiple out channels. *)\n\n(*\n   The pretty-printing engine internal data structures.\n*)\n\nlet id x = x\n\n(* A devoted type for sizes to avoid confusion\n   between sizes and mere integers. *)\nmodule Size : sig\n  type t\n\n  val to_int : t -> int\n  val of_int : int -> t\n  val zero : t\n  val unknown : t\n  val is_known : t -> bool\nend  = struct\n  type t = int\n\n  let to_int = id\n  let of_int = id\n  let zero = 0\n  let unknown = -1\n  let is_known n = n >= 0\nend\n\n\n\n(* The pretty-printing boxes definition:\n   a pretty-printing box is either\n   - hbox: horizontal box (no line splitting)\n   - vbox: vertical box (every break hint splits the line)\n   - hvbox: horizontal/vertical box\n     (the box behaves as an horizontal box if it fits on\n      the current line, otherwise the box behaves as a vertical box)\n   - hovbox: horizontal or vertical compacting box\n     (the box is compacting material, printing as much material as possible\n      on every lines)\n   - box: horizontal or vertical compacting box with enhanced box structure\n     (the box behaves as an horizontal or vertical box but break hints split\n      the line if splitting would move to the left)\n*)\ntype box_type = CamlinternalFormatBasics.block_type =\n  | Pp_hbox | Pp_vbox | Pp_hvbox | Pp_hovbox | Pp_box | Pp_fits\n\n\n(* The pretty-printing tokens definition:\n   are either text to print or pretty printing\n   elements that drive indentation and line splitting. *)\ntype pp_token =\n  | Pp_text of string          (* normal text *)\n  | Pp_break of {              (* complete break *)\n      fits: string * int * string;   (* line is not split *)\n      breaks: string * int * string; (* line is split *)\n    }\n  | Pp_tbreak of int * int     (* go to next tabulation *)\n  | Pp_stab                    (* set a tabulation *)\n  | Pp_begin of int * box_type (* beginning of a box *)\n  | Pp_end                     (* end of a box *)\n  | Pp_tbegin of tbox          (* beginning of a tabulation box *)\n  | Pp_tend                    (* end of a tabulation box *)\n  | Pp_newline                 (* to force a newline inside a box *)\n  | Pp_if_newline              (* to do something only if this very\n                                  line has been broken *)\n  | Pp_open_tag of stag         (* opening a tag name *)\n  | Pp_close_tag               (* closing the most recently open tag *)\n\nand stag = ..\n\nand tbox = Pp_tbox of int list ref  (* Tabulation box *)\n\ntype tag = string\ntype stag += String_tag of tag\n\n\n(* The pretty-printer queue:\n   pretty-printing material is not written in the output as soon as emitted;\n   instead, the material is simply recorded in the pretty-printer queue,\n   until the enclosing box has a known computed size and proper splitting\n   decisions can be made.\n\n   The pretty-printer queue contains formatting elements to be printed.\n   Each formatting element is a tuple (size, token, length), where\n   - length is the declared length of the token,\n   - size is effective size of the token when it is printed\n     (size is set when the size of the box is known, so that size of break\n      hints are definitive). *)\ntype pp_queue_elem = {\n  mutable size : Size.t;\n  token : pp_token;\n  length : int;\n}\n\n\n(* The pretty-printer queue definition. *)\ntype pp_queue = pp_queue_elem Queue.t\n\n(* The pretty-printer scanning stack. *)\n\n(* The pretty-printer scanning stack: scanning element definition. *)\ntype pp_scan_elem = {\n  left_total : int; (* Value of pp_left_total when the element was enqueued. *)\n  queue_elem : pp_queue_elem\n}\n\n(* The pretty-printer formatting stack:\n   the formatting stack contains the description of all the currently active\n   boxes; the pretty-printer formatting stack is used to split the lines\n   while printing tokens. *)\n\n(* The pretty-printer formatting stack: formatting stack element definition.\n   Each stack element describes a pretty-printing box. *)\ntype pp_format_elem = { box_type : box_type; width : int }\n\n(* The formatter definition.\n   Each formatter value is a pretty-printer instance with all its\n   machinery. *)\ntype formatter = {\n  (* The pretty-printer scanning stack. *)\n  pp_scan_stack : pp_scan_elem Stack.t;\n  (* The pretty-printer formatting stack. *)\n  pp_format_stack : pp_format_elem Stack.t;\n  pp_tbox_stack : tbox Stack.t;\n  (* The pretty-printer semantics tag stack. *)\n  pp_tag_stack : stag Stack.t;\n  pp_mark_stack : stag Stack.t;\n  (* Value of right margin. *)\n  mutable pp_margin : int;\n  (* Minimal space left before margin, when opening a box. *)\n  mutable pp_min_space_left : int;\n  (* Maximum value of indentation:\n     no box can be opened further. *)\n  mutable pp_max_indent : int;\n  (* Space remaining on the current line. *)\n  mutable pp_space_left : int;\n  (* Current value of indentation. *)\n  mutable pp_current_indent : int;\n  (* True when the line has been broken by the pretty-printer. *)\n  mutable pp_is_new_line : bool;\n  (* Total width of tokens already printed. *)\n  mutable pp_left_total : int;\n  (* Total width of tokens ever put in queue. *)\n  mutable pp_right_total : int;\n  (* Current number of open boxes. *)\n  mutable pp_curr_depth : int;\n  (* Maximum number of boxes which can be simultaneously open. *)\n  mutable pp_max_boxes : int;\n  (* Ellipsis string. *)\n  mutable pp_ellipsis : string;\n  (* Output function. *)\n  mutable pp_out_string : string -> int -> int -> unit;\n  (* Flushing function. *)\n  mutable pp_out_flush : unit -> unit;\n  (* Output of new lines. *)\n  mutable pp_out_newline : unit -> unit;\n  (* Output of break hints spaces. *)\n  mutable pp_out_spaces : int -> unit;\n  (* Output of indentation of new lines. *)\n  mutable pp_out_indent : int -> unit;\n  (* Are tags printed ? *)\n  mutable pp_print_tags : bool;\n  (* Are tags marked ? *)\n  mutable pp_mark_tags : bool;\n  (* Find opening and closing markers of tags. *)\n  mutable pp_mark_open_tag : stag -> string;\n  mutable pp_mark_close_tag : stag -> string;\n  mutable pp_print_open_tag : stag -> unit;\n  mutable pp_print_close_tag : stag -> unit;\n  (* The pretty-printer queue. *)\n  pp_queue : pp_queue;\n}\n\n\n(* The formatter specific tag handling functions. *)\ntype formatter_stag_functions = {\n  mark_open_stag : stag -> string;\n  mark_close_stag : stag -> string;\n  print_open_stag : stag -> unit;\n  print_close_stag : stag -> unit;\n}\n\n\n(* The formatter functions to output material. *)\ntype formatter_out_functions = {\n  out_string : string -> int -> int -> unit;\n  out_flush : unit -> unit;\n  out_newline : unit -> unit;\n  out_spaces : int -> unit;\n  out_indent : int -> unit;\n}\n\n\n(*\n\n  Auxiliaries and basic functions.\n\n*)\n\n(* Enter a token in the pretty-printer queue. *)\nlet pp_enqueue state token =\n  state.pp_right_total <- state.pp_right_total + token.length;\n  Queue.add token state.pp_queue\n\n\nlet pp_clear_queue state =\n  state.pp_left_total <- 1; state.pp_right_total <- 1;\n  Queue.clear state.pp_queue\n\n\n(* Pp_infinity: large value for default tokens size.\n\n   Pp_infinity is documented as being greater than 1e10; to avoid\n   confusion about the word 'greater', we choose pp_infinity greater\n   than 1e10 + 1; for correct handling of tests in the algorithm,\n   pp_infinity must be even one more than 1e10 + 1; let's stand on the\n   safe side by choosing 1.e10+10.\n\n   Pp_infinity could probably be 1073741823 that is 2^30 - 1, that is\n   the minimal upper bound for integers; now that max_int is defined,\n   this limit could also be defined as max_int - 1.\n\n   However, before setting pp_infinity to something around max_int, we\n   must carefully double-check all the integer arithmetic operations\n   that involve pp_infinity, since any overflow would wreck havoc the\n   pretty-printing algorithm's invariants. Given that this arithmetic\n   correctness check is difficult and error prone and given that 1e10\n   + 1 is in practice large enough, there is no need to attempt to set\n   pp_infinity to the theoretically maximum limit. It is not worth the\n   burden ! *)\nlet pp_infinity = 1000000010\n\n(* Output functions for the formatter. *)\nlet pp_output_string state s = state.pp_out_string s 0 (String.length s)\nand pp_output_newline state = state.pp_out_newline ()\nand pp_output_spaces state n = state.pp_out_spaces n\nand pp_output_indent state n = state.pp_out_indent n\n\n(* Format a textual token *)\nlet format_pp_text state size text =\n  state.pp_space_left <- state.pp_space_left - size;\n  pp_output_string state text;\n  state.pp_is_new_line <- false\n\n(* Format a string by its length, if not empty *)\nlet format_string state s =\n  if s <> \"\" then format_pp_text state (String.length s) s\n\n(* To format a break, indenting a new line. *)\nlet break_new_line state (before, offset, after) width =\n  format_string state before;\n  pp_output_newline state;\n  state.pp_is_new_line <- true;\n  let indent = state.pp_margin - width + offset in\n  (* Don't indent more than pp_max_indent. *)\n  let real_indent = Int.min state.pp_max_indent indent in\n  state.pp_current_indent <- real_indent;\n  state.pp_space_left <- state.pp_margin - state.pp_current_indent;\n  pp_output_indent state state.pp_current_indent;\n  format_string state after\n\n\n(* To force a line break inside a box: no offset is added. *)\nlet break_line state width = break_new_line state (\"\", 0, \"\") width\n\n(* To format a break that fits on the current line. *)\nlet break_same_line state (before, width, after) =\n  format_string state before;\n  state.pp_space_left <- state.pp_space_left - width;\n  pp_output_spaces state width;\n  format_string state after\n\n\n(* To indent no more than pp_max_indent, if one tries to open a box\n   beyond pp_max_indent, then the box is rejected on the left\n   by simulating a break. *)\nlet pp_force_break_line state =\n  match Stack.top_opt state.pp_format_stack with\n  | None -> pp_output_newline state\n  | Some { box_type; width } ->\n    if width > state.pp_space_left then\n      match box_type with\n      | Pp_fits | Pp_hbox -> ()\n      | Pp_vbox | Pp_hvbox | Pp_hovbox | Pp_box -> break_line state width\n\n\n(* To skip a token, if the previous line has been broken. *)\nlet pp_skip_token state =\n  match Queue.take_opt state.pp_queue with\n  | None -> () (* print_if_newline must have been the last printing command *)\n  | Some { size; length; _ } ->\n    state.pp_left_total <- state.pp_left_total - length;\n    state.pp_space_left <- state.pp_space_left + Size.to_int size\n\n\n(*\n\n  The main pretty printing functions.\n\n*)\n\n(* Formatting a token with a given size. *)\nlet format_pp_token state size = function\n\n  | Pp_text s ->\n    format_pp_text state size s\n\n  | Pp_begin (off, ty) ->\n    let insertion_point = state.pp_margin - state.pp_space_left in\n    if insertion_point > state.pp_max_indent then\n      (* can not open a box right there. *)\n      begin pp_force_break_line state end;\n    let width = state.pp_space_left - off in\n    let box_type =\n      match ty with\n      | Pp_vbox -> Pp_vbox\n      | Pp_hbox | Pp_hvbox | Pp_hovbox | Pp_box | Pp_fits ->\n        if size > state.pp_space_left then ty else Pp_fits in\n    Stack.push { box_type; width } state.pp_format_stack\n\n  | Pp_end ->\n    Stack.pop_opt state.pp_format_stack |> ignore\n\n  | Pp_tbegin (Pp_tbox _ as tbox) ->\n    Stack.push tbox state.pp_tbox_stack\n\n  | Pp_tend ->\n    Stack.pop_opt state.pp_tbox_stack |> ignore\n\n  | Pp_stab ->\n    begin match Stack.top_opt state.pp_tbox_stack with\n    | None -> () (* No open tabulation box. *)\n    | Some (Pp_tbox tabs) ->\n      let rec add_tab n = function\n        | [] -> [n]\n        | x :: l as ls -> if n < x then n :: ls else x :: add_tab n l in\n      tabs := add_tab (state.pp_margin - state.pp_space_left) !tabs\n    end\n\n  | Pp_tbreak (n, off) ->\n    let insertion_point = state.pp_margin - state.pp_space_left in\n    begin match Stack.top_opt state.pp_tbox_stack with\n    | None -> () (* No open tabulation box. *)\n    | Some (Pp_tbox tabs) ->\n      let tab =\n        match !tabs with\n        | [] -> insertion_point\n        | first :: _ ->\n          let rec find = function\n            | head :: tail ->\n              if head >= insertion_point then head else find tail\n            | [] -> first in\n          find !tabs in\n      let offset = tab - insertion_point in\n      if offset >= 0\n      then break_same_line state (\"\", offset + n, \"\")\n      else break_new_line state (\"\", tab + off, \"\") state.pp_margin\n    end\n\n  | Pp_newline ->\n    begin match Stack.top_opt state.pp_format_stack with\n    | None -> pp_output_newline state (* No open box. *)\n    | Some { width; _} -> break_line state width\n    end\n\n  | Pp_if_newline ->\n    if state.pp_current_indent != state.pp_margin - state.pp_space_left\n    then pp_skip_token state\n\n  | Pp_break { fits; breaks } ->\n    let before, off, _ = breaks in\n    begin match Stack.top_opt state.pp_format_stack with\n    | None -> () (* No open box. *)\n    | Some { box_type; width } ->\n      begin match box_type with\n      | Pp_hovbox ->\n        if size + String.length before > state.pp_space_left\n        then break_new_line state breaks width\n        else break_same_line state fits\n      | Pp_box ->\n        (* Have the line just been broken here ? *)\n        if state.pp_is_new_line then break_same_line state fits else\n        if size + String.length before > state.pp_space_left\n          then break_new_line state breaks width else\n        (* break the line here leads to new indentation ? *)\n        if state.pp_current_indent > state.pp_margin - width + off\n        then break_new_line state breaks width\n        else break_same_line state fits\n      | Pp_hvbox -> break_new_line state breaks width\n      | Pp_fits -> break_same_line state fits\n      | Pp_vbox -> break_new_line state breaks width\n      | Pp_hbox -> break_same_line state fits\n      end\n    end\n\n   | Pp_open_tag tag_name ->\n     let marker = state.pp_mark_open_tag tag_name in\n     pp_output_string state marker;\n     Stack.push tag_name state.pp_mark_stack\n\n   | Pp_close_tag ->\n     begin match Stack.pop_opt state.pp_mark_stack with\n     | None -> () (* No more tag to close. *)\n     | Some tag_name ->\n       let marker = state.pp_mark_close_tag tag_name in\n       pp_output_string state marker\n     end\n\n\n(* Print if token size is known else printing is delayed.\n   Printing is delayed when the text waiting in the queue requires\n   more room to format than exists on the current line. *)\nlet rec advance_left state =\n  match Queue.peek_opt state.pp_queue with\n  | None -> () (* No tokens to print *)\n  | Some { size; token; length } ->\n    let pending_count = state.pp_right_total - state.pp_left_total in\n    if Size.is_known size || pending_count >= state.pp_space_left then begin\n      Queue.take state.pp_queue |> ignore; (* Not empty: we peek into it *)\n      let size = if Size.is_known size then Size.to_int size else pp_infinity in\n      format_pp_token state size token;\n      state.pp_left_total <- length + state.pp_left_total;\n      (advance_left [@tailcall]) state\n    end\n\n\n(* To enqueue a token : try to advance. *)\nlet enqueue_advance state tok = pp_enqueue state tok; advance_left state\n\n\n(* To enqueue strings. *)\nlet enqueue_string_as state size s =\n  enqueue_advance state { size; token = Pp_text s; length = Size.to_int size }\n\n\nlet enqueue_string state s =\n  enqueue_string_as state (Size.of_int (String.length s)) s\n\n\n(* Routines for scan stack\n   determine size of boxes. *)\n\n(* The scan_stack is never empty. *)\nlet initialize_scan_stack stack =\n  Stack.clear stack;\n  let queue_elem = { size = Size.unknown; token = Pp_text \"\"; length = 0 } in\n  Stack.push { left_total = -1; queue_elem } stack\n\n(* Setting the size of boxes on scan stack:\n   if ty = true then size of break is set else size of box is set;\n   in each case pp_scan_stack is popped.\n\n   Note:\n   Pattern matching on scan stack is exhaustive, since scan_stack is never\n   empty.\n   Pattern matching on token in scan stack is also exhaustive,\n   since scan_push is used on breaks and opening of boxes. *)\nlet set_size state ty =\n  match Stack.top_opt state.pp_scan_stack with\n  | None -> () (* scan_stack is never empty. *)\n  | Some { left_total; queue_elem } ->\n    let size = Size.to_int queue_elem.size in\n    (* test if scan stack contains any data that is not obsolete. *)\n    if left_total < state.pp_left_total then\n      initialize_scan_stack state.pp_scan_stack\n    else\n      match queue_elem.token with\n      | Pp_break _ | Pp_tbreak (_, _) ->\n        if ty then begin\n          queue_elem.size <- Size.of_int (state.pp_right_total + size);\n          Stack.pop_opt state.pp_scan_stack |> ignore\n        end\n      | Pp_begin (_, _) ->\n        if not ty then begin\n          queue_elem.size <- Size.of_int (state.pp_right_total + size);\n          Stack.pop_opt state.pp_scan_stack |> ignore\n        end\n      | Pp_text _ | Pp_stab | Pp_tbegin _ | Pp_tend | Pp_end\n      | Pp_newline | Pp_if_newline | Pp_open_tag _ | Pp_close_tag ->\n        () (* scan_push is only used for breaks and boxes. *)\n\n\n(* Push a token on pretty-printer scanning stack.\n   If b is true set_size is called. *)\nlet scan_push state b token =\n  pp_enqueue state token;\n  if b then set_size state true;\n  let elem = { left_total = state.pp_right_total; queue_elem = token } in\n  Stack.push elem state.pp_scan_stack\n\n\n(* To open a new box :\n   the user may set the depth bound pp_max_boxes\n   any text nested deeper is printed as the ellipsis string. *)\nlet pp_open_box_gen state indent br_ty =\n  state.pp_curr_depth <- state.pp_curr_depth + 1;\n  if state.pp_curr_depth < state.pp_max_boxes then\n    let size = Size.of_int (- state.pp_right_total) in\n    let elem = { size; token = Pp_begin (indent, br_ty); length = 0 } in\n    scan_push state false elem else\n  if state.pp_curr_depth = state.pp_max_boxes\n  then enqueue_string state state.pp_ellipsis\n\n\n(* The box which is always open. *)\nlet pp_open_sys_box state = pp_open_box_gen state 0 Pp_hovbox\n\n(* Close a box, setting sizes of its sub boxes. *)\nlet pp_close_box state () =\n  if state.pp_curr_depth > 1 then\n  begin\n    if state.pp_curr_depth < state.pp_max_boxes then\n    begin\n      pp_enqueue state { size = Size.zero; token = Pp_end; length = 0 };\n      set_size state true; set_size state false\n    end;\n    state.pp_curr_depth <- state.pp_curr_depth - 1;\n  end\n\n\n(* Open a tag, pushing it on the tag stack. *)\nlet pp_open_stag state tag_name =\n  if state.pp_print_tags then\n  begin\n    Stack.push tag_name state.pp_tag_stack;\n    state.pp_print_open_tag tag_name\n  end;\n  if state.pp_mark_tags then\n    let token = Pp_open_tag tag_name in\n    pp_enqueue state { size = Size.zero; token; length = 0 }\n\n\n(* Close a tag, popping it from the tag stack. *)\nlet pp_close_stag state () =\n  if state.pp_mark_tags then\n    pp_enqueue state { size = Size.zero; token = Pp_close_tag; length = 0 };\n  if state.pp_print_tags then\n    match Stack.pop_opt state.pp_tag_stack with\n    | None -> () (* No more tag to close. *)\n    | Some tag_name ->\n      state.pp_print_close_tag tag_name\n\nlet pp_open_tag state s = pp_open_stag state (String_tag s)\nlet pp_close_tag state () = pp_close_stag state ()\n\nlet pp_set_print_tags state b = state.pp_print_tags <- b\nlet pp_set_mark_tags state b = state.pp_mark_tags <- b\nlet pp_get_print_tags state () = state.pp_print_tags\nlet pp_get_mark_tags state () = state.pp_mark_tags\nlet pp_set_tags state b =\n  pp_set_print_tags state b; pp_set_mark_tags state b\n\n\n(* Handling tag handling functions: get/set functions. *)\nlet pp_get_formatter_stag_functions state () = {\n  mark_open_stag = state.pp_mark_open_tag;\n  mark_close_stag = state.pp_mark_close_tag;\n  print_open_stag = state.pp_print_open_tag;\n  print_close_stag = state.pp_print_close_tag;\n}\n\n\nlet pp_set_formatter_stag_functions state {\n     mark_open_stag = mot;\n     mark_close_stag = mct;\n     print_open_stag = pot;\n     print_close_stag = pct;\n  } =\n  state.pp_mark_open_tag <- mot;\n  state.pp_mark_close_tag <- mct;\n  state.pp_print_open_tag <- pot;\n  state.pp_print_close_tag <- pct\n\n\n(* Initialize pretty-printer. *)\nlet pp_rinit state =\n  pp_clear_queue state;\n  initialize_scan_stack state.pp_scan_stack;\n  Stack.clear state.pp_format_stack;\n  Stack.clear state.pp_tbox_stack;\n  Stack.clear state.pp_tag_stack;\n  Stack.clear state.pp_mark_stack;\n  state.pp_current_indent <- 0;\n  state.pp_curr_depth <- 0;\n  state.pp_space_left <- state.pp_margin;\n  pp_open_sys_box state\n\nlet clear_tag_stack state =\n  Stack.iter (fun _ -> pp_close_tag state ()) state.pp_tag_stack\n\n\n(* Flushing pretty-printer queue. *)\nlet pp_flush_queue state b =\n  clear_tag_stack state;\n  while state.pp_curr_depth > 1 do\n    pp_close_box state ()\n  done;\n  state.pp_right_total <- pp_infinity;\n  advance_left state;\n  if b then pp_output_newline state;\n  pp_rinit state\n\n(*\n\n  Procedures to format values and use boxes.\n\n*)\n\n(* To format a string. *)\nlet pp_print_as_size state size s =\n  if state.pp_curr_depth < state.pp_max_boxes\n  then enqueue_string_as state size s\n\n\nlet pp_print_as state isize s =\n  pp_print_as_size state (Size.of_int isize) s\n\n\nlet pp_print_string state s =\n  pp_print_as state (String.length s) s\n\nlet pp_print_bytes state s =\n  pp_print_as state (Bytes.length s) (Bytes.to_string s)\n\n(* To format an integer. *)\nlet pp_print_int state i = pp_print_string state (Int.to_string i)\n\n(* To format a float. *)\nlet pp_print_float state f = pp_print_string state (string_of_float f)\n\n(* To format a boolean. *)\nlet pp_print_bool state b = pp_print_string state (string_of_bool b)\n\n(* To format a char. *)\nlet pp_print_char state c =\n  pp_print_as state 1 (String.make 1 c)\n\n\n(* Opening boxes. *)\nlet pp_open_hbox state () = pp_open_box_gen state 0 Pp_hbox\nand pp_open_vbox state indent = pp_open_box_gen state indent Pp_vbox\n\nand pp_open_hvbox state indent = pp_open_box_gen state indent Pp_hvbox\nand pp_open_hovbox state indent = pp_open_box_gen state indent Pp_hovbox\nand pp_open_box state indent = pp_open_box_gen state indent Pp_box\n\n\n(* Printing queued text.\n\n   [pp_print_flush] prints all pending items in the pretty-printer queue and\n   then flushes the low level output device of the formatter to actually\n   display printing material.\n\n   [pp_print_newline] behaves as [pp_print_flush] after printing an additional\n   new line. *)\nlet pp_print_newline state () =\n  pp_flush_queue state true; state.pp_out_flush ()\nand pp_print_flush state () =\n  pp_flush_queue state false; state.pp_out_flush ()\n\n\n(* To get a newline when one does not want to close the current box. *)\nlet pp_force_newline state () =\n  if state.pp_curr_depth < state.pp_max_boxes then\n    enqueue_advance state { size = Size.zero; token = Pp_newline; length = 0 }\n\n\n(* To format something, only in case the line has just been broken. *)\nlet pp_print_if_newline state () =\n  if state.pp_curr_depth < state.pp_max_boxes then\n    enqueue_advance state\n      { size = Size.zero; token = Pp_if_newline; length = 0 }\n\n\n(* Generalized break hint that allows printing strings before/after\n   same-line offset (width) or new-line offset *)\nlet pp_print_custom_break state ~fits ~breaks =\n  let before, width, after = fits in\n  if state.pp_curr_depth < state.pp_max_boxes then\n    let size = Size.of_int (- state.pp_right_total) in\n    let token = Pp_break { fits; breaks } in\n    let length = String.length before + width + String.length after in\n    let elem = { size; token; length } in\n    scan_push state true elem\n\n(* Printing break hints:\n   A break hint indicates where a box may be broken.\n   If line is broken then offset is added to the indentation of the current\n   box else (the value of) width blanks are printed. *)\nlet pp_print_break state width offset =\n  pp_print_custom_break state\n    ~fits:(\"\", width, \"\") ~breaks:(\"\", offset, \"\")\n\n\n(* Print a space :\n   a space is a break hint that prints a single space if the break does not\n   split the line;\n   a cut is a break hint that prints nothing if the break does not split the\n   line. *)\nlet pp_print_space state () = pp_print_break state 1 0\nand pp_print_cut state () = pp_print_break state 0 0\n\n\n(* Tabulation boxes. *)\nlet pp_open_tbox state () =\n  state.pp_curr_depth <- state.pp_curr_depth + 1;\n  if state.pp_curr_depth < state.pp_max_boxes then\n    let size = Size.zero in\n    let elem = { size; token = Pp_tbegin (Pp_tbox (ref [])); length = 0 } in\n    enqueue_advance state elem\n\n\n(* Close a tabulation box. *)\nlet pp_close_tbox state () =\n  if state.pp_curr_depth > 1 then\n  begin\n   if state.pp_curr_depth < state.pp_max_boxes then\n     let elem = { size = Size.zero; token = Pp_tend; length = 0 } in\n     enqueue_advance state elem;\n     state.pp_curr_depth <- state.pp_curr_depth - 1\n  end\n\n\n(* Print a tabulation break. *)\nlet pp_print_tbreak state width offset =\n  if state.pp_curr_depth < state.pp_max_boxes then\n    let size = Size.of_int (- state.pp_right_total) in\n    let elem = { size; token = Pp_tbreak (width, offset); length = width } in\n    scan_push state true elem\n\n\nlet pp_print_tab state () = pp_print_tbreak state 0 0\n\nlet pp_set_tab state () =\n  if state.pp_curr_depth < state.pp_max_boxes then\n    let elem = { size = Size.zero; token = Pp_stab; length = 0 } in\n    enqueue_advance state elem\n\n\n(*\n\n  Procedures to control the pretty-printers\n\n*)\n\n(* Set_max_boxes. *)\nlet pp_set_max_boxes state n = if n > 1 then state.pp_max_boxes <- n\n\n(* To know the current maximum number of boxes allowed. *)\nlet pp_get_max_boxes state () = state.pp_max_boxes\n\nlet pp_over_max_boxes state () = state.pp_curr_depth = state.pp_max_boxes\n\n(* Ellipsis. *)\nlet pp_set_ellipsis_text state s = state.pp_ellipsis <- s\nand pp_get_ellipsis_text state () = state.pp_ellipsis\n\n\n(* To set the margin of pretty-printer. *)\nlet pp_limit n =\n  if n < pp_infinity then n else pred pp_infinity\n\n\n(* Internal pretty-printer functions. *)\nlet pp_set_min_space_left state n =\n  if n >= 1 then\n    let n = pp_limit n in\n    state.pp_min_space_left <- n;\n    state.pp_max_indent <- state.pp_margin - state.pp_min_space_left;\n    pp_rinit state\n\n\n(* Initially, we have :\n   pp_max_indent = pp_margin - pp_min_space_left, and\n   pp_space_left = pp_margin. *)\nlet pp_set_max_indent state n =\n  if n > 1 then\n    pp_set_min_space_left state (state.pp_margin - n)\n\n\nlet pp_get_max_indent state () = state.pp_max_indent\n\nlet pp_set_margin state n =\n  if n >= 1 then\n    let n = pp_limit n in\n    state.pp_margin <- n;\n    let new_max_indent =\n      (* Try to maintain max_indent to its actual value. *)\n      if state.pp_max_indent <= state.pp_margin\n      then state.pp_max_indent else\n      (* If possible maintain pp_min_space_left to its actual value,\n         if this leads to a too small max_indent, take half of the\n         new margin, if it is greater than 1. *)\n       Int.max (Int.max (state.pp_margin - state.pp_min_space_left)\n                (state.pp_margin / 2)) 1 in\n    (* Rebuild invariants. *)\n    pp_set_max_indent state new_max_indent\n\n\n(** Geometry functions and types *)\ntype geometry = { max_indent:int; margin: int}\n\nlet validate_geometry {margin; max_indent} =\n  if max_indent < 2 then\n    Error \"max_indent < 2\"\n  else if margin <= max_indent then\n    Error \"margin <= max_indent\"\n  else Ok ()\n\nlet check_geometry geometry =\n  match validate_geometry geometry with\n  | Ok () -> true\n  | Error _ -> false\n\nlet pp_get_margin state () = state.pp_margin\n\nlet pp_set_full_geometry state {margin; max_indent} =\n  pp_set_margin state margin;\n  pp_set_max_indent state max_indent;\n  ()\n\nlet pp_set_geometry state ~max_indent ~margin =\n  let geometry = { max_indent; margin } in\n  match validate_geometry geometry with\n  | Error msg ->\n    raise (Invalid_argument (\"Format.pp_set_geometry: \" ^ msg))\n  | Ok () ->\n    pp_set_full_geometry state geometry\n\nlet pp_safe_set_geometry state ~max_indent ~margin =\n  let geometry = { max_indent; margin } in\n  match validate_geometry geometry with\n  | Error _msg ->\n     ()\n  | Ok () ->\n    pp_set_full_geometry state geometry\n\nlet pp_get_geometry state () =\n  { margin = pp_get_margin state (); max_indent = pp_get_max_indent state () }\n\nlet pp_update_geometry state update =\n  let geometry = pp_get_geometry state () in\n  pp_set_full_geometry state (update geometry)\n\n(* Setting a formatter basic output functions. *)\nlet pp_set_formatter_out_functions state {\n      out_string = f;\n      out_flush = g;\n      out_newline = h;\n      out_spaces = i;\n      out_indent = j;\n    } =\n  state.pp_out_string <- f;\n  state.pp_out_flush <- g;\n  state.pp_out_newline <- h;\n  state.pp_out_spaces <- i;\n  state.pp_out_indent <- j\n\nlet pp_get_formatter_out_functions state () = {\n  out_string = state.pp_out_string;\n  out_flush = state.pp_out_flush;\n  out_newline = state.pp_out_newline;\n  out_spaces = state.pp_out_spaces;\n  out_indent = state.pp_out_indent;\n}\n\n\n(* Setting a formatter basic string output and flush functions. *)\nlet pp_set_formatter_output_functions state f g =\n  state.pp_out_string <- f; state.pp_out_flush <- g\n\nlet pp_get_formatter_output_functions state () =\n  (state.pp_out_string, state.pp_out_flush)\n\n\n(* The default function to output new lines. *)\nlet display_newline state () = state.pp_out_string \"\\n\" 0  1\n\n(* The default function to output spaces. *)\nlet blank_line = String.make 80 ' '\nlet rec display_blanks state n =\n  if n > 0 then\n  if n <= 80 then state.pp_out_string blank_line 0 n else\n  begin\n    state.pp_out_string blank_line 0 80;\n    display_blanks state (n - 80)\n  end\n\n\n(* The default function to output indentation of new lines. *)\nlet display_indent = display_blanks\n\n(* Setting a formatter basic output functions as printing to a given\n   [Pervasive.out_channel] value. *)\nlet pp_set_formatter_out_channel state oc =\n  state.pp_out_string <- output_substring oc;\n  state.pp_out_flush <- (fun () -> flush oc);\n  state.pp_out_newline <- display_newline state;\n  state.pp_out_spaces <- display_blanks state;\n  state.pp_out_indent <- display_indent state\n\n(*\n\n  Defining specific formatters\n\n*)\n\nlet default_pp_mark_open_tag = function\n  | String_tag s -> \"<\" ^ s ^ \">\"\n  | _ -> \"\"\nlet default_pp_mark_close_tag = function\n  | String_tag s -> \"</\" ^ s ^ \">\"\n  | _ -> \"\"\n\nlet default_pp_print_open_tag = ignore\nlet default_pp_print_close_tag = ignore\n\n(* Building a formatter given its basic output functions.\n   Other fields get reasonable default values. *)\nlet pp_make_formatter f g h i j =\n  (* The initial state of the formatter contains a dummy box. *)\n  let pp_queue = Queue.create () in\n  let sys_tok =\n    { size = Size.unknown; token = Pp_begin (0, Pp_hovbox); length = 0 } in\n  Queue.add sys_tok pp_queue;\n  let scan_stack = Stack.create () in\n  initialize_scan_stack scan_stack;\n  Stack.push { left_total = 1; queue_elem = sys_tok } scan_stack;\n  let pp_margin = 78\n  and pp_min_space_left = 10 in\n  {\n    pp_scan_stack = scan_stack;\n    pp_format_stack = Stack.create ();\n    pp_tbox_stack = Stack.create ();\n    pp_tag_stack = Stack.create ();\n    pp_mark_stack = Stack.create ();\n    pp_margin = pp_margin;\n    pp_min_space_left = pp_min_space_left;\n    pp_max_indent = pp_margin - pp_min_space_left;\n    pp_space_left = pp_margin;\n    pp_current_indent = 0;\n    pp_is_new_line = true;\n    pp_left_total = 1;\n    pp_right_total = 1;\n    pp_curr_depth = 1;\n    pp_max_boxes = max_int;\n    pp_ellipsis = \".\";\n    pp_out_string = f;\n    pp_out_flush = g;\n    pp_out_newline = h;\n    pp_out_spaces = i;\n    pp_out_indent = j;\n    pp_print_tags = false;\n    pp_mark_tags = false;\n    pp_mark_open_tag = default_pp_mark_open_tag;\n    pp_mark_close_tag = default_pp_mark_close_tag;\n    pp_print_open_tag = default_pp_print_open_tag;\n    pp_print_close_tag = default_pp_print_close_tag;\n    pp_queue = pp_queue;\n  }\n\n\n(* Build a formatter out of its out functions. *)\nlet formatter_of_out_functions out_funs =\n  pp_make_formatter\n    out_funs.out_string\n    out_funs.out_flush\n    out_funs.out_newline\n    out_funs.out_spaces\n    out_funs.out_indent\n\n\n(* Make a formatter with default functions to output spaces,\n  indentation, and new lines. *)\nlet make_formatter output flush =\n  let ppf = pp_make_formatter output flush ignore ignore ignore in\n  ppf.pp_out_newline <- display_newline ppf;\n  ppf.pp_out_spaces <- display_blanks ppf;\n  ppf.pp_out_indent <- display_indent ppf;\n  ppf\n\n\n(* Make a formatter writing to a given [Pervasive.out_channel] value. *)\nlet formatter_of_out_channel oc =\n  make_formatter (output_substring oc) (fun () -> flush oc)\n\n\n(* Make a formatter writing to a given [Buffer.t] value. *)\nlet formatter_of_buffer b =\n  make_formatter (Buffer.add_substring b) ignore\n\n\n(* Allocating buffer for pretty-printing purposes.\n   Default buffer size is pp_buffer_size or 512.\n*)\nlet pp_buffer_size = 512\nlet pp_make_buffer () = Buffer.create pp_buffer_size\n\n(* The standard (shared) buffer. *)\nlet stdbuf = pp_make_buffer ()\n\n(* Predefined formatters standard formatter to print\n   to [Stdlib.stdout], [Stdlib.stderr], and {!stdbuf}. *)\nlet std_formatter = formatter_of_out_channel Stdlib.stdout\nand err_formatter = formatter_of_out_channel Stdlib.stderr\nand str_formatter = formatter_of_buffer stdbuf\n\n\n(* [flush_buffer_formatter buf ppf] flushes formatter [ppf],\n   then returns the contents of buffer [buf] that is reset.\n   Formatter [ppf] is supposed to print to buffer [buf], otherwise this\n   function is not really useful. *)\nlet flush_buffer_formatter buf ppf =\n  pp_flush_queue ppf false;\n  let s = Buffer.contents buf in\n  Buffer.reset buf;\n  s\n\n\n(* Flush [str_formatter] and get the contents of [stdbuf]. *)\nlet flush_str_formatter () = flush_buffer_formatter stdbuf str_formatter\n\n(*\n  Symbolic pretty-printing\n*)\n\n(*\n  Symbolic pretty-printing is pretty-printing with no low level output.\n\n  When using a symbolic formatter, all regular pretty-printing activities\n  occur but output material is symbolic and stored in a buffer of output\n  items. At the end of pretty-printing, flushing the output buffer allows\n  post-processing of symbolic output before low level output operations.\n*)\n\ntype symbolic_output_item =\n  | Output_flush\n  | Output_newline\n  | Output_string of string\n  | Output_spaces of int\n  | Output_indent of int\n\ntype symbolic_output_buffer = {\n  mutable symbolic_output_contents : symbolic_output_item list;\n}\n\nlet make_symbolic_output_buffer () =\n  { symbolic_output_contents = [] }\n\nlet clear_symbolic_output_buffer sob =\n  sob.symbolic_output_contents <- []\n\nlet get_symbolic_output_buffer sob =\n  List.rev sob.symbolic_output_contents\n\nlet flush_symbolic_output_buffer sob =\n  let items = get_symbolic_output_buffer sob in\n  clear_symbolic_output_buffer sob;\n  items\n\nlet add_symbolic_output_item sob item =\n  sob.symbolic_output_contents <- item :: sob.symbolic_output_contents\n\nlet formatter_of_symbolic_output_buffer sob =\n  let symbolic_flush sob () =\n    add_symbolic_output_item sob Output_flush\n  and symbolic_newline sob () =\n    add_symbolic_output_item sob Output_newline\n  and symbolic_string sob s i n =\n    add_symbolic_output_item sob (Output_string (String.sub s i n))\n  and symbolic_spaces sob n =\n    add_symbolic_output_item sob (Output_spaces n)\n  and symbolic_indent sob n =\n    add_symbolic_output_item sob (Output_indent n) in\n\n  let f = symbolic_string sob\n  and g = symbolic_flush sob\n  and h = symbolic_newline sob\n  and i = symbolic_spaces sob\n  and j = symbolic_indent sob in\n  pp_make_formatter f g h i j\n\n(*\n\n  Basic functions on the 'standard' formatter\n  (the formatter that prints to [Stdlib.stdout]).\n\n*)\n\nlet open_hbox = pp_open_hbox std_formatter\nand open_vbox = pp_open_vbox std_formatter\nand open_hvbox = pp_open_hvbox std_formatter\nand open_hovbox = pp_open_hovbox std_formatter\nand open_box = pp_open_box std_formatter\nand close_box = pp_close_box std_formatter\nand open_tag = pp_open_tag std_formatter\nand close_tag = pp_close_tag std_formatter\nand open_stag = pp_open_stag std_formatter\nand close_stag = pp_close_stag std_formatter\nand print_as = pp_print_as std_formatter\nand print_string = pp_print_string std_formatter\nand print_bytes = pp_print_bytes std_formatter\nand print_int = pp_print_int std_formatter\nand print_float = pp_print_float std_formatter\nand print_char = pp_print_char std_formatter\nand print_bool = pp_print_bool std_formatter\nand print_break = pp_print_break std_formatter\nand print_cut = pp_print_cut std_formatter\nand print_space = pp_print_space std_formatter\nand force_newline = pp_force_newline std_formatter\nand print_flush = pp_print_flush std_formatter\nand print_newline = pp_print_newline std_formatter\nand print_if_newline = pp_print_if_newline std_formatter\n\nand open_tbox = pp_open_tbox std_formatter\nand close_tbox = pp_close_tbox std_formatter\nand print_tbreak = pp_print_tbreak std_formatter\n\nand set_tab = pp_set_tab std_formatter\nand print_tab = pp_print_tab std_formatter\n\nand set_margin = pp_set_margin std_formatter\nand get_margin = pp_get_margin std_formatter\n\nand set_max_indent = pp_set_max_indent std_formatter\nand get_max_indent = pp_get_max_indent std_formatter\n\nand set_geometry = pp_set_geometry std_formatter\nand safe_set_geometry = pp_safe_set_geometry std_formatter\nand get_geometry = pp_get_geometry std_formatter\nand update_geometry = pp_update_geometry std_formatter\n\nand set_max_boxes = pp_set_max_boxes std_formatter\nand get_max_boxes = pp_get_max_boxes std_formatter\nand over_max_boxes = pp_over_max_boxes std_formatter\n\nand set_ellipsis_text = pp_set_ellipsis_text std_formatter\nand get_ellipsis_text = pp_get_ellipsis_text std_formatter\n\nand set_formatter_out_channel =\n  pp_set_formatter_out_channel std_formatter\n\nand set_formatter_out_functions =\n  pp_set_formatter_out_functions std_formatter\nand get_formatter_out_functions =\n  pp_get_formatter_out_functions std_formatter\n\nand set_formatter_output_functions =\n  pp_set_formatter_output_functions std_formatter\nand get_formatter_output_functions =\n  pp_get_formatter_output_functions std_formatter\n\nand set_formatter_stag_functions =\n  pp_set_formatter_stag_functions std_formatter\nand get_formatter_stag_functions =\n  pp_get_formatter_stag_functions std_formatter\nand set_print_tags =\n  pp_set_print_tags std_formatter\nand get_print_tags =\n  pp_get_print_tags std_formatter\nand set_mark_tags =\n  pp_set_mark_tags std_formatter\nand get_mark_tags =\n  pp_get_mark_tags std_formatter\nand set_tags =\n  pp_set_tags std_formatter\n\n\n(* Convenience functions *)\n\n(* To format a list *)\nlet rec pp_print_list ?(pp_sep = pp_print_cut) pp_v ppf = function\n  | [] -> ()\n  | [v] -> pp_v ppf v\n  | v :: vs ->\n    pp_v ppf v;\n    pp_sep ppf ();\n    pp_print_list ~pp_sep pp_v ppf vs\n\n(* To format a sequence *)\nlet rec pp_print_seq_in ~pp_sep pp_v ppf seq =\n  match seq () with\n  | Seq.Nil -> ()\n  | Seq.Cons (v, seq) ->\n    pp_sep ppf ();\n    pp_v ppf v;\n    pp_print_seq_in ~pp_sep pp_v ppf seq\n\nlet pp_print_seq ?(pp_sep = pp_print_cut) pp_v ppf seq =\n  match seq () with\n  | Seq.Nil -> ()\n  | Seq.Cons (v, seq) ->\n    pp_v ppf v;\n    pp_print_seq_in ~pp_sep pp_v ppf seq\n\n(* To format free-flowing text *)\nlet pp_print_text ppf s =\n  let len = String.length s in\n  let left = ref 0 in\n  let right = ref 0 in\n  let flush () =\n    pp_print_string ppf (String.sub s !left (!right - !left));\n    incr right; left := !right;\n  in\n  while (!right <> len) do\n    match s.[!right] with\n      | '\\n' ->\n        flush ();\n        pp_force_newline ppf ()\n      | ' ' ->\n        flush (); pp_print_space ppf ()\n      (* there is no specific support for '\\t'\n         as it is unclear what a right semantics would be *)\n      | _ -> incr right\n  done;\n  if !left <> len then flush ()\n\nlet pp_print_option ?(none = fun _ () -> ()) pp_v ppf = function\n| None -> none ppf ()\n| Some v -> pp_v ppf v\n\nlet pp_print_result ~ok ~error ppf = function\n| Ok v -> ok ppf v\n| Error e -> error ppf e\n\nlet pp_print_either ~left ~right ppf = function\n| Either.Left l -> left ppf l\n| Either.Right r -> right ppf r\n\n (**************************************************************)\n\nlet compute_tag output tag_acc =\n  let buf = Buffer.create 16 in\n  let ppf = formatter_of_buffer buf in\n  output ppf tag_acc;\n  pp_print_flush ppf ();\n  let len = Buffer.length buf in\n  if len < 2 then Buffer.contents buf\n  else Buffer.sub buf 1 (len - 2)\n\n (**************************************************************\n\n  Defining continuations to be passed as arguments of\n  CamlinternalFormat.make_printf.\n\n  **************************************************************)\n\nopen CamlinternalFormatBasics\nopen CamlinternalFormat\n\n(* Interpret a formatting entity on a formatter. *)\nlet output_formatting_lit ppf fmting_lit = match fmting_lit with\n  | Close_box                 -> pp_close_box ppf ()\n  | Close_tag                 -> pp_close_tag ppf ()\n  | Break (_, width, offset)  -> pp_print_break ppf width offset\n  | FFlush                    -> pp_print_flush ppf ()\n  | Force_newline             -> pp_force_newline ppf ()\n  | Flush_newline             -> pp_print_newline ppf ()\n  | Magic_size (_, _)         -> ()\n  | Escaped_at                -> pp_print_char ppf '@'\n  | Escaped_percent           -> pp_print_char ppf '%'\n  | Scan_indic c              -> pp_print_char ppf '@'; pp_print_char ppf c\n\n(* Recursively output an \"accumulator\" containing a reversed list of\n   printing entities (string, char, flus, ...) in an output_stream. *)\n(* Differ from Printf.output_acc by the interpretation of formatting. *)\n(* Used as a continuation of CamlinternalFormat.make_printf. *)\nlet rec output_acc ppf acc = match acc with\n  | Acc_string_literal (Acc_formatting_lit (p, Magic_size (_, size)), s)\n  | Acc_data_string (Acc_formatting_lit (p, Magic_size (_, size)), s) ->\n    output_acc ppf p;\n    pp_print_as_size ppf (Size.of_int size) s;\n  | Acc_char_literal (Acc_formatting_lit (p, Magic_size (_, size)), c)\n  | Acc_data_char (Acc_formatting_lit (p, Magic_size (_, size)), c) ->\n    output_acc ppf p;\n    pp_print_as_size ppf (Size.of_int size) (String.make 1 c);\n  | Acc_formatting_lit (p, f) ->\n    output_acc ppf p;\n    output_formatting_lit ppf f;\n  | Acc_formatting_gen (p, Acc_open_tag acc') ->\n    output_acc ppf p;\n    pp_open_stag ppf (String_tag (compute_tag output_acc acc'))\n  | Acc_formatting_gen (p, Acc_open_box acc') ->\n    output_acc ppf p;\n    let (indent, bty) = open_box_of_string (compute_tag output_acc acc') in\n    pp_open_box_gen ppf indent bty\n  | Acc_string_literal (p, s)\n  | Acc_data_string (p, s)   -> output_acc ppf p; pp_print_string ppf s;\n  | Acc_char_literal (p, c)\n  | Acc_data_char (p, c)     -> output_acc ppf p; pp_print_char ppf c;\n  | Acc_delay (p, f)         -> output_acc ppf p; f ppf;\n  | Acc_flush p              -> output_acc ppf p; pp_print_flush ppf ();\n  | Acc_invalid_arg (p, msg) -> output_acc ppf p; invalid_arg msg;\n  | End_of_acc               -> ()\n\n(* Recursively output an \"accumulator\" containing a reversed list of\n   printing entities (string, char, flus, ...) in a buffer. *)\n(* Differ from Printf.bufput_acc by the interpretation of formatting. *)\n(* Used as a continuation of CamlinternalFormat.make_printf. *)\nlet rec strput_acc ppf acc = match acc with\n  | Acc_string_literal (Acc_formatting_lit (p, Magic_size (_, size)), s)\n  | Acc_data_string (Acc_formatting_lit (p, Magic_size (_, size)), s) ->\n    strput_acc ppf p;\n    pp_print_as_size ppf (Size.of_int size) s;\n  | Acc_char_literal (Acc_formatting_lit (p, Magic_size (_, size)), c)\n  | Acc_data_char (Acc_formatting_lit (p, Magic_size (_, size)), c) ->\n    strput_acc ppf p;\n    pp_print_as_size ppf (Size.of_int size) (String.make 1 c);\n  | Acc_delay (Acc_formatting_lit (p, Magic_size (_, size)), f) ->\n    strput_acc ppf p;\n    pp_print_as_size ppf (Size.of_int size) (f ());\n  | Acc_formatting_lit (p, f) ->\n    strput_acc ppf p;\n    output_formatting_lit ppf f;\n  | Acc_formatting_gen (p, Acc_open_tag acc') ->\n    strput_acc ppf p;\n    pp_open_stag ppf (String_tag (compute_tag strput_acc acc'))\n  | Acc_formatting_gen (p, Acc_open_box acc') ->\n    strput_acc ppf p;\n    let (indent, bty) = open_box_of_string (compute_tag strput_acc acc') in\n    pp_open_box_gen ppf indent bty\n  | Acc_string_literal (p, s)\n  | Acc_data_string (p, s)   -> strput_acc ppf p; pp_print_string ppf s;\n  | Acc_char_literal (p, c)\n  | Acc_data_char (p, c)     -> strput_acc ppf p; pp_print_char ppf c;\n  | Acc_delay (p, f)         -> strput_acc ppf p; pp_print_string ppf (f ());\n  | Acc_flush p              -> strput_acc ppf p; pp_print_flush ppf ();\n  | Acc_invalid_arg (p, msg) -> strput_acc ppf p; invalid_arg msg;\n  | End_of_acc               -> ()\n\n(*\n\n  Defining [fprintf] and various flavors of [fprintf].\n\n*)\n\nlet kfprintf k ppf (Format (fmt, _)) =\n  make_printf\n    (fun acc -> output_acc ppf acc; k ppf)\n    End_of_acc fmt\n\nand ikfprintf k ppf (Format (fmt, _)) =\n  make_iprintf k ppf fmt\n\nlet ifprintf _ppf (Format (fmt, _)) =\n  make_iprintf ignore () fmt\n\nlet fprintf ppf = kfprintf ignore ppf\nlet printf fmt = fprintf std_formatter fmt\nlet eprintf fmt = fprintf err_formatter fmt\n\nlet kdprintf k (Format (fmt, _)) =\n  make_printf\n    (fun acc -> k (fun ppf -> output_acc ppf acc))\n    End_of_acc fmt\n\nlet dprintf fmt = kdprintf (fun i -> i) fmt\n\nlet ksprintf k (Format (fmt, _)) =\n  let b = pp_make_buffer () in\n  let ppf = formatter_of_buffer b in\n  let k acc =\n    strput_acc ppf acc;\n    k (flush_buffer_formatter b ppf) in\n  make_printf k End_of_acc fmt\n\n\nlet sprintf fmt = ksprintf id fmt\n\nlet kasprintf k (Format (fmt, _)) =\n  let b = pp_make_buffer () in\n  let ppf = formatter_of_buffer b in\n  let k acc =\n    output_acc ppf acc;\n    k (flush_buffer_formatter b ppf) in\n  make_printf k End_of_acc fmt\n\n\nlet asprintf fmt = kasprintf id fmt\n\n(* Flushing standard formatters at end of execution. *)\n\nlet flush_standard_formatters () =\n  pp_print_flush std_formatter ();\n  pp_print_flush err_formatter ()\n\nlet () = at_exit flush_standard_formatters\n\n(*\n\n  Deprecated stuff.\n\n*)\n\n(* Deprecated : subsumed by pp_set_formatter_out_functions *)\nlet pp_set_all_formatter_output_functions state\n    ~out:f ~flush:g ~newline:h ~spaces:i =\n  pp_set_formatter_output_functions state f g;\n  state.pp_out_newline <- h;\n  state.pp_out_spaces <- i\n\n(* Deprecated : subsumed by pp_get_formatter_out_functions *)\nlet pp_get_all_formatter_output_functions state () =\n  (state.pp_out_string, state.pp_out_flush,\n   state.pp_out_newline, state.pp_out_spaces)\n\n\n(* Deprecated : subsumed by set_formatter_out_functions *)\nlet set_all_formatter_output_functions =\n  pp_set_all_formatter_output_functions std_formatter\n\n\n(* Deprecated : subsumed by get_formatter_out_functions *)\nlet get_all_formatter_output_functions =\n  pp_get_all_formatter_output_functions std_formatter\n\n\n(* Deprecated : error prone function, do not use it.\n   This function is neither compositional nor incremental, since it flushes\n   the pretty-printer queue at each call.\n   To get the same functionality, define a formatter of your own writing to\n   the buffer argument, as in\n   let ppf = formatter_of_buffer b\n   then use {!fprintf ppf} as usual. *)\nlet bprintf b (Format (fmt, _) : ('a, formatter, unit) format) =\n  let ppf = formatter_of_buffer b in\n  let k acc = output_acc ppf acc; pp_flush_queue ppf false in\n  make_printf k End_of_acc fmt\n\n\n(* Deprecated : alias for ksprintf. *)\nlet kprintf = ksprintf\n\n\n\n(* Deprecated tag functions *)\n\ntype formatter_tag_functions = {\n  mark_open_tag : tag -> string;\n  mark_close_tag : tag -> string;\n  print_open_tag : tag -> unit;\n  print_close_tag : tag -> unit;\n}\n\n\nlet pp_set_formatter_tag_functions state {\n     mark_open_tag = mot;\n     mark_close_tag = mct;\n     print_open_tag = pot;\n     print_close_tag = pct;\n   } =\n  let stringify f e = function String_tag s -> f s | _ -> e in\n  state.pp_mark_open_tag <- stringify mot \"\";\n  state.pp_mark_close_tag <- stringify mct \"\";\n  state.pp_print_open_tag <- stringify pot ();\n  state.pp_print_close_tag <- stringify pct ()\n\nlet pp_get_formatter_tag_functions fmt () =\n  let funs = pp_get_formatter_stag_functions fmt () in\n  let mark_open_tag s = funs.mark_open_stag (String_tag s) in\n  let mark_close_tag s = funs.mark_close_stag (String_tag s) in\n  let print_open_tag s = funs.print_open_stag (String_tag s) in\n  let print_close_tag s = funs.print_close_stag (String_tag s) in\n  {mark_open_tag; mark_close_tag; print_open_tag; print_close_tag}\n\nlet set_formatter_tag_functions =\n  pp_set_formatter_tag_functions std_formatter\nand get_formatter_tag_functions =\n  pp_get_formatter_tag_functions std_formatter\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Registering OCaml values with the C runtime for later callbacks *)\n\nexternal register_named_value : string -> Obj.t -> unit\n                              = \"caml_register_named_value\"\n\nlet register name v =\n  register_named_value name (Obj.repr v)\n\nlet register_exception name (exn : exn) =\n  let exn = Obj.repr exn in\n  let slot = if Obj.tag exn = Obj.object_tag then exn else Obj.field exn 0 in\n  register_named_value name slot\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*          Jerome Vouillon, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 2002 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nopen Obj\n\n(**** Object representation ****)\n\nexternal set_id: 'a -> 'a = \"caml_set_oo_id\" [@@noalloc]\n\n(**** Object copy ****)\n\nlet copy o =\n  let o = (Obj.obj (Obj.dup (Obj.repr o))) in\n  set_id o\n\n(**** Compression options ****)\n(* Parameters *)\ntype params = {\n    mutable compact_table : bool;\n    mutable copy_parent : bool;\n    mutable clean_when_copying : bool;\n    mutable retry_count : int;\n    mutable bucket_small_size : int\n  }\n\nlet params = {\n  compact_table = true;\n  copy_parent = true;\n  clean_when_copying = true;\n  retry_count = 3;\n  bucket_small_size = 16\n}\n\n(**** Parameters ****)\n\nlet initial_object_size = 2\n\n(**** Items ****)\n\ntype item = DummyA | DummyB | DummyC of int\nlet _ = [DummyA; DummyB; DummyC 0] (* to avoid warnings *)\n\nlet dummy_item = (magic () : item)\n\n(**** Types ****)\n\ntype tag\ntype label = int\ntype closure = item\ntype t = DummyA | DummyB | DummyC of int\nlet _ = [DummyA; DummyB; DummyC 0] (* to avoid warnings *)\n\ntype obj = t array\nexternal ret : (obj -> 'a) -> closure = \"%identity\"\n\n(**** Labels ****)\n\nlet public_method_label s : tag =\n  let accu = ref 0 in\n  for i = 0 to String.length s - 1 do\n    accu := 223 * !accu + Char.code s.[i]\n  done;\n  (* reduce to 31 bits *)\n  accu := !accu land (1 lsl 31 - 1);\n  (* make it signed for 64 bits architectures *)\n  let tag = if !accu > 0x3FFFFFFF then !accu - (1 lsl 31) else !accu in\n  (* Printf.eprintf \"%s = %d\\n\" s tag; flush stderr; *)\n  magic tag\n\n(**** Sparse array ****)\n\nmodule Vars =\n  Map.Make(struct type t = string let compare (x:t) y = compare x y end)\ntype vars = int Vars.t\n\nmodule Meths =\n  Map.Make(struct type t = string let compare (x:t) y = compare x y end)\ntype meths = label Meths.t\nmodule Labs =\n  Map.Make(struct type t = label let compare (x:t) y = compare x y end)\ntype labs = bool Labs.t\n\n(* The compiler assumes that the first field of this structure is [size]. *)\ntype table =\n { mutable size: int;\n   mutable methods: closure array;\n   mutable methods_by_name: meths;\n   mutable methods_by_label: labs;\n   mutable previous_states:\n     (meths * labs * (label * item) list * vars *\n      label list * string list) list;\n   mutable hidden_meths: (label * item) list;\n   mutable vars: vars;\n   mutable initializers: (obj -> unit) list }\n\nlet dummy_table =\n  { methods = [| dummy_item |];\n    methods_by_name = Meths.empty;\n    methods_by_label = Labs.empty;\n    previous_states = [];\n    hidden_meths = [];\n    vars = Vars.empty;\n    initializers = [];\n    size = 0 }\n\nlet table_count = ref 0\n\n(* dummy_met should be a pointer, so use an atom *)\nlet dummy_met : item = obj (Obj.new_block 0 0)\n(* if debugging is needed, this could be a good idea: *)\n(* let dummy_met () = failwith \"Undefined method\" *)\n\nlet rec fit_size n =\n  if n <= 2 then n else\n  fit_size ((n+1)/2) * 2\n\nlet new_table pub_labels =\n  incr table_count;\n  let len = Array.length pub_labels in\n  let methods = Array.make (len*2+2) dummy_met in\n  methods.(0) <- magic len;\n  methods.(1) <- magic (fit_size len * Sys.word_size / 8 - 1);\n  for i = 0 to len - 1 do methods.(i*2+3) <- magic pub_labels.(i) done;\n  { methods = methods;\n    methods_by_name = Meths.empty;\n    methods_by_label = Labs.empty;\n    previous_states = [];\n    hidden_meths = [];\n    vars = Vars.empty;\n    initializers = [];\n    size = initial_object_size }\n\nlet resize array new_size =\n  let old_size = Array.length array.methods in\n  if new_size > old_size then begin\n    let new_buck = Array.make new_size dummy_met in\n    Array.blit array.methods 0 new_buck 0 old_size;\n    array.methods <- new_buck\n end\n\nlet put array label element =\n  resize array (label + 1);\n  array.methods.(label) <- element\n\n(**** Classes ****)\n\nlet method_count = ref 0\nlet inst_var_count = ref 0\n\n(* type t *)\ntype meth = item\n\nlet new_method table =\n  let index = Array.length table.methods in\n  resize table (index + 1);\n  index\n\nlet get_method_label table name =\n  try\n    Meths.find name table.methods_by_name\n  with Not_found ->\n    let label = new_method table in\n    table.methods_by_name <- Meths.add name label table.methods_by_name;\n    table.methods_by_label <- Labs.add label true table.methods_by_label;\n    label\n\nlet get_method_labels table names =\n  Array.map (get_method_label table) names\n\nlet set_method table label element =\n  incr method_count;\n  if Labs.find label table.methods_by_label then\n    put table label element\n  else\n    table.hidden_meths <- (label, element) :: table.hidden_meths\n\nlet get_method table label =\n  try List.assoc label table.hidden_meths\n  with Not_found -> table.methods.(label)\n\nlet to_list arr =\n  if arr == magic 0 then [] else Array.to_list arr\n\nlet narrow table vars virt_meths concr_meths =\n  let vars = to_list vars\n  and virt_meths = to_list virt_meths\n  and concr_meths = to_list concr_meths in\n  let virt_meth_labs = List.map (get_method_label table) virt_meths in\n  let concr_meth_labs = List.map (get_method_label table) concr_meths in\n  table.previous_states <-\n     (table.methods_by_name, table.methods_by_label, table.hidden_meths,\n      table.vars, virt_meth_labs, vars)\n     :: table.previous_states;\n  table.vars <-\n    Vars.fold\n      (fun lab info tvars ->\n        if List.mem lab vars then Vars.add lab info tvars else tvars)\n      table.vars Vars.empty;\n  let by_name = ref Meths.empty in\n  let by_label = ref Labs.empty in\n  List.iter2\n    (fun met label ->\n       by_name := Meths.add met label !by_name;\n       by_label :=\n          Labs.add label\n            (try Labs.find label table.methods_by_label with Not_found -> true)\n            !by_label)\n    concr_meths concr_meth_labs;\n  List.iter2\n    (fun met label ->\n       by_name := Meths.add met label !by_name;\n       by_label := Labs.add label false !by_label)\n    virt_meths virt_meth_labs;\n  table.methods_by_name <- !by_name;\n  table.methods_by_label <- !by_label;\n  table.hidden_meths <-\n     List.fold_right\n       (fun ((lab, _) as met) hm ->\n          if List.mem lab virt_meth_labs then hm else met::hm)\n       table.hidden_meths\n       []\n\nlet widen table =\n  let (by_name, by_label, saved_hidden_meths, saved_vars, virt_meths, vars) =\n    List.hd table.previous_states\n  in\n  table.previous_states <- List.tl table.previous_states;\n  table.vars <-\n     List.fold_left\n       (fun s v -> Vars.add v (Vars.find v table.vars) s)\n       saved_vars vars;\n  table.methods_by_name <- by_name;\n  table.methods_by_label <- by_label;\n  table.hidden_meths <-\n     List.fold_right\n       (fun ((lab, _) as met) hm ->\n          if List.mem lab virt_meths then hm else met::hm)\n       table.hidden_meths\n       saved_hidden_meths\n\nlet new_slot table =\n  let index = table.size in\n  table.size <- index + 1;\n  index\n\nlet new_variable table name =\n  try Vars.find name table.vars\n  with Not_found ->\n    let index = new_slot table in\n    if name <> \"\" then table.vars <- Vars.add name index table.vars;\n    index\n\nlet to_array arr =\n  if arr = Obj.magic 0 then [||] else arr\n\nlet new_methods_variables table meths vals =\n  let meths = to_array meths in\n  let nmeths = Array.length meths and nvals = Array.length vals in\n  let res = Array.make (nmeths + nvals) 0 in\n  for i = 0 to nmeths - 1 do\n    res.(i) <- get_method_label table meths.(i)\n  done;\n  for i = 0 to nvals - 1 do\n    res.(i+nmeths) <- new_variable table vals.(i)\n  done;\n  res\n\nlet get_variable table name =\n  try Vars.find name table.vars with Not_found -> assert false\n\nlet get_variables table names =\n  Array.map (get_variable table) names\n\nlet add_initializer table f =\n  table.initializers <- f::table.initializers\n\n(*\nmodule Keys =\n  Map.Make(struct type t = tag array let compare (x:t) y = compare x y end)\nlet key_map = ref Keys.empty\nlet get_key tags : item =\n  try magic (Keys.find tags !key_map : tag array)\n  with Not_found ->\n    key_map := Keys.add tags tags !key_map;\n    magic tags\n*)\n\nlet create_table public_methods =\n  if public_methods == magic 0 then new_table [||] else\n  (* [public_methods] must be in ascending order for bytecode *)\n  let tags = Array.map public_method_label public_methods in\n  let table = new_table tags in\n  Array.iteri\n    (fun i met ->\n      let lab = i*2+2 in\n      table.methods_by_name  <- Meths.add met lab table.methods_by_name;\n      table.methods_by_label <- Labs.add lab true table.methods_by_label)\n    public_methods;\n  table\n\nlet init_class table =\n  inst_var_count := !inst_var_count + table.size - 1;\n  table.initializers <- List.rev table.initializers;\n  resize table (3 + magic table.methods.(1) * 16 / Sys.word_size)\n\nlet inherits cla vals virt_meths concr_meths (_, super, _, env) top =\n  narrow cla vals virt_meths concr_meths;\n  let init =\n    if top then super cla env else Obj.repr (super cla) in\n  widen cla;\n  Array.concat\n    [[| repr init |];\n     magic (Array.map (get_variable cla) (to_array vals) : int array);\n     Array.map\n       (fun nm -> repr (get_method cla (get_method_label cla nm) : closure))\n       (to_array concr_meths) ]\n\nlet make_class pub_meths class_init =\n  let table = create_table pub_meths in\n  let env_init = class_init table in\n  init_class table;\n  (env_init (Obj.repr 0), class_init, env_init, Obj.repr 0)\n\ntype init_table = { mutable env_init: t; mutable class_init: table -> t }\n[@@warning \"-unused-field\"]\n\nlet make_class_store pub_meths class_init init_table =\n  let table = create_table pub_meths in\n  let env_init = class_init table in\n  init_class table;\n  init_table.class_init <- class_init;\n  init_table.env_init <- env_init\n\nlet dummy_class loc =\n  let undef = fun _ -> raise (Undefined_recursive_module loc) in\n  (Obj.magic undef, undef, undef, Obj.repr 0)\n\n(**** Objects ****)\n\nlet create_object table =\n  (* XXX Appel de [obj_block] | Call to [obj_block]  *)\n  let obj = Obj.new_block Obj.object_tag table.size in\n  (* XXX Appel de [caml_modify] | Call to [caml_modify] *)\n  Obj.set_field obj 0 (Obj.repr table.methods);\n  Obj.obj (set_id obj)\n\nlet create_object_opt obj_0 table =\n  if (Obj.magic obj_0 : bool) then obj_0 else begin\n    (* XXX Appel de [obj_block] | Call to [obj_block]  *)\n    let obj = Obj.new_block Obj.object_tag table.size in\n    (* XXX Appel de [caml_modify] | Call to [caml_modify] *)\n    Obj.set_field obj 0 (Obj.repr table.methods);\n    Obj.obj (set_id obj)\n  end\n\nlet rec iter_f obj =\n  function\n    []   -> ()\n  | f::l -> f obj; iter_f obj l\n\nlet run_initializers obj table =\n  let inits = table.initializers in\n  if inits <> [] then\n    iter_f obj inits\n\nlet run_initializers_opt obj_0 obj table =\n  if (Obj.magic obj_0 : bool) then obj else begin\n    let inits = table.initializers in\n    if inits <> [] then iter_f obj inits;\n    obj\n  end\n\nlet create_object_and_run_initializers obj_0 table =\n  if (Obj.magic obj_0 : bool) then obj_0 else begin\n    let obj = create_object table in\n    run_initializers obj table;\n    obj\n  end\n\n(* Equivalent primitive below\nlet sendself obj lab =\n  (magic obj : (obj -> t) array array).(0).(lab) obj\n*)\nexternal send : obj -> tag -> 'a = \"%send\"\nexternal sendcache : obj -> tag -> t -> int -> 'a = \"%sendcache\"\nexternal sendself : obj -> label -> 'a = \"%sendself\"\nexternal get_public_method : obj -> tag -> closure\n    = \"caml_get_public_method\" [@@noalloc]\n\n(**** table collection access ****)\n\ntype tables =\n  | Empty\n  | Cons of {key : closure; mutable data: tables; mutable next: tables}\n\nlet set_data tables v = match tables with\n  | Empty -> assert false\n  | Cons tables -> tables.data <- v\nlet set_next tables v = match tables with\n  | Empty -> assert false\n  | Cons tables -> tables.next <- v\nlet get_key = function\n  | Empty -> assert false\n  | Cons tables -> tables.key\nlet get_data = function\n  | Empty -> assert false\n  | Cons tables -> tables.data\nlet get_next = function\n  | Empty -> assert false\n  | Cons tables -> tables.next\n\nlet build_path n keys tables =\n  let res = Cons {key = Obj.magic 0; data = Empty; next = Empty} in\n  let r = ref res in\n  for i = 0 to n do\n    r := Cons {key = keys.(i); data = !r; next = Empty}\n  done;\n  set_data tables !r;\n  res\n\nlet rec lookup_keys i keys tables =\n  if i < 0 then tables else\n  let key = keys.(i) in\n  let rec lookup_key (tables:tables) =\n    if get_key tables == key then\n      match get_data tables with\n      | Empty -> assert false\n      | Cons _ as tables_data ->\n          lookup_keys (i-1) keys tables_data\n    else\n      match get_next tables with\n      | Cons _ as next -> lookup_key next\n      | Empty ->\n          let next : tables = Cons {key; data = Empty; next = Empty} in\n          set_next tables next;\n          build_path (i-1) keys next\n  in\n  lookup_key tables\n\nlet lookup_tables root keys =\n  match get_data root with\n  | Cons _ as root_data ->\n    lookup_keys (Array.length keys - 1) keys root_data\n  | Empty ->\n    build_path (Array.length keys - 1) keys root\n\n(**** builtin methods ****)\n\nlet get_const x = ret (fun _obj -> x)\nlet get_var n   = ret (fun obj -> Array.unsafe_get obj n)\nlet get_env e n =\n  ret (fun obj ->\n    Array.unsafe_get (Obj.magic (Array.unsafe_get obj e) : obj) n)\nlet get_meth n  = ret (fun obj -> sendself obj n)\nlet set_var n   = ret (fun obj x -> Array.unsafe_set obj n x)\nlet app_const f x = ret (fun _obj -> f x)\nlet app_var f n   = ret (fun obj -> f (Array.unsafe_get obj n))\nlet app_env f e n =\n  ret (fun obj ->\n    f (Array.unsafe_get (Obj.magic (Array.unsafe_get obj e) : obj) n))\nlet app_meth f n  = ret (fun obj -> f (sendself obj n))\nlet app_const_const f x y = ret (fun _obj -> f x y)\nlet app_const_var f x n   = ret (fun obj -> f x (Array.unsafe_get obj n))\nlet app_const_meth f x n = ret (fun obj -> f x (sendself obj n))\nlet app_var_const f n x = ret (fun obj -> f (Array.unsafe_get obj n) x)\nlet app_meth_const f n x = ret (fun obj -> f (sendself obj n) x)\nlet app_const_env f x e n =\n  ret (fun obj ->\n    f x (Array.unsafe_get (Obj.magic (Array.unsafe_get obj e) : obj) n))\nlet app_env_const f e n x =\n  ret (fun obj ->\n    f (Array.unsafe_get (Obj.magic (Array.unsafe_get obj e) : obj) n) x)\nlet meth_app_const n x = ret (fun obj -> (sendself obj n : _ -> _) x)\nlet meth_app_var n m =\n  ret (fun obj -> (sendself obj n : _ -> _) (Array.unsafe_get obj m))\nlet meth_app_env n e m =\n  ret (fun obj -> (sendself obj n : _ -> _)\n      (Array.unsafe_get (Obj.magic (Array.unsafe_get obj e) : obj) m))\nlet meth_app_meth n m =\n  ret (fun obj -> (sendself obj n : _ -> _) (sendself obj m))\nlet send_const m x c =\n  ret (fun obj -> sendcache x m (Array.unsafe_get obj 0) c)\nlet send_var m n c =\n  ret (fun obj ->\n    sendcache (Obj.magic (Array.unsafe_get obj n) : obj) m\n      (Array.unsafe_get obj 0) c)\nlet send_env m e n c =\n  ret (fun obj ->\n    sendcache\n      (Obj.magic (Array.unsafe_get\n                    (Obj.magic (Array.unsafe_get obj e) : obj) n) : obj)\n      m (Array.unsafe_get obj 0) c)\nlet send_meth m n c =\n  ret (fun obj ->\n    sendcache (sendself obj n) m (Array.unsafe_get obj 0) c)\nlet new_cache table =\n  let n = new_method table in\n  let n =\n    if n mod 2 = 0 || n > 2 + magic table.methods.(1) * 16 / Sys.word_size\n    then n else new_method table\n  in\n  table.methods.(n) <- Obj.magic 0;\n  n\n\ntype impl =\n    GetConst\n  | GetVar\n  | GetEnv\n  | GetMeth\n  | SetVar\n  | AppConst\n  | AppVar\n  | AppEnv\n  | AppMeth\n  | AppConstConst\n  | AppConstVar\n  | AppConstEnv\n  | AppConstMeth\n  | AppVarConst\n  | AppEnvConst\n  | AppMethConst\n  | MethAppConst\n  | MethAppVar\n  | MethAppEnv\n  | MethAppMeth\n  | SendConst\n  | SendVar\n  | SendEnv\n  | SendMeth\n  | Closure of closure\n\nlet method_impl table i arr =\n  let next () = incr i; magic arr.(!i) in\n  match next() with\n    GetConst -> let x : t = next() in get_const x\n  | GetVar   -> let n = next() in get_var n\n  | GetEnv   -> let e = next() in let n = next() in get_env e n\n  | GetMeth  -> let n = next() in get_meth n\n  | SetVar   -> let n = next() in set_var n\n  | AppConst -> let f = next() in let x = next() in app_const f x\n  | AppVar   -> let f = next() in let n = next () in app_var f n\n  | AppEnv   ->\n      let f = next() in  let e = next() in let n = next() in\n      app_env f e n\n  | AppMeth  -> let f = next() in let n = next () in app_meth f n\n  | AppConstConst ->\n      let f = next() in let x = next() in let y = next() in\n      app_const_const f x y\n  | AppConstVar ->\n      let f = next() in let x = next() in let n = next() in\n      app_const_var f x n\n  | AppConstEnv ->\n      let f = next() in let x = next() in let e = next () in let n = next() in\n      app_const_env f x e n\n  | AppConstMeth ->\n      let f = next() in let x = next() in let n = next() in\n      app_const_meth f x n\n  | AppVarConst ->\n      let f = next() in let n = next() in let x = next() in\n      app_var_const f n x\n  | AppEnvConst ->\n      let f = next() in let e = next () in let n = next() in let x = next() in\n      app_env_const f e n x\n  | AppMethConst ->\n      let f = next() in let n = next() in let x = next() in\n      app_meth_const f n x\n  | MethAppConst ->\n      let n = next() in let x = next() in meth_app_const n x\n  | MethAppVar ->\n      let n = next() in let m = next() in meth_app_var n m\n  | MethAppEnv ->\n      let n = next() in let e = next() in let m = next() in\n      meth_app_env n e m\n  | MethAppMeth ->\n      let n = next() in let m = next() in meth_app_meth n m\n  | SendConst ->\n      let m = next() in let x = next() in send_const m x (new_cache table)\n  | SendVar ->\n      let m = next() in let n = next () in send_var m n (new_cache table)\n  | SendEnv ->\n      let m = next() in let e = next() in let n = next() in\n      send_env m e n (new_cache table)\n  | SendMeth ->\n      let m = next() in let n = next () in send_meth m n (new_cache table)\n  | Closure _ as clo -> magic clo\n\nlet set_methods table methods =\n  let len = Array.length methods in let i = ref 0 in\n  while !i < len do\n    let label = methods.(!i) in let clo = method_impl table i methods in\n    set_method table label clo;\n    incr i\n  done\n\n(**** Statistics ****)\n\ntype stats =\n  { classes: int; methods: int; inst_vars: int; }\n\nlet stats () =\n  { classes = !table_count;\n    methods = !method_count; inst_vars = !inst_var_count; }\n","module Js = struct\n  type t\n\n  type 'a js_array = t\n\n  type ('a, 'b) meth_callback = t\n\n  external string : string -> t = \"caml_jsstring_of_string\"\n\n  external to_string : t -> string = \"caml_string_of_jsstring\"\n\n  external bytestring : string -> t = \"caml_jsbytes_of_string\"\n\n  external to_bytestring : t -> string = \"caml_string_of_jsbytes\"\n\n  external bool : bool -> t = \"caml_js_from_bool\"\n\n  external to_bool : t -> bool = \"caml_js_to_bool\"\n\n  external array : 'a array -> t = \"caml_js_from_array\"\n\n  external to_array : t -> 'a array = \"caml_js_to_array\"\n\n  external number_of_float : float -> t = \"caml_js_from_float\"\n\n  external float_of_number : t -> float = \"caml_js_to_float\"\n\n  external number_of_int32 : int32 -> t = \"caml_js_from_int32\"\n\n  external int32_of_number : t -> int32 = \"caml_js_to_int32\"\n\n  external number_of_nativeint : nativeint -> t = \"caml_js_from_nativeint\"\n\n  external nativeint_of_number : t -> nativeint = \"caml_js_to_nativeint\"\n\n  external typeof : t -> t = \"caml_js_typeof\"\n\n  external instanceof : t -> t -> bool = \"caml_js_instanceof\"\n\n  external debugger : unit -> unit = \"debugger\"\n\n  external get : t -> t -> t = \"caml_js_get\"\n\n  external set : t -> t -> t -> unit = \"caml_js_set\"\n\n  external delete : t -> t -> unit = \"caml_js_delete\"\n\n  external call : t -> t -> t array -> t = \"caml_js_call\"\n\n  external fun_call : t -> t array -> t = \"caml_js_fun_call\"\n\n  external meth_call : t -> string -> t array -> t = \"caml_js_meth_call\"\n\n  external new_obj : t -> t array -> t = \"caml_js_new\"\n\n  external new_obj_arr : t -> t js_array -> t = \"caml_ojs_new_arr\"\n\n  external obj : (string * t) array -> t = \"caml_js_object\"\n\n  external equals : t -> t -> bool = \"caml_js_equals\"\n\n  external strict_equals : t -> t -> bool = \"caml_js_strict_equals\"\n\n  external pure_expr : (unit -> 'a) -> 'a = \"caml_js_pure_expr\"\n\n  external eval_string : string -> 'a = \"caml_js_eval_string\"\n\n  external js_expr : string -> 'a = \"caml_js_expr\"\n\n  external pure_js_expr : string -> 'a = \"caml_pure_js_expr\"\n\n  external callback : ('b -> 'a) -> ('b, 'a) meth_callback\n    = \"caml_js_wrap_callback_unsafe\"\n\n  external callback_with_arguments :\n    (t js_array -> 'b) -> ('c, t js_array -> 'b) meth_callback\n    = \"caml_js_wrap_callback_arguments\"\n\n  external callback_with_arity : int -> ('a -> 'b) -> ('c, 'a -> 'b) meth_callback\n    = \"caml_js_wrap_callback_strict\"\n\n  external meth_callback : ('b -> 'a) -> ('b, 'a) meth_callback\n    = \"caml_js_wrap_meth_callback_unsafe\"\n\n  external meth_callback_with_arity : int -> ('b -> 'a) -> ('b, 'a) meth_callback\n    = \"caml_js_wrap_meth_callback_strict\"\n\n  external meth_callback_with_arguments :\n    ('b -> t js_array -> 'a) -> ('b, t js_array -> 'a) meth_callback\n    = \"caml_js_wrap_meth_callback_arguments\"\n\n  external wrap_callback : ('a -> 'b) -> ('c, 'a -> 'b) meth_callback\n    = \"caml_js_wrap_callback\"\n\n  external wrap_meth_callback : ('a -> 'b) -> ('a, 'b) meth_callback\n    = \"caml_js_wrap_meth_callback\"\nend\n\nmodule Sys = struct\n  type 'a callback = 'a\n\n  external create_file : name:string -> content:string -> unit = \"caml_create_file\"\n\n  external read_file : name:string -> string = \"caml_read_file_content\"\n\n  external set_channel_output' : out_channel -> (js_string:Js.t -> unit) callback -> unit\n    = \"caml_ml_set_channel_output\"\n\n  external set_channel_input' : in_channel -> (unit -> string) callback -> unit\n    = \"caml_ml_set_channel_refill\"\n\n  external mount_point : unit -> string list = \"caml_list_mount_point\"\n\n  external mount_autoload : string -> (string -> string -> string option) callback -> unit\n    = \"caml_mount_autoload\"\n\n  external unmount : string -> unit = \"caml_unmount\"\n\n  type redirection\n\n  external redirect_channel : out_channel -> into:out_channel -> redirection\n    = \"caml_ml_channel_redirect\"\n\n  external restore_channel : out_channel -> redirection -> unit\n    = \"caml_ml_channel_restore\"\n\n  module Config = struct\n    external use_js_string : unit -> bool = \"caml_jsoo_flags_use_js_string\"\n\n    type effects_backend =\n      [ `Disabled\n      | `Cps\n      | `Double_translation\n      ]\n\n    external effects_ : unit -> string = \"caml_jsoo_flags_effects\"\n\n    let effects () =\n      match effects_ () with\n      | \"disabled\" -> `Disabled\n      | \"cps\" -> `Cps\n      | \"double-translation\" -> `Double_translation\n      | _ -> assert false\n  end\n\n  let version = Runtime_version.s\n\n  let git_version = Runtime_version.git_version\nend\n\nmodule Error : sig\n  type t\n\n  val raise_ : t -> 'a\n\n  val attach_js_backtrace : exn -> force:bool -> exn\n  (** Attach a JavasScript error to an OCaml exception.  if [force = false] and a\n    JavasScript error is already attached, it will do nothing. This function is useful to\n    store and retrieve information about JavaScript stack traces.\n\n    Attaching JavasScript errors will happen automatically when compiling with\n    [--enable with-js-error]. *)\n\n  val of_exn : exn -> t option\n  (** Extract a JavaScript error attached to an OCaml exception, if any.  This is useful to\n      inspect an eventual stack strace, especially when sourcemap is enabled. *)\n\n  exception Exn of t\n  (** The [Error] exception wrap javascript exceptions when caught by OCaml code.\n      In case the javascript exception is not an instance of javascript [Error],\n      it will be serialized and wrapped into a [Failure] exception.\n  *)\nend = struct\n  type t\n\n  exception Exn of t\n\n  let _ = Callback.register_exception \"jsError\" (Exn (Obj.magic [||]))\n\n  external raise_ : t -> 'a = \"caml_throw_js_exception\"\n\n  external of_exn : exn -> t option = \"caml_js_error_option_of_exception\"\n\n  external attach_js_backtrace : exn -> force:bool -> exn = \"caml_exn_with_js_backtrace\"\nend\n\n[@@@ocaml.warning \"-32-60\"]\n\nmodule For_compatibility_only = struct\n  (* Add primitives for compatibility reasons. Existing users might\n     depend on it (e.g. gen_js_api), we dont want the ocaml compiler\n     to complain about theses missing primitives. *)\n\n  external caml_js_from_string : string -> Js.t = \"caml_js_from_string\"\n\n  external caml_js_to_byte_string : Js.t -> string = \"caml_js_to_byte_string\"\n\n  external caml_js_to_string : Js.t -> string = \"caml_js_to_string\"\n\n  external caml_list_of_js_array : 'a Js.js_array -> 'a list = \"caml_list_of_js_array\"\n\n  external caml_list_to_js_array : 'a list -> 'a Js.js_array = \"caml_list_to_js_array\"\n\n  external variable : string -> 'a = \"caml_js_var\"\n\n  external caml_string_of_array : 'a array -> string = \"caml_string_of_array\"\nend\n\nmodule Typed_array = struct\n  type ('a, 'b) typedArray = Js.t\n\n  type arrayBuffer = Js.t\n\n  type uint8Array = Js.t\n\n  external kind : ('a, 'b) typedArray -> ('a, 'b) Bigarray.kind\n    = \"caml_ba_kind_of_typed_array\"\n\n  external from_genarray :\n    ('a, 'b, Bigarray.c_layout) Bigarray.Genarray.t -> ('a, 'b) typedArray\n    = \"caml_ba_to_typed_array\"\n\n  external to_genarray :\n    ('a, 'b) typedArray -> ('a, 'b, Bigarray.c_layout) Bigarray.Genarray.t\n    = \"caml_ba_from_typed_array\"\n\n  module Bigstring = struct\n    type t = (char, Bigarray.int8_unsigned_elt, Bigarray.c_layout) Bigarray.Array1.t\n\n    external to_arrayBuffer : t -> arrayBuffer = \"bigstring_to_array_buffer\"\n\n    external to_uint8Array : t -> uint8Array = \"bigstring_to_typed_array\"\n\n    external of_arrayBuffer : arrayBuffer -> t = \"bigstring_of_array_buffer\"\n\n    external of_uint8Array : uint8Array -> t = \"bigstring_of_typed_array\"\n  end\n\n  external of_uint8Array : uint8Array -> string = \"caml_string_of_uint8_array\"\nend\n\nmodule Int64 = struct\n  external create_int64_lo_mi_hi : int -> int -> int -> Int64.t\n    = \"caml_int64_create_lo_mi_hi\"\nend\n\nmodule Effect : sig\n  external assume_no_perform : (unit -> 'a) -> 'a = \"caml_assume_no_perform\"\n  (** Passing a function [f] as argument of `assume_no_perform` guarantees that,\n      when compiling with `--effects=double-translation`, the direct-style\n      version of [f] is called, which is faster than the CPS version. As a\n      consequence, performing an effect in a transitive callee of [f] will\n      raise `Effect.Unhandled`, regardless of any effect handlers installed\n      before the call to `assume_no_perform`, unless a new effect handler was\n      installed in the meantime.\n\n      This behaviour is the same when double translation is disabled. *)\nend = struct\n  external assume_no_perform : (unit -> 'a) -> 'a = \"caml_assume_no_perform\"\nend\n","(* Js_of_ocaml library\n * http://www.ocsigen.org/js_of_ocaml/\n * Copyright (C) 2010 Jérôme Vouillon\n * Laboratoire PPS - CNRS Université Paris Diderot\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, with linking exception;\n * either version 2.1 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *)\nopen! Import\n\n(* This local module [Js] is needed so that the ppx_js extension work within that file. *)\nmodule Js = struct\n  type +'a t\n\n  type (-'a, +'b) meth_callback\n\n  module Unsafe = struct\n    type top\n\n    type any = top t\n\n    type any_js_array = any\n\n    external inject : 'a -> any = \"%identity\"\n\n    external coerce : _ t -> _ t = \"%identity\"\n\n    external get : 'a -> 'b -> 'c = \"caml_js_get\"\n\n    external set : 'a -> 'b -> 'c -> unit = \"caml_js_set\"\n\n    external delete : 'a -> 'b -> unit = \"caml_js_delete\"\n\n    external call : 'a -> 'b -> any array -> 'c = \"caml_js_call\"\n\n    external fun_call : 'a -> any array -> 'b = \"caml_js_fun_call\"\n\n    external meth_call : 'a -> string -> any array -> 'b = \"caml_js_meth_call\"\n\n    external new_obj : 'a -> any array -> 'b = \"caml_js_new\"\n\n    external new_obj_arr : 'a -> any_js_array -> 'b = \"caml_ojs_new_arr\"\n\n    external obj : (string * any) array -> 'a = \"caml_js_object\"\n\n    external equals : 'a -> 'b -> bool = \"caml_js_equals\"\n\n    external strict_equals : 'a -> 'b -> bool = \"caml_js_strict_equals\"\n\n    external pure_expr : (unit -> 'a) -> 'a = \"caml_js_pure_expr\"\n\n    external eval_string : string -> 'a = \"caml_js_eval_string\"\n\n    external js_expr : string -> 'a = \"caml_js_expr\"\n\n    external pure_js_expr : string -> 'a = \"caml_pure_js_expr\"\n\n    let global = pure_js_expr \"globalThis\"\n\n    external callback : ('a -> 'b) -> ('c, 'a -> 'b) meth_callback\n      = \"caml_js_wrap_callback_unsafe\"\n\n    external callback_with_arguments :\n      (any_js_array -> 'b) -> ('c, any_js_array -> 'b) meth_callback\n      = \"caml_js_wrap_callback_arguments\"\n\n    external callback_with_arity : int -> ('a -> 'b) -> ('c, 'a -> 'b) meth_callback\n      = \"caml_js_wrap_callback_strict\"\n\n    external meth_callback : ('b -> 'a) -> ('b, 'a) meth_callback\n      = \"caml_js_wrap_meth_callback_unsafe\"\n\n    external meth_callback_with_arity : int -> ('b -> 'a) -> ('b, 'a) meth_callback\n      = \"caml_js_wrap_meth_callback_strict\"\n\n    external meth_callback_with_arguments :\n      ('b -> any_js_array -> 'a) -> ('b, any_js_array -> 'a) meth_callback\n      = \"caml_js_wrap_meth_callback_arguments\"\n\n    (* DEPRECATED *)\n    external variable : string -> 'a = \"caml_js_var\"\n  end\n\n  (****)\n\n  type 'a opt = 'a\n\n  type 'a optdef = 'a\n\n  external debugger : unit -> unit = \"debugger\"\n\n  let null : 'a opt = Unsafe.pure_js_expr \"null\"\n\n  external some : 'a -> 'a opt = \"%identity\"\n\n  let undefined : 'a optdef = Unsafe.pure_js_expr \"undefined\"\n\n  external def : 'a -> 'a optdef = \"%identity\"\n\n  module type OPT = sig\n    type 'a t\n\n    val empty : 'a t\n\n    val return : 'a -> 'a t\n\n    val map : 'a t -> ('a -> 'b) -> 'b t\n\n    val bind : 'a t -> ('a -> 'b t) -> 'b t\n\n    val test : 'a t -> bool\n\n    val iter : 'a t -> ('a -> unit) -> unit\n\n    val case : 'a t -> (unit -> 'b) -> ('a -> 'b) -> 'b\n\n    val get : 'a t -> (unit -> 'a) -> 'a\n\n    val option : 'a option -> 'a t\n\n    val to_option : 'a t -> 'a option\n\n    external equals : _ t -> _ t -> bool = \"caml_js_equals\"\n\n    external strict_equals : _ t -> _ t -> bool = \"caml_js_strict_equals\"\n  end\n\n  module Opt : OPT with type 'a t = 'a opt = struct\n    type 'a t = 'a opt\n\n    let empty = null\n\n    let return = some\n\n    external equals : _ t -> _ t -> bool = \"caml_js_equals\"\n\n    external strict_equals : _ t -> _ t -> bool = \"caml_js_strict_equals\"\n\n    let map x f = if equals x null then null else return (f x)\n\n    let bind x f = if equals x null then null else f x\n\n    let test x = not (equals x null)\n\n    let iter x f = if not (equals x null) then f x\n\n    let case x f g = if equals x null then f () else g x\n\n    let get x f = if equals x null then f () else x\n\n    let option x =\n      match x with\n      | None -> empty\n      | Some x -> return x\n\n    let to_option x = case x (fun () -> None) (fun x -> Some x)\n  end\n\n  module Optdef : OPT with type 'a t = 'a optdef = struct\n    type 'a t = 'a optdef\n\n    let empty = undefined\n\n    let return = def\n\n    external equals : _ t -> _ t -> bool = \"caml_js_equals\"\n\n    external strict_equals : _ t -> _ t -> bool = \"caml_js_strict_equals\"\n\n    let map x f = if strict_equals x undefined then undefined else return (f x)\n\n    let bind x f = if strict_equals x undefined then undefined else f x\n\n    let test x = not (strict_equals x undefined)\n\n    let iter x f = if not (strict_equals x undefined) then f x\n\n    let case x f g = if strict_equals x undefined then f () else g x\n\n    let get x f = if strict_equals x undefined then f () else x\n\n    let option x =\n      match x with\n      | None -> empty\n      | Some x -> return x\n\n    let to_option x = case x (fun () -> None) (fun x -> Some x)\n  end\n\n  (****)\n\n  let coerce x f g = Opt.get (f x) (fun () -> g x)\n\n  let coerce_opt x f g = Opt.get (Opt.bind x f) (fun () -> g x)\n\n  (****)\n\n  type +'a meth\n\n  type +'a gen_prop\n\n  type 'a readonly_prop = < get : 'a > gen_prop\n\n  type 'a writeonly_prop = < set : 'a -> unit > gen_prop\n\n  type 'a prop = < get : 'a ; set : 'a -> unit > gen_prop\n\n  type 'a optdef_prop = < get : 'a optdef ; set : 'a -> unit > gen_prop\n\n  type +'a constr\n\n  (****)\n\n  type 'a callback = (unit, 'a) meth_callback\n\n  external wrap_callback : ('a -> 'b) -> ('c, 'a -> 'b) meth_callback\n    = \"caml_js_wrap_callback\"\n\n  external wrap_meth_callback : ('a -> 'b) -> ('a, 'b) meth_callback\n    = \"caml_js_wrap_meth_callback\"\n\n  (****)\n\n  external equals : _ t -> _ t -> bool = \"caml_js_equals\"\n\n  external strict_equals : _ t -> _ t -> bool = \"caml_js_strict_equals\"\n\n  (****)\n\n  let _true = Unsafe.pure_js_expr \"true\"\n\n  let _false = Unsafe.pure_js_expr \"false\"\n\n  type match_result_handle\n\n  type string_array\n\n  class type number = object\n    method toString : js_string t meth\n\n    method toString_radix : int -> js_string t meth\n\n    method toLocaleString : js_string t meth\n\n    method toFixed : int -> js_string t meth\n\n    method toExponential : js_string t meth\n\n    method toExponential_digits : int -> js_string t meth\n\n    method toPrecision : int -> js_string t meth\n  end\n\n  and js_string = object\n    method toString : js_string t meth\n\n    method valueOf : js_string t meth\n\n    method charAt : int -> js_string t meth\n\n    method charCodeAt : int -> number t meth\n\n    method codePointAt : int -> number t optdef meth\n\n    (* This may return NaN... *)\n    method concat : js_string t -> js_string t meth\n\n    method concat_2 : js_string t -> js_string t -> js_string t meth\n\n    method concat_3 : js_string t -> js_string t -> js_string t -> js_string t meth\n\n    method concat_4 :\n      js_string t -> js_string t -> js_string t -> js_string t -> js_string t meth\n\n    method indexOf : js_string t -> int meth\n\n    method indexOf_from : js_string t -> int -> int meth\n\n    method lastIndexOf : js_string t -> int meth\n\n    method lastIndexOf_from : js_string t -> int -> int meth\n\n    method localeCompare : js_string t -> number t meth\n\n    method _match : regExp t -> match_result_handle t opt meth\n\n    method normalize : js_string t meth\n\n    method normalize_form : normalization t -> js_string t meth\n\n    method replace : regExp t -> js_string t -> js_string t meth\n\n    method replace_string : js_string t -> js_string t -> js_string t meth\n\n    method search : regExp t -> int meth\n\n    method slice : int -> int -> js_string t meth\n\n    method slice_end : int -> js_string t meth\n\n    method split : js_string t -> string_array t meth\n\n    method split_limited : js_string t -> int -> string_array t meth\n\n    method split_regExp : regExp t -> string_array t meth\n\n    method split_regExpLimited : regExp t -> int -> string_array t meth\n\n    method substring : int -> int -> js_string t meth\n\n    method substring_toEnd : int -> js_string t meth\n\n    method toLowerCase : js_string t meth\n\n    method toLocaleLowerCase : js_string t meth\n\n    method toUpperCase : js_string t meth\n\n    method toLocaleUpperCase : js_string t meth\n\n    method trim : js_string t meth\n\n    method length : int readonly_prop\n  end\n\n  and regExp = object\n    method exec : js_string t -> match_result_handle t opt meth\n\n    method test : js_string t -> bool t meth\n\n    method toString : js_string t meth\n\n    method source : js_string t readonly_prop\n\n    method global : bool t readonly_prop\n\n    method ignoreCase : bool t readonly_prop\n\n    method multiline : bool t readonly_prop\n\n    method lastIndex : int prop\n  end\n\n  and normalization = js_string\n\n  type number_t = number t\n\n  (* string is used by ppx_js, it needs to come before any use of the\n     new syntax in this file *)\n  external string : string -> js_string t = \"caml_jsstring_of_string\"\n\n  external to_string : js_string t -> string = \"caml_string_of_jsstring\"\n\n  let nfc = string \"NFC\"\n\n  let nfd = string \"NFD\"\n\n  let nfkc = string \"NFKC\"\n\n  let nfkd = string \"NFKD\"\nend\n\ninclude Js\n\nclass type string_constr = object\n  method fromCharCode : int -> js_string t meth\nend\n\nlet string_constr = Unsafe.global##._String\n\nlet regExp = Unsafe.global##._RegExp\n\nlet regExp_copy = regExp\n\nlet regExp_withFlags = regExp\n\nclass type ['a] js_array = object\n  method toString : js_string t meth\n\n  method toLocaleString : js_string t meth\n\n  method concat : 'a js_array t -> 'a js_array t meth\n\n  method join : js_string t -> js_string t meth\n\n  method pop : 'a optdef meth\n\n  method push : 'a -> int meth\n\n  method push_2 : 'a -> 'a -> int meth\n\n  method push_3 : 'a -> 'a -> 'a -> int meth\n\n  method push_4 : 'a -> 'a -> 'a -> 'a -> int meth\n\n  method reverse : 'a js_array t meth\n\n  method shift : 'a optdef meth\n\n  method slice : int -> int -> 'a js_array t meth\n\n  method slice_end : int -> 'a js_array t meth\n\n  method sort : ('a -> 'a -> number_t) callback -> 'a js_array t meth\n\n  method sort_asStrings : 'a js_array t meth\n\n  method splice : int -> int -> 'a js_array t meth\n\n  method splice_1 : int -> int -> 'a -> 'a js_array t meth\n\n  method splice_2 : int -> int -> 'a -> 'a -> 'a js_array t meth\n\n  method splice_3 : int -> int -> 'a -> 'a -> 'a -> 'a js_array t meth\n\n  method splice_4 : int -> int -> 'a -> 'a -> 'a -> 'a -> 'a js_array t meth\n\n  method unshift : 'a -> int meth\n\n  method unshift_2 : 'a -> 'a -> int meth\n\n  method unshift_3 : 'a -> 'a -> 'a -> int meth\n\n  method unshift_4 : 'a -> 'a -> 'a -> 'a -> int meth\n\n  method some : ('a -> int -> 'a js_array t -> bool t) callback -> bool t meth\n\n  method every : ('a -> int -> 'a js_array t -> bool t) callback -> bool t meth\n\n  method forEach : ('a -> int -> 'a js_array t -> unit) callback -> unit meth\n\n  method map : ('a -> int -> 'a js_array t -> 'b) callback -> 'b js_array t meth\n\n  method filter : ('a -> int -> 'a js_array t -> bool t) callback -> 'a js_array t meth\n\n  method reduce_init : ('b -> 'a -> int -> 'a js_array t -> 'b) callback -> 'b -> 'b meth\n\n  method reduce : ('a -> 'a -> int -> 'a js_array t -> 'a) callback -> 'a meth\n\n  method reduceRight_init :\n    ('b -> 'a -> int -> 'a js_array t -> 'b) callback -> 'b -> 'b meth\n\n  method reduceRight : ('a -> 'a -> int -> 'a js_array t -> 'a) callback -> 'a meth\n\n  method length : int prop\nend\n\nlet object_constructor = Unsafe.global##._Object\n\nlet object_keys o : js_string t js_array t = object_constructor##keys o\n\nlet array_constructor = Unsafe.global##._Array\n\nlet array_empty = array_constructor\n\nlet array_length = array_constructor\n\nlet array_get : 'a #js_array t -> int -> 'a optdef = Unsafe.get\n\nlet array_set : 'a #js_array t -> int -> 'a -> unit = Unsafe.set\n\nlet array_map_poly :\n    'a #js_array t -> ('a -> int -> 'a #js_array t -> 'b) callback -> 'b #js_array t =\n fun a cb -> (Unsafe.coerce a)##map cb\n\nlet array_map f a = array_map_poly a (wrap_callback (fun x _idx _ -> f x))\n\nlet array_mapi f a = array_map_poly a (wrap_callback (fun x idx _ -> f idx x))\n\nclass type match_result = object\n  inherit [js_string t] js_array\n\n  method index : int readonly_prop\n\n  method input : js_string t readonly_prop\nend\n\nlet str_array : string_array t -> js_string t js_array t = Unsafe.coerce\n\nlet match_result : match_result_handle t -> match_result t = Unsafe.coerce\n\nclass type date = object\n  method toString : js_string t meth\n\n  method toDateString : js_string t meth\n\n  method toTimeString : js_string t meth\n\n  method toLocaleString : js_string t meth\n\n  method toLocaleDateString : js_string t meth\n\n  method toLocaleTimeString : js_string t meth\n\n  method valueOf : number_t meth\n\n  method getTime : number_t meth\n\n  method getFullYear : int meth\n\n  method getUTCFullYear : int meth\n\n  method getMonth : int meth\n\n  method getUTCMonth : int meth\n\n  method getDate : int meth\n\n  method getUTCDate : int meth\n\n  method getDay : int meth\n\n  method getUTCDay : int meth\n\n  method getHours : int meth\n\n  method getUTCHours : int meth\n\n  method getMinutes : int meth\n\n  method getUTCMinutes : int meth\n\n  method getSeconds : int meth\n\n  method getUTCSeconds : int meth\n\n  method getMilliseconds : int meth\n\n  method getUTCMilliseconds : int meth\n\n  method getTimezoneOffset : int meth\n\n  method setTime : number_t -> number_t meth\n\n  method setFullYear : int -> number_t meth\n\n  method setUTCFullYear : int -> number_t meth\n\n  method setMonth : int -> number_t meth\n\n  method setUTCMonth : int -> number_t meth\n\n  method setDate : int -> number_t meth\n\n  method setUTCDate : int -> number_t meth\n\n  method setDay : int -> number_t meth\n\n  method setUTCDay : int -> number_t meth\n\n  method setHours : int -> number_t meth\n\n  method setUTCHours : int -> number_t meth\n\n  method setMinutes : int -> number_t meth\n\n  method setUTCMinutes : int -> number_t meth\n\n  method setSeconds : int -> number_t meth\n\n  method setUTCSeconds : int -> number_t meth\n\n  method setMilliseconds : int -> number_t meth\n\n  method setUTCMilliseconds : int -> number_t meth\n\n  method toUTCString : js_string t meth\n\n  method toISOString : js_string t meth\n\n  method toJSON : 'a -> js_string t meth\nend\n\nclass type date_constr = object\n  method parse : js_string t -> number_t meth\n\n  method _UTC_month : int -> int -> number_t meth\n\n  method _UTC_day : int -> int -> number_t meth\n\n  method _UTC_hour : int -> int -> int -> int -> number_t meth\n\n  method _UTC_min : int -> int -> int -> int -> int -> number_t meth\n\n  method _UTC_sec : int -> int -> int -> int -> int -> int -> number_t meth\n\n  method _UTC_ms : int -> int -> int -> int -> int -> int -> int -> number_t meth\n\n  method now : number_t meth\nend\n\nlet date_constr = Unsafe.global##._Date\n\nlet date : date_constr t = date_constr\n\nlet date_now : date t constr = date_constr\n\nlet date_fromTimeValue : (number_t -> date t) constr = date_constr\n\nlet date_month : (int -> int -> date t) constr = date_constr\n\nlet date_day : (int -> int -> int -> date t) constr = date_constr\n\nlet date_hour : (int -> int -> int -> int -> date t) constr = date_constr\n\nlet date_min : (int -> int -> int -> int -> int -> date t) constr = date_constr\n\nlet date_sec : (int -> int -> int -> int -> int -> int -> date t) constr = date_constr\n\nlet date_ms : (int -> int -> int -> int -> int -> int -> int -> date t) constr =\n  date_constr\n\nclass type math = object\n  method _E : number_t readonly_prop\n\n  method _LN2 : number_t readonly_prop\n\n  method _LN10 : number_t readonly_prop\n\n  method _LOG2E : number_t readonly_prop\n\n  method _LOG10E : number_t readonly_prop\n\n  method _PI : number_t readonly_prop\n\n  method _SQRT1_2_ : number_t readonly_prop\n\n  method _SQRT2 : number_t readonly_prop\n\n  method abs : number_t -> number_t meth\n\n  method acos : number_t -> number_t meth\n\n  method asin : number_t -> number_t meth\n\n  method atan : number_t -> number_t meth\n\n  method atan2 : number_t -> number_t -> number_t meth\n\n  method ceil : number_t -> number_t meth\n\n  method cos : number_t -> number_t meth\n\n  method exp : number_t -> number_t meth\n\n  method floor : number_t -> number_t meth\n\n  method log : number_t -> number_t meth\n\n  method max : number_t -> number_t -> number_t meth\n\n  method max_3 : number_t -> number_t -> number_t -> number_t meth\n\n  method max_4 : number_t -> number_t -> number_t -> number_t -> number_t meth\n\n  method min : number_t -> number_t -> number_t meth\n\n  method min_3 : number_t -> number_t -> number_t -> number_t meth\n\n  method min_4 : number_t -> number_t -> number_t -> number_t -> number_t meth\n\n  method pow : number_t -> number_t -> number_t meth\n\n  method random : number_t meth\n\n  method round : number_t -> number_t meth\n\n  method sin : number_t -> number_t meth\n\n  method sqrt : number_t -> number_t meth\n\n  method tan : number_t -> number_t meth\nend\n\nlet math = Unsafe.global##._Math\n\nclass type error = object\n  method name : js_string t prop\n\n  method message : js_string t prop\n\n  method stack : js_string t optdef prop\n\n  method toString : js_string t meth\nend\n\nlet error_constr = Unsafe.global##._Error\n\nmodule Js_error = struct\n  type error_t = error t\n\n  include Jsoo_runtime.Error\n\n  external of_error : error_t -> t = \"%identity\"\n\n  external to_error : t -> error_t = \"%identity\"\n\n  let name e = to_string (to_error e)##.name\n\n  let message e = to_string (to_error e)##.message\n\n  let stack (e : t) : string option =\n    Opt.to_option (Opt.map (to_error e)##.stack to_string)\n\n  let to_string e = to_string (to_error e)##toString\nend\n\nmodule Magic = struct\n  module type T = sig\n    exception Error of error t\n  end\n\n  type ('a, 'b) eq = Eq : ('a, 'a) eq\n\n  let (eq : (error t, Js_error.t) eq) = Obj.magic Eq\n\n  let m =\n    match eq with\n    | Eq ->\n        (module struct\n          exception Error = Js_error.Exn\n        end : T)\n\n  module Error = (val m : T)\nend\n\ninclude Magic.Error\n\nlet raise_js_error e = Js_error.raise_ (Js_error.of_error e)\n\nlet string_of_error e = Js_error.to_string (Js_error.of_error e)\n\nlet exn_with_js_backtrace = Js_error.attach_js_backtrace\n\nexternal js_error_of_exn : exn -> error t opt = \"caml_js_error_of_exception\"\n\nclass type json = object\n  method parse : js_string t -> 'a meth\n\n  method stringify : 'a -> js_string t meth\nend\n\nlet _JSON : json t = Unsafe.global##._JSON\n\nlet decodeURI (s : js_string t) : js_string t =\n  Unsafe.fun_call Unsafe.global##.decodeURI [| Unsafe.inject s |]\n\nlet decodeURIComponent (s : js_string t) : js_string t =\n  Unsafe.fun_call Unsafe.global##.decodeURIComponent [| Unsafe.inject s |]\n\nlet encodeURI (s : js_string t) : js_string t =\n  Unsafe.fun_call Unsafe.global##.encodeURI [| Unsafe.inject s |]\n\nlet encodeURIComponent (s : js_string t) : js_string t =\n  Unsafe.fun_call Unsafe.global##.encodeURIComponent [| Unsafe.inject s |]\n\nlet escape (s : js_string t) : js_string t =\n  Unsafe.fun_call Unsafe.global##.escape [| Unsafe.inject s |]\n\nlet unescape (s : js_string t) : js_string t =\n  Unsafe.fun_call Unsafe.global##.unescape [| Unsafe.inject s |]\n\nexternal bool : bool -> bool t = \"caml_js_from_bool\"\n\nexternal to_bool : bool t -> bool = \"caml_js_to_bool\"\n\nexternal array : 'a array -> 'a js_array t = \"caml_js_from_array\"\n\nexternal to_array : 'a js_array t -> 'a array = \"caml_js_to_array\"\n\nexternal bytestring : string -> js_string t = \"caml_jsbytes_of_string\"\n\nexternal to_bytestring : js_string t -> string = \"caml_string_of_jsbytes\"\n\nexternal float : float -> number_t = \"caml_js_from_float\"\n\nexternal to_float : number_t -> float = \"caml_js_to_float\"\n\nexternal number_of_float : float -> number t = \"caml_js_from_float\"\n\nexternal float_of_number : number t -> float = \"caml_js_to_float\"\n\nexternal int32 : int32 -> number_t = \"caml_js_from_int32\"\n\nexternal to_int32 : number_t -> int32 = \"caml_js_to_int32\"\n\nexternal nativeint : nativeint -> number_t = \"caml_js_from_nativeint\"\n\nexternal to_nativeint : number_t -> nativeint = \"caml_js_to_nativeint\"\n\nexternal typeof : _ t -> js_string t = \"caml_js_typeof\"\n\nexternal instanceof : _ t -> _ constr -> bool = \"caml_js_instanceof\"\n\nlet isNaN (i : 'a) : bool =\n  to_bool (Unsafe.fun_call Unsafe.global##.isNaN [| Unsafe.inject i |])\n\nlet parseInt (s : js_string t) : int =\n  let s = Unsafe.fun_call Unsafe.global##.parseInt [| Unsafe.inject s |] in\n  if isNaN s then failwith \"parseInt\" else s\n\nlet parseFloat (s : js_string t) : number_t =\n  let s = Unsafe.fun_call Unsafe.global##.parseFloat [| Unsafe.inject s |] in\n  if isNaN s then failwith \"parseFloat\" else s\n\nlet _ =\n  Printexc.register_printer (fun e ->\n      if instanceof (Obj.magic e : < .. > t) error_constr\n      then\n        let e = Js_error.of_error (Obj.magic e : error t) in\n        Some (Js_error.to_string e)\n      else\n        match e with\n        | Js_error.Exn e -> Some (Js_error.to_string e)\n        | _ -> None)\n\nlet export_js (field : js_string t) x =\n  Unsafe.set\n    (Unsafe.pure_js_expr \"jsoo_exports\")\n    field\n    (if\n       String.equal (Js.to_string (typeof (Obj.magic x))) \"function\"\n       (* function with arity/length equal to zero are already wrapped *)\n       && Unsafe.get (Obj.magic x) (Js.string \"length\") > 0\n     then Obj.magic (wrap_callback (Obj.magic x))\n     else x)\n\nlet export field x = export_js (string field) x\n\nlet export_all obj =\n  let keys = object_keys obj in\n  keys##forEach\n    (wrap_callback (fun (key : js_string t) _ _ -> export_js key (Unsafe.get obj key)))\n\n(****)\n\n(* DEPRECATED *)\n\ntype float_prop = number_t prop\n","(* Js_of_ocaml library\n * http://www.ocsigen.org/js_of_ocaml/\n * Copyright (C) 2010 Jérôme Vouillon\n * Laboratoire PPS - CNRS Université Paris Diderot\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, with linking exception;\n * either version 2.1 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *)\n\nopen Js\nopen! Import\n\nclass type ['node] nodeList = object\n  method item : int -> 'node t opt meth\n\n  method length : int readonly_prop\nend\n\nlet list_of_nodeList (nodeList : 'a nodeList t) =\n  let length = nodeList##.length in\n  let rec add_item acc i =\n    if i < length\n    then\n      match Opt.to_option (nodeList##item i) with\n      | None -> add_item acc (i + 1)\n      | Some e -> add_item (e :: acc) (i + 1)\n    else List.rev acc\n  in\n  add_item [] 0\n\ntype nodeType =\n  | OTHER\n  (* Will not happen *)\n  | ELEMENT\n  | ATTRIBUTE\n  | TEXT\n  | CDATA_SECTION\n  | ENTITY_REFERENCE\n  | ENTITY\n  | PROCESSING_INSTRUCTION\n  | COMMENT\n  | DOCUMENT\n  | DOCUMENT_TYPE\n  | DOCUMENT_FRAGMENT\n  | NOTATION\n\nmodule DocumentPosition = struct\n  type t = int\n\n  type mask = int\n\n  let disconnected = 0x01\n\n  let preceding = 0x02\n\n  let following = 0x04\n\n  let contains = 0x08\n\n  let contained_by = 0x10\n\n  let implementation_specific = 0x20\n\n  let has t mask = t land mask = mask\n\n  let add x y = x lor y\n\n  let ( + ) = add\nend\n\nclass type node = object\n  method nodeName : js_string t readonly_prop\n\n  method nodeValue : js_string t opt readonly_prop\n\n  method nodeType : nodeType readonly_prop\n\n  method parentNode : node t opt prop\n\n  method childNodes : node nodeList t prop\n\n  method firstChild : node t opt prop\n\n  method lastChild : node t opt prop\n\n  method previousSibling : node t opt prop\n\n  method nextSibling : node t opt prop\n\n  method namespaceURI : js_string t opt prop\n\n  method insertBefore : node t -> node t opt -> node t meth\n\n  method replaceChild : node t -> node t -> node t meth\n\n  method removeChild : node t -> node t meth\n\n  method appendChild : node t -> node t meth\n\n  method hasChildNodes : bool t meth\n\n  method cloneNode : bool t -> node t meth\n\n  method compareDocumentPosition : node t -> DocumentPosition.t meth\n\n  method lookupNamespaceURI : js_string t -> js_string t opt meth\n\n  method lookupPrefix : js_string t -> js_string t opt meth\nend\n\nlet appendChild (p : #node t) (n : #node t) = ignore (p##appendChild (n :> node t))\n\nlet removeChild (p : #node t) (n : #node t) = ignore (p##removeChild (n :> node t))\n\nlet replaceChild (p : #node t) (n : #node t) (o : #node t) =\n  ignore (p##replaceChild (n :> node t) (o :> node t))\n\nlet insertBefore (p : #node t) (n : #node t) (o : #node t opt) =\n  ignore (p##insertBefore (n :> node t) (o :> node t opt))\n\n(** Specification of [Attr] objects. *)\nclass type attr = object\n  inherit node\n\n  method name : js_string t readonly_prop\n\n  method specified : bool t readonly_prop\n\n  method value : js_string t prop\n\n  method ownerElement : element t prop\nend\n\n(** Specification of [NamedNodeMap] objects. *)\nand ['node] namedNodeMap = object\n  method getNamedItem : js_string t -> 'node t opt meth\n\n  method setNamedItem : 'node t -> 'node t opt meth\n\n  method removeNamedItem : js_string t -> 'node t opt meth\n\n  method item : int -> 'node t opt meth\n\n  method length : int readonly_prop\nend\n\n(** Specification of [Element] objects. *)\nand element = object\n  inherit node\n\n  method tagName : js_string t readonly_prop\n\n  method getAttribute : js_string t -> js_string t opt meth\n\n  method setAttribute : js_string t -> js_string t -> unit meth\n\n  method removeAttribute : js_string t -> unit meth\n\n  method hasAttribute : js_string t -> bool t meth\n\n  method getAttributeNS : js_string t -> js_string t -> js_string t opt meth\n\n  method setAttributeNS : js_string t -> js_string t -> js_string t -> unit meth\n\n  method removeAttributeNS : js_string t -> js_string t -> unit meth\n\n  method hasAttributeNS : js_string t -> js_string t -> bool t meth\n\n  method getAttributeNode : js_string t -> attr t opt meth\n\n  method setAttributeNode : attr t -> attr t opt meth\n\n  method removeAttributeNode : attr t -> attr t meth\n\n  method getAttributeNodeNS : js_string t -> js_string t -> attr t opt meth\n\n  method setAttributeNodeNS : attr t -> attr t opt meth\n\n  method getElementsByTagName : js_string t -> element nodeList t meth\n\n  method attributes : attr namedNodeMap t readonly_prop\nend\n\nclass type characterData = object\n  inherit node\n\n  method data : js_string t prop\n\n  method length : int readonly_prop\n\n  method subjs_stringData : int -> int -> js_string t meth\n\n  method appendData : js_string t -> unit meth\n\n  method insertData : int -> js_string t -> unit meth\n\n  method deleteData : int -> int -> unit meth\n\n  method replaceData : int -> int -> js_string t -> unit meth\nend\n\nclass type comment = characterData\n\nclass type text = characterData\n\nclass type documentFragment = node\n\nclass type ['element] document = object\n  inherit node\n\n  method documentElement : 'element t readonly_prop\n\n  method createDocumentFragment : documentFragment t meth\n\n  method createElement : js_string t -> 'element t meth\n\n  method createElementNS : js_string t -> js_string t -> 'element t meth\n\n  method createTextNode : js_string t -> text t meth\n\n  method createAttribute : js_string t -> attr t meth\n\n  method createComment : js_string t -> comment t meth\n\n  method getElementById : js_string t -> 'element t opt meth\n\n  method getElementsByTagName : js_string t -> 'element nodeList t meth\n\n  method importNode : element t -> bool t -> 'element t meth\n\n  method adoptNode : element t -> 'element t meth\nend\n\ntype node_type =\n  | Element of element t\n  | Attr of attr t\n  | Text of text t\n  | Other of node t\n\nlet nodeType e =\n  match e##.nodeType with\n  | ELEMENT -> Element (Js.Unsafe.coerce e)\n  | ATTRIBUTE -> Attr (Js.Unsafe.coerce e)\n  | CDATA_SECTION | TEXT -> Text (Js.Unsafe.coerce e)\n  | _ -> Other (e :> node t)\n\nmodule CoerceTo = struct\n  let cast (e : #node Js.t) t =\n    if e##.nodeType == t then Js.some (Js.Unsafe.coerce e) else Js.null\n\n  let element e : element Js.t Js.opt = cast e ELEMENT\n\n  let text e : text Js.t Js.opt =\n    if e##.nodeType == TEXT || e##.nodeType == CDATA_SECTION\n    then Js.some (Js.Unsafe.coerce e)\n    else Js.null\n\n  let attr e : attr Js.t Js.opt = cast e ATTRIBUTE\nend\n\ntype ('a, 'b) event_listener = ('a, 'b -> bool t) meth_callback opt\n(** The type of event listener functions.  The first type parameter\n      ['a] is the type of the target object; the second parameter\n      ['b] is the type of the event object. *)\n\nclass type ['a] event = object\n  method _type : js_string t readonly_prop\n\n  method target : 'a t opt readonly_prop\n\n  method currentTarget : 'a t opt readonly_prop\n\n  method preventDefault : unit meth\n\n  (* Legacy methods *)\n  method srcElement : 'a t opt readonly_prop\nend\n\nclass type ['a, 'b] customEvent = object\n  inherit ['a] event\n\n  method detail : 'b Js.opt Js.readonly_prop\nend\n\nlet no_handler : ('a, 'b) event_listener = Js.null\n\n(* The function preventDefault must be called explicitly when\n   using addEventListener... *)\nlet handler f =\n  Js.some\n    (Js.Unsafe.callback (fun e ->\n         let res = f e in\n         if not (Js.to_bool res) then e##preventDefault;\n         res))\n\nlet full_handler f =\n  Js.some\n    (Js.Unsafe.meth_callback (fun this e ->\n         let res = f this e in\n         if not (Js.to_bool res) then e##preventDefault;\n         res))\n\nlet invoke_handler (f : ('a, 'b) event_listener) (this : 'a) (event : 'b) : bool t =\n  Js.Unsafe.call f this [| Js.Unsafe.inject event |]\n\nlet eventTarget (e : (< .. > as 'a) #event t) : 'a t =\n  Opt.get e##.target (fun () -> Opt.get e##.srcElement (fun () -> raise Not_found))\n\nmodule Event = struct\n  type 'a typ = Js.js_string Js.t\n\n  let make s = Js.string s\nend\n\ntype event_listener_id = unit -> unit\n\nclass type event_listener_options = object\n  method capture : bool t writeonly_prop\n\n  method once : bool t writeonly_prop\n\n  method passive : bool t writeonly_prop\nend\n\nlet addEventListenerWithOptions (e : < .. > t) typ ?capture ?once ?passive h =\n  if not (Js.Optdef.test (Js.Unsafe.coerce e)##.addEventListener)\n  then\n    let ev = (Js.string \"on\")##concat typ in\n    let callback e = Js.Unsafe.call (h, e, [||]) in\n    let () = (Js.Unsafe.coerce e)##attachEvent ev callback in\n    fun () -> (Js.Unsafe.coerce e)##detachEvent ev callback\n  else\n    let opts : event_listener_options t = Js.Unsafe.obj [||] in\n    let iter t f =\n      match t with\n      | None -> ()\n      | Some b -> f b\n    in\n    iter capture (fun b -> opts##.capture := b);\n    iter once (fun b -> opts##.once := b);\n    iter passive (fun b -> opts##.passive := b);\n    let () = (Js.Unsafe.coerce e)##addEventListener typ h opts in\n    fun () -> (Js.Unsafe.coerce e)##removeEventListener typ h opts\n\nlet addEventListener (e : < .. > t) typ h capt =\n  addEventListenerWithOptions e typ ~capture:capt h\n\nlet removeEventListener id = id ()\n\nlet preventDefault ev = ev##preventDefault\n\nlet createCustomEvent ?bubbles ?cancelable ?detail typ =\n  let opt_iter f = function\n    | None -> ()\n    | Some x -> f x\n  in\n  let opts = Unsafe.obj [||] in\n  opt_iter (fun x -> opts##.bubbles := bool x) bubbles;\n  opt_iter (fun x -> opts##.cancelable := bool x) cancelable;\n  opt_iter (fun x -> opts##.detail := some x) detail;\n  let constr :\n      (   ('a, 'b) #customEvent Js.t Event.typ\n       -> < detail : 'b opt prop > t\n       -> ('a, 'b) customEvent t)\n      constr =\n    Unsafe.global##._CustomEvent\n  in\n  new%js constr typ opts\n\nclass type stringList = object\n  method item : int -> js_string t opt meth\n\n  method length : int readonly_prop\n\n  method contains : js_string t -> bool t meth\nend\n","(* Js_of_ocaml library\n * http://www.ocsigen.org/js_of_ocaml/\n * Copyright (C) 2010 Jérôme Vouillon\n * Laboratoire PPS - CNRS Université Paris Diderot\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, with linking exception;\n * either version 2.1 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *)\n\nopen Js\nopen! Import\n\nexternal html_escape : js_string t -> js_string t = \"caml_js_html_escape\"\n\nexternal html_entities : js_string t -> js_string t opt = \"caml_js_html_entities\"\n\nlet decode_html_entities s =\n  Js.Opt.get (html_entities s) (fun () -> failwith (\"Invalid entity \" ^ Js.to_string s))\n\nclass type cssStyleDeclaration = object\n  method setProperty :\n    js_string t -> js_string t -> js_string t optdef -> js_string t meth\n\n  method getPropertyValue : js_string t -> js_string t meth\n\n  method getPropertyPriority : js_string t -> js_string t meth\n\n  method removeProperty : js_string t -> js_string t meth\n\n  method animation : js_string t prop\n\n  method animationDelay : js_string t prop\n\n  method animationDirection : js_string t prop\n\n  method animationDuration : js_string t prop\n\n  method animationFillMode : js_string t prop\n\n  method animationIterationCount : js_string t prop\n\n  method animationName : js_string t prop\n\n  method animationPlayState : js_string t prop\n\n  method animationTimingFunction : js_string t prop\n\n  method background : js_string t prop\n\n  method backgroundAttachment : js_string t prop\n\n  method backgroundColor : js_string t prop\n\n  method backgroundImage : js_string t prop\n\n  method backgroundPosition : js_string t prop\n\n  method backgroundRepeat : js_string t prop\n\n  method border : js_string t prop\n\n  method borderBottom : js_string t prop\n\n  method borderBottomColor : js_string t prop\n\n  method borderBottomStyle : js_string t prop\n\n  method borderBottomWidth : js_string t prop\n\n  method borderCollapse : js_string t prop\n\n  method borderColor : js_string t prop\n\n  method borderLeft : js_string t prop\n\n  method borderLeftColor : js_string t prop\n\n  method borderLeftStyle : js_string t prop\n\n  method borderLeftWidth : js_string t prop\n\n  method borderRadius : js_string t prop\n\n  method borderRight : js_string t prop\n\n  method borderRightColor : js_string t prop\n\n  method borderRightStyle : js_string t prop\n\n  method borderRightWidth : js_string t prop\n\n  method borderSpacing : js_string t prop\n\n  method borderStyle : js_string t prop\n\n  method borderTop : js_string t prop\n\n  method borderTopColor : js_string t prop\n\n  method borderTopStyle : js_string t prop\n\n  method borderTopWidth : js_string t prop\n\n  method borderWidth : js_string t prop\n\n  method bottom : js_string t prop\n\n  method captionSide : js_string t prop\n\n  method clear : js_string t prop\n\n  method clip : js_string t prop\n\n  method color : js_string t prop\n\n  method content : js_string t prop\n\n  method counterIncrement : js_string t prop\n\n  method counterReset : js_string t prop\n\n  method cssFloat : js_string t prop\n\n  method cssText : js_string t prop\n\n  method cursor : js_string t prop\n\n  method direction : js_string t prop\n\n  method display : js_string t prop\n\n  method emptyCells : js_string t prop\n\n  method fill : js_string t prop\n\n  method font : js_string t prop\n\n  method fontFamily : js_string t prop\n\n  method fontSize : js_string t prop\n\n  method fontStyle : js_string t prop\n\n  method fontVariant : js_string t prop\n\n  method fontWeight : js_string t prop\n\n  method height : js_string t prop\n\n  method left : js_string t prop\n\n  method letterSpacing : js_string t prop\n\n  method lineHeight : js_string t prop\n\n  method listStyle : js_string t prop\n\n  method listStyleImage : js_string t prop\n\n  method listStylePosition : js_string t prop\n\n  method listStyleType : js_string t prop\n\n  method margin : js_string t prop\n\n  method marginBottom : js_string t prop\n\n  method marginLeft : js_string t prop\n\n  method marginRight : js_string t prop\n\n  method marginTop : js_string t prop\n\n  method maxHeight : js_string t prop\n\n  method maxWidth : js_string t prop\n\n  method minHeight : js_string t prop\n\n  method minWidth : js_string t prop\n\n  method opacity : js_string t prop\n\n  method outline : js_string t prop\n\n  method outlineColor : js_string t prop\n\n  method outlineOffset : js_string t prop\n\n  method outlineStyle : js_string t prop\n\n  method outlineWidth : js_string t prop\n\n  method overflow : js_string t prop\n\n  method overflowX : js_string t prop\n\n  method overflowY : js_string t prop\n\n  method padding : js_string t prop\n\n  method paddingBottom : js_string t prop\n\n  method paddingLeft : js_string t prop\n\n  method paddingRight : js_string t prop\n\n  method paddingTop : js_string t prop\n\n  method pageBreakAfter : js_string t prop\n\n  method pageBreakBefore : js_string t prop\n\n  method pointerEvents : js_string t prop\n\n  method position : js_string t prop\n\n  method right : js_string t prop\n\n  method stroke : js_string t prop\n\n  method strokeWidth : js_string t prop\n\n  method tableLayout : js_string t prop\n\n  method textAlign : js_string t prop\n\n  method textAnchor : js_string t prop\n\n  method textDecoration : js_string t prop\n\n  method textIndent : js_string t prop\n\n  method textTransform : js_string t prop\n\n  method top : js_string t prop\n\n  method transform : js_string t prop\n\n  method verticalAlign : js_string t prop\n\n  method visibility : js_string t prop\n\n  method whiteSpace : js_string t prop\n\n  method width : js_string t prop\n\n  method wordSpacing : js_string t prop\n\n  method zIndex : js_string t prop\nend\n\ntype ('a, 'b) event_listener = ('a, 'b) Dom.event_listener\n\ntype mouse_button =\n  | No_button\n  | Left_button\n  | Middle_button\n  | Right_button\n\ntype delta_mode =\n  | Delta_pixel\n  | Delta_line\n  | Delta_page\n\nclass type event = object\n  inherit [element] Dom.event\nend\n\nand ['a] customEvent = object\n  inherit [element, 'a] Dom.customEvent\nend\n\nand focusEvent = object\n  inherit event\n\n  method relatedTarget : element t opt readonly_prop\nend\n\nand mouseEvent = object\n  inherit event\n\n  method relatedTarget : element t opt readonly_prop\n\n  method clientX : number_t readonly_prop\n\n  method clientY : number_t readonly_prop\n\n  method screenX : number_t readonly_prop\n\n  method screenY : number_t readonly_prop\n\n  method offsetX : number_t readonly_prop\n\n  method offsetY : number_t readonly_prop\n\n  method ctrlKey : bool t readonly_prop\n\n  method shiftKey : bool t readonly_prop\n\n  method altKey : bool t readonly_prop\n\n  method metaKey : bool t readonly_prop\n\n  method button : int readonly_prop\n\n  method buttons : int readonly_prop\n\n  method which : mouse_button optdef readonly_prop\n\n  method fromElement : element t opt optdef readonly_prop\n\n  method toElement : element t opt optdef readonly_prop\n\n  method pageX : number_t optdef readonly_prop\n\n  method pageY : number_t optdef readonly_prop\nend\n\nand keyboardEvent = object\n  inherit event\n\n  method altKey : bool t readonly_prop\n\n  method shiftKey : bool t readonly_prop\n\n  method ctrlKey : bool t readonly_prop\n\n  method metaKey : bool t readonly_prop\n\n  method location : int readonly_prop\n\n  method key : js_string t optdef readonly_prop\n\n  method code : js_string t optdef readonly_prop\n\n  method isComposing : bool t readonly_prop\n\n  method repeat : bool t readonly_prop\n\n  method getModifierState : js_string t -> bool t meth\n\n  method which : int optdef readonly_prop\n\n  method charCode : int optdef readonly_prop\n\n  method keyCode : int readonly_prop\n\n  method keyIdentifier : js_string t optdef readonly_prop\nend\n\nand wheelEvent = object\n  (* All modern browsers *)\n  inherit mouseEvent\n\n  method deltaX : number_t readonly_prop\n\n  method deltaY : number_t readonly_prop\n\n  method deltaZ : number_t readonly_prop\n\n  method deltaMode : delta_mode readonly_prop\n\n  method wheelDelta : int readonly_prop\n\n  method wheelDeltaX : int optdef readonly_prop\n\n  method wheelDeltaY : int optdef readonly_prop\nend\n\nand mousewheelEvent = wheelEvent\n\nand mouseScrollEvent = object\n  (* Deprecated *)\n  inherit mouseEvent\n\n  method detail : int readonly_prop\n\n  method axis : int optdef readonly_prop\n\n  method _HORIZONTAL_AXIS : int optdef readonly_prop\n\n  method _VERTICAL_AXIS : int optdef readonly_prop\nend\n\nand touchEvent = object\n  inherit event\n\n  method touches : touchList t readonly_prop\n\n  method targetTouches : touchList t readonly_prop\n\n  method changedTouches : touchList t readonly_prop\n\n  method ctrlKey : bool t readonly_prop\n\n  method shiftKey : bool t readonly_prop\n\n  method altKey : bool t readonly_prop\n\n  method metaKey : bool t readonly_prop\n\n  method relatedTarget : element t opt readonly_prop\nend\n\nand touchList = object\n  method length : int readonly_prop\n\n  method item : int -> touch t optdef meth\nend\n\nand touch = object\n  method identifier : int readonly_prop\n\n  method target : element t optdef readonly_prop\n\n  method screenX : number_t readonly_prop\n\n  method screenY : number_t readonly_prop\n\n  method clientX : number_t readonly_prop\n\n  method clientY : number_t readonly_prop\n\n  method pageX : number_t readonly_prop\n\n  method pageY : number_t readonly_prop\nend\n\nand submitEvent = object\n  inherit event\n\n  method submitter : element t readonly_prop\nend\n\nand dragEvent = object\n  inherit mouseEvent\n\n  method dataTransfer : dataTransfer t readonly_prop\nend\n\nand clipboardEvent = object\n  inherit event\n\n  method clipboardData : dataTransfer t readonly_prop\nend\n\nand toggleEvent = object\n  inherit event\n\n  method newState : js_string t readonly_prop\n\n  method oldState : js_string t readonly_prop\nend\n\nand mediaQueryListEvent = object\n  inherit event\n\n  method matches : js_string t readonly_prop\n\n  method media : bool t readonly_prop\nend\n\nand dataTransfer = object\n  method dropEffect : js_string t prop\n\n  method effectAllowed : js_string t prop\n\n  method files : File.fileList t readonly_prop\n\n  method types : js_string t js_array t readonly_prop\n\n  method addElement : element t -> unit meth\n\n  method clearData : js_string t -> unit meth\n\n  method clearData_all : unit meth\n\n  method getData : js_string t -> js_string t meth\n\n  method setData : js_string t -> js_string t -> unit meth\n\n  method setDragImage : element t -> int -> int -> unit meth\nend\n\nand eventTarget = object ('self)\n  method onclick : ('self t, mouseEvent t) event_listener writeonly_prop\n\n  method ondblclick : ('self t, mouseEvent t) event_listener writeonly_prop\n\n  method onmousedown : ('self t, mouseEvent t) event_listener writeonly_prop\n\n  method onmouseup : ('self t, mouseEvent t) event_listener writeonly_prop\n\n  method onmouseover : ('self t, mouseEvent t) event_listener writeonly_prop\n\n  method onmousemove : ('self t, mouseEvent t) event_listener writeonly_prop\n\n  method onmouseout : ('self t, mouseEvent t) event_listener writeonly_prop\n\n  method onkeypress : ('self t, keyboardEvent t) event_listener writeonly_prop\n\n  method onkeydown : ('self t, keyboardEvent t) event_listener writeonly_prop\n\n  method onkeyup : ('self t, keyboardEvent t) event_listener writeonly_prop\n\n  method onscroll : ('self t, event t) event_listener writeonly_prop\n\n  method onwheel : ('self t, wheelEvent t) event_listener writeonly_prop\n\n  method ondragstart : ('self t, dragEvent t) event_listener writeonly_prop\n\n  method ondragend : ('self t, dragEvent t) event_listener writeonly_prop\n\n  method ondragenter : ('self t, dragEvent t) event_listener writeonly_prop\n\n  method ondragover : ('self t, dragEvent t) event_listener writeonly_prop\n\n  method ondragleave : ('self t, dragEvent t) event_listener writeonly_prop\n\n  method ondrag : ('self t, dragEvent t) event_listener writeonly_prop\n\n  method ondrop : ('self t, dragEvent t) event_listener writeonly_prop\n\n  method onanimationstart : ('self t, animationEvent t) event_listener writeonly_prop\n\n  method onanimationend : ('self t, animationEvent t) event_listener writeonly_prop\n\n  method onanimationiteration : ('self t, animationEvent t) event_listener writeonly_prop\n\n  method onanimationcancel : ('self t, animationEvent t) event_listener writeonly_prop\n\n  method ontransitionrun : ('self t, transitionEvent t) event_listener writeonly_prop\n\n  method ontransitionstart : ('self t, transitionEvent t) event_listener writeonly_prop\n\n  method ontransitionend : ('self t, transitionEvent t) event_listener writeonly_prop\n\n  method ontransitioncancel : ('self t, transitionEvent t) event_listener writeonly_prop\n\n  method ongotpointercapture : ('self t, pointerEvent t) event_listener writeonly_prop\n\n  method onlostpointercapture : ('self t, pointerEvent t) event_listener writeonly_prop\n\n  method onpointerenter : ('self t, pointerEvent t) event_listener writeonly_prop\n\n  method onpointercancel : ('self t, pointerEvent t) event_listener writeonly_prop\n\n  method onpointerdown : ('self t, pointerEvent t) event_listener writeonly_prop\n\n  method onpointerleave : ('self t, pointerEvent t) event_listener writeonly_prop\n\n  method onpointermove : ('self t, pointerEvent t) event_listener writeonly_prop\n\n  method onpointerout : ('self t, pointerEvent t) event_listener writeonly_prop\n\n  method onpointerover : ('self t, pointerEvent t) event_listener writeonly_prop\n\n  method onpointerup : ('self t, pointerEvent t) event_listener writeonly_prop\n\n  method dispatchEvent : event t -> bool t meth\nend\n\nand popStateEvent = object\n  inherit event\n\n  method state : Js.Unsafe.any readonly_prop\nend\n\nand pointerEvent = object\n  inherit mouseEvent\n\n  method pointerId : int Js.readonly_prop\n\n  method width : number_t Js.readonly_prop\n\n  method height : number_t Js.readonly_prop\n\n  method pressure : number_t Js.readonly_prop\n\n  method tangentialPressure : number_t Js.readonly_prop\n\n  method tiltX : int Js.readonly_prop\n\n  method tiltY : int Js.readonly_prop\n\n  method twist : int Js.readonly_prop\n\n  method pointerType : Js.js_string Js.t Js.readonly_prop\n\n  method isPrimary : bool Js.t Js.readonly_prop\nend\n\nand storageEvent = object\n  inherit event\n\n  method key : js_string t opt readonly_prop\n\n  method oldValue : js_string t opt readonly_prop\n\n  method newValue : js_string t opt readonly_prop\n\n  method url : js_string t readonly_prop\n\n  method storageArea : storage t opt readonly_prop\nend\n\nand storage = object\n  method length : int readonly_prop\n\n  method key : int -> js_string t opt meth\n\n  method getItem : js_string t -> js_string t opt meth\n\n  method setItem : js_string t -> js_string t -> unit meth\n\n  method removeItem : js_string t -> unit meth\n\n  method clear : unit meth\nend\n\nand hashChangeEvent = object\n  inherit event\n\n  method oldURL : js_string t readonly_prop\n\n  method newURL : js_string t readonly_prop\nend\n\nand animationEvent = object\n  inherit event\n\n  method animationName : js_string t readonly_prop\n\n  method elapsedTime : number_t readonly_prop\n\n  method pseudoElement : js_string t readonly_prop\nend\n\nand transitionEvent = object\n  inherit event\n\n  method propertyName : js_string t readonly_prop\n\n  method elapsedTime : number_t readonly_prop\n\n  method pseudoElement : js_string t readonly_prop\nend\n\nand mediaEvent = object\n  inherit event\nend\n\nand messageEvent = object\n  inherit event\n\n  method data : Unsafe.any opt readonly_prop\n\n  method source : Unsafe.any opt readonly_prop\nend\n\nand nodeSelector = object\n  method querySelector : js_string t -> element t opt meth\n\n  method querySelectorAll : js_string t -> element Dom.nodeList t meth\nend\n\nand tokenList = object\n  method length : int readonly_prop\n\n  method item : int -> js_string t optdef meth\n\n  method contains : js_string t -> bool t meth\n\n  method add : js_string t -> unit meth\n\n  method remove : js_string t -> unit meth\n\n  method toggle : js_string t -> bool t meth\n\n  method stringifier : js_string t prop\nend\n\nand element = object\n  inherit Dom.element\n\n  inherit nodeSelector\n\n  method id : js_string t prop\n\n  method title : js_string t prop\n\n  method lang : js_string t prop\n\n  method dir : js_string t prop\n\n  method className : js_string t prop\n\n  method classList : tokenList t readonly_prop\n\n  method closest : js_string t -> element t opt meth\n\n  method style : cssStyleDeclaration t prop\n\n  method innerHTML : js_string t prop\n\n  method outerHTML : js_string t prop\n\n  method textContent : js_string t opt prop\n\n  method innerText : js_string t prop\n\n  method clientLeft : int readonly_prop\n\n  method clientTop : int readonly_prop\n\n  method clientWidth : int readonly_prop\n\n  method clientHeight : int readonly_prop\n\n  method offsetLeft : int readonly_prop\n\n  method offsetTop : int readonly_prop\n\n  method offsetParent : element t opt readonly_prop\n\n  method offsetWidth : int readonly_prop\n\n  method offsetHeight : int readonly_prop\n\n  method scrollLeft : number_t prop\n\n  method scrollTop : number_t prop\n\n  method scrollWidth : int prop\n\n  method scrollHeight : int prop\n\n  method getClientRects : clientRectList t meth\n\n  method getBoundingClientRect : clientRect t meth\n\n  method scrollIntoView : bool t -> unit meth\n\n  method click : unit meth\n\n  method focus : unit meth\n\n  method blur : unit meth\n\n  inherit eventTarget\nend\n\nand clientRect = object\n  method top : number_t readonly_prop\n\n  method right : number_t readonly_prop\n\n  method bottom : number_t readonly_prop\n\n  method left : number_t readonly_prop\n\n  method width : number_t readonly_prop\n\n  method height : number_t readonly_prop\nend\n\nand clientRectList = object\n  method length : int readonly_prop\n\n  method item : int -> clientRect t opt meth\nend\n\nlet no_handler : ('a, 'b) event_listener = Dom.no_handler\n\nlet handler = Dom.handler\n\nlet full_handler = Dom.full_handler\n\nlet invoke_handler = Dom.invoke_handler\n\nmodule Event = struct\n  type 'a typ = 'a Dom.Event.typ\n\n  let cancel = Dom.Event.make \"cancel\"\n\n  let click = Dom.Event.make \"click\"\n\n  let close = Dom.Event.make \"close\"\n\n  let copy = Dom.Event.make \"copy\"\n\n  let cut = Dom.Event.make \"cut\"\n\n  let paste = Dom.Event.make \"paste\"\n\n  let dblclick = Dom.Event.make \"dblclick\"\n\n  let mousedown = Dom.Event.make \"mousedown\"\n\n  let mouseup = Dom.Event.make \"mouseup\"\n\n  let mouseover = Dom.Event.make \"mouseover\"\n\n  let mousemove = Dom.Event.make \"mousemove\"\n\n  let mouseout = Dom.Event.make \"mouseout\"\n\n  let keypress = Dom.Event.make \"keypress\"\n\n  let keydown = Dom.Event.make \"keydown\"\n\n  let keyup = Dom.Event.make \"keyup\"\n\n  let mousewheel = Dom.Event.make \"mousewheel\"\n\n  let wheel = Dom.Event.make \"wheel\"\n\n  let _DOMMouseScroll = Dom.Event.make \"DOMMouseScroll\"\n\n  let touchstart = Dom.Event.make \"touchstart\"\n\n  let touchmove = Dom.Event.make \"touchmove\"\n\n  let touchend = Dom.Event.make \"touchend\"\n\n  let touchcancel = Dom.Event.make \"touchcancel\"\n\n  let dragstart = Dom.Event.make \"dragstart\"\n\n  let dragend = Dom.Event.make \"dragend\"\n\n  let dragenter = Dom.Event.make \"dragenter\"\n\n  let dragover = Dom.Event.make \"dragover\"\n\n  let dragleave = Dom.Event.make \"dragleave\"\n\n  let drag = Dom.Event.make \"drag\"\n\n  let drop = Dom.Event.make \"drop\"\n\n  let hashchange = Dom.Event.make \"hashchange\"\n\n  let change = Dom.Event.make \"change\"\n\n  let input = Dom.Event.make \"input\"\n\n  let timeupdate = Dom.Event.make \"timeupdate\"\n\n  let submit = Dom.Event.make \"submit\"\n\n  let scroll = Dom.Event.make \"scroll\"\n\n  let focus = Dom.Event.make \"focus\"\n\n  let blur = Dom.Event.make \"blur\"\n\n  let load = Dom.Event.make \"load\"\n\n  let unload = Dom.Event.make \"unload\"\n\n  let beforeunload = Dom.Event.make \"beforeunload\"\n\n  let resize = Dom.Event.make \"resize\"\n\n  let orientationchange = Dom.Event.make \"orientationchange\"\n\n  let popstate = Dom.Event.make \"popstate\"\n\n  let error = Dom.Event.make \"error\"\n\n  let abort = Dom.Event.make \"abort\"\n\n  let select = Dom.Event.make \"select\"\n\n  let online = Dom.Event.make \"online\"\n\n  let offline = Dom.Event.make \"offline\"\n\n  let checking = Dom.Event.make \"checking\"\n\n  let noupdate = Dom.Event.make \"noupdate\"\n\n  let downloading = Dom.Event.make \"downloading\"\n\n  let progress = Dom.Event.make \"progress\"\n\n  let updateready = Dom.Event.make \"updateready\"\n\n  let cached = Dom.Event.make \"cached\"\n\n  let obsolete = Dom.Event.make \"obsolete\"\n\n  let domContentLoaded = Dom.Event.make \"DOMContentLoaded\"\n\n  let animationstart = Dom.Event.make \"animationstart\"\n\n  let animationend = Dom.Event.make \"animationend\"\n\n  let animationiteration = Dom.Event.make \"animationiteration\"\n\n  let animationcancel = Dom.Event.make \"animationcancel\"\n\n  let transitionrun = Dom.Event.make \"transitionrun\"\n\n  let transitionstart = Dom.Event.make \"transitionstart\"\n\n  let transitionend = Dom.Event.make \"transitionend\"\n\n  let transitioncancel = Dom.Event.make \"transitioncancel\"\n\n  let canplay = Dom.Event.make \"canplay\"\n\n  let canplaythrough = Dom.Event.make \"canplaythrough\"\n\n  let durationchange = Dom.Event.make \"durationchange\"\n\n  let emptied = Dom.Event.make \"emptied\"\n\n  let ended = Dom.Event.make \"ended\"\n\n  let gotpointercapture = Dom.Event.make \"gotpointercapture\"\n\n  let loadeddata = Dom.Event.make \"loadeddata\"\n\n  let loadedmetadata = Dom.Event.make \"loadedmetadata\"\n\n  let loadstart = Dom.Event.make \"loadstart\"\n\n  let lostpointercapture = Dom.Event.make \"lostpointercapture\"\n\n  let message = Dom.Event.make \"message\"\n\n  let pause = Dom.Event.make \"pause\"\n\n  let play = Dom.Event.make \"play\"\n\n  let playing = Dom.Event.make \"playing\"\n\n  let pointerenter = Dom.Event.make \"pointerenter\"\n\n  let pointercancel = Dom.Event.make \"pointercancel\"\n\n  let pointerdown = Dom.Event.make \"pointerdown\"\n\n  let pointerleave = Dom.Event.make \"pointerleave\"\n\n  let pointermove = Dom.Event.make \"pointermove\"\n\n  let pointerout = Dom.Event.make \"pointerout\"\n\n  let pointerover = Dom.Event.make \"pointerover\"\n\n  let pointerup = Dom.Event.make \"pointerup\"\n\n  let ratechange = Dom.Event.make \"ratechange\"\n\n  let seeked = Dom.Event.make \"seeked\"\n\n  let seeking = Dom.Event.make \"seeking\"\n\n  let stalled = Dom.Event.make \"stalled\"\n\n  let suspend = Dom.Event.make \"suspend\"\n\n  let volumechange = Dom.Event.make \"volumechange\"\n\n  let waiting = Dom.Event.make \"waiting\"\n\n  let toggle = Dom.Event.make \"toggle\"\n\n  let make = Dom.Event.make\nend\n\ntype event_listener_id = Dom.event_listener_id\n\nlet addEventListener = Dom.addEventListener\n\nlet addEventListenerWithOptions = Dom.addEventListenerWithOptions\n\nlet removeEventListener = Dom.removeEventListener\n\nlet createCustomEvent = Dom.createCustomEvent\n\nclass type ['node] collection = object\n  method length : int readonly_prop\n\n  method item : int -> 'node t opt meth\n\n  method namedItem : js_string t -> 'node t opt meth\nend\n\nclass type htmlElement = element\n\nclass type headElement = object\n  inherit element\n\n  method profile : js_string t prop\nend\n\nclass type linkElement = object\n  inherit element\n\n  method disabled : bool t prop\n\n  method charset : js_string t prop\n\n  method crossorigin : js_string t prop\n\n  method href : js_string t prop\n\n  method hreflang : js_string t prop\n\n  method media : js_string t prop\n\n  method rel : js_string t prop\n\n  method rev : js_string t prop\n\n  method target : js_string t prop\n\n  method _type : js_string t prop\nend\n\nclass type titleElement = object\n  inherit element\n\n  method text : js_string t prop\nend\n\nclass type metaElement = object\n  inherit element\n\n  method content : js_string t prop\n\n  method httpEquiv : js_string t prop\n\n  method name : js_string t prop\n\n  method scheme : js_string t prop\nend\n\nclass type baseElement = object\n  inherit element\n\n  method href : js_string t prop\n\n  method target : js_string t prop\nend\n\nclass type styleElement = object\n  inherit element\n\n  method disabled : bool t prop\n\n  method media : js_string t prop\n\n  method _type : js_string t prop\nend\n\nclass type bodyElement = element\n\nclass type formElement = object\n  inherit element\n\n  method elements : element collection t readonly_prop\n\n  method length : int readonly_prop\n\n  method acceptCharset : js_string t prop\n\n  method action : js_string t prop\n\n  method enctype : js_string t prop\n\n  method _method : js_string t prop\n\n  method target : js_string t prop\n\n  method submit : unit meth\n\n  method reset : unit meth\n\n  method onsubmit : ('self t, submitEvent t) event_listener writeonly_prop\nend\n\nclass type optGroupElement = object\n  inherit element\n\n  method disabled : bool t prop\n\n  method label : js_string t prop\nend\n\nclass type optionElement = object\n  inherit optGroupElement\n\n  method form : formElement t opt readonly_prop\n\n  method defaultSelected : bool t prop\n\n  method text : js_string t readonly_prop\n\n  method index : int readonly_prop\n\n  method selected : bool t prop\n\n  method value : js_string t prop\nend\n\nclass type selectElement = object ('self)\n  inherit element\n\n  method _type : js_string t readonly_prop\n\n  method selectedIndex : int prop\n\n  method value : js_string t prop\n\n  method length : int prop\n\n  method form : formElement t opt readonly_prop\n\n  method options : optionElement collection t readonly_prop\n\n  method disabled : bool t prop\n\n  method multiple : bool t prop\n\n  method name : js_string t readonly_prop\n\n  method size : int prop\n\n  method tabIndex : int prop\n\n  method add : #optGroupElement t -> #optGroupElement t opt -> unit meth\n\n  method remove : int -> unit meth\n\n  method required : bool t writeonly_prop\n\n  method onchange : ('self t, event t) event_listener prop\n\n  method oninput : ('self t, event t) event_listener prop\nend\n\nclass type inputElement = object ('self)\n  inherit element\n\n  method defaultValue : js_string t prop\n\n  method defaultChecked : js_string t prop\n\n  method form : formElement t opt readonly_prop\n\n  method accept : js_string t prop\n\n  method accessKey : js_string t prop\n\n  method align : js_string t prop\n\n  method alt : js_string t prop\n\n  method checked : bool t prop\n\n  method disabled : bool t prop\n\n  method maxLength : int prop\n\n  method name : js_string t readonly_prop\n\n  method readOnly : bool t prop\n\n  method required : bool t writeonly_prop\n\n  method size : int prop\n\n  method src : js_string t prop\n\n  method tabIndex : int prop\n\n  method _type : js_string t readonly_prop\n\n  method useMap : js_string t prop\n\n  method value : js_string t prop\n\n  method select : unit meth\n\n  method files : File.fileList t readonly_prop\n\n  method placeholder : js_string t writeonly_prop\n\n  method selectionDirection : js_string t prop\n\n  method selectionStart : int prop\n\n  method selectionEnd : int prop\n\n  method onselect : ('self t, event t) event_listener prop\n\n  method onchange : ('self t, event t) event_listener prop\n\n  method oninput : ('self t, event t) event_listener prop\n\n  method onblur : ('self t, focusEvent t) event_listener prop\n\n  method onfocus : ('self t, focusEvent t) event_listener prop\nend\n\nclass type textAreaElement = object ('self)\n  inherit element\n\n  method defaultValue : js_string t prop\n\n  method form : formElement t opt readonly_prop\n\n  method accessKey : js_string t prop\n\n  method cols : int prop\n\n  method disabled : bool t prop\n\n  method name : js_string t readonly_prop\n\n  method readOnly : bool t prop\n\n  method rows : int prop\n\n  method selectionDirection : js_string t prop\n\n  method selectionEnd : int prop\n\n  method selectionStart : int prop\n\n  method tabIndex : int prop\n\n  method _type : js_string t readonly_prop\n\n  method value : js_string t prop\n\n  method select : unit meth\n\n  method required : bool t writeonly_prop\n\n  method placeholder : js_string t writeonly_prop\n\n  method onselect : ('self t, event t) event_listener prop\n\n  method onchange : ('self t, event t) event_listener prop\n\n  method oninput : ('self t, event t) event_listener prop\n\n  method onblur : ('self t, focusEvent t) event_listener prop\n\n  method onfocus : ('self t, focusEvent t) event_listener prop\nend\n\nclass type buttonElement = object\n  inherit element\n\n  method form : formElement t opt readonly_prop\n\n  method accessKey : js_string t prop\n\n  method disabled : bool t prop\n\n  method name : js_string t readonly_prop\n\n  method tabIndex : int prop\n\n  method _type : js_string t readonly_prop\n\n  method value : js_string t prop\nend\n\nclass type labelElement = object\n  inherit element\n\n  method form : formElement t opt readonly_prop\n\n  method accessKey : js_string t prop\n\n  method htmlFor : js_string t prop\nend\n\nclass type fieldSetElement = object\n  inherit element\n\n  method form : formElement t opt readonly_prop\nend\n\nclass type legendElement = object\n  inherit element\n\n  method form : formElement t opt readonly_prop\n\n  method accessKey : js_string t prop\nend\n\nclass type uListElement = element\n\nclass type oListElement = element\n\nclass type dListElement = element\n\nclass type liElement = element\n\nclass type dialogElement = object\n  inherit element\n\n  method close : unit meth\n\n  method close_returnValue : js_string t -> unit meth\n\n  method open_ : bool t prop\n\n  method returnValue : js_string t prop\n\n  method show : unit meth\n\n  method showModal : unit meth\n\n  method oncancel : ('self t, event t) event_listener prop\n\n  method onclose : ('self t, event t) event_listener prop\nend\n\nclass type divElement = element\n\nclass type paragraphElement = element\n\nclass type headingElement = element\n\nclass type quoteElement = object\n  inherit element\n\n  method cite : js_string t prop\nend\n\nclass type preElement = element\n\nclass type brElement = element\n\nclass type hrElement = element\n\nclass type modElement = object\n  inherit element\n\n  method cite : js_string t prop\n\n  method dateTime : js_string t prop\nend\n\nclass type anchorElement = object\n  inherit element\n\n  method accessKey : js_string t prop\n\n  method charset : js_string t prop\n\n  method coords : js_string t prop\n\n  method download : js_string t prop\n\n  method href : js_string t prop\n\n  method hreflang : js_string t prop\n\n  method name : js_string t prop\n\n  method rel : js_string t prop\n\n  method rev : js_string t prop\n\n  method shape : js_string t prop\n\n  method tabIndex : int prop\n\n  method target : js_string t prop\n\n  method _type : js_string t prop\nend\n\nclass type detailsElement = object ('self)\n  inherit element\n\n  method open_ : bool t prop\n\n  method name : js_string t prop\n\n  method ontoggle : ('self t, toggleEvent t) event_listener prop\nend\n\nclass type imageElement = object ('self)\n  inherit element\n\n  method alt : js_string t prop\n\n  method src : js_string t prop\n\n  method useMap : js_string t prop\n\n  method isMap : bool t prop\n\n  method width : int prop\n\n  method height : int prop\n\n  method naturalWidth : int readonly_prop\n\n  method naturalHeight : int readonly_prop\n\n  method complete : bool t prop\n\n  method onload : ('self t, event t) event_listener prop\n\n  method onerror : ('self t, event t) event_listener prop\n\n  method onabort : ('self t, event t) event_listener prop\nend\n\nclass type objectElement = object\n  inherit element\n\n  method form : formElement t opt readonly_prop\n\n  method code : js_string t prop\n\n  method archive : js_string t prop\n\n  method codeBase : js_string t prop\n\n  method codeType : js_string t prop\n\n  method data : js_string t prop\n\n  method declare : bool t prop\n\n  method height : js_string t prop\n\n  method name : js_string t prop\n\n  method standby : js_string t prop\n\n  method tabIndex : int prop\n\n  method _type : js_string t prop\n\n  method useMap : js_string t prop\n\n  method width : js_string t prop\n\n  method document : Dom.element Dom.document t opt readonly_prop\nend\n\nclass type paramElement = object\n  inherit element\n\n  method name : js_string t prop\n\n  method _type : js_string t prop\n\n  method value : js_string t prop\n\n  method valueType : js_string t prop\nend\n\nclass type areaElement = object\n  inherit element\n\n  method accessKey : js_string t prop\n\n  method alt : js_string t prop\n\n  method coords : js_string t prop\n\n  method href : js_string t prop\n\n  method noHref : bool t prop\n\n  method shape : js_string t prop\n\n  method tabIndex : int prop\n\n  method target : js_string t prop\nend\n\nclass type mapElement = object\n  inherit element\n\n  method areas : areaElement collection t readonly_prop\n\n  method name : js_string t prop\nend\n\nclass type scriptElement = object\n  inherit element\n\n  method text : js_string t prop\n\n  method charset : js_string t prop\n\n  method defer : bool t prop\n\n  method src : js_string t prop\n\n  method _type : js_string t prop\n\n  method async : bool t prop\nend\n\nclass type embedElement = object\n  inherit element\n\n  method src : js_string t prop\n\n  method height : js_string t prop\n\n  method width : js_string t prop\n\n  method _type : js_string t prop\nend\n\nclass type tableCellElement = object\n  inherit element\n\n  method cellIndex : int readonly_prop\n\n  method abbr : js_string t prop\n\n  method align : js_string t prop\n\n  method axis : js_string t prop\n\n  method ch : js_string t prop\n\n  method chOff : js_string t prop\n\n  method colSpan : int prop\n\n  method headers : js_string t prop\n\n  method rowSpan : int prop\n\n  method scope : js_string t prop\n\n  method vAlign : js_string t prop\nend\n\nclass type tableRowElement = object\n  inherit element\n\n  method rowIndex : int readonly_prop\n\n  method sectionRowIndex : int readonly_prop\n\n  method cells : tableCellElement collection t readonly_prop\n\n  method align : js_string t prop\n\n  method ch : js_string t prop\n\n  method chOff : js_string t prop\n\n  method vAlign : js_string t prop\n\n  method insertCell : int -> tableCellElement t meth\n\n  method deleteCell : int -> unit meth\nend\n\nclass type tableColElement = object\n  inherit element\n\n  method align : js_string t prop\n\n  method ch : js_string t prop\n\n  method chOff : js_string t prop\n\n  method span : int prop\n\n  method vAlign : js_string t prop\n\n  method width : js_string t prop\nend\n\nclass type tableSectionElement = object\n  inherit element\n\n  method align : js_string t prop\n\n  method ch : js_string t prop\n\n  method chOff : js_string t prop\n\n  method vAlign : js_string t prop\n\n  method rows : tableRowElement collection t readonly_prop\n\n  method insertRow : int -> tableRowElement t meth\n\n  method deleteRow : int -> unit meth\nend\n\nclass type tableCaptionElement = element\n\nclass type tableElement = object\n  inherit element\n\n  method caption : tableCaptionElement t prop\n\n  method tHead : tableSectionElement t prop\n\n  method tFoot : tableSectionElement t prop\n\n  method rows : tableRowElement collection t readonly_prop\n\n  method tBodies : tableSectionElement collection t readonly_prop\n\n  method align : js_string t prop\n\n  method border : js_string t prop\n\n  method cellPadding : js_string t prop\n\n  method cellSpacing : js_string t prop\n\n  method frame : js_string t prop\n\n  method rules : js_string t prop\n\n  method summary : js_string t prop\n\n  method width : js_string t prop\n\n  method createTHead : tableSectionElement t meth\n\n  method deleteTHead : unit meth\n\n  method createTFoot : tableSectionElement t meth\n\n  method deleteTFoot : unit meth\n\n  method createCaption : tableCaptionElement t meth\n\n  method deleteCaption : unit meth\n\n  method insertRow : int -> tableRowElement t meth\n\n  method deleteRow : int -> unit meth\nend\n\nclass type timeRanges = object\n  method length : int readonly_prop\n\n  method start : int -> number_t meth\n\n  method end_ : int -> number_t meth\nend\n\ntype networkState =\n  | NETWORK_EMPTY\n  | NETWORK_IDLE\n  | NETWORK_LOADING\n  | NETWORK_NO_SOURCE\n\ntype readyState =\n  | HAVE_NOTHING\n  | HAVE_METADATA\n  | HAVE_CURRENT_DATA\n  | HAVE_FUTURE_DATA\n  | HAVE_ENOUGH_DATA\n\n(* http://www.w3schools.com/tags/ref_av_dom.asp *)\n(* only features supported by all browser. (IE9+) *)\nclass type mediaElement = object\n  inherit element\n\n  method canPlayType : js_string t -> js_string t meth\n\n  method load : unit meth\n\n  method play : unit meth\n\n  method pause : unit meth\n\n  method autoplay : bool t prop\n\n  method buffered : timeRanges t readonly_prop\n\n  method controls : bool t prop\n\n  method currentSrc : js_string t readonly_prop\n\n  method currentTime : number_t prop\n\n  method duration : number_t readonly_prop\n\n  method ended : bool t readonly_prop\n\n  method loop : bool t prop\n\n  method mediagroup : js_string t prop\n\n  method muted : bool t prop\n\n  method networkState_int : int readonly_prop\n\n  method networkState : networkState readonly_prop\n\n  method paused : bool t readonly_prop\n\n  method playbackRate : number_t prop\n\n  method played : timeRanges t readonly_prop\n\n  method preload : js_string t prop\n\n  method readyState_int : int readonly_prop\n\n  method readyState : readyState readonly_prop\n\n  method seekable : timeRanges t readonly_prop\n\n  method seeking : bool t readonly_prop\n\n  method src : js_string t prop\n\n  method volume : number_t prop\n\n  method oncanplay : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method oncanplaythrough : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method ondurationchange : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onemptied : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onended : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onloadeddata : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onloadedmetadata : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onloadstart : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onpause : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onplay : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onplaying : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onratechange : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onseeked : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onseeking : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onstalled : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onsuspend : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onvolumechange : ('self t, mediaEvent t) event_listener writeonly_prop\n\n  method onwaiting : ('self t, mediaEvent t) event_listener writeonly_prop\nend\n\nclass type audioElement = object\n  inherit mediaElement\nend\n\nclass type videoElement = object\n  inherit mediaElement\nend\n\ntype context = js_string t\n\nlet _2d_ = Js.string \"2d\"\n\ntype canvasPattern\n\nclass type canvasElement = object\n  inherit element\n\n  method width : int prop\n\n  method height : int prop\n\n  method toDataURL : js_string t meth\n\n  method toDataURL_type : js_string t -> js_string t meth\n\n  method toDataURL_type_compression : js_string t -> number_t -> js_string t meth\n\n  method getContext : js_string t -> canvasRenderingContext2D t meth\nend\n\nand canvasRenderingContext2D = object\n  method canvas : canvasElement t readonly_prop\n\n  method save : unit meth\n\n  method restore : unit meth\n\n  method scale : number_t -> number_t -> unit meth\n\n  method rotate : number_t -> unit meth\n\n  method translate : number_t -> number_t -> unit meth\n\n  method transform :\n    number_t -> number_t -> number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method setTransform :\n    number_t -> number_t -> number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method globalAlpha : number_t prop\n\n  method globalCompositeOperation : js_string t prop\n\n  method strokeStyle : js_string t writeonly_prop\n\n  method strokeStyle_gradient : canvasGradient t writeonly_prop\n\n  method strokeStyle_pattern : canvasPattern t writeonly_prop\n\n  method fillStyle : js_string t writeonly_prop\n\n  method fillStyle_gradient : canvasGradient t writeonly_prop\n\n  method fillStyle_pattern : canvasPattern t writeonly_prop\n\n  method createLinearGradient :\n    number_t -> number_t -> number_t -> number_t -> canvasGradient t meth\n\n  method createRadialGradient :\n       number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> canvasGradient t meth\n\n  method createPattern : imageElement t -> js_string t -> canvasPattern t meth\n\n  method createPattern_fromCanvas : canvasElement t -> js_string t -> canvasPattern t meth\n\n  method createPattern_fromVideo : videoElement t -> js_string t -> canvasPattern t meth\n\n  method lineWidth : number_t prop\n\n  method lineCap : js_string t prop\n\n  method lineJoin : js_string t prop\n\n  method miterLimit : number_t prop\n\n  method shadowOffsetX : number_t prop\n\n  method shadowOffsetY : number_t prop\n\n  method shadowBlur : number_t prop\n\n  method shadowColor : js_string t prop\n\n  method clearRect : number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method fillRect : number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method strokeRect : number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method beginPath : unit meth\n\n  method closePath : unit meth\n\n  method moveTo : number_t -> number_t -> unit meth\n\n  method lineTo : number_t -> number_t -> unit meth\n\n  method quadraticCurveTo : number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method bezierCurveTo :\n    number_t -> number_t -> number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method arcTo : number_t -> number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method rect : number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method arc :\n    number_t -> number_t -> number_t -> number_t -> number_t -> bool t -> unit meth\n\n  method ellipse :\n       number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> bool t\n    -> unit meth\n\n  method fill : unit meth\n\n  method stroke : unit meth\n\n  method clip : unit meth\n\n  method isPointInPath : number_t -> number_t -> bool t meth\n\n  method drawFocusRing : #element t -> number_t -> number_t -> bool t -> bool t meth\n\n  method font : js_string t prop\n\n  method textAlign : js_string t prop\n\n  method textBaseline : js_string t prop\n\n  method fillText : js_string t -> number_t -> number_t -> unit meth\n\n  method fillText_withWidth : js_string t -> number_t -> number_t -> number_t -> unit meth\n\n  method strokeText : js_string t -> number_t -> number_t -> unit meth\n\n  method strokeText_withWidth :\n    js_string t -> number_t -> number_t -> number_t -> unit meth\n\n  method measureText : js_string t -> textMetrics t meth\n\n  method drawImage : imageElement t -> number_t -> number_t -> unit meth\n\n  method drawImage_withSize :\n    imageElement t -> number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method drawImage_full :\n       imageElement t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> unit meth\n\n  method drawImage_fromCanvas : canvasElement t -> number_t -> number_t -> unit meth\n\n  method drawImage_fromCanvasWithSize :\n    canvasElement t -> number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method drawImage_fullFromCanvas :\n       canvasElement t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> unit meth\n\n  method drawImage_fromVideoWithVideo :\n    videoElement t -> number_t -> number_t -> unit meth\n\n  method drawImage_fromVideoWithSize :\n    videoElement t -> number_t -> number_t -> number_t -> number_t -> unit meth\n\n  method drawImage_fullFromVideo :\n       videoElement t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> number_t\n    -> unit meth\n\n  method createImageData : int -> int -> imageData t meth\n\n  method getImageData : number_t -> number_t -> number_t -> number_t -> imageData t meth\n\n  method putImageData : imageData t -> number_t -> number_t -> unit meth\nend\n\nand canvasGradient = object\n  method addColorStop : number_t -> js_string t -> unit meth\nend\n\nand textMetrics = object\n  method actualBoundingBoxAscent : number_t readonly_prop\n  (** https://developer.mozilla.org/docs/Web/API/TextMetrics/actualBoundingBoxAscent *)\n\n  method actualBoundingBoxDescent : number_t readonly_prop\n  (** https://developer.mozilla.org/docs/Web/API/TextMetrics/actualBoundingBoxDescent *)\n\n  method actualBoundingBoxLeft : number_t readonly_prop\n  (** https://developer.mozilla.org/docs/Web/API/TextMetrics/actualBoundingBoxLeft *)\n\n  method actualBoundingBoxRight : number_t readonly_prop\n  (** https://developer.mozilla.org/docs/Web/API/TextMetrics/actualBoundingBoxRight *)\n\n  method alphabeticBaseline : number_t readonly_prop\n  (** https://developer.mozilla.org/docs/Web/API/TextMetrics/alphabeticBaseline *)\n\n  method fontBoundingBoxAscent : number_t readonly_prop\n  (** https://developer.mozilla.org/docs/Web/API/TextMetrics/fontBoundingBoxAscent *)\n\n  method fontBoundingBoxDescent : number_t readonly_prop\n  (** https://developer.mozilla.org/docs/Web/API/TextMetrics/fontBoundingBoxDescent *)\n\n  method hangingBaseline : number_t readonly_prop\n  (** https://developer.mozilla.org/docs/Web/API/TextMetrics/hangingBaseline *)\n\n  method ideographicBaseline : number_t readonly_prop\n  (** https://developer.mozilla.org/docs/Web/API/TextMetrics/ideographicBaseline *)\n\n  method width : number_t readonly_prop\n  (** https://developer.mozilla.org/docs/Web/API/TextMetrics/width *)\nend\n\nand imageData = object\n  method width : int readonly_prop\n\n  method height : int readonly_prop\n\n  method data : canvasPixelArray t readonly_prop\nend\n\nand canvasPixelArray = object\n  method length : int readonly_prop\nend\n\nexternal pixel_get : canvasPixelArray t -> int -> int = \"caml_js_get\"\n\nexternal pixel_set : canvasPixelArray t -> int -> int -> unit = \"caml_js_set\"\n\nclass type range = object\n  method collapsed : bool t readonly_prop\n\n  method startOffset : int readonly_prop\n\n  method endOffset : int readonly_prop\n\n  method startContainer : Dom.node t readonly_prop\n\n  method endContainer : Dom.node t readonly_prop\n\n  method setStart : Dom.node t -> int -> unit meth\n\n  method setEnd : Dom.node t -> int -> unit meth\n\n  method setStartBefore : Dom.node t -> unit meth\n\n  method setEndBefore : Dom.node t -> unit meth\n\n  method setStartAfter : Dom.node t -> unit meth\n\n  method setEndAfter : Dom.node t -> unit meth\n\n  method selectNode : Dom.node t -> unit meth\n\n  method selectNodeContents : Dom.node t -> unit meth\n\n  method collapse : bool t -> unit meth\n\n  method cloneContents : Dom.documentFragment t meth\n\n  method extractContents : Dom.documentFragment t meth\n\n  method deleteContents : unit meth\n\n  method insertNode : Dom.node t -> unit meth\n\n  method surroundContents : Dom.node t -> unit meth\n\n  method cloneRange : range t meth\n\n  method toString : js_string t meth\nend\n\n(** Information on current selection *)\nclass type selection = object\n  method anchorNode : Dom.node t readonly_prop\n\n  method anchorOffset : int readonly_prop\n\n  method focusNode : Dom.node t readonly_prop\n\n  method focusOffset : int readonly_prop\n\n  method isCollapsed : bool t readonly_prop\n\n  method rangeCount : int readonly_prop\n\n  method getRangeAt : int -> range t meth\n\n  method collapse : bool t -> unit meth\n\n  method extend : Dom.node t -> int -> unit meth\n\n  method modify : js_string t -> js_string t -> js_string t -> unit meth\n\n  method collapseToStart : unit meth\n\n  method collapseToEnd : unit meth\n\n  method selectAllChildren : Dom.node t -> unit meth\n\n  method addRange : range t -> unit meth\n\n  method removeRange : range t -> unit meth\n\n  method removeAllRanges : unit meth\n\n  method deleteFromDocument : unit meth\n\n  method containsNode : Dom.node t -> bool t -> bool t meth\n\n  method toString : js_string t meth\nend\n\nclass type document = object\n  inherit [element] Dom.document\n\n  inherit nodeSelector\n\n  inherit eventTarget\n\n  method title : js_string t prop\n\n  method referrer : js_string t readonly_prop\n\n  method domain : js_string t prop\n\n  method _URL : js_string t readonly_prop\n\n  method head : headElement t prop\n\n  method body : bodyElement t prop\n\n  method documentElement : htmlElement t readonly_prop\n\n  method images : imageElement collection t readonly_prop\n\n  method applets : element collection t readonly_prop\n\n  method links : element collection t readonly_prop\n\n  method forms : formElement collection t readonly_prop\n\n  method anchors : element collection t readonly_prop\n\n  method cookie : js_string t prop\n\n  method designMode : js_string t prop\n\n  method open_ : unit meth\n\n  method close : unit meth\n\n  method write : js_string t -> unit meth\n\n  method execCommand : js_string t -> bool t -> js_string t opt -> unit meth\n\n  method createRange : range t meth\n\n  method readyState : js_string t readonly_prop\n\n  method getElementsByClassName : js_string t -> element Dom.nodeList t meth\n\n  method getElementsByName : js_string t -> element Dom.nodeList t meth\n\n  method activeElement : element t opt readonly_prop\n\n  method hidden : bool t readonly_prop\n\n  method onfullscreenchange : (document t, event t) event_listener writeonly_prop\n\n  method onwebkitfullscreenchange : (document t, event t) event_listener writeonly_prop\n\n  inherit eventTarget\nend\n\ntype interval_id\n\ntype timeout_id\n\ntype animation_frame_request_id\n\nclass type location = object\n  method href : js_string t prop\n\n  method protocol : js_string t prop\n\n  method host : js_string t prop\n\n  method hostname : js_string t prop\n\n  method origin : js_string t readonly_prop\n\n  method port : js_string t prop\n\n  method pathname : js_string t prop\n\n  method search : js_string t prop\n\n  method hash : js_string t prop\n\n  method assign : js_string t -> unit meth\n\n  method replace : js_string t -> unit meth\n\n  method reload : unit meth\nend\n\nlet location_origin (loc : location t) = loc##.origin\n\nclass type history = object\n  method length : int readonly_prop\n\n  method state : Js.Unsafe.any readonly_prop\n\n  method go : int opt -> unit meth\n\n  method back : unit meth\n\n  method forward : unit meth\n\n  method pushState : 'a. 'a -> js_string t -> js_string t opt -> unit meth\n\n  method replaceState : 'a. 'a -> js_string t -> js_string t opt -> unit meth\nend\n\nclass type undoManager = object end\n\nclass type navigator = object\n  method appCodeName : js_string t readonly_prop\n\n  method appName : js_string t readonly_prop\n\n  method appVersion : js_string t readonly_prop\n\n  method cookieEnabled : bool t readonly_prop\n\n  method onLine : bool t readonly_prop\n\n  method platform : js_string t readonly_prop\n\n  method vendor : js_string t readonly_prop\n\n  method userAgent : js_string t readonly_prop\n\n  method language : js_string t opt readonly_prop\n\n  method maxTouchPoints : int readonly_prop\n\n  method userLanguage : js_string t optdef readonly_prop\nend\n\nclass type screen = object\n  method width : int readonly_prop\n\n  method height : int readonly_prop\n\n  method availWidth : int readonly_prop\n\n  method availHeight : int readonly_prop\nend\n\nclass type applicationCache = object\n  method status : int readonly_prop\n\n  method update : unit meth\n\n  method abort : unit meth\n\n  method swapCache : unit meth\n\n  method onchecking : (applicationCache t, event t) event_listener prop\n\n  method onerror : (applicationCache t, event t) event_listener prop\n\n  method onnoupdate : (applicationCache t, event t) event_listener prop\n\n  method ondownloading : (applicationCache t, event t) event_listener prop\n\n  method onprogress : (applicationCache t, event t) event_listener prop\n\n  method onupdateready : (applicationCache t, event t) event_listener prop\n\n  method oncached : (applicationCache t, event t) event_listener prop\n\n  method onobsolete : (applicationCache t, event t) event_listener prop\n\n  inherit eventTarget\nend\n\nclass type _URL = object\n  method createObjectURL : #File.blob t -> js_string t meth\n\n  method revokeObjectURL : js_string t -> unit meth\nend\n\nclass type mediaQueryList = object\n  method media : js_string t prop\n\n  method matches : bool readonly_prop\n\n  method onchange : (mediaQueryList t, mediaQueryListEvent t) event_listener prop\n\n  inherit eventTarget\nend\n\nclass type window = object\n  inherit eventTarget\n\n  method document : document t readonly_prop\n\n  method applicationCache : applicationCache t readonly_prop\n\n  method name : js_string t prop\n\n  method location : location t readonly_prop\n\n  method history : history t readonly_prop\n\n  method undoManager : undoManager t readonly_prop\n\n  method navigator : navigator t readonly_prop\n\n  method getSelection : selection t meth\n\n  method close : unit meth\n\n  method closed : bool t readonly_prop\n\n  method stop : unit meth\n\n  method focus : unit meth\n\n  method blur : unit meth\n\n  method scrollX : number_t readonly_prop\n\n  method scrollY : number_t readonly_prop\n\n  method scroll : number_t -> number_t -> unit meth\n\n  method scrollTo : number_t -> number_t -> unit meth\n\n  method scrollBy : number_t -> number_t -> unit meth\n\n  method sessionStorage : storage t optdef readonly_prop\n\n  method localStorage : storage t optdef readonly_prop\n\n  method top : window t readonly_prop\n\n  method parent : window t readonly_prop\n\n  method frameElement : element t opt readonly_prop\n\n  method open_ : js_string t -> js_string t -> js_string t opt -> window t opt meth\n\n  method alert : js_string t -> unit meth\n\n  method confirm : js_string t -> bool t meth\n\n  method prompt : js_string t -> js_string t -> js_string t opt meth\n\n  method print : unit meth\n\n  method setInterval : (unit -> unit) Js.callback -> number_t -> interval_id meth\n\n  method clearInterval : interval_id -> unit meth\n\n  method setTimeout : (unit -> unit) Js.callback -> number_t -> timeout_id meth\n\n  method clearTimeout : timeout_id -> unit meth\n\n  method requestAnimationFrame :\n    (number_t -> unit) Js.callback -> animation_frame_request_id meth\n\n  method cancelAnimationFrame : animation_frame_request_id -> unit meth\n\n  method screen : screen t readonly_prop\n\n  method innerWidth : int readonly_prop\n\n  method innerHeight : int readonly_prop\n\n  method outerWidth : int readonly_prop\n\n  method outerHeight : int readonly_prop\n\n  method getComputedStyle : #element t -> cssStyleDeclaration t meth\n\n  method getComputedStyle_pseudoElt :\n    #element t -> js_string t -> cssStyleDeclaration t meth\n\n  method atob : js_string t -> js_string t meth\n\n  method btoa : js_string t -> js_string t meth\n\n  method onload : (window t, event t) event_listener prop\n\n  method onunload : (window t, event t) event_listener prop\n\n  method onbeforeunload : (window t, event t) event_listener prop\n\n  method onblur : (window t, focusEvent t) event_listener prop\n\n  method onfocus : (window t, focusEvent t) event_listener prop\n\n  method onresize : (window t, event t) event_listener prop\n\n  method onorientationchange : (window t, event t) event_listener prop\n\n  method onpopstate : (window t, popStateEvent t) event_listener prop\n\n  method onhashchange : (window t, hashChangeEvent t) event_listener prop\n\n  method ononline : (window t, event t) event_listener writeonly_prop\n\n  method onoffline : (window t, event t) event_listener writeonly_prop\n\n  method _URL : _URL t readonly_prop\n\n  method devicePixelRatio : number_t readonly_prop\n\n  method matchMedia : js_string t -> mediaQueryList t meth\nend\n\nlet window : window t = Js.Unsafe.global\n\n(* The toplevel object *)\n\nlet document = window##.document\n\nlet getElementById id =\n  Js.Opt.case\n    (document##getElementById (Js.string id))\n    (fun () -> raise Not_found)\n    (fun pnode -> pnode)\n\nlet getElementById_exn id =\n  Js.Opt.case\n    (document##getElementById (Js.string id))\n    (fun () -> failwith (Printf.sprintf \"getElementById_exn: %S not found\" id))\n    (fun pnode -> pnode)\n\nlet getElementById_opt id = Js.Opt.to_option (document##getElementById (Js.string id))\n\nlet getElementById_coerce id coerce =\n  Js.Opt.case\n    (document##getElementById (Js.string id))\n    (fun () -> None)\n    (fun e -> Js.Opt.to_option (coerce e))\n\n(****)\n\nclass type frameSetElement = object\n  inherit element\n\n  method cols : js_string t prop\n\n  method rows : js_string t prop\nend\n\nclass type frameElement = object\n  inherit element\n\n  method frameBorder : js_string t prop\n\n  method longDesc : js_string t prop\n\n  method marginHeight : js_string t prop\n\n  method marginWidth : js_string t prop\n\n  method name : js_string t prop\n\n  method noResize : bool t prop\n\n  method scrolling : js_string t prop\n\n  method src : js_string t prop\n\n  method contentDocument : document t opt readonly_prop\nend\n\nclass type iFrameElement = object\n  inherit element\n\n  method frameBorder : js_string t prop\n\n  method height : js_string t prop\n\n  method width : js_string t prop\n\n  method longDesc : js_string t prop\n\n  method marginHeight : js_string t prop\n\n  method marginWidth : js_string t prop\n\n  method name : js_string t prop\n\n  method scrolling : js_string t prop\n\n  method src : js_string t prop\n\n  method contentDocument : document t opt readonly_prop\n\n  method contentWindow : window t readonly_prop\nend\n\n(****)\n\n(*XXX Should provide creation functions a la lablgtk... *)\n\nlet opt_iter x f =\n  match x with\n  | None -> ()\n  | Some v -> f v\n\nlet createElement (doc : document t) name = doc##createElement (Js.string name)\n\nlet unsafeCreateElement doc name = Js.Unsafe.coerce (createElement doc name)\n\nlet createElementSyntax = ref `Unknown\n\nlet rec unsafeCreateElementEx ?_type ?name doc elt =\n  if Poly.(_type = None) && Poly.(name = None)\n  then Js.Unsafe.coerce (createElement doc elt)\n  else\n    match !createElementSyntax with\n    | `Standard ->\n        let res = Js.Unsafe.coerce (createElement doc elt) in\n        opt_iter _type (fun t -> res##._type := t);\n        opt_iter name (fun n -> res##.name := n);\n        res\n    | `Extended ->\n        let a = new%js Js.array_empty in\n        ignore (a##push_2 (Js.string \"<\") (Js.string elt));\n        opt_iter _type (fun t ->\n            ignore (a##push_3 (Js.string \" type=\\\"\") (html_escape t) (Js.string \"\\\"\")));\n        opt_iter name (fun n ->\n            ignore (a##push_3 (Js.string \" name=\\\"\") (html_escape n) (Js.string \"\\\"\")));\n        ignore (a##push (Js.string \">\"));\n        Js.Unsafe.coerce (doc##createElement (a##join (Js.string \"\")))\n    | `Unknown ->\n        createElementSyntax :=\n          if\n            try\n              let el : inputElement Js.t =\n                Js.Unsafe.coerce\n                  (document##createElement (Js.string \"<input name=\\\"x\\\">\"))\n              in\n              Js.equals el##.tagName##toLowerCase (Js.string \"input\")\n              && Js.equals el##.name (Js.string \"x\")\n            with _ -> false\n          then `Extended\n          else `Standard;\n        unsafeCreateElementEx ?_type ?name doc elt\n\nlet createHtml doc : htmlElement t = unsafeCreateElement doc \"html\"\n\nlet createHead doc : headElement t = unsafeCreateElement doc \"head\"\n\nlet createLink doc : linkElement t = unsafeCreateElement doc \"link\"\n\nlet createTitle doc : titleElement t = unsafeCreateElement doc \"title\"\n\nlet createMeta doc : metaElement t = unsafeCreateElement doc \"meta\"\n\nlet createBase doc : baseElement t = unsafeCreateElement doc \"base\"\n\nlet createStyle doc : styleElement t = unsafeCreateElement doc \"style\"\n\nlet createBody doc : bodyElement t = unsafeCreateElement doc \"body\"\n\nlet createForm doc : formElement t = unsafeCreateElement doc \"form\"\n\nlet createOptgroup doc : optGroupElement t = unsafeCreateElement doc \"optgroup\"\n\nlet createOption doc : optionElement t = unsafeCreateElement doc \"option\"\n\nlet createSelect ?_type ?name doc : selectElement t =\n  unsafeCreateElementEx ?_type ?name doc \"select\"\n\nlet createInput ?_type ?name doc : inputElement t =\n  unsafeCreateElementEx ?_type ?name doc \"input\"\n\nlet createTextarea ?_type ?name doc : textAreaElement t =\n  unsafeCreateElementEx ?_type ?name doc \"textarea\"\n\nlet createButton ?_type ?name doc : buttonElement t =\n  unsafeCreateElementEx ?_type ?name doc \"button\"\n\nlet createLabel doc : labelElement t = unsafeCreateElement doc \"label\"\n\nlet createFieldset doc : fieldSetElement t = unsafeCreateElement doc \"fieldset\"\n\nlet createLegend doc : legendElement t = unsafeCreateElement doc \"legend\"\n\nlet createUl doc : uListElement t = unsafeCreateElement doc \"ul\"\n\nlet createOl doc : oListElement t = unsafeCreateElement doc \"ol\"\n\nlet createDl doc : dListElement t = unsafeCreateElement doc \"dl\"\n\nlet createLi doc : liElement t = unsafeCreateElement doc \"li\"\n\nlet createDialog doc : dialogElement t = unsafeCreateElement doc \"dialog\"\n\nlet createDiv doc : divElement t = unsafeCreateElement doc \"div\"\n\nlet createEmbed doc : embedElement t = unsafeCreateElement doc \"embed\"\n\nlet createP doc : paragraphElement t = unsafeCreateElement doc \"p\"\n\nlet createH1 doc : headingElement t = unsafeCreateElement doc \"h1\"\n\nlet createH2 doc : headingElement t = unsafeCreateElement doc \"h2\"\n\nlet createH3 doc : headingElement t = unsafeCreateElement doc \"h3\"\n\nlet createH4 doc : headingElement t = unsafeCreateElement doc \"h4\"\n\nlet createH5 doc : headingElement t = unsafeCreateElement doc \"h5\"\n\nlet createH6 doc : headingElement t = unsafeCreateElement doc \"h6\"\n\nlet createQ doc : quoteElement t = unsafeCreateElement doc \"q\"\n\nlet createBlockquote doc : quoteElement t = unsafeCreateElement doc \"blockquote\"\n\nlet createPre doc : preElement t = unsafeCreateElement doc \"pre\"\n\nlet createBr doc : brElement t = unsafeCreateElement doc \"br\"\n\nlet createHr doc : hrElement t = unsafeCreateElement doc \"hr\"\n\nlet createIns doc : modElement t = unsafeCreateElement doc \"ins\"\n\nlet createDel doc : modElement t = unsafeCreateElement doc \"del\"\n\nlet createA doc : anchorElement t = unsafeCreateElement doc \"a\"\n\nlet createImg doc : imageElement t = unsafeCreateElement doc \"img\"\n\nlet createObject doc : objectElement t = unsafeCreateElement doc \"object\"\n\nlet createParam doc : paramElement t = unsafeCreateElement doc \"param\"\n\nlet createMap doc : mapElement t = unsafeCreateElement doc \"map\"\n\nlet createArea doc : areaElement t = unsafeCreateElement doc \"area\"\n\nlet createScript doc : scriptElement t = unsafeCreateElement doc \"script\"\n\nlet createTable doc : tableElement t = unsafeCreateElement doc \"table\"\n\nlet createCaption doc : tableCaptionElement t = unsafeCreateElement doc \"caption\"\n\nlet createCol doc : tableColElement t = unsafeCreateElement doc \"col\"\n\nlet createColgroup doc : tableColElement t = unsafeCreateElement doc \"colgroup\"\n\nlet createThead doc : tableSectionElement t = unsafeCreateElement doc \"thead\"\n\nlet createTfoot doc : tableSectionElement t = unsafeCreateElement doc \"tfoot\"\n\nlet createTbody doc : tableSectionElement t = unsafeCreateElement doc \"tbody\"\n\nlet createTr doc : tableRowElement t = unsafeCreateElement doc \"tr\"\n\nlet createTh doc : tableCellElement t = unsafeCreateElement doc \"th\"\n\nlet createTd doc : tableCellElement t = unsafeCreateElement doc \"td\"\n\nlet createSub doc = createElement doc \"sub\"\n\nlet createSup doc = createElement doc \"sup\"\n\nlet createSpan doc = createElement doc \"span\"\n\nlet createTt doc = createElement doc \"tt\"\n\nlet createI doc = createElement doc \"i\"\n\nlet createB doc = createElement doc \"b\"\n\nlet createBig doc = createElement doc \"big\"\n\nlet createSmall doc = createElement doc \"small\"\n\nlet createEm doc = createElement doc \"em\"\n\nlet createStrong doc = createElement doc \"strong\"\n\nlet createCite doc = createElement doc \"cite\"\n\nlet createDfn doc = createElement doc \"dfn\"\n\nlet createCode doc = createElement doc \"code\"\n\nlet createSamp doc = createElement doc \"samp\"\n\nlet createKbd doc = createElement doc \"kbd\"\n\nlet createVar doc = createElement doc \"var\"\n\nlet createAbbr doc = createElement doc \"abbr\"\n\nlet createDd doc = createElement doc \"dd\"\n\nlet createDt doc = createElement doc \"dt\"\n\nlet createNoscript doc = createElement doc \"noscript\"\n\nlet createAddress doc = createElement doc \"address\"\n\nlet createFrameset doc : frameSetElement t = unsafeCreateElement doc \"frameset\"\n\nlet createFrame doc : frameElement t = unsafeCreateElement doc \"frame\"\n\nlet createIframe doc : iFrameElement t = unsafeCreateElement doc \"iframe\"\n\nlet createAudio doc : audioElement t = unsafeCreateElement doc \"audio\"\n\nlet createVideo doc : audioElement t = unsafeCreateElement doc \"video\"\n\nexception Canvas_not_available\n\nlet createCanvas doc : canvasElement t =\n  let c = unsafeCreateElement doc \"canvas\" in\n  if not (Opt.test c##.getContext) then raise Canvas_not_available;\n  c\n\nlet html_element : htmlElement t constr = Js.Unsafe.global##._HTMLElement\n\nmodule CoerceTo = struct\n  let element (e : #Dom.node Js.t) : element Js.t Js.opt =\n    if Js.instanceof e html_element then Js.some (Js.Unsafe.coerce e) else Js.null\n\n  let unsafeCoerce tag (e : #element t) =\n    if Js.equals e##.tagName##toLowerCase (Js.string tag)\n    then Js.some (Js.Unsafe.coerce e)\n    else Js.null\n\n  let a e = unsafeCoerce \"a\" e\n\n  let area e = unsafeCoerce \"area\" e\n\n  let base e = unsafeCoerce \"base\" e\n\n  let blockquote e = unsafeCoerce \"blockquote\" e\n\n  let body e = unsafeCoerce \"body\" e\n\n  let br e = unsafeCoerce \"br\" e\n\n  let button e = unsafeCoerce \"button\" e\n\n  let canvas e = unsafeCoerce \"canvas\" e\n\n  let caption e = unsafeCoerce \"caption\" e\n\n  let col e = unsafeCoerce \"col\" e\n\n  let colgroup e = unsafeCoerce \"colgroup\" e\n\n  let del e = unsafeCoerce \"del\" e\n\n  let details e = unsafeCoerce \"details\" e\n\n  let div e = unsafeCoerce \"div\" e\n\n  let dl e = unsafeCoerce \"dl\" e\n\n  let fieldset e = unsafeCoerce \"fieldset\" e\n\n  let embed e = unsafeCoerce \"embed\" e\n\n  let form e = unsafeCoerce \"form\" e\n\n  let frameset e = unsafeCoerce \"frameset\" e\n\n  let frame e = unsafeCoerce \"frame\" e\n\n  let h1 e = unsafeCoerce \"h1\" e\n\n  let h2 e = unsafeCoerce \"h2\" e\n\n  let h3 e = unsafeCoerce \"h3\" e\n\n  let h4 e = unsafeCoerce \"h4\" e\n\n  let h5 e = unsafeCoerce \"h5\" e\n\n  let h6 e = unsafeCoerce \"h6\" e\n\n  let head e = unsafeCoerce \"head\" e\n\n  let hr e = unsafeCoerce \"hr\" e\n\n  let html e = unsafeCoerce \"html\" e\n\n  let iframe e = unsafeCoerce \"iframe\" e\n\n  let img e = unsafeCoerce \"img\" e\n\n  let input e = unsafeCoerce \"input\" e\n\n  let ins e = unsafeCoerce \"ins\" e\n\n  let label e = unsafeCoerce \"label\" e\n\n  let legend e = unsafeCoerce \"legend\" e\n\n  let li e = unsafeCoerce \"li\" e\n\n  let link e = unsafeCoerce \"link\" e\n\n  let map e = unsafeCoerce \"map\" e\n\n  let meta e = unsafeCoerce \"meta\" e\n\n  let _object e = unsafeCoerce \"object\" e\n\n  let ol e = unsafeCoerce \"ol\" e\n\n  let optgroup e = unsafeCoerce \"optgroup\" e\n\n  let option e = unsafeCoerce \"option\" e\n\n  let p e = unsafeCoerce \"p\" e\n\n  let param e = unsafeCoerce \"param\" e\n\n  let pre e = unsafeCoerce \"pre\" e\n\n  let q e = unsafeCoerce \"q\" e\n\n  let script e = unsafeCoerce \"script\" e\n\n  let select e = unsafeCoerce \"select\" e\n\n  let style e = unsafeCoerce \"style\" e\n\n  let table e = unsafeCoerce \"table\" e\n\n  let tbody e = unsafeCoerce \"tbody\" e\n\n  let td e = unsafeCoerce \"td\" e\n\n  let textarea e = unsafeCoerce \"textarea\" e\n\n  let tfoot e = unsafeCoerce \"tfoot\" e\n\n  let th e = unsafeCoerce \"th\" e\n\n  let thead e = unsafeCoerce \"thead\" e\n\n  let title e = unsafeCoerce \"title\" e\n\n  let tr e = unsafeCoerce \"tr\" e\n\n  let ul e = unsafeCoerce \"ul\" e\n\n  let audio e = unsafeCoerce \"audio\" e\n\n  let video e = unsafeCoerce \"video\" e\n\n  let unsafeCoerceEvent constr (ev : #event t) =\n    if Js.Optdef.test (def constr) && Js.instanceof ev constr\n    then Js.some (Js.Unsafe.coerce ev)\n    else Js.null\n\n  let mouseEvent ev = unsafeCoerceEvent Js.Unsafe.global##._MouseEvent ev\n\n  let keyboardEvent ev = unsafeCoerceEvent Js.Unsafe.global##._KeyboardEvent ev\n\n  let wheelEvent ev = unsafeCoerceEvent Js.Unsafe.global##._WheelEvent ev\n\n  let mouseScrollEvent ev = unsafeCoerceEvent Js.Unsafe.global##._MouseScrollEvent ev\n\n  let popStateEvent ev = unsafeCoerceEvent Js.Unsafe.global##._PopStateEvent ev\n\n  let messageEvent ev = unsafeCoerceEvent Js.Unsafe.global##._MessageEvent ev\nend\n\n(****)\n\nlet eventTarget = Dom.eventTarget\n\nlet eventRelatedTarget (e : #mouseEvent t) = e##.relatedTarget\n\nlet eventAbsolutePosition' (e : #mouseEvent t) =\n  let body = document##.body in\n  let html = document##.documentElement in\n  ( Js.to_float e##.clientX\n    +. Js.to_float body##.scrollLeft\n    +. Js.to_float html##.scrollLeft\n  , Js.to_float e##.clientY\n    +. Js.to_float body##.scrollTop\n    +. Js.to_float html##.scrollTop )\n\nlet eventAbsolutePosition (e : #mouseEvent t) =\n  Optdef.case\n    e##.pageX\n    (fun () -> eventAbsolutePosition' e)\n    (fun x ->\n      Optdef.case\n        e##.pageY\n        (fun () -> eventAbsolutePosition' e)\n        (fun y -> Js.to_float x, Js.to_float y))\n\nlet elementClientPosition (e : #element t) =\n  let r = e##getBoundingClientRect in\n  let body = document##.body in\n  let html = document##.documentElement in\n  ( truncate (Js.to_float r##.left) - body##.clientLeft - html##.clientLeft\n  , truncate (Js.to_float r##.top) - body##.clientTop - html##.clientTop )\n\nlet getDocumentScroll () =\n  let body = document##.body in\n  let html = document##.documentElement in\n  ( Js.to_float body##.scrollLeft +. Js.to_float html##.scrollLeft\n  , Js.to_float body##.scrollTop +. Js.to_float html##.scrollTop )\n\nlet buttonPressed (ev : #mouseEvent Js.t) =\n  Js.Optdef.case\n    ev##.which\n    (fun () ->\n      match ev##.button with\n      | 1 -> Left_button\n      | 2 -> Right_button\n      | 4 -> Middle_button\n      | _ -> No_button)\n    (fun x -> x)\n\nlet addMousewheelEventListenerWithOptions e ?capture ?once ?passive h =\n  addEventListenerWithOptions\n    ?capture\n    ?once\n    ?passive\n    e\n    Event.wheel\n    (handler (fun (e : mousewheelEvent t) ->\n         let dx = -Optdef.get e##.wheelDeltaX (fun () -> 0) / 40 in\n         let dy = -Optdef.get e##.wheelDeltaY (fun () -> e##.wheelDelta) / 40 in\n         h (e :> mouseEvent t) ~dx ~dy))\n\nlet addMousewheelEventListener e h capt =\n  addMousewheelEventListenerWithOptions ~capture:capt e h\n\n(*****)\n\nmodule Keyboard_code = struct\n  type t =\n    | Unidentified\n    (* Alphabetic Characters *)\n    | KeyA\n    | KeyB\n    | KeyC\n    | KeyD\n    | KeyE\n    | KeyF\n    | KeyG\n    | KeyH\n    | KeyI\n    | KeyJ\n    | KeyK\n    | KeyL\n    | KeyM\n    | KeyN\n    | KeyO\n    | KeyP\n    | KeyQ\n    | KeyR\n    | KeyS\n    | KeyT\n    | KeyU\n    | KeyV\n    | KeyW\n    | KeyX\n    | KeyY\n    | KeyZ\n    (* Digits *)\n    | Digit0\n    | Digit1\n    | Digit2\n    | Digit3\n    | Digit4\n    | Digit5\n    | Digit6\n    | Digit7\n    | Digit8\n    | Digit9\n    | Minus\n    | Equal\n    (* Whitespace *)\n    | Tab\n    | Enter\n    | Space\n    (* Editing *)\n    | Escape\n    | Backspace\n    | Insert\n    | Delete\n    | CapsLock\n    (* Misc Printable *)\n    | BracketLeft\n    | BracketRight\n    | Semicolon\n    | Quote\n    | Backquote\n    | Backslash\n    | Comma\n    | Period\n    | Slash\n    (* Function keys *)\n    | F1\n    | F2\n    | F3\n    | F4\n    | F5\n    | F6\n    | F7\n    | F8\n    | F9\n    | F10\n    | F11\n    | F12\n    (* Numpad keys *)\n    | Numpad0\n    | Numpad1\n    | Numpad2\n    | Numpad3\n    | Numpad4\n    | Numpad5\n    | Numpad6\n    | Numpad7\n    | Numpad8\n    | Numpad9\n    | NumpadMultiply\n    | NumpadSubtract\n    | NumpadAdd\n    | NumpadDecimal\n    | NumpadEqual\n    | NumpadEnter\n    | NumpadDivide\n    | NumLock\n    (* Modifier keys *)\n    | ControlLeft\n    | ControlRight\n    | MetaLeft\n    | MetaRight\n    | ShiftLeft\n    | ShiftRight\n    | AltLeft\n    | AltRight\n    (* Arrow keys *)\n    | ArrowLeft\n    | ArrowRight\n    | ArrowUp\n    | ArrowDown\n    (* Navigation *)\n    | PageUp\n    | PageDown\n    | Home\n    | End\n    (* Sound *)\n    | VolumeMute\n    | VolumeDown\n    | VolumeUp\n    (* Media *)\n    | MediaTrackPrevious\n    | MediaTrackNext\n    | MediaPlayPause\n    | MediaStop\n    (* Browser special *)\n    | ContextMenu\n    | BrowserSearch\n    | BrowserHome\n    | BrowserFavorites\n    | BrowserRefresh\n    | BrowserStop\n    | BrowserForward\n    | BrowserBack\n    (* Misc *)\n    | OSLeft\n    | OSRight\n    | ScrollLock\n    | PrintScreen\n    | IntlBackslash\n    | IntlYen\n    | Pause\n\n  let try_code v =\n    match Js.to_string v with\n    (* Alphabetic Characters *)\n    | \"KeyA\" -> KeyA\n    | \"KeyB\" -> KeyB\n    | \"KeyC\" -> KeyC\n    | \"KeyD\" -> KeyD\n    | \"KeyE\" -> KeyE\n    | \"KeyF\" -> KeyF\n    | \"KeyG\" -> KeyG\n    | \"KeyH\" -> KeyH\n    | \"KeyI\" -> KeyI\n    | \"KeyJ\" -> KeyJ\n    | \"KeyK\" -> KeyK\n    | \"KeyL\" -> KeyL\n    | \"KeyM\" -> KeyM\n    | \"KeyN\" -> KeyN\n    | \"KeyO\" -> KeyO\n    | \"KeyP\" -> KeyP\n    | \"KeyQ\" -> KeyQ\n    | \"KeyR\" -> KeyR\n    | \"KeyS\" -> KeyS\n    | \"KeyT\" -> KeyT\n    | \"KeyU\" -> KeyU\n    | \"KeyV\" -> KeyV\n    | \"KeyW\" -> KeyW\n    | \"KeyX\" -> KeyX\n    | \"KeyY\" -> KeyY\n    | \"KeyZ\" -> KeyZ\n    (* Digits *)\n    | \"Digit0\" -> Digit0\n    | \"Digit1\" -> Digit1\n    | \"Digit2\" -> Digit2\n    | \"Digit3\" -> Digit3\n    | \"Digit4\" -> Digit4\n    | \"Digit5\" -> Digit5\n    | \"Digit6\" -> Digit6\n    | \"Digit7\" -> Digit7\n    | \"Digit8\" -> Digit8\n    | \"Digit9\" -> Digit9\n    | \"Minus\" -> Minus\n    | \"Equal\" -> Equal\n    (* Whitespace *)\n    | \"Tab\" -> Tab\n    | \"Enter\" -> Enter\n    | \"Space\" -> Space\n    (* Editing *)\n    | \"Escape\" -> Escape\n    | \"Backspace\" -> Backspace\n    | \"Insert\" -> Insert\n    | \"Delete\" -> Delete\n    | \"CapsLock\" -> CapsLock\n    (* Misc Printable *)\n    | \"BracketLeft\" -> BracketLeft\n    | \"BracketRight\" -> BracketRight\n    | \"Semicolon\" -> Semicolon\n    | \"Quote\" -> Quote\n    | \"Backquote\" -> Backquote\n    | \"Backslash\" -> Backslash\n    | \"Comma\" -> Comma\n    | \"Period\" -> Period\n    | \"Slash\" -> Slash\n    (* Function keys *)\n    | \"F1\" -> F1\n    | \"F2\" -> F2\n    | \"F3\" -> F3\n    | \"F4\" -> F4\n    | \"F5\" -> F5\n    | \"F6\" -> F6\n    | \"F7\" -> F7\n    | \"F8\" -> F8\n    | \"F9\" -> F9\n    | \"F10\" -> F10\n    | \"F11\" -> F11\n    | \"F12\" -> F12\n    (* Numpad keys *)\n    | \"Numpad0\" -> Numpad0\n    | \"Numpad1\" -> Numpad1\n    | \"Numpad2\" -> Numpad2\n    | \"Numpad3\" -> Numpad3\n    | \"Numpad4\" -> Numpad4\n    | \"Numpad5\" -> Numpad5\n    | \"Numpad6\" -> Numpad6\n    | \"Numpad7\" -> Numpad7\n    | \"Numpad8\" -> Numpad8\n    | \"Numpad9\" -> Numpad9\n    | \"NumpadMultiply\" -> NumpadMultiply\n    | \"NumpadSubtract\" -> NumpadSubtract\n    | \"NumpadAdd\" -> NumpadAdd\n    | \"NumpadDecimal\" -> NumpadDecimal\n    | \"NumpadEqual\" -> NumpadEqual\n    | \"NumpadEnter\" -> NumpadEnter\n    | \"NumpadDivide\" -> NumpadDivide\n    | \"NumLock\" -> NumLock\n    (* Modifier keys *)\n    | \"ControlLeft\" -> ControlLeft\n    | \"ControlRight\" -> ControlRight\n    | \"MetaLeft\" -> MetaLeft\n    | \"MetaRight\" -> MetaRight\n    | \"ShiftLeft\" -> ShiftLeft\n    | \"ShiftRight\" -> ShiftRight\n    | \"AltLeft\" -> AltLeft\n    | \"AltRight\" -> AltRight\n    (* Arrow keys *)\n    | \"ArrowLeft\" -> ArrowLeft\n    | \"ArrowRight\" -> ArrowRight\n    | \"ArrowUp\" -> ArrowUp\n    | \"ArrowDown\" -> ArrowDown\n    (* Navigation *)\n    | \"PageUp\" -> PageUp\n    | \"PageDown\" -> PageDown\n    | \"Home\" -> Home\n    | \"End\" -> End\n    (* Sound *)\n    | \"VolumeMute\" -> VolumeMute\n    | \"VolumeDown\" -> VolumeDown\n    | \"VolumeUp\" -> VolumeUp\n    (* Media *)\n    | \"MediaTrackPrevious\" -> MediaTrackPrevious\n    | \"MediaTrackNext\" -> MediaTrackNext\n    | \"MediaPlayPause\" -> MediaPlayPause\n    | \"MediaStop\" -> MediaStop\n    (* Browser special *)\n    | \"ContextMenu\" -> ContextMenu\n    | \"BrowserSearch\" -> BrowserSearch\n    | \"BrowserHome\" -> BrowserHome\n    | \"BrowserFavorites\" -> BrowserFavorites\n    | \"BrowserRefresh\" -> BrowserRefresh\n    | \"BrowserStop\" -> BrowserStop\n    | \"BrowserForward\" -> BrowserForward\n    | \"BrowserBack\" -> BrowserBack\n    (* Misc *)\n    | \"OSLeft\" -> OSLeft\n    | \"OSRight\" -> OSRight\n    | \"ScrollLock\" -> ScrollLock\n    | \"PrintScreen\" -> PrintScreen\n    | \"IntlBackslash\" -> IntlBackslash\n    | \"IntlYen\" -> IntlYen\n    | \"Pause\" -> Pause\n    | _ -> Unidentified\n\n  let try_key_code_left = function\n    | 16 -> ShiftLeft\n    | 17 -> ControlLeft\n    | 18 -> AltLeft\n    | 91 -> MetaLeft\n    | _ -> Unidentified\n\n  let try_key_code_right = function\n    | 16 -> ShiftRight\n    | 17 -> ControlRight\n    | 18 -> AltRight\n    | 91 -> MetaRight\n    | _ -> Unidentified\n\n  let try_key_code_numpad = function\n    | 46 -> NumpadDecimal\n    | 45 -> Numpad0\n    | 35 -> Numpad1\n    | 40 -> Numpad2\n    | 34 -> Numpad3\n    | 37 -> Numpad4\n    | 12 -> Numpad5\n    | 39 -> Numpad6\n    | 36 -> Numpad7\n    | 38 -> Numpad8\n    | 33 -> Numpad9\n    | 13 -> NumpadEnter\n    | 111 -> NumpadDivide\n    | 107 -> NumpadAdd\n    | 109 -> NumpadSubtract\n    | 106 -> NumpadMultiply\n    | 110 -> NumpadDecimal\n    | 96 -> Numpad0\n    | 97 -> Numpad1\n    | 98 -> Numpad2\n    | 99 -> Numpad3\n    | 100 -> Numpad4\n    | 101 -> Numpad5\n    | 102 -> Numpad6\n    | 103 -> Numpad7\n    | 104 -> Numpad8\n    | 105 -> Numpad9\n    | _ -> Unidentified\n\n  let try_key_code_normal = function\n    | 27 -> Escape\n    | 112 -> F1\n    | 113 -> F2\n    | 114 -> F3\n    | 115 -> F4\n    | 116 -> F5\n    | 117 -> F6\n    | 118 -> F7\n    | 119 -> F8\n    | 120 -> F9\n    | 121 -> F10\n    | 122 -> F11\n    | 123 -> F12\n    | 42 -> PrintScreen\n    | 145 -> ScrollLock\n    | 19 -> Pause\n    | 192 -> Backquote\n    | 49 -> Digit1\n    | 50 -> Digit2\n    | 51 -> Digit3\n    | 52 -> Digit4\n    | 53 -> Digit5\n    | 54 -> Digit6\n    | 55 -> Digit7\n    | 56 -> Digit8\n    | 57 -> Digit9\n    | 48 -> Digit0\n    | 189 -> Minus\n    | 187 -> Equal\n    | 8 -> Backspace\n    | 9 -> Tab\n    | 81 -> KeyQ\n    | 87 -> KeyW\n    | 69 -> KeyE\n    | 82 -> KeyR\n    | 84 -> KeyT\n    | 89 -> KeyY\n    | 85 -> KeyU\n    | 73 -> KeyI\n    | 79 -> KeyO\n    | 80 -> KeyP\n    | 219 -> BracketLeft\n    | 221 -> BracketRight\n    | 220 -> Backslash\n    | 20 -> CapsLock\n    | 65 -> KeyA\n    | 83 -> KeyS\n    | 68 -> KeyD\n    | 70 -> KeyF\n    | 71 -> KeyG\n    | 72 -> KeyH\n    | 74 -> KeyJ\n    | 75 -> KeyK\n    | 76 -> KeyL\n    | 186 -> Semicolon\n    | 222 -> Quote\n    | 13 -> Enter\n    | 90 -> KeyZ\n    | 88 -> KeyX\n    | 67 -> KeyC\n    | 86 -> KeyV\n    | 66 -> KeyB\n    | 78 -> KeyN\n    | 77 -> KeyM\n    | 188 -> Comma\n    | 190 -> Period\n    | 191 -> Slash\n    | 32 -> Space\n    | 93 -> ContextMenu\n    | 45 -> Insert\n    | 36 -> Home\n    | 33 -> PageUp\n    | 46 -> Delete\n    | 35 -> End\n    | 34 -> PageDown\n    | 37 -> ArrowLeft\n    | 40 -> ArrowDown\n    | 39 -> ArrowRight\n    | 38 -> ArrowUp\n    | _ -> Unidentified\n\n  let make_unidentified _ = Unidentified\n\n  let try_next value f = function\n    | Unidentified -> Optdef.case value make_unidentified f\n    | v -> v\n\n  let run_next value f = function\n    | Unidentified -> f value\n    | v -> v\n\n  let get_key_code evt = evt##.keyCode\n\n  let try_key_location evt =\n    match evt##.location with\n    | 1 -> run_next (get_key_code evt) try_key_code_left\n    | 2 -> run_next (get_key_code evt) try_key_code_right\n    | 3 -> run_next (get_key_code evt) try_key_code_numpad\n    | _ -> fun v -> v\n\n  let ( |> ) x f = f x\n\n  let of_event evt =\n    Unidentified\n    |> try_next evt##.code try_code\n    |> try_key_location evt\n    |> run_next (get_key_code evt) try_key_code_normal\n\n  let of_key_code = try_key_code_normal\nend\n\nmodule Keyboard_key = struct\n  type t = Uchar.t option\n\n  let char_of_int value =\n    if 0 < value then try Some (Uchar.of_int value) with _ -> None else None\n\n  let empty_string _ = Js.string \"\"\n\n  let none _ = None\n\n  let of_event evt =\n    let key = Optdef.get evt##.key empty_string in\n    match key##.length with\n    | 0 -> Optdef.case evt##.charCode none char_of_int\n    | 1 -> char_of_int (int_of_float (Js.to_float (key##charCodeAt 0)))\n    | _ -> None\nend\n\n(*****)\n\nlet element : #Dom.element t -> element t = Js.Unsafe.coerce\n\ntype taggedElement =\n  | A of anchorElement t\n  | Area of areaElement t\n  | Audio of audioElement t\n  | Base of baseElement t\n  | Blockquote of quoteElement t\n  | Body of bodyElement t\n  | Br of brElement t\n  | Button of buttonElement t\n  | Canvas of canvasElement t\n  | Caption of tableCaptionElement t\n  | Col of tableColElement t\n  | Colgroup of tableColElement t\n  | Del of modElement t\n  | Dialog of dialogElement t\n  | Div of divElement t\n  | Dl of dListElement t\n  | Embed of embedElement t\n  | Fieldset of fieldSetElement t\n  | Form of formElement t\n  | Frameset of frameSetElement t\n  | Frame of frameElement t\n  | H1 of headingElement t\n  | H2 of headingElement t\n  | H3 of headingElement t\n  | H4 of headingElement t\n  | H5 of headingElement t\n  | H6 of headingElement t\n  | Head of headElement t\n  | Hr of hrElement t\n  | Html of htmlElement t\n  | Iframe of iFrameElement t\n  | Img of imageElement t\n  | Input of inputElement t\n  | Ins of modElement t\n  | Label of labelElement t\n  | Legend of legendElement t\n  | Li of liElement t\n  | Link of linkElement t\n  | Map of mapElement t\n  | Meta of metaElement t\n  | Object of objectElement t\n  | Ol of oListElement t\n  | Optgroup of optGroupElement t\n  | Option of optionElement t\n  | P of paragraphElement t\n  | Param of paramElement t\n  | Pre of preElement t\n  | Q of quoteElement t\n  | Script of scriptElement t\n  | Select of selectElement t\n  | Style of styleElement t\n  | Table of tableElement t\n  | Tbody of tableSectionElement t\n  | Td of tableCellElement t\n  | Textarea of textAreaElement t\n  | Tfoot of tableSectionElement t\n  | Th of tableCellElement t\n  | Thead of tableSectionElement t\n  | Title of titleElement t\n  | Tr of tableRowElement t\n  | Ul of uListElement t\n  | Video of videoElement t\n  | Other of element t\n\nlet other e = Other (e : #element t :> element t)\n\nlet tagged (e : #element t) =\n  let tag = Js.to_bytestring e##.tagName##toLowerCase in\n  if String.length tag = 0\n  then other e\n  else\n    match String.unsafe_get tag 0 with\n    | 'a' -> (\n        match tag with\n        | \"a\" -> A (Js.Unsafe.coerce e)\n        | \"area\" -> Area (Js.Unsafe.coerce e)\n        | \"audio\" -> Audio (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'b' -> (\n        match tag with\n        | \"base\" -> Base (Js.Unsafe.coerce e)\n        | \"blockquote\" -> Blockquote (Js.Unsafe.coerce e)\n        | \"body\" -> Body (Js.Unsafe.coerce e)\n        | \"br\" -> Br (Js.Unsafe.coerce e)\n        | \"button\" -> Button (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'c' -> (\n        match tag with\n        | \"canvas\" -> Canvas (Js.Unsafe.coerce e)\n        | \"caption\" -> Caption (Js.Unsafe.coerce e)\n        | \"col\" -> Col (Js.Unsafe.coerce e)\n        | \"colgroup\" -> Colgroup (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'd' -> (\n        match tag with\n        | \"del\" -> Del (Js.Unsafe.coerce e)\n        | \"div\" -> Div (Js.Unsafe.coerce e)\n        | \"dl\" -> Dl (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'e' -> (\n        match tag with\n        | \"embed\" -> Embed (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'f' -> (\n        match tag with\n        | \"fieldset\" -> Fieldset (Js.Unsafe.coerce e)\n        | \"form\" -> Form (Js.Unsafe.coerce e)\n        | \"frameset\" -> Frameset (Js.Unsafe.coerce e)\n        | \"frame\" -> Frame (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'h' -> (\n        match tag with\n        | \"h1\" -> H1 (Js.Unsafe.coerce e)\n        | \"h2\" -> H2 (Js.Unsafe.coerce e)\n        | \"h3\" -> H3 (Js.Unsafe.coerce e)\n        | \"h4\" -> H4 (Js.Unsafe.coerce e)\n        | \"h5\" -> H5 (Js.Unsafe.coerce e)\n        | \"h6\" -> H6 (Js.Unsafe.coerce e)\n        | \"head\" -> Head (Js.Unsafe.coerce e)\n        | \"hr\" -> Hr (Js.Unsafe.coerce e)\n        | \"html\" -> Html (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'i' -> (\n        match tag with\n        | \"iframe\" -> Iframe (Js.Unsafe.coerce e)\n        | \"img\" -> Img (Js.Unsafe.coerce e)\n        | \"input\" -> Input (Js.Unsafe.coerce e)\n        | \"ins\" -> Ins (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'l' -> (\n        match tag with\n        | \"label\" -> Label (Js.Unsafe.coerce e)\n        | \"legend\" -> Legend (Js.Unsafe.coerce e)\n        | \"li\" -> Li (Js.Unsafe.coerce e)\n        | \"link\" -> Link (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'm' -> (\n        match tag with\n        | \"map\" -> Map (Js.Unsafe.coerce e)\n        | \"meta\" -> Meta (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'o' -> (\n        match tag with\n        | \"object\" -> Object (Js.Unsafe.coerce e)\n        | \"ol\" -> Ol (Js.Unsafe.coerce e)\n        | \"optgroup\" -> Optgroup (Js.Unsafe.coerce e)\n        | \"option\" -> Option (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'p' -> (\n        match tag with\n        | \"p\" -> P (Js.Unsafe.coerce e)\n        | \"param\" -> Param (Js.Unsafe.coerce e)\n        | \"pre\" -> Pre (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'q' -> (\n        match tag with\n        | \"q\" -> Q (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 's' -> (\n        match tag with\n        | \"script\" -> Script (Js.Unsafe.coerce e)\n        | \"select\" -> Select (Js.Unsafe.coerce e)\n        | \"style\" -> Style (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 't' -> (\n        match tag with\n        | \"table\" -> Table (Js.Unsafe.coerce e)\n        | \"tbody\" -> Tbody (Js.Unsafe.coerce e)\n        | \"td\" -> Td (Js.Unsafe.coerce e)\n        | \"textarea\" -> Textarea (Js.Unsafe.coerce e)\n        | \"tfoot\" -> Tfoot (Js.Unsafe.coerce e)\n        | \"th\" -> Th (Js.Unsafe.coerce e)\n        | \"thead\" -> Thead (Js.Unsafe.coerce e)\n        | \"title\" -> Title (Js.Unsafe.coerce e)\n        | \"tr\" -> Tr (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'u' -> (\n        match tag with\n        | \"ul\" -> Ul (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | 'v' -> (\n        match tag with\n        | \"video\" -> Video (Js.Unsafe.coerce e)\n        | _ -> other e)\n    | _ -> other e\n\nlet opt_tagged e = Opt.case e (fun () -> None) (fun e -> Some (tagged e))\n\ntype taggedEvent =\n  | MouseEvent of mouseEvent t\n  | KeyboardEvent of keyboardEvent t\n  | MessageEvent of messageEvent t\n  | MousewheelEvent of mousewheelEvent t\n  | MouseScrollEvent of mouseScrollEvent t\n  | PopStateEvent of popStateEvent t\n  | OtherEvent of event t\n\nlet taggedEvent (ev : #event Js.t) =\n  Js.Opt.case\n    (CoerceTo.mouseEvent ev)\n    (fun () ->\n      Js.Opt.case\n        (CoerceTo.keyboardEvent ev)\n        (fun () ->\n          Js.Opt.case\n            (CoerceTo.wheelEvent ev)\n            (fun () ->\n              Js.Opt.case\n                (CoerceTo.mouseScrollEvent ev)\n                (fun () ->\n                  Js.Opt.case\n                    (CoerceTo.popStateEvent ev)\n                    (fun () ->\n                      Js.Opt.case\n                        (CoerceTo.messageEvent ev)\n                        (fun () -> OtherEvent (ev :> event t))\n                        (fun ev -> MessageEvent ev))\n                    (fun ev -> PopStateEvent ev))\n                (fun ev -> MouseScrollEvent ev))\n            (fun ev -> MousewheelEvent ev))\n        (fun ev -> KeyboardEvent ev))\n    (fun ev -> MouseEvent ev)\n\nlet opt_taggedEvent ev = Opt.case ev (fun () -> None) (fun ev -> Some (taggedEvent ev))\n\nlet stopPropagation ev =\n  let e = Js.Unsafe.coerce ev in\n  Optdef.case\n    e##.stopPropagation\n    (fun () -> e##.cancelBubble := Js._true)\n    (fun _ -> e##_stopPropagation)\n\nlet _requestAnimationFrame : (unit -> unit) Js.callback -> unit =\n  Js.Unsafe.pure_expr (fun _ ->\n      let w = Js.Unsafe.coerce window in\n      let l =\n        [ w##.requestAnimationFrame\n        ; w##.mozRequestAnimationFrame\n        ; w##.webkitRequestAnimationFrame\n        ; w##.oRequestAnimationFrame\n        ; w##.msRequestAnimationFrame\n        ]\n      in\n      try\n        let req = List.find (fun c -> Js.Optdef.test c) l in\n        fun callback -> Js.Unsafe.fun_call req [| Js.Unsafe.inject callback |]\n      with Not_found ->\n        let now () = Js.to_float (new%js Js.date_now)##getTime in\n        let last = ref (now ()) in\n        fun callback ->\n          let t = now () in\n          let dt = !last +. (1000. /. 60.) -. t in\n          let dt = if Poly.(dt < 0.) then 0. else dt in\n          last := t;\n          ignore (window##setTimeout callback (Js.float dt)))\n\n(****)\n\nlet hasPushState () = Js.Optdef.test (Js.Unsafe.coerce window##.history)##.pushState\n\nlet hasPlaceholder () =\n  let i = createInput document in\n  Js.Optdef.test (Js.Unsafe.coerce i)##.placeholder\n\nlet hasRequired () =\n  let i = createInput document in\n  Js.Optdef.test (Js.Unsafe.coerce i)##.required\n\nlet overflow_limit = 2147483_000.\n\n(* ms *)\n\ntype timeout_id_safe = timeout_id option ref\n\nlet setTimeout callback d : timeout_id_safe =\n  let id = ref None in\n  let rec loop d () =\n    let step, remain =\n      if Poly.(d > overflow_limit) then overflow_limit, d -. overflow_limit else d, 0.\n    in\n    let cb = if Poly.(remain = 0.) then callback else loop remain in\n    id := Some (window##setTimeout (Js.wrap_callback cb) (Js.float step))\n  in\n  loop d ();\n  id\n\nlet clearTimeout (id : timeout_id_safe) =\n  match !id with\n  | None -> ()\n  | Some x ->\n      id := None;\n      window##clearTimeout x\n\nlet js_array_of_collection (c : #element collection Js.t) : #element Js.t Js.js_array Js.t\n    =\n  Js.Unsafe.(meth_call (js_expr \"[].slice\") \"call\" [| inject c |])\n","(* Js_of_ocaml library\n * http://www.ocsigen.org/js_of_ocaml/\n * Copyright (C) 2010 Jérôme Vouillon\n * Laboratoire PPS - CNRS Université Paris Diderot\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, with linking exception;\n * either version 2.1 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *)\n\nopen Js\nopen! Import\n\nclass type console = object\n  method log : _ -> unit meth\n\n  method log_2 : _ -> _ -> unit meth\n\n  method log_3 : _ -> _ -> _ -> unit meth\n\n  method log_4 : _ -> _ -> _ -> _ -> unit meth\n\n  method log_5 : _ -> _ -> _ -> _ -> _ -> unit meth\n\n  method log_6 : _ -> _ -> _ -> _ -> _ -> _ -> unit meth\n\n  method log_7 : _ -> _ -> _ -> _ -> _ -> _ -> _ -> unit meth\n\n  method log_8 : _ -> _ -> _ -> _ -> _ -> _ -> _ -> _ -> unit meth\n\n  method debug : _ -> unit meth\n\n  method debug_2 : _ -> _ -> unit meth\n\n  method debug_3 : _ -> _ -> _ -> unit meth\n\n  method debug_4 : _ -> _ -> _ -> _ -> unit meth\n\n  method debug_5 : _ -> _ -> _ -> _ -> _ -> unit meth\n\n  method info : _ -> unit meth\n\n  method info_2 : _ -> _ -> unit meth\n\n  method info_3 : _ -> _ -> _ -> unit meth\n\n  method info_4 : _ -> _ -> _ -> _ -> unit meth\n\n  method info_5 : _ -> _ -> _ -> _ -> _ -> unit meth\n\n  method warn : _ -> unit meth\n\n  method warn_2 : _ -> _ -> unit meth\n\n  method warn_3 : _ -> _ -> _ -> unit meth\n\n  method warn_4 : _ -> _ -> _ -> _ -> unit meth\n\n  method warn_5 : _ -> _ -> _ -> _ -> _ -> unit meth\n\n  method error : _ -> unit meth\n\n  method error_2 : _ -> _ -> unit meth\n\n  method error_3 : _ -> _ -> _ -> unit meth\n\n  method error_4 : _ -> _ -> _ -> _ -> unit meth\n\n  method error_5 : _ -> _ -> _ -> _ -> _ -> unit meth\n\n  method assert_ : bool t -> unit meth\n\n  method assert_1 : bool t -> _ -> unit meth\n\n  method assert_2 : bool t -> _ -> _ -> unit meth\n\n  method assert_3 : bool t -> _ -> _ -> _ -> unit meth\n\n  method assert_4 : bool t -> _ -> _ -> _ -> _ -> unit meth\n\n  method assert_5 : bool t -> _ -> _ -> _ -> _ -> _ -> unit meth\n\n  method dir : _ -> unit meth\n\n  method dirxml : Dom.node t -> unit meth\n\n  method trace : unit meth\n\n  method group : _ -> unit meth\n\n  method group_2 : _ -> _ -> unit meth\n\n  method group_3 : _ -> _ -> _ -> unit meth\n\n  method group_4 : _ -> _ -> _ -> _ -> unit meth\n\n  method group_5 : _ -> _ -> _ -> _ -> _ -> unit meth\n\n  method groupCollapsed : _ -> unit meth\n\n  method groupCollapsed_2 : _ -> _ -> unit meth\n\n  method groupCollapsed_3 : _ -> _ -> _ -> unit meth\n\n  method groupCollapsed_4 : _ -> _ -> _ -> _ -> unit meth\n\n  method groupCollapsed_5 : _ -> _ -> _ -> _ -> _ -> unit meth\n\n  method groupEnd : unit meth\n\n  method time : js_string t -> unit meth\n\n  method timeEnd : js_string t -> unit meth\nend\n\nexternal get_console : unit -> console t = \"caml_js_get_console\"\n\nlet console = get_console ()\n","(* This file is part of Lwt, released under the MIT license. See LICENSE.md for\n   details, or visit https://github.com/ocsigen/lwt/blob/master/LICENSE.md. *)\n\n\n\nexception Empty\n\ntype 'a t = {\n  mutable prev : 'a t;\n  mutable next : 'a t;\n}\n\ntype 'a node = {\n  node_prev : 'a t;\n  node_next : 'a t;\n  mutable node_data : 'a;\n  mutable node_active : bool;\n}\n\nexternal seq_of_node : 'a node -> 'a t = \"%identity\"\nexternal node_of_seq : 'a t -> 'a node = \"%identity\"\n\n(* +-----------------------------------------------------------------+\n   | Operations on nodes                                             |\n   +-----------------------------------------------------------------+ *)\n\nlet get node =\n  node.node_data\n\nlet set node data =\n  node.node_data <- data\n\nlet remove node =\n  if node.node_active then begin\n    node.node_active <- false;\n    let seq = seq_of_node node in\n    seq.prev.next <- seq.next;\n    seq.next.prev <- seq.prev\n  end\n\n(* +-----------------------------------------------------------------+\n   | Operations on sequences                                         |\n   +-----------------------------------------------------------------+ *)\n\nlet create () =\n  let rec seq = { prev = seq; next = seq } in\n  seq\n\nlet clear seq =\n  seq.prev <- seq;\n  seq.next <- seq\n\nlet is_empty seq = seq.next == seq\n\nlet length seq =\n  let rec loop curr len =\n    if curr == seq then\n      len\n    else\n      let node = node_of_seq curr in loop node.node_next (len + 1)\n  in\n  loop seq.next 0\n\nlet add_l data seq =\n  let node = { node_prev = seq; node_next = seq.next; node_data = data; node_active = true } in\n  seq.next.prev <- seq_of_node node;\n  seq.next <- seq_of_node node;\n  node\n\nlet add_r data seq =\n  let node = { node_prev = seq.prev; node_next = seq; node_data = data; node_active = true } in\n  seq.prev.next <- seq_of_node node;\n  seq.prev <- seq_of_node node;\n  node\n\nlet take_l seq =\n  if is_empty seq then\n    raise Empty\n  else begin\n    let node = node_of_seq seq.next in\n    remove node;\n    node.node_data\n  end\n\nlet take_r seq =\n  if is_empty seq then\n    raise Empty\n  else begin\n    let node = node_of_seq seq.prev in\n    remove node;\n    node.node_data\n  end\n\nlet take_opt_l seq =\n  if is_empty seq then\n    None\n  else begin\n    let node = node_of_seq seq.next in\n    remove node;\n    Some node.node_data\n  end\n\nlet take_opt_r seq =\n  if is_empty seq then\n    None\n  else begin\n    let node = node_of_seq seq.prev in\n    remove node;\n    Some node.node_data\n  end\n\nlet transfer_l s1 s2 =\n  s2.next.prev <- s1.prev;\n  s1.prev.next <- s2.next;\n  s2.next <- s1.next;\n  s1.next.prev <- s2;\n  s1.prev <- s1;\n  s1.next <- s1\n\nlet transfer_r s1 s2 =\n  s2.prev.next <- s1.next;\n  s1.next.prev <- s2.prev;\n  s2.prev <- s1.prev;\n  s1.prev.next <- s2;\n  s1.prev <- s1;\n  s1.next <- s1\n\nlet iter_l f seq =\n  let rec loop curr =\n    if curr != seq then begin\n      let node = node_of_seq curr in\n      if node.node_active then f node.node_data;\n      loop node.node_next\n    end\n  in\n  loop seq.next\n\nlet iter_r f seq =\n  let rec loop curr =\n    if curr != seq then begin\n      let node = node_of_seq curr in\n      if node.node_active then f node.node_data;\n      loop node.node_prev\n    end\n  in\n  loop seq.prev\n\nlet iter_node_l f seq =\n  let rec loop curr =\n    if curr != seq then begin\n      let node = node_of_seq curr in\n      if node.node_active then f node;\n      loop node.node_next\n    end\n  in\n  loop seq.next\n\nlet iter_node_r f seq =\n  let rec loop curr =\n    if curr != seq then begin\n      let node = node_of_seq curr in\n      if node.node_active then f node;\n      loop node.node_prev\n    end\n  in\n  loop seq.prev\n\nlet fold_l f seq acc =\n  let rec loop curr acc =\n    if curr == seq then\n      acc\n    else\n      let node = node_of_seq curr in\n      if node.node_active then\n        loop node.node_next (f node.node_data acc)\n      else\n        loop node.node_next acc\n  in\n  loop seq.next acc\n\nlet fold_r f seq acc =\n  let rec loop curr acc =\n    if curr == seq then\n      acc\n    else\n      let node = node_of_seq curr in\n      if node.node_active then\n        loop node.node_prev (f node.node_data acc)\n      else\n        loop node.node_prev acc\n  in\n  loop seq.prev acc\n\nlet find_node_l f seq =\n  let rec loop curr =\n    if curr != seq then\n      let node = node_of_seq curr in\n      if node.node_active then\n        if f node.node_data then\n          node\n        else\n          loop node.node_next\n      else\n        loop node.node_next\n    else\n      raise Not_found\n  in\n  loop seq.next\n\nlet find_node_r f seq =\n  let rec loop curr =\n    if curr != seq then\n      let node = node_of_seq curr in\n      if node.node_active then\n        if f node.node_data then\n          node\n        else\n          loop node.node_prev\n      else\n        loop node.node_prev\n    else\n      raise Not_found\n  in\n  loop seq.prev\n\nlet find_node_opt_l f seq =\n  try Some (find_node_l f seq) with Not_found -> None\n\nlet find_node_opt_r f seq =\n  try Some (find_node_r f seq) with Not_found -> None\n","(* This file is part of Lwt, released under the MIT license. See LICENSE.md for\n   details, or visit https://github.com/ocsigen/lwt/blob/master/LICENSE.md. *)\n\n\n\n(* Reading guide\n\n   Welcome to the implementation of the Lwt core! This is a big file, but we\n   hope that reading it (parts at a time!) will not be scary :) Here is why:\n\n\n   * Sectioning\n\n   The code is broken up into sections, each one of which is an internal module.\n   Most of the modules have a signature, which serves as a neat table of\n   contents.\n\n   It is recommended that you read this file with code folding enabled. If you\n   fold all the modules, you can visualize the logical structure of Lwt quite\n   easily. You can then expand modules as needed, depending on what part of the\n   implementation you are interested in. Without code folding, you face an\n   intimidating wall of code :( You can still visually parse the file, however,\n   because there are plenty of blank lines to help section things off. You can\n   also view this file folded online:\n\n     https://gist.github.com/aantron/9fab0bdead98a60fccf06e0189186863\n     https://gist.github.com/aantron/97b58520d5bb4858ccac6f54700a24d7\n\n   The signatures are unusual: big comments are absent. They are moved into the\n   modules, so that they are hidden by code folding when you (the reader!) are\n   not interested in those modules.\n\n\n   * Documentation\n\n   The documentation begins with an overview of major concepts and components.\n   This overview puts everything into context. You don't have to read the whole\n   thing. The overview begins with basic concepts, moves on to advanced ones,\n   and then gets into the truly esoteric. You can read about each concept on an\n   as-needed basis. However, once you have read the whole overview, you will be\n   aware of *everything* that is needed to understand, and work with, the core\n   of Lwt.\n\n   Littered in the code are additional comments, that go in-depth on various\n   local implementation details, opportunities, regrets, and the like.\n\n   The sections (modules) of the code correspond closely to sections of the\n   overview.\n\n\n   * Whitespace\n\n   The total line count of this file may seem frightening, but one third of it\n   is whitespace and comments, both there to help you read the remaining two\n   thirds!\n\n   Also, within those two thirds, there are large groups of functions that are\n   repetitive and formulaic, so there is much less conceptually-unique code in\n   Lwt than you might think at first.\n\n\n   * Please edit the code and the docs!\n\n   This code is meant to be readable, and to be edited. If you are reading\n   something, and think there is a better way to express it, please go ahead and\n   open a pull request to the Lwt repository at\n\n     https://github.com/ocsigen/lwt\n\n   Even if your pull request somehow doesn't get merged, you will have educated\n   the maintainers, not to mention other contributors, and users. This is true\n   even if the change is trivial -- sometimes, maintainers just need to be\n   educated multiple times before they see the wisdom of it :/\n\n   Likewise, if you would like to make a code contribution to the Lwt core, it\n   is quite welcome, and we hope that this code is readable enough for you to be\n   able to make it!\n\n\n   Enjoy! *)\n\n\n\n(* Overview\n\n   In this file, there is a \"model\" function -- [Lwt.bind] -- which pulls\n   together many (though not all) of the concepts and helpers discussed in this\n   overview. To find it, search for \"let bind,\" and you can examine it while\n   reading the overview. The authors of this file intend to put extra effort\n   into writing nice comments inside [Lwt.bind] :)\n\n\n   0. Main mechanism and two aspects\n\n   The Lwt interface ([lwt.mli]) provides one main mechanism, promises, and two\n   \"aspects,\" which are *not* necessary to understand the main mechanism\n   promises, but they are still there:\n\n   - promise cancellation\n   - sequence-associated storage\n\n   If you are not interested in cancellation or storage, you can ignore these\n   two complications, and still get a pretty good understanding of the code. To\n   help, all identifiers related to cancellation contain the string \"cancel,\"\n   and all identifiers related to storage contain \"storage.\"\n\n\n   1. Promises\n\n   A promise is a cell that can be in one of two states: \"resolved\" or\n   \"pending.\"\n\n   - Resolved promises\n\n     A resolved promise is either \"fulfilled\" with a value, or \"rejected\" with\n     an exception. The state of a resolved promise will never change again: a\n     resolved promise is immutable. A resolved promise is basically equivalent\n     to an [('a, exn) Stdlib.result]. Resolved promises are produced in two\n     ways:\n\n     - [Lwt.return], [Lwt.fail], and related functions, produce \"trivial\"\n       promises that are resolved from the start.\n     - The other way is to resolve a promise that started out pending.\n\n     Note that rejected promises have nothing to do with unhandled exceptions.\n\n   - Pending promises\n\n     ...are those that may become resolved in the future. Each pending promise\n     carries a list of callbacks. These callbacks are added by functions like\n     [Lwt.bind], and called by Lwt if/when the promise is resolved. These\n     callbacks typically end up resolving additional promises; see section\n     \"Resolution loop\" below.\n\n     Pending promises are produced in three ways, according to how they can be\n     resolved:\n\n     - Initial promises\n\n       ...are created by [Lwt.wait] and [Lwt.task]. The user of Lwt resolves\n       these promises manually, through the resolvers returned by those\n       functions.\n\n     - Sequential composition\n\n       For example, [Lwt.bind]. These promises are only resolved when the\n       preceding sequence of promises resolves. The user cannot resolve these\n       promises directly (but see the section on cancellation below).\n\n     - Concurrent composition\n\n       For example, [Lwt.join] or [Lwt.choose]. These promises are only resolved\n       when all or one of a set of \"preceding\" promises resolve. The user cannot\n       resolve these promises directly (but see the section on cancellation\n       below).\n\n\n   2. Resolvers\n\n   Resolvers are given to the user by [Lwt.wait] and [Lwt.task], and can be used\n   by the user to resolve the corresponding promises. Note that this means the\n   user only ever gets resolvers for initial promises.\n\n   Internally, resolvers are the exact same objects as the promises they\n   resolve, even though the resolver is exposed as a reference of a different\n   type by [lwt.mli]. For details on why, see section \"Type system abuse\" below.\n\n\n   3. Callbacks\n\n   ...are attached by Lwt to pending promises, and are run by Lwt if/when those\n   promises are resolved. These callbacks are not directly exposed through\n   [lwt.mli] -- they are a low-level mechanism. For example, to implement\n   [Lwt.bind p f], Lwt attaches a callback to [p] that does some internal Lwt\n   book-keeping, and then calls [f] if [p] is fulfilled, and does something else\n   if [p] is rejected.\n\n   Callbacks come in two flavors: regular callbacks and cancel callbacks. The\n   only material differences between them are that:\n\n   - regular callbacks are always called when a promise is resolved, but cancel\n     callbacks are called, in addition, only if the promise is canceled, and\n   - all cancel callbacks of a promise are called before any regular callback\n     is called.\n\n   Cancellation is a special case of resolution, in particular, a special case\n   of rejection, but see the section on cancellation later below.\n\n\n   4. Resolution loop\n\n   Resolving a pending promise triggers its callbacks, and those might resolve\n   more pending promises, triggering more callbacks, etc. This behavior is the\n   *resolution loop*. Lwt has some machinery to avoid stack overflow and other\n   unfortunate situations during this loop.\n\n   This chaining of promise resolutions through callbacks can be seen as a kind\n   of promise dependency graph, in which the nodes are pending promises, and the\n   edges are callbacks. During the resolution loop, Lwt starts at some initial\n   promise that is getting resolved by the user, and recursively resolves all\n   dependent promises. The graph is modified: resolved promises are no longer\n   pending, so they are no longer part of the graph.\n\n   Some of these dependencies are explicit to Lwt, e.g. the callbacks registered\n   by [Lwt.bind]. Others are not visible to Lwt, because the user can always\n   register a callback using a function like [Lwt.on_success], and use that\n   callback to resolve another initial promise. All the explicit dependencies\n   are created by Lwt's own sequential and concurrent composition functions\n   (so, [Lwt.bind], [Lwt.join], etc). Whether dependencies are explicit or not\n   is relevant only to cancellation.\n\n\n   5. Cancellation\n\n   As described above, ordinary promise resolution proceeds from an initial\n   promise, forward along callbacks through the dependency graph. Since it\n   starts from an initial promise, it can only be triggered using a resolver.\n\n   Cancellation is a sort of dual to ordinary resolution. Instead of starting at\n   an initial promise/resolver, cancellation starts at *any* promise. It then\n   goes *backwards* through the explicit dependency graph, looking for\n   cancelable initial promises to cancel -- those that were created by\n   [Lwt.task]. After finding them, cancellation resolves them normally with\n   [Rejected Lwt.Canceled], causing an ordinary promise resolution process.\n\n   To summarize, cancellation is a way to trigger an *ordinary* resolution of\n   promises created with [Lwt.task], by first searching for them in the promise\n   dependency graph (which is assembled by [Lwt.bind], [Lwt.join], etc).\n\n   This backwards search is triggered only by [Lwt.cancel]. It is also possible\n   for the user to cancel a promise directly by rejecting it with\n   [Lwt.Canceled], but in all cases where the user can do so, the search would\n   be redundant anyway -- the user has only two ways of directly rejecting a\n   promise with [Lwt.Canceled] (or any exception, for that matter):\n\n   - The user can create an initial promise, then reject it through its\n     resolver. The search is redundant because it would find only the same\n     initial promise to cancel.\n   - The user can create a trivial promise by calling [Lwt.fail Lwt.Canceled].\n     The search is again redundant; in this case it would find nothing to\n     cancel.\n\n   Note that there is a quirk: only promises created by [Lwt.task] are\n   susceptible to being canceled by [Lwt.cancel], but the user can manually\n   cancel initial promises created by both [Lwt.task] and [Lwt.wait].\n\n   Due to [Lwt.cancel], promise cancellation, and therefore resolution, can be\n   initiated by the user without access to a resolver. This is important for\n   reasoning about state changes in the implementation of Lwt, and is referenced\n   in some implementation detail comments.\n\n\n   6. No I/O\n\n   The Lwt core deliberately doesn't do I/O. The resolution loop stops running\n   once no promises can be resolved immediately. It has to be restarted later\n   by some surrounding I/O loop. This I/O loop typically keeps track of pending\n   promises that represent blocked or in-progress I/O; other pending promises\n   that indirectly depend on I/O are not explicitly tracked. They are retained\n   in memory by references captured inside callbacks.\n\n   On Unix and Windows, a separate top-level loop, typically [Lwt_main.run], is\n   necessary to repeatedly call [select], [epoll], or [kevent], and resolve\n   blocked I/O promises.\n\n   In JavaScript, references to promises are retained by JavaScript code, which\n   is, in turn, triggered by the JS engine. In other words, the top-level loop\n   is buried inside the JS engine.\n\n   This separation of the Lwt core from the top-level I/O loop keeps the core\n   portable.\n\n\n   7. Promise \"proxying\"\n\n   In [Lwt.bind : 'a t -> ('a -> 'b t) -> 'b t], the outer ['b t] is created by\n   [bind] first, and returned to the user. The inner ['b t] is created by the\n   user later, and then returned to [bind]. At that point, [bind] needs to make\n   the inner and outer ['b t]s behave identically.\n\n   This is accomplished by making one of the promises point to the other. The\n   first of the promises thus becomes a \"proxy,\" and the other is its\n   \"underlying\" promise.\n\n   After that, all operations that would be performed by Lwt on the proxy are\n   instead performed on the underlying promise. This is ensured by the numerous\n   calls to the internal function [underlying] in this file.\n\n   Because of the pervasive use of [underlying], proxies can be more or less\n   ignored on a first reading the code. However, becoming a proxy is a kind of\n   state change, and any promise that is returned by a callback to [bind], or to\n   a similar Lwt function, might become a proxy. That means: just about any\n   promise that is handed to the user, might become a proxy promise by the next\n   time Lwt sees it. This is important for reasoning about possible state\n   changes in implementation of Lwt, and is referenced in some implementation\n   detail comments.\n\n\n   8. Sequence-associated storage\n\n   Lwt has a global key-value map. The map can be preserved across sequential\n   composition functions, so that it has the same state in the user's callback\n   [f] as it did at the time the user called [Lwt.bind p f].\n\n   The details are pretty straightforward, and discussed in module\n   [Sequence_associated_storage]. The main thing to be aware of is the many\n   references to [current_storage] throughout Lwt, which are needed to properly\n   save and restore the mapping.\n\n\n   9. Type system abuse\n\n   The implementation uses the type system somewhat extensively. Gentle\n   introductions can be found here:\n\n     https://discuss.ocaml.org/t/161/7\n     https://discuss.ocaml.org/t/161/16\n\n   A short summary follows.\n\n   The promise state is, internally, a GADT which encodes the state in its type\n   parameters. Thus, if you do [let p = underlying p], the shadowing reference\n   [p] is statically known *not* to be a proxy, and the compiler knows that the\n   corresponding match case [Proxy _] is impossible.\n\n   The external promise type, ['a t], and the external resolver type, ['a u],\n   are not GADTs. Furthermore, they are, respectively, covariant and\n   contravariant in ['a], while the internal promise type is invariant in ['a].\n   For these reasons, there are nasty casts between ['a t], ['a u], and the\n   internal promise type. The implementation is, of course, written in terms of\n   the internal type.\n\n   Casting from an ['a t] to an internal promise produces a reference for\n   which the state is \"unknown\": this is simulated with a helper GADT, which\n   encodes existential types. There are several similar casts, which are used\n   to document possible state changes between the time a promise is created,\n   and the later time it is used in a callback. You can see these casts in\n   action in [Lwt.bind]. The cast syntax is pretty light, and, besides being\n   commented in [bind], all such casts are documented in modules [Public_types]\n   and [Basic_helpers].\n\n\n   If you've made it this far, you are an Lwt expert! Rejoice! *)\n\n\n\n(* [Lwt_sequence] is deprecated – we don't want users outside Lwt using it.\n   However, it is still used internally by Lwt. So, briefly disable warning 3\n   (\"deprecated\"), and create a local, non-deprecated alias for\n   [Lwt_sequence] that can be referred to by the rest of the code in this\n   module without triggering any more warnings. *)\nmodule Lwt_sequence = Lwt_sequence\n\n(* Some sequence-associated storage types\n\n   Sequence-associated storage is defined and documented later, in module\n   [Sequence_associated_storage]. However, the following types are mentioned in\n   the definition of [promise], so they must be defined here first. *)\nmodule Storage_map =\n  Map.Make\n    (struct\n      type t = int\n      let compare = compare\n    end)\ntype storage = (unit -> unit) Storage_map.t\n\n\n\nmodule Main_internal_types =\nstruct\n  (* Phantom types for use with types [promise] and [state]. These are never\n     constructed; the purpose of the constructors is to prove to the type\n     checker that these types are distinct from each other. Warning 37, \"unused\n     constructor,\" therefore has to be temporarily suppressed. *)\n\n  [@@@ocaml.warning \"-37\"]\n\n  type underlying = private Underlying_and_this_constructor_is_not_used\n  type proxy = private Proxy_and_this_constructor_is_not_used\n\n  type resolved = private Resolved_and_this_constructor_is_not_used\n  type pending = private Pending_and_this_constructor_is_not_used\n\n  [@@@ocaml.warning \"+37\"]\n\n\n\n  (* Promises proper. *)\n\n  type ('a, 'u, 'c) promise = {\n    mutable state : ('a, 'u, 'c) state;\n  }\n\n  and (_, _, _) state =\n    | Fulfilled : 'a                  -> ('a, underlying, resolved) state\n    | Rejected  : exn                 -> ( _, underlying, resolved) state\n    | Pending   : 'a callbacks        -> ('a, underlying, pending)  state\n    | Proxy     : ('a, _, 'c) promise -> ('a, proxy,      'c)       state\n\n  (* Note:\n\n     A promise whose state is [Proxy _] is a \"proxy\" promise. A promise whose\n     state is *not* [Proxy _] is an \"underlying\" promise.\n\n     The \"underlying promise of [p]\" is:\n\n     - [p], if [p] is itself underlying.\n     - Otherwise, [p] is a proxy and has state [Proxy p']. The underlying\n       promise of [p] is the underlying promise of [p'].\n\n     In other words, to find the underlying promise of a proxy, Lwt follows the\n     [Proxy _] links to the end. *)\n\n  (* Note:\n\n     When a promise is resolved, or becomes a proxy, its state field is\n     mutated. This invalidates the type invariants on the promise. See internal\n     function [set_promise_state] for details about that.\n\n     When an Lwt function has a reference to a promise, and also registers a\n     callback that has a reference to the same promise, the invariants on the\n     reference may become invalid by the time the callback is called. All such\n     callbacks have comments explaining what the valid invariants are at that\n     point, and/or casts to (1) get the correct typing and (2) document the\n     potential state change for readers of the code. *)\n\n\n\n  (* Callback information for pending promises. *)\n\n  and 'a callbacks = {\n    mutable regular_callbacks : 'a regular_callback_list;\n    mutable cancel_callbacks  : 'a cancel_callback_list;\n    mutable how_to_cancel     : how_to_cancel;\n    mutable cleanups_deferred : int;\n  }\n\n  and 'a regular_callback = 'a resolved_state -> unit\n\n  and cancel_callback = unit -> unit\n\n  and 'a resolved_state = ('a, underlying, resolved) state\n\n  and how_to_cancel =\n    | Not_cancelable              :                           how_to_cancel\n    | Cancel_this_promise         :                           how_to_cancel\n    | Propagate_cancel_to_one     : (_, _, _) promise      -> how_to_cancel\n    | Propagate_cancel_to_several : (_, _, _) promise list -> how_to_cancel\n\n  and 'a regular_callback_list =\n    | Regular_callback_list_empty\n    | Regular_callback_list_concat of\n      'a regular_callback_list * 'a regular_callback_list\n    | Regular_callback_list_implicitly_removed_callback of\n      'a regular_callback\n    | Regular_callback_list_explicitly_removable_callback of\n      'a regular_callback option ref\n\n  and _ cancel_callback_list =\n    | Cancel_callback_list_empty :\n      _ cancel_callback_list\n    | Cancel_callback_list_concat :\n      'a cancel_callback_list * 'a cancel_callback_list ->\n        'a cancel_callback_list\n    | Cancel_callback_list_callback :\n      storage * cancel_callback ->\n        _ cancel_callback_list\n    | Cancel_callback_list_remove_sequence_node :\n      ('a, _, _) promise Lwt_sequence.node ->\n        'a cancel_callback_list\n\n  (* Notes:\n\n     These type definitions are guilty of performing several optimizations,\n     without which they would be much easier to understand.\n\n     - The type parameters of ['a resolved_state] guarantee that it is either\n       [Fulfilled _] or [Rejected _]. So, it is equivalent to\n       [('a, exn) Stdlib.result], and, indeed, should have an identical\n       memory representation.\n\n     - As per the Overview, there are regular callbacks and cancel callbacks.\n       Cancel callbacks are called only on cancellation, and, then, before any\n       regular callbacks are called.\n\n       Despite the different types for the two kinds of callbacks, they are\n       otherwise the same. Cancel callbacks just don't need a result state\n       argument, because it is known to be [Rejected Canceled].\n\n     - Regular callbacks are not allowed to raise exceptions. All regular\n       callbacks are created in this file, so this can be checked.\n\n       Cancel callbacks can raise exceptions, but if they do so, the exceptions\n       are passed to [async_exception_hook].\n\n     - [how_to_cancel] implements the dependency graph mentioned in the\n       Overview. It is traversed backwards during [Lwt.cancel]. It is a GADT\n       because we don't care about the actual types of the promise references\n       stored, or their invariants. The constructors correspond to pending\n       promise kinds as follows:\n         - [Not_cancelable]: initial, [Lwt.wait].\n         - [Cancel_this_promise]: initial, [Lwt.task].\n         - [Propagate_cancel_to_one]: sequential composition, e.g. [Lwt.bind].\n         - [Propagate_cancel_to_several]: concurrent composition, e.g.\n           [Lwt.join].\n\n     - The two callback list types are ordinary append-friendly lists, with two\n       optimizations inlined:\n\n       - ['a regular_callback_list] apparently has two \"kinds\" of regular\n         callbacks, implicitly removed and explicitly removable. All callbacks\n         are removable. It's just that, for some callbacks, they will only be\n         removed at the same time that the promise they are attached to becomes\n         resolved. When that happens, the entire state of that promise changes\n         to [Fulfilled _] or [Rejected _], and the reference to the whole\n         callback list is simply lost. This \"removes\" the callback. For these\n         callbacks, ['a regular_callback_list] attempts to trim an option and a\n         reference cell with the\n         [Regular_callback_list_implicitly_removed_callback] constructor.\n\n       - ['a cancel_callback_list] has\n         [Cancel_callback_list_remove_sequence_node node], which is the same as\n         [Cancel_callback_list_callback (_, (fun _ ->\n           Lwt_sequence.remove node))].\n         This was probably done to avoid a closure allocation.\n\n     - The [cleanups_deferred] field is explained in module\n       [Pending_callbacks]. *)\nend\nopen Main_internal_types\n\n\n\nmodule Public_types =\nstruct\n  type +'a t\n  type -'a u\n\n  let to_public_promise : ('a, _, _) promise -> 'a t = Obj.magic\n  let to_public_resolver : ('a, _, _) promise -> 'a u = Obj.magic\n\n  type _ packed_promise =\n    | Internal : ('a, _, _) promise -> 'a packed_promise\n    [@@ocaml.unboxed]\n\n  let to_internal_promise (p : 'a t) : 'a packed_promise =\n    Internal (Obj.magic p)\n  let to_internal_resolver (r : 'a u) : 'a packed_promise =\n    Internal (Obj.magic r)\n\n  (* Most functions that take a public promise (['a t]) convert it to an\n     internal promise as follows:\n\n       (* p : 'a t *)\n\n       let Internal p = to_internal_promise p in\n\n       (* p : ('a, u, c) promise, where u and c are fresh types, i.e. the\n          invariants on p are unknown. *)\n\n     This cast is a no-op cast. It only produces a reference with a different\n     type. The introduction and immediate elimination of [Internal _] seems to\n     be optimized away even on older versions of OCaml that don't have Flambda\n     and don't support [[@@ocaml.unboxed]]. *)\n\n  (* This could probably save an allocation by using [Obj.magic]. *)\n  let state_of_result = function\n    | Ok x -> Fulfilled x\n    | Error exn -> Rejected exn\nend\ninclude Public_types\n\n\n\nmodule Basic_helpers :\nsig\n  val identical : ('a, _, _) promise -> ('a, _, _) promise -> bool\n  val underlying : ('a, 'u, 'c) promise -> ('a, underlying, 'c) promise\n\n  type ('a, 'u, 'c) state_changed =\n    | State_may_have_changed of ('a, 'u, 'c) promise\n    [@@ocaml.unboxed]\n  val set_promise_state :\n    ('a, _, _) promise -> ('a, 'u, 'c) state -> ('a, 'u, 'c) state_changed\n\n  type 'a may_now_be_proxy =\n    | State_may_now_be_pending_proxy :\n      ('a, _, pending) promise -> 'a may_now_be_proxy\n    [@@ocaml.unboxed]\n  val may_now_be_proxy :\n    ('a, underlying, pending) promise -> 'a may_now_be_proxy\nend =\nstruct\n  (* Checks physical equality ([==]) of two internal promises. Unlike [==], does\n     not force unification of their invariants. *)\n  let identical p1 p2 =\n    (to_public_promise p1) == (to_public_promise p2)\n\n  (* [underlying p] evaluates to the underlying promise of [p].\n\n     If multiple [Proxy _] links are traversed, [underlying] updates all the\n     proxies to point immediately to their final underlying promise. *)\n  let rec underlying\n      : type u c. ('a, u, c) promise -> ('a, underlying, c) promise =\n    fun p ->\n\n    match p.state with\n    | Fulfilled _ -> (p : (_, underlying, _) promise)\n    | Rejected _ -> p\n    | Pending _ -> p\n    | Proxy p' ->\n      let p'' = underlying p' in\n      if not (identical p'' p') then\n        p.state <- Proxy p'';\n      p''\n\n\n\n  type ('a, 'u, 'c) state_changed =\n    | State_may_have_changed of ('a, 'u, 'c) promise\n    [@@ocaml.unboxed]\n\n  let set_promise_state p state =\n    let p : (_, _, _) promise = Obj.magic p in\n    p.state <- state;\n    State_may_have_changed p\n\n  (* [set_promise_state p state] mutates the state of [p], and evaluates to a\n     (wrapped) reference to [p] with the same invariants as on [state]. The\n     original reference [p] should be shadowed when calling this function:\n\n       let State_may_have_changed p = set_promise_state p (Fulfilled 42) in ...\n\n     This is a kind of cheap imitation of linear typing, which is good enough\n     for the needs of [lwt.ml].\n\n     Internal functions that transitively call [set_promise_state] likewise\n     return the new reference. This ends at some top-level function, typically\n     either a callback or a function in the public API. There, the new reference\n     is still bound, but is then explicitly ignored.\n\n     The state of a promise is never updated directly outside this module\n     [Basic_helpers]. All updates elsewhere are done through\n     [set_promise_state].\n\n     To avoid problems with type-level invariants not matching reality, data\n     structures do not store promises with concrete invariants -- except\n     resolved promises, which are immutable. Indeed, if one looks at\n     definitions of data structures that can store pending promises, e.g. the\n     [how_to_cancel] graph, the invariants are existentially quantified.\n\n     Note: it's possible to statically disallow the setting of the [state] field\n     by making type [promise] private. However, that seems to require writing a\n     signature that is a near-duplicate of [Main_internal_types], or some abuse\n     of functors. *)\n\n\n\n  type 'a may_now_be_proxy =\n    | State_may_now_be_pending_proxy :\n      ('a, _, pending) promise -> 'a may_now_be_proxy\n    [@@ocaml.unboxed]\n\n  let may_now_be_proxy p = State_may_now_be_pending_proxy p\n\n  (* Many functions, for example [Lwt.bind] and [Lwt.join], create a fresh\n     pending promise [p] and return it to the user.\n\n     They do not return a corresponding resolver. That means that only the\n     function itself (typically, a callback registered by it) can resolve [p].\n     The only thing the user can do directly is try to cancel [p], but, since\n     [p] is not an initial promise, the cancellation attempt simply propagates\n     past [p] to [p]'s predecessors. If that eventually results in canceling\n     [p], it will be through the normal mechanisms of the function (e.g.\n     [Lwt.bind]'s callback).\n\n     As a result, the only possible state change, before the callback, is that\n     [p] may have become a proxy. Now,\n\n     - If [p] does not undergo this state change and become a proxy, it remains\n       an underlying, pending promise.\n     - If [p] does become a proxy, it will be a proxy for another promise [p']\n       created fresh by [Lwt.bind], to which this same argument applies. See\n       [make_into_proxy].\n\n     So, by induction on the length of the proxy ([Proxy _]) chain, at the time\n     the callback is called, [p] is either an underlying, pending promise, or a\n     proxy for a pending promise.\n\n     The cast\n\n       let State_may_now_be_pending_proxy p = may_now_be_proxy p in ...\n\n     encodes the possibility of this state change. It replaces a reference\n\n       p : ('a, underlying, pending)\n\n     with\n\n       p : ('a, $Unknown, pending)\n\n     and is typically seen at the beginning of callbacks registered by\n     [Lwt.bind] and similar functions.\n\n     The cast is a no-op cast. The introduction and immediate elimination of\n     [State_may_have_changed _] seems to be optimized away even on old versions\n     of OCaml. *)\nend\nopen Basic_helpers\n\n(* Small helpers to avoid catching ocaml-runtime exceptions *)\nmodule Exception_filter = struct\n  type t = exn -> bool\n  let handle_all = fun _ -> true\n  let handle_all_except_runtime = function\n    | Out_of_memory -> false\n    | Stack_overflow -> false\n    | _ -> true\n  let v =\n    (* Default value: the legacy behaviour to avoid breaking programs *)\n    ref handle_all\n  let set f = v := f\n  let run e = !v e\nend\n\nmodule Sequence_associated_storage :\nsig\n  (* Public interface *)\n  type 'v key\n  val new_key : unit -> _ key\n  val get : 'v key -> 'v option\n  val with_value : 'v key -> 'v option -> (unit -> 'b) -> 'b\n\n  (* Internal interface *)\n  val current_storage : storage ref\nend =\nstruct\n  (* The idea behind sequence-associated storage is to preserve some values\n     during a call to [bind] or other sequential composition operation, and\n     restore those values in the callback function:\n\n       Lwt.with_value my_key (Some \"foo\") (fun () ->\n       p >|= fun () ->\n       assert (Lwt.get my_key = Some \"foo\"))\n         (* Will succeed even if this callback is called later. *)\n\n     Note that it does not matter that the callback is defined within an\n     argument of [with_value], i.e., this does the same:\n\n       let f = fun () -> assert (Lwt.get my_key = Some \"foo\") in\n       Lwt.with_value my_key (Some \"foo\") (fun () -> p >|= f)\n\n     All that matters is that the top-most sequencing operation (in this case,\n     map) is executed by that argument.\n\n     This is implemented using a single global heterogeneous key-value map.\n     Sequential composition functions snapshot this map when they are called,\n     and restore the snapshot right before calling the user's callback. The same\n     happens for cancel triggers added by [on_cancel].\n\n     Maintainer's note: I think using this mechanism should be discouraged in\n     new code. *)\n\n  type 'v key = {\n    id : int;\n    mutable value : 'v option;\n  }\n\n  let next_key_id = ref 0\n\n  let new_key () =\n    let id = !next_key_id in\n    next_key_id := id + 1;\n    {id = id; value = None}\n\n  let current_storage = ref Storage_map.empty\n\n  let get key =\n    if Storage_map.mem key.id !current_storage then begin\n      let refresh = Storage_map.find key.id !current_storage in\n      refresh ();\n      let value = key.value in\n      key.value <- None;\n      value\n    end\n    else\n      None\n\n  let with_value key value f =\n    let new_storage =\n      match value with\n      | Some _ ->\n        let refresh = fun () -> key.value <- value in\n        Storage_map.add key.id refresh !current_storage\n      | None ->\n        Storage_map.remove key.id !current_storage\n    in\n\n    let saved_storage = !current_storage in\n    current_storage := new_storage;\n    try\n      let result = f () in\n      current_storage := saved_storage;\n      result\n    with exn when Exception_filter.run exn ->\n      current_storage := saved_storage;\n      raise exn\nend\ninclude Sequence_associated_storage\n\n\n\nmodule Pending_callbacks :\nsig\n  (* Mutating callback lists attached to pending promises *)\n  val add_implicitly_removed_callback :\n    'a callbacks -> 'a regular_callback -> unit\n  val add_explicitly_removable_callback_to_each_of :\n    'a t list -> 'a regular_callback -> unit\n  val add_explicitly_removable_callback_and_give_remove_function :\n    'a t list -> 'a regular_callback -> cancel_callback\n  val add_cancel_callback : 'a callbacks -> cancel_callback -> unit\n  val merge_callbacks : from:'a callbacks -> into:'a callbacks -> unit\nend =\nstruct\n  let concat_regular_callbacks l1 l2 =\n    begin match l1, l2 with\n    | Regular_callback_list_empty, _ -> l2\n    | _, Regular_callback_list_empty -> l1\n    | _, _ -> Regular_callback_list_concat (l1, l2)\n    end\n\n  let concat_cancel_callbacks l1 l2 =\n    begin match l1, l2 with\n    | Cancel_callback_list_empty, _ -> l2\n    | _, Cancel_callback_list_empty -> l1\n    | _, _ -> Cancel_callback_list_concat (l1, l2)\n    end\n\n  (* In a callback list, filters out cells of explicitly removable callbacks\n     that have been removed. *)\n  let rec clean_up_callback_cells = function\n    | Regular_callback_list_explicitly_removable_callback {contents = None} ->\n      Regular_callback_list_empty\n\n    | Regular_callback_list_explicitly_removable_callback {contents = Some _}\n    | Regular_callback_list_implicitly_removed_callback _\n    | Regular_callback_list_empty as callbacks ->\n      callbacks\n\n    | Regular_callback_list_concat (l1, l2) ->\n      let l1 = clean_up_callback_cells l1 in\n      let l2 = clean_up_callback_cells l2 in\n      concat_regular_callbacks l1 l2\n\n  (* See [clear_explicitly_removable_callback_cell] and [merge_callbacks]. *)\n  let cleanup_throttle = 42\n\n  (* Explicitly removable callbacks are added (mainly) by [Lwt.choose] and its\n     similar functions. In [Lwt.choose [p; p']], if [p'] resolves first, the\n     callback added by [Lwt.choose] to [p] is removed.\n\n     The removal itself is accomplished when this function clears the reference\n     cell [cell], which contains the reference to that callback.\n\n     If [p] is a long-pending promise that repeatedly participates in\n     [Lwt.choose], perhaps in a loop, it will accumulate a large number of\n     cleared reference cells in this fashion. To avoid a memory leak, they must\n     be cleaned up. However, the cells are not cleaned up on *every* removal,\n     presumably because scanning the callback list that often, and rebuilding\n     it, can get expensive.\n\n     Cleanup is throttled by maintaining a counter, [cleanups_deferred], on each\n     pending promise. The counter is incremented each time this function wants\n     to clean the callback list (right after clearing a cell). When the counter\n     reaches [cleanup_throttle], the callback list is actually scanned and\n     cleared callback cells are removed. *)\n  let clear_explicitly_removable_callback_cell cell ~originally_added_to:ps =\n    cell := None;\n\n    (* Go through the promises the cell had originally been added to, and either\n       defer a cleanup, or actually clean up their callback lists. *)\n    ps |> List.iter (fun p ->\n      let Internal p = to_internal_promise p in\n      match (underlying p).state with\n      (* Some of the promises may already have been resolved at the time this\n         function is called. *)\n      | Fulfilled _ -> ()\n      | Rejected _ -> ()\n\n      | Pending callbacks ->\n        match callbacks.regular_callbacks with\n        (* If the promise has only one regular callback, and it is removable, it\n           must have been the cell cleared in this function, above. In that\n           case, just set its callback list to empty. *)\n        | Regular_callback_list_explicitly_removable_callback _ ->\n          callbacks.regular_callbacks <- Regular_callback_list_empty\n\n        (* Maintainer's note: I think this function shouldn't try to trigger a\n           cleanup in the first two cases, but I am preserving them for now, as\n           this is how the code was written in the past. *)\n        | Regular_callback_list_empty\n        | Regular_callback_list_implicitly_removed_callback _\n        | Regular_callback_list_concat _ ->\n          let cleanups_deferred = callbacks.cleanups_deferred + 1 in\n          if cleanups_deferred > cleanup_throttle then begin\n            callbacks.cleanups_deferred <- 0;\n            callbacks.regular_callbacks <-\n              clean_up_callback_cells callbacks.regular_callbacks\n          end else\n            callbacks.cleanups_deferred <- cleanups_deferred)\n\n  (* Concatenates both kinds of callbacks on [~from] to the corresponding lists\n     of [~into]. The callback lists on [~from] are *not* then cleared, because\n     this function is called only by [Sequential_composition.make_into_proxy],\n     which immediately changes the state of [~from] and loses references to the\n     original callback lists.\n\n     The [cleanups_deferred] fields of both promises are summed, and if the sum\n     exceeds [cleanup_throttle], a cleanup of regular callbacks is triggered.\n     This is to prevent memory leaks; see\n     [clear_explicitly_removable_callback_cell]. *)\n  let merge_callbacks ~from ~into =\n    let regular_callbacks =\n      concat_regular_callbacks into.regular_callbacks from.regular_callbacks in\n    let cleanups_deferred = into.cleanups_deferred + from.cleanups_deferred in\n\n    let regular_callbacks, cleanups_deferred =\n      if cleanups_deferred > cleanup_throttle then\n        clean_up_callback_cells regular_callbacks, 0\n      else\n        regular_callbacks, cleanups_deferred\n    in\n\n    let cancel_callbacks =\n      concat_cancel_callbacks into.cancel_callbacks from.cancel_callbacks in\n\n    into.regular_callbacks <- regular_callbacks;\n    into.cancel_callbacks <- cancel_callbacks;\n    into.cleanups_deferred <- cleanups_deferred\n\n\n\n  (* General, internal, function for adding a regular callback. *)\n  let add_regular_callback_list_node callbacks node =\n    callbacks.regular_callbacks <-\n      match callbacks.regular_callbacks with\n      | Regular_callback_list_empty ->\n        node\n      | Regular_callback_list_implicitly_removed_callback _\n      | Regular_callback_list_explicitly_removable_callback _\n      | Regular_callback_list_concat _ as existing ->\n        Regular_callback_list_concat (node, existing)\n\n  let add_implicitly_removed_callback callbacks f =\n    add_regular_callback_list_node\n      callbacks (Regular_callback_list_implicitly_removed_callback f)\n\n  (* Adds [callback] as removable to each promise in [ps]. The first promise in\n     [ps] to trigger [callback] removes [callback] from the other promises; this\n     guarantees that [callback] is called at most once. All the promises in [ps]\n     must be pending.\n\n     This is an internal function, indirectly used by the implementations of\n     [Lwt.choose] and related functions. *)\n  let add_explicitly_removable_callback_and_give_cell ps f =\n    let rec cell = ref (Some self_removing_callback_wrapper)\n    and self_removing_callback_wrapper result =\n      clear_explicitly_removable_callback_cell cell ~originally_added_to:ps;\n      f result\n    in\n\n    let node = Regular_callback_list_explicitly_removable_callback cell in\n    ps |> List.iter (fun p ->\n      let Internal p = to_internal_promise p in\n      match (underlying p).state with\n      | Pending callbacks -> add_regular_callback_list_node callbacks node\n      | Fulfilled _ -> assert false\n      | Rejected _ -> assert false);\n\n    cell\n\n  let add_explicitly_removable_callback_to_each_of ps f =\n    ignore (add_explicitly_removable_callback_and_give_cell ps f)\n\n  (* This is basically just to support [Lwt.protected], which needs to remove\n     the callback in circumstances other than the callback being called. *)\n  let add_explicitly_removable_callback_and_give_remove_function ps f =\n    let cell = add_explicitly_removable_callback_and_give_cell ps f in\n    fun () ->\n      clear_explicitly_removable_callback_cell cell ~originally_added_to:ps\n\n  let add_cancel_callback callbacks f =\n    let node = Cancel_callback_list_callback (!current_storage, f) in\n\n    callbacks.cancel_callbacks <-\n      match callbacks.cancel_callbacks with\n      | Cancel_callback_list_empty ->\n        node\n\n      | Cancel_callback_list_callback _\n      | Cancel_callback_list_remove_sequence_node _\n      | Cancel_callback_list_concat _ ->\n        Cancel_callback_list_concat (node, callbacks.cancel_callbacks)\nend\nopen Pending_callbacks\n\n\n\nmodule Resolution_loop :\nsig\n  (* All user-provided callbacks are called by Lwt only through this module. It\n     tracks the current callback stack depth, and decides whether each callback\n     call should be deferred or not. *)\n\n  (* Internal interface used only in this module Lwt *)\n  val resolve :\n    ?allow_deferring:bool ->\n    ?maximum_callback_nesting_depth:int ->\n    ('a, underlying, pending) promise ->\n    'a resolved_state ->\n      ('a, underlying, resolved) state_changed\n\n  val run_callbacks_or_defer_them :\n    ?allow_deferring:bool ->\n    ?maximum_callback_nesting_depth:int ->\n    ('a callbacks) ->\n    'a resolved_state ->\n      unit\n\n  val run_callback_or_defer_it :\n    ?run_immediately_and_ensure_tail_call:bool ->\n    callback:(unit -> 'a) ->\n    if_deferred:(unit -> 'a * 'b regular_callback * 'b resolved_state) ->\n      'a\n\n  val handle_with_async_exception_hook : ('a -> unit) -> 'a -> unit\n\n  (* Internal interface exposed to other modules in Lwt *)\n  val abandon_wakeups : unit -> unit\n\n  (* Public interface *)\n  exception Canceled\n\n  val async_exception_hook : (exn -> unit) ref\nend =\nstruct\n  (* When Lwt needs to call a callback, it enters the resolution loop. This\n     typically happens when Lwt sets the state of one promise to [Fulfilled _]\n     or [Rejected _]. The callbacks that were attached to the promise when it\n     was pending must then be called.\n\n     This also happens in a few other situations. For example, when [Lwt.bind]\n     is called on a promise, but that promise is already resolved, the callback\n     passed to [bind] must be called.\n\n     The callbacks triggered during the resolution loop might resolve more\n     promises, triggering more callbacks, and so on. This is what makes the\n     resolution loop a {e loop}.\n\n     Lwt generally tries to call each callback immediately. However, this can\n     lead to a progressive deepening of the call stack, until there is a stack\n     overflow. This can't be avoided by doing tail calls, because Lwt always\n     needs to do exception handling around callbacks calls: each callback call\n     is followed by an exception handler. Instead, what Lwt does is track the\n     current callback call depth. Once that depth reaches a certain number,\n     [default_maximum_callback_nesting_depth], defined below, further callbacks\n     are deferred into a queue instead. That queue is drained when Lwt exits\n     from the top-most callback call that triggered the resolution loop in the\n     first place.\n\n     To ensure that this deferral mechanism is always properly invoked, all\n     callbacks called by Lwt are called through one of three functions provided\n     by this module:\n\n     - [resolve], which calls all the callbacks associated to a pending promise\n       (and resolves it, changing its state).\n     - [run_callbacks_or_defer_them], which is internally used by [resolve] to\n       call callbacks that are in a record of type ['a callbacks], which records\n       are associated with pending promises. This function is exposed because\n       the current implementation of [Lwt.cancel] needs to call it directly.\n       Promise resolution and callback calling are separated in a unique way in\n       [cancel].\n     - [run_callback_or_defer_it], which is used by [Lwt.bind] and similar\n       functions to call single callbacks when the promises passed to\n       [Lwt.bind], etc., are already resolved.\n\n     Current Lwt actually has a messy mix of callback-calling behaviors. For\n     example, [Lwt.bind] is expected to always call its callback immediately,\n     while [Lwt.wakeup_later] is expected to defer all callbacks of the promise\n     resolved, {e unless} Lwt is not already inside the resolution loop.\n\n     We planned to make these behaviors uniform in Lwt 4.0.0, but decided\n     against it due to the risk of breaking users. See\n\n     - https://github.com/ocsigen/lwt/pull/500\n     - https://github.com/ocsigen/lwt/pull/519\n\n     As part of the preparation for the change, the above callback-invoking\n     functions support several optional arguments to emulate the various\n     behaviors. We decided not to remove this machinery, because we might want\n     to expose different APIs to Lwt in the future.\n\n     - [~allow_deferring:false] allows ignoring the callback stack depth, and\n       calling the callbacks immediately. This emulates the old resolution\n       behavior.\n     - [~maximum_callback_nesting_depth:1] allows limiting the depth which\n       triggers deferral on a per-call-site basis. This is used by\n       [Lwt.wakeup_later].\n     - [~run_immediately_and_ensure_tail_call:true] is like\n       [~allow_deferring:false], which ignores the callback stack depth.\n       However, to ensure that the callback is tail-called, Lwt doesn't even\n       update the callback stack depth for the benefit of *other* callback\n       calls. It just blindly calls the callback.\n\n     See discussion of callback-calling semantics in:\n\n       https://github.com/ocsigen/lwt/issues/329\n\n     * Context\n\n     The resolution loop effectively handles all promises that can be resolved\n     immediately, without blocking on I/O. A complete program that does I/O\n     calls [Lwt_main.run]. See \"No I/O\" in the Overview. *)\n\n\n\n  let async_exception_hook =\n    ref (fun exn ->\n      prerr_string \"Fatal error: exception \";\n      prerr_string (Printexc.to_string exn);\n      prerr_char '\\n';\n      Printexc.print_backtrace stderr;\n      flush stderr;\n      exit 2)\n\n  let handle_with_async_exception_hook f v =\n    (* Note that this function does not care if [f] evaluates to a promise. In\n       particular, if [f v] evaluates to [p] and [p] is already rejected or will\n       be reject later, it is not the responsibility of this function to pass\n       the exception to [!async_exception_hook]. *)\n    try f v\n    with exn when Exception_filter.run exn ->\n      !async_exception_hook exn\n\n\n\n  exception Canceled\n\n\n\n  (* Runs the callbacks (formerly) associated to a promise. Cancel callbacks are\n     run first, if the promise was canceled. These are followed by regular\n     callbacks.\n\n     The reason for the \"formerly\" is that the promise's state has already been\n     set to [Fulfilled _] or [Rejected _], so the callbacks are no longer\n     reachable through the promise reference. This is why the direct [callbacks]\n     record must be given to this function. *)\n  let run_callbacks\n      (callbacks : 'a callbacks)\n      (result : 'a resolved_state) : unit =\n\n    let run_cancel_callbacks fs =\n      let rec iter_callback_list fs rest =\n        match fs with\n        | Cancel_callback_list_empty ->\n          iter_list rest\n        | Cancel_callback_list_callback (storage, f) ->\n          current_storage := storage;\n          handle_with_async_exception_hook f ();\n          iter_list rest\n        | Cancel_callback_list_remove_sequence_node node ->\n          Lwt_sequence.remove node;\n          iter_list rest\n        | Cancel_callback_list_concat (fs, fs') ->\n          iter_callback_list fs (fs'::rest)\n\n      and iter_list rest =\n        match rest with\n        | [] -> ()\n        | fs::rest -> iter_callback_list fs rest\n\n      in\n\n      iter_callback_list fs []\n    in\n\n    let run_regular_callbacks fs =\n      let rec iter_callback_list fs rest =\n        match fs with\n        | Regular_callback_list_empty ->\n          iter_list rest\n        | Regular_callback_list_implicitly_removed_callback f ->\n          f result;\n          iter_list rest\n        | Regular_callback_list_explicitly_removable_callback\n            {contents = None} ->\n          iter_list rest\n        | Regular_callback_list_explicitly_removable_callback\n            {contents = Some f} ->\n          f result;\n          iter_list rest\n        | Regular_callback_list_concat (fs, fs') ->\n          iter_callback_list fs (fs'::rest)\n\n      and iter_list rest =\n        match rest with\n        | [] -> ()\n        | fs::rest -> iter_callback_list fs rest\n\n      in\n\n      iter_callback_list fs []\n    in\n\n    (* Pattern matching is much faster than polymorphic comparison. *)\n    let is_canceled =\n      match result with\n      | Rejected Canceled -> true\n      | Rejected _ -> false\n      | Fulfilled _ -> false\n    in\n    if is_canceled then\n      run_cancel_callbacks callbacks.cancel_callbacks;\n    run_regular_callbacks callbacks.regular_callbacks\n\n\n\n  let default_maximum_callback_nesting_depth = 42\n\n  let current_callback_nesting_depth = ref 0\n\n  type deferred_callbacks =\n    Deferred : ('a callbacks * 'a resolved_state) -> deferred_callbacks\n    [@@ocaml.unboxed]\n\n  let deferred_callbacks : deferred_callbacks Queue.t = Queue.create ()\n\n  (* Before entering a resolution loop, it is necessary to take a snapshot of\n     the current state of sequence-associated storage. This is because many of\n     the callbacks that will be run will modify the storage. The storage is\n     restored to the snapshot when the resolution loop is exited. *)\n  let enter_resolution_loop () =\n    current_callback_nesting_depth := !current_callback_nesting_depth + 1;\n    let storage_snapshot = !current_storage in\n    storage_snapshot\n\n  let leave_resolution_loop (storage_snapshot : storage) : unit =\n    if !current_callback_nesting_depth = 1 then begin\n      while not (Queue.is_empty deferred_callbacks) do\n        let Deferred (callbacks, result) = Queue.pop deferred_callbacks in\n        run_callbacks callbacks result\n      done\n    end;\n    current_callback_nesting_depth := !current_callback_nesting_depth - 1;\n    current_storage := storage_snapshot\n\n  let run_in_resolution_loop f =\n    let storage_snapshot = enter_resolution_loop () in\n    let result = f () in\n    leave_resolution_loop storage_snapshot;\n    result\n\n  (* This is basically a hack to fix https://github.com/ocsigen/lwt/issues/48.\n     If currently resolving promises, it immediately exits all recursive\n     entries of the resolution loop, goes to the top level, runs any deferred\n     callbacks, and exits the top-level resolution loop.\n\n     The name should probably be [abaondon_resolution_loop]. *)\n  let abandon_wakeups () =\n    if !current_callback_nesting_depth <> 0 then\n      leave_resolution_loop Storage_map.empty\n\n\n\n  let run_callbacks_or_defer_them\n      ?(allow_deferring = true)\n      ?(maximum_callback_nesting_depth = default_maximum_callback_nesting_depth)\n      callbacks result =\n\n    let should_defer =\n      allow_deferring\n      && !current_callback_nesting_depth >= maximum_callback_nesting_depth\n    in\n\n    if should_defer then\n      Queue.push (Deferred (callbacks, result)) deferred_callbacks\n    else\n      run_in_resolution_loop (fun () ->\n        run_callbacks callbacks result)\n\n  let resolve ?allow_deferring ?maximum_callback_nesting_depth p result =\n    let Pending callbacks = p.state in\n    let p = set_promise_state p result in\n\n    run_callbacks_or_defer_them\n      ?allow_deferring ?maximum_callback_nesting_depth callbacks result;\n\n    p\n\n  let run_callback_or_defer_it\n      ?(run_immediately_and_ensure_tail_call = false)\n      ~callback:f\n      ~if_deferred =\n\n    if run_immediately_and_ensure_tail_call then\n      f ()\n\n    else\n      let should_defer =\n        !current_callback_nesting_depth\n          >= default_maximum_callback_nesting_depth\n      in\n\n      if should_defer then begin\n        let immediate_result, deferred_callback, deferred_result =\n          if_deferred () in\n        let deferred_record =\n          {\n            regular_callbacks =\n              Regular_callback_list_implicitly_removed_callback\n                deferred_callback;\n            cancel_callbacks = Cancel_callback_list_empty;\n            how_to_cancel = Not_cancelable;\n            cleanups_deferred = 0\n          }\n        in\n        Queue.push\n          (Deferred (deferred_record, deferred_result)) deferred_callbacks;\n        immediate_result\n      end\n      else\n        run_in_resolution_loop (fun () ->\n          f ())\nend\ninclude Resolution_loop\n\n\n\nmodule Resolving :\nsig\n  val wakeup_later_result : 'a u -> ('a, exn) result -> unit\n  val wakeup_later : 'a u -> 'a -> unit\n  val wakeup_later_exn : _ u -> exn -> unit\n\n  val wakeup_result : 'a u -> ('a, exn) result -> unit\n  val wakeup : 'a u -> 'a -> unit\n  val wakeup_exn : _ u -> exn -> unit\n\n  val cancel : 'a t -> unit\nend =\nstruct\n  (* Note that this function deviates from the \"ideal\" callback deferral\n     behavior: it runs callbacks directly on the current stack. It should\n     therefore be possible to cause a stack overflow using this function. *)\n  let wakeup_general api_function_name r result =\n    let Internal p = to_internal_resolver r in\n    let p = underlying p in\n\n    match p.state with\n    | Rejected Canceled ->\n      ()\n    | Fulfilled _ ->\n      Printf.ksprintf invalid_arg \"Lwt.%s\" api_function_name\n    | Rejected _ ->\n      Printf.ksprintf invalid_arg \"Lwt.%s\" api_function_name\n\n    | Pending _ ->\n      let result = state_of_result result in\n      let State_may_have_changed p = resolve ~allow_deferring:false p result in\n      ignore p\n\n  let wakeup_result r result = wakeup_general \"wakeup_result\" r result\n  let wakeup r v = wakeup_general \"wakeup\" r (Ok v)\n  let wakeup_exn r exn = wakeup_general \"wakeup_exn\" r (Error exn)\n\n  let wakeup_later_general api_function_name r result =\n    let Internal p = to_internal_resolver r in\n    let p = underlying p in\n\n    match p.state with\n    | Rejected Canceled ->\n      ()\n    | Fulfilled _ ->\n      Printf.ksprintf invalid_arg \"Lwt.%s\" api_function_name\n    | Rejected _ ->\n      Printf.ksprintf invalid_arg \"Lwt.%s\" api_function_name\n\n    | Pending _ ->\n      let result = state_of_result result in\n      let State_may_have_changed p =\n        resolve ~maximum_callback_nesting_depth:1 p result in\n      ignore p\n\n  let wakeup_later_result r result =\n    wakeup_later_general \"wakeup_later_result\" r result\n  let wakeup_later r v =\n    wakeup_later_general \"wakeup_later\" r (Ok v)\n  let wakeup_later_exn r exn =\n    wakeup_later_general \"wakeup_later_exn\" r (Error exn)\n\n\n\n  type packed_callbacks =\n    | Packed : _ callbacks -> packed_callbacks\n    [@@ocaml.unboxed]\n\n  (* Note that this function deviates from the \"ideal\" callback deferral\n     behavior: it runs callbacks directly on the current stack. It should\n     therefore be possible to cause a stack overflow using this function. *)\n  let cancel p =\n    let canceled_result = Rejected Canceled in\n\n    (* Walks the promise dependency graph backwards, looking for cancelable\n       initial promises, and cancels (only) them.\n\n       Found initial promises are canceled immediately, as they are found, by\n       setting their state to [Rejected Canceled]. This is to prevent them from\n       being \"found twice\" if they are reachable by two or more distinct paths\n       through the promise dependency graph.\n\n       The callbacks of these initial promises are then run, in a separate\n       phase. These callbacks propagate cancellation forwards to any dependent\n       promises. See \"Cancellation\" in the Overview. *)\n    let propagate_cancel : (_, _, _) promise -> packed_callbacks list =\n        fun p ->\n      let rec cancel_and_collect_callbacks :\n          'a 'u 'c. packed_callbacks list -> ('a, 'u, 'c) promise ->\n            packed_callbacks list =\n          fun (type c) callbacks_accumulator (p : (_, _, c) promise) ->\n\n        let p = underlying p in\n        match p.state with\n        (* If the promise is not still pending, it can't be canceled. *)\n        | Fulfilled _ ->\n          callbacks_accumulator\n        | Rejected _ ->\n          callbacks_accumulator\n\n        | Pending callbacks ->\n          match callbacks.how_to_cancel with\n          | Not_cancelable ->\n            callbacks_accumulator\n          | Cancel_this_promise ->\n            let State_may_have_changed p =\n              set_promise_state p canceled_result in\n            ignore p;\n            (Packed callbacks)::callbacks_accumulator\n          | Propagate_cancel_to_one p' ->\n            cancel_and_collect_callbacks callbacks_accumulator p'\n          | Propagate_cancel_to_several ps ->\n            List.fold_left cancel_and_collect_callbacks callbacks_accumulator ps\n      in\n      cancel_and_collect_callbacks [] p\n    in\n\n    let Internal p = to_internal_promise p in\n    let callbacks = propagate_cancel p in\n\n    callbacks |> List.iter (fun (Packed callbacks) ->\n      run_callbacks_or_defer_them\n        ~allow_deferring:false callbacks canceled_result)\nend\ninclude Resolving\n\n\n\nmodule Trivial_promises :\nsig\n  val return : 'a -> 'a t\n  val fail : exn -> _ t\n  val of_result : ('a, exn) result -> 'a t\n\n  val return_unit : unit t\n  val return_true : bool t\n  val return_false : bool t\n  val return_none : _ option t\n  val return_some : 'a -> 'a option t\n  val return_ok : 'a -> ('a, _) result t\n  val return_error : 'e -> (_, 'e) result t\n  val return_nil : _ list t\n\n  val fail_with : string -> _ t\n  val fail_invalid_arg : string -> _ t\nend =\nstruct\n  let return v =\n    to_public_promise {state = Fulfilled v}\n\n  let of_result result =\n    to_public_promise {state = state_of_result result}\n\n  let fail exn =\n    to_public_promise {state = Rejected exn}\n\n  let return_unit = return ()\n  let return_none = return None\n  let return_some x = return (Some x)\n  let return_nil = return []\n  let return_true = return true\n  let return_false = return false\n  let return_ok x = return (Ok x)\n  let return_error x = return (Error x)\n\n  let fail_with msg =\n    to_public_promise {state = Rejected (Failure msg)}\n\n  let fail_invalid_arg msg =\n    to_public_promise {state = Rejected (Invalid_argument msg)}\nend\ninclude Trivial_promises\n\n\n\nmodule Pending_promises :\nsig\n  (* Internal *)\n  val new_pending :\n    how_to_cancel:how_to_cancel -> ('a, underlying, pending) promise\n  val propagate_cancel_to_several : _ t list -> how_to_cancel\n\n  (* Initial pending promises (public) *)\n  val wait : unit -> 'a t * 'a u\n  val task : unit -> 'a t * 'a u\n\n  val add_task_r : 'a u Lwt_sequence.t -> 'a t\n  val add_task_l : 'a u Lwt_sequence.t -> 'a t\n\n  val protected : 'a t -> 'a t\n  val no_cancel : 'a t -> 'a t\nend =\nstruct\n  let new_pending ~how_to_cancel =\n    let state =\n      Pending {\n        regular_callbacks = Regular_callback_list_empty;\n        cancel_callbacks = Cancel_callback_list_empty;\n        how_to_cancel;\n        cleanups_deferred = 0;\n      }\n    in\n    {state}\n\n  let propagate_cancel_to_several ps =\n    (* Using a dirty cast here to avoid rebuilding the list :( Not bothering\n       with the invariants, because [Propagate_cancel_to_several] packs them,\n       and code that matches on [Propagate_cancel_to_several] doesn't care about\n       them anyway. *)\n    let cast_promise_list : 'a t list -> ('a, _, _) promise list = Obj.magic in\n    Propagate_cancel_to_several (cast_promise_list ps)\n\n\n\n  let wait () =\n    let p = new_pending ~how_to_cancel:Not_cancelable in\n    to_public_promise p, to_public_resolver p\n\n  let task () =\n    let p = new_pending ~how_to_cancel:Cancel_this_promise in\n    to_public_promise p, to_public_resolver p\n\n\n\n\n  let cast_sequence_node\n      (node : 'a u Lwt_sequence.node)\n      (_actual_content:('a, 'u, 'c) promise)\n        : ('a, 'u, 'c) promise Lwt_sequence.node =\n    Obj.magic node\n\n  let add_task_r sequence =\n    let p = new_pending ~how_to_cancel:Cancel_this_promise in\n    let node = Lwt_sequence.add_r (to_public_resolver p) sequence in\n    let node = cast_sequence_node node p in\n\n    let Pending callbacks = p.state in\n    callbacks.cancel_callbacks <-\n      Cancel_callback_list_remove_sequence_node node;\n\n    to_public_promise p\n\n  let add_task_l sequence =\n    let p = new_pending ~how_to_cancel:Cancel_this_promise in\n    let node = Lwt_sequence.add_l (to_public_resolver p) sequence in\n    let node = cast_sequence_node node p in\n\n    let Pending callbacks = p.state in\n    callbacks.cancel_callbacks <-\n      Cancel_callback_list_remove_sequence_node node;\n\n    to_public_promise p\n\n\n\n  let protected p =\n    let Internal p_internal = to_internal_promise p in\n    match (underlying p_internal).state with\n    | Fulfilled _ -> p\n    | Rejected _ -> p\n\n    | Pending _ ->\n      let p' = new_pending ~how_to_cancel:Cancel_this_promise in\n\n      let callback p_result =\n        let State_may_now_be_pending_proxy p' = may_now_be_proxy p' in\n        let p' = underlying p' in\n        (* In this callback, [p'] will either still itself be pending, or it\n           will have become a proxy for a pending promise. The reasoning for\n           this is almost the same as in the comment at [may_now_be_proxy]. The\n           differences are:\n\n           - [p'] *is* an initial promise, so it *can* get canceled. However, if\n             it does, the [on_cancel] handler installed below will remove this\n             callback.\n           - [p'] never gets passed to [make_into_proxy], the only effect of\n             which is that it cannot be the underlying promise of another\n             (proxy) promise. So, [p'] can only appear at the head of a chain of\n             [Proxy _] links, and it's not necessary to worry about whether the\n             inductive reasoning at [may_now_be_proxy] applies. *)\n\n        let State_may_have_changed p' =\n          resolve ~allow_deferring:false p' p_result in\n        ignore p'\n      in\n\n      let remove_the_callback =\n        add_explicitly_removable_callback_and_give_remove_function\n          [p] callback\n      in\n\n      let Pending p'_callbacks = p'.state in\n      add_cancel_callback p'_callbacks remove_the_callback;\n\n      to_public_promise p'\n\n  let no_cancel p =\n    let Internal p_internal = to_internal_promise p in\n    match (underlying p_internal).state with\n    | Fulfilled _ -> p\n    | Rejected _ -> p\n\n    | Pending p_callbacks ->\n      let p' = new_pending ~how_to_cancel:Not_cancelable in\n\n      let callback p_result =\n        let State_may_now_be_pending_proxy p' = may_now_be_proxy p' in\n        let p' = underlying p' in\n        (* In this callback, [p'] will either still itself be pending, or it\n           will have become a proxy for a pending promise. The reasoning for\n           this is as in [protected] and [may_now_be_proxy], but even simpler,\n           because [p'] is not cancelable. *)\n\n        let State_may_have_changed p' =\n          resolve ~allow_deferring:false p' p_result in\n        ignore p'\n      in\n      add_implicitly_removed_callback p_callbacks callback;\n\n      to_public_promise p'\nend\ninclude Pending_promises\n\n\n\nmodule Sequential_composition :\nsig\n  (* Main interface (public) *)\n  val bind : 'a t -> ('a -> 'b t) -> 'b t\n  val map : ('a -> 'b) -> 'a t -> 'b t\n  external reraise : exn -> 'a = \"%reraise\"\n  val catch : (unit -> 'a t) -> (exn -> 'a t) -> 'a t\n  val finalize : (unit -> 'a t) -> (unit -> unit t) -> 'a t\n  val try_bind : (unit -> 'a t) -> ('a -> 'b t) -> (exn -> 'b t) -> 'b t\n\n  (* Cancel callbacks (public). *)\n  val on_cancel : 'a t -> (unit -> unit) -> unit\n\n  (* Non-promise callbacks (public) *)\n  val on_success : 'a t -> ('a -> unit) -> unit\n  val on_failure : _ t -> (exn -> unit) -> unit\n  val on_termination : _ t -> (unit -> unit) -> unit\n  val on_any : 'a t -> ('a -> unit) -> (exn -> unit) -> unit\n\n  (* Backtrace support (internal; for use by the PPX) *)\n  val backtrace_bind :\n    (exn -> exn) -> 'a t -> ('a -> 'b t) -> 'b t\n  val backtrace_catch :\n    (exn -> exn) -> (unit -> 'a t) -> (exn -> 'a t) -> 'a t\n  val backtrace_finalize :\n    (exn -> exn) -> (unit -> 'a t) -> (unit -> unit t) -> 'a t\n  val backtrace_try_bind :\n    (exn -> exn) -> (unit -> 'a t) -> ('a -> 'b t) -> (exn -> 'b t) -> 'b t\nend =\nstruct\n  (* There are five primary sequential composition functions: [bind], [map],\n     [catch], [finalize], and [try_bind]. Of these, [try_bind] is the most\n     general -- all the others can be implemented in terms of it.\n\n     Lwt conflates concurrency with error propagation. If Lwt did not do this,\n     there would be only two primary functions: [bind] and [map], and, of these\n     two, [bind] is the most general. Since [bind] is the most relevant\n     specifically to concurrency, and is also the most familiar function in Lwt,\n     its implementation serves as a kind of \"model\" for the rest. It is the most\n     commented, and all the other functions follow a similar pattern to [bind].\n\n     Four of the primary functions have [backtrace_*] versions, which are not\n     truly public, and exist to support the PPX. [backtrace_map] does not exist\n     because the PPX does not need it.\n\n     The remaining four functions in this section attach \"lower-level-ish\"\n     non-promise-producing callbacks to promises: these are the [on_*]\n     functions. Of these, [on_any] is the most general. If Lwt did not conflate\n     concurrency with error handling, there would only be one: [on_success]. *)\n\n\n\n  (* Makes [~user_provided_promise] into a proxy of [~outer_promise]. After\n     [make_into_proxy], these two promise references \"behave identically.\"\n\n     Note that this is not symmetric: [user_provided_promise] always becomes the\n     proxy. [make_into_proxy] is called only by [bind] and similar functions in\n     this module. This means that:\n\n     - the only way for a promise to become a proxy is by being returned from\n       the callback given by the user to [bind], or a similar function, and\n     - the only way for a promise to become underlying for a promise other than\n       itself is to be the outer promise originally returned to the user from\n       [bind], or a similar function.\n\n     These two facts are important for reasoning about how and which promises\n     can become proxies, underlying, etc.; in particular, it is used in the\n     argument in [may_now_be_proxy] for correct predictions about state changes.\n\n     [~outer_promise] is always a pending promise when [make_into_proxy] is\n     called; for the explanation, see [may_now_be_proxy] (though the caller of\n     [make_into_proxy] always calls [underlying] first to pass the underlying\n     pending promise to [make_into_proxy]).\n\n     The reasons proxying is used, instead of adding a callback to\n     [~user_provided_promise] to resolve [~outer_promise] when the former\n     becomes resolved probably are:\n\n     - Promises have more behaviors than resolution. One would have to add a\n       cancellation handler to [~outer_promise] to propagate the cancellation\n       back to [~user_provided_promise], for example. It may be easier to just\n       think of them as the same promise.\n     - If using callbacks, resolving [~user_provided_promise] would not\n       immediately resolve [~outer_promise]. Another callback added to\n       [~user_provided_promise] might see [~user_provided_promise] resolved,\n       but [~outer_promise] still pending, depending on the order in which\n       callbacks are run. *)\n  let make_into_proxy\n      (type c)\n      ~(outer_promise : ('a, underlying, pending) promise)\n      ~(user_provided_promise : ('a, _, c) promise)\n        : ('a, underlying, c) state_changed =\n\n    (* Using [p'] as it's the name used inside [bind], etc., for promises with\n       this role -- [p'] is the promise returned by the user's function. *)\n    let p' = underlying user_provided_promise in\n\n    if identical p' outer_promise then\n      State_may_have_changed p'\n      (* We really want to return [State_may_have_changed outer_promise], but\n         the reference through [p'] has the right type. *)\n\n    else\n      match p'.state with\n      | Fulfilled _ ->\n        resolve ~allow_deferring:false outer_promise p'.state\n      | Rejected _ ->\n        resolve ~allow_deferring:false outer_promise p'.state\n\n      | Pending p'_callbacks ->\n        let Pending outer_callbacks = outer_promise.state in\n\n        merge_callbacks ~from:p'_callbacks ~into:outer_callbacks;\n        outer_callbacks.how_to_cancel <- p'_callbacks.how_to_cancel;\n\n        let State_may_have_changed p' =\n          set_promise_state p' (Proxy outer_promise) in\n        ignore p';\n\n        State_may_have_changed outer_promise\n        (* The state hasn't actually changed, but we still have to wrap\n           [outer_promise] for type checking. *)\n\n        (* The state of [p'] may instead have changed -- it may have become a\n           proxy. However, callers of [make_into_proxy] don't know if\n           [user_provided_promise] was a proxy or not (that's why we call\n           underlying on it at the top of this function, to get [p']). We can\n           therefore take a dangerous shortcut and not bother returning a new\n           reference to [user_provided_promise] for shadowing. *)\n\n\n\n  (* Maintainer's note: a lot of the code below can probably be deduplicated in\n     some way, especially if assuming Flambda. *)\n\n  let bind p f =\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    (* In case [Lwt.bind] needs to defer the call to [f], this function will be\n       called to create:\n\n       1. The promise, [p''], that must be returned to the caller immediately.\n       2. The callback that resolves [p''].\n\n       [Lwt.bind] defers the call to [f] in two circumstances:\n\n       1. The promise [p] is pending.\n       2. The promise [p] is fulfilled, but the current callback call nesting\n          depth is such that the call to [f] must go into the callback queue, in\n          order to avoid stack overflow.\n\n      Mechanism (2) is currently disabled. It may be used in an alternative Lwt\n      API.\n\n      Functions other than [Lwt.bind] have analogous deferral behavior. *)\n    let create_result_promise_and_callback_if_deferred () =\n      let p'' = new_pending ~how_to_cancel:(Propagate_cancel_to_one p) in\n      (* The result promise is a fresh pending promise.\n\n         Initially, trying to cancel this fresh pending promise [p''] will\n         propagate the cancellation attempt to [p] (backwards through the\n         promise dependency graph). If/when [p] is fulfilled, Lwt will call the\n         user's callback [f] below, which will provide a new promise [p'], and\n         [p'] will become a proxy of [p'']. At that point, trying to cancel\n         [p''] will be equivalent to trying to cancel [p'], so the behavior will\n         depend on how the user obtained [p']. *)\n\n      let saved_storage = !current_storage in\n\n      let callback p_result =\n        match p_result with\n        | Fulfilled v ->\n          current_storage := saved_storage;\n\n          let p' =\n            try f v with exn\n            when Exception_filter.run exn -> fail exn\n          in\n          let Internal p' = to_internal_promise p' in\n          (* Run the user's function [f]. *)\n\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n          (* [p''] was an underlying promise when it was created above, but it\n             may have become a proxy by the time this code is being executed.\n             However, it is still either an underlying pending promise, or a\n             proxy for a pending promise. Therefore, [may_now_be_proxy] produces\n             a reference with the right type variables. We immediately get\n             [p'']'s current underlying promise. *)\n\n          let State_may_have_changed p'' =\n            make_into_proxy ~outer_promise:p'' ~user_provided_promise:p' in\n          ignore p''\n          (* Make the outer promise [p''] behaviorally identical to the promise\n             [p'] returned by [f] by making [p'] into a proxy of [p'']. *)\n\n        | Rejected _ as p_result ->\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            resolve ~allow_deferring:false p'' p_result in\n          ignore p''\n      in\n\n      (to_public_promise p'', callback)\n    in\n\n    match p.state with\n    | Fulfilled v ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> f v)\n        ~if_deferred:(fun () ->\n          let (p'', callback) =\n            create_result_promise_and_callback_if_deferred () in\n          (p'', callback, p.state))\n\n    | Rejected _ as result ->\n      to_public_promise {state = result}\n\n    | Pending p_callbacks ->\n      let (p'', callback) = create_result_promise_and_callback_if_deferred () in\n      add_implicitly_removed_callback p_callbacks callback;\n      p''\n\n  let backtrace_bind add_loc p f =\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    let create_result_promise_and_callback_if_deferred () =\n      let p'' = new_pending ~how_to_cancel:(Propagate_cancel_to_one p) in\n\n      let saved_storage = !current_storage in\n\n      let callback p_result =\n        match p_result with\n        | Fulfilled v ->\n          current_storage := saved_storage;\n\n          let p' =\n            try f v\n            with exn when Exception_filter.run exn ->\n              fail (add_loc exn) in\n          let Internal p' = to_internal_promise p' in\n\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            make_into_proxy ~outer_promise:p'' ~user_provided_promise:p' in\n          ignore p''\n\n        | Rejected exn ->\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            resolve ~allow_deferring:false p'' (Rejected (add_loc exn)) in\n          ignore p''\n      in\n\n      (to_public_promise p'', callback)\n    in\n\n    match p.state with\n    | Fulfilled v ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> f v)\n        ~if_deferred:(fun () ->\n          let (p'', callback) =\n            create_result_promise_and_callback_if_deferred () in\n          (p'', callback, p.state))\n\n    | Rejected exn ->\n      to_public_promise {state = Rejected (add_loc exn)}\n\n    | Pending p_callbacks ->\n      let (p'', callback) = create_result_promise_and_callback_if_deferred () in\n      add_implicitly_removed_callback p_callbacks callback;\n      p''\n\n  let map f p =\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    let create_result_promise_and_callback_if_deferred () =\n      let p'' = new_pending ~how_to_cancel:(Propagate_cancel_to_one p) in\n\n      let saved_storage = !current_storage in\n\n      let callback p_result =\n        match p_result with\n        | Fulfilled v ->\n          current_storage := saved_storage;\n\n          let p''_result =\n            try Fulfilled (f v) with exn\n            when Exception_filter.run exn -> Rejected exn\n          in\n\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            resolve ~allow_deferring:false p'' p''_result in\n          ignore p''\n\n        | Rejected _ as p_result ->\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            resolve ~allow_deferring:false p'' p_result in\n          ignore p''\n      in\n\n      (to_public_promise p'', callback)\n    in\n\n    match p.state with\n    | Fulfilled v ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () ->\n          to_public_promise\n            {state =\n              try Fulfilled (f v)\n              with exn when Exception_filter.run exn -> Rejected exn})\n        ~if_deferred:(fun () ->\n          let (p'', callback) =\n            create_result_promise_and_callback_if_deferred () in\n          (p'', callback, p.state))\n\n    | Rejected _ as result ->\n      to_public_promise {state = result}\n\n    | Pending p_callbacks ->\n      let (p'', callback) = create_result_promise_and_callback_if_deferred () in\n      add_implicitly_removed_callback p_callbacks callback;\n      p''\n\n  external reraise : exn -> 'a = \"%reraise\"\n\n  let catch f h =\n    let p =\n      try f ()\n      with exn when Exception_filter.run exn -> fail exn\n    in\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    let create_result_promise_and_callback_if_deferred () =\n      let p'' = new_pending ~how_to_cancel:(Propagate_cancel_to_one p) in\n\n      let saved_storage = !current_storage in\n\n      let callback p_result =\n        match p_result with\n        | Fulfilled _ as p_result ->\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            resolve ~allow_deferring:false p'' p_result in\n          ignore p''\n\n        | Rejected exn ->\n          current_storage := saved_storage;\n\n          let p' =\n            try h exn\n            with exn when Exception_filter.run exn -> fail exn\n          in\n          let Internal p' = to_internal_promise p' in\n\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            make_into_proxy ~outer_promise:p'' ~user_provided_promise:p' in\n          ignore p''\n      in\n\n      (to_public_promise p'', callback)\n    in\n\n    match p.state with\n    | Fulfilled _ ->\n      to_public_promise p\n\n    | Rejected exn ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> h exn)\n        ~if_deferred:(fun () ->\n          let (p'', callback) =\n            create_result_promise_and_callback_if_deferred () in\n          (p'', callback, p.state))\n\n    | Pending p_callbacks ->\n      let (p'', callback) = create_result_promise_and_callback_if_deferred () in\n      add_implicitly_removed_callback p_callbacks callback;\n      p''\n\n  let backtrace_catch add_loc f h =\n    let p =\n      try f ()\n      with exn when Exception_filter.run exn -> fail exn\n    in\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    let create_result_promise_and_callback_if_deferred () =\n      let p'' = new_pending ~how_to_cancel:(Propagate_cancel_to_one p) in\n\n      let saved_storage = !current_storage in\n\n      let callback p_result =\n        match p_result with\n        | Fulfilled _ as p_result ->\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            resolve ~allow_deferring:false p'' p_result in\n          ignore p''\n\n        | Rejected exn ->\n          current_storage := saved_storage;\n\n          let p' =\n            try h exn\n            with exn when Exception_filter.run exn ->\n              fail (add_loc exn)\n          in\n          let Internal p' = to_internal_promise p' in\n\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            make_into_proxy ~outer_promise:p'' ~user_provided_promise:p' in\n          ignore p''\n      in\n\n      (to_public_promise p'', callback)\n    in\n\n    match p.state with\n    | Fulfilled _ ->\n      to_public_promise p\n\n    | Rejected exn ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> h (add_loc exn))\n        ~if_deferred:(fun () ->\n          let (p'', callback) =\n            create_result_promise_and_callback_if_deferred () in\n          (p'', callback, p.state))\n\n    | Pending p_callbacks ->\n      let (p'', callback) = create_result_promise_and_callback_if_deferred () in\n      add_implicitly_removed_callback p_callbacks callback;\n      p''\n\n  let try_bind f f' h =\n    let p =\n      try f ()\n      with exn when Exception_filter.run exn -> fail exn\n    in\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    let create_result_promise_and_callback_if_deferred () =\n      let p'' = new_pending ~how_to_cancel:(Propagate_cancel_to_one p) in\n\n      let saved_storage = !current_storage in\n\n      let callback p_result =\n        match p_result with\n        | Fulfilled v ->\n          current_storage := saved_storage;\n\n          let p' =\n            try f' v\n            with exn when Exception_filter.run exn -> fail exn\n          in\n          let Internal p' = to_internal_promise p' in\n\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            make_into_proxy ~outer_promise:p'' ~user_provided_promise:p' in\n          ignore p''\n\n        | Rejected exn ->\n          current_storage := saved_storage;\n\n          let p' =\n            try h exn\n            with exn when Exception_filter.run exn -> fail exn\n          in\n          let Internal p' = to_internal_promise p' in\n\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            make_into_proxy ~outer_promise:p'' ~user_provided_promise:p' in\n          ignore p''\n      in\n\n      (to_public_promise p'', callback)\n    in\n\n    match p.state with\n    | Fulfilled v ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> f' v)\n        ~if_deferred:(fun () ->\n          let (p'', callback) =\n            create_result_promise_and_callback_if_deferred () in\n          (p'', callback, p.state))\n\n    | Rejected exn ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> h exn)\n        ~if_deferred:(fun () ->\n          let (p'', callback) =\n            create_result_promise_and_callback_if_deferred () in\n          (p'', callback, p.state))\n\n    | Pending p_callbacks ->\n      let (p'', callback) = create_result_promise_and_callback_if_deferred () in\n      add_implicitly_removed_callback p_callbacks callback;\n      p''\n\n  let backtrace_try_bind add_loc f f' h =\n    let p =\n      try f ()\n      with exn when Exception_filter.run exn -> fail exn\n    in\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    let create_result_promise_and_callback_if_deferred () =\n      let p'' = new_pending ~how_to_cancel:(Propagate_cancel_to_one p) in\n\n      let saved_storage = !current_storage in\n\n      let callback p_result =\n        match p_result with\n        | Fulfilled v ->\n          current_storage := saved_storage;\n\n          let p' =\n            try f' v\n            with exn when Exception_filter.run exn ->\n              fail (add_loc exn)\n          in\n          let Internal p' = to_internal_promise p' in\n\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            make_into_proxy ~outer_promise:p'' ~user_provided_promise:p' in\n          ignore p''\n\n        | Rejected exn ->\n          current_storage := saved_storage;\n\n          let p' =\n            try h exn\n            with exn when Exception_filter.run exn ->\n              fail (add_loc exn)\n          in\n          let Internal p' = to_internal_promise p' in\n\n          let State_may_now_be_pending_proxy p'' = may_now_be_proxy p'' in\n          let p'' = underlying p'' in\n\n          let State_may_have_changed p'' =\n            make_into_proxy ~outer_promise:p'' ~user_provided_promise:p' in\n          ignore p''\n      in\n\n      (to_public_promise p'', callback)\n    in\n\n    match p.state with\n    | Fulfilled v ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> f' v)\n        ~if_deferred:(fun () ->\n          let (p'', callback) =\n            create_result_promise_and_callback_if_deferred () in\n          (p'', callback, p.state))\n\n    | Rejected exn ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> h (add_loc exn))\n        ~if_deferred:(fun () ->\n          let (p'', callback) =\n            create_result_promise_and_callback_if_deferred () in\n          (p'', callback, p.state))\n\n    | Pending p_callbacks ->\n      let (p'', callback) = create_result_promise_and_callback_if_deferred () in\n      add_implicitly_removed_callback p_callbacks callback;\n      p''\n\n  let finalize f f' =\n    try_bind f\n      (fun x -> bind (f' ()) (fun () -> return x))\n      (fun e -> bind (f' ()) (fun () -> fail e))\n\n  let backtrace_finalize add_loc f f' =\n    backtrace_try_bind add_loc f\n      (fun x -> bind (f' ()) (fun () -> return x))\n      (fun e -> bind (f' ()) (fun () -> fail (add_loc e)))\n\n\n\n  let on_cancel p f =\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    match p.state with\n    | Rejected Canceled ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> handle_with_async_exception_hook f ())\n        ~if_deferred:(fun () ->\n          ((), (fun _ -> handle_with_async_exception_hook f ()), Fulfilled ()))\n\n    | Rejected _ ->\n      ()\n\n    | Fulfilled _ ->\n      ()\n\n    | Pending callbacks ->\n      add_cancel_callback callbacks f\n\n\n\n  let on_success p f =\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    let callback_if_deferred () =\n      let saved_storage = !current_storage in\n\n      fun result ->\n        match result with\n        | Fulfilled v ->\n          current_storage := saved_storage;\n          handle_with_async_exception_hook f v\n\n        | Rejected _ ->\n          ()\n    in\n\n    match p.state with\n    | Fulfilled v ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> handle_with_async_exception_hook f v)\n        ~if_deferred:(fun () ->\n          let callback = callback_if_deferred () in\n          ((), callback, p.state))\n\n    | Rejected _ ->\n      ()\n\n    | Pending p_callbacks ->\n      let callback = callback_if_deferred () in\n      add_implicitly_removed_callback p_callbacks callback\n\n  let on_failure p f =\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    let callback_if_deferred () =\n      let saved_storage = !current_storage in\n\n      fun result ->\n        match result with\n        | Fulfilled _ ->\n          ()\n\n        | Rejected exn ->\n          current_storage := saved_storage;\n          handle_with_async_exception_hook f exn\n    in\n\n    match p.state with\n    | Fulfilled _ ->\n      ()\n\n    | Rejected exn ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> handle_with_async_exception_hook f exn)\n        ~if_deferred:(fun () ->\n          let callback = callback_if_deferred () in\n          ((), callback, p.state))\n\n    | Pending p_callbacks ->\n      let callback = callback_if_deferred () in\n      add_implicitly_removed_callback p_callbacks callback\n\n  let on_termination p f =\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    let callback_if_deferred () =\n      let saved_storage = !current_storage in\n\n      fun _result ->\n        current_storage := saved_storage;\n        handle_with_async_exception_hook f ()\n    in\n\n    match p.state with\n    | Fulfilled _ ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> handle_with_async_exception_hook f ())\n        ~if_deferred:(fun () ->\n          let callback = callback_if_deferred () in\n          ((), callback, p.state))\n\n    | Rejected _ ->\n      run_callback_or_defer_it\n      ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> handle_with_async_exception_hook f ())\n        ~if_deferred:(fun () ->\n          let callback = callback_if_deferred () in\n          ((), callback, p.state))\n\n    | Pending p_callbacks ->\n      let callback = callback_if_deferred () in\n      add_implicitly_removed_callback p_callbacks callback\n\n  let on_any p f g =\n    let Internal p = to_internal_promise p in\n    let p = underlying p in\n\n    let callback_if_deferred () =\n      let saved_storage = !current_storage in\n\n      fun result ->\n        match result with\n        | Fulfilled v ->\n          current_storage := saved_storage;\n          handle_with_async_exception_hook f v\n\n        | Rejected exn ->\n          current_storage := saved_storage;\n          handle_with_async_exception_hook g exn\n    in\n\n    match p.state with\n    | Fulfilled v ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> handle_with_async_exception_hook f v)\n        ~if_deferred:(fun () ->\n          let callback = callback_if_deferred () in\n          ((), callback, p.state))\n\n    | Rejected exn ->\n      run_callback_or_defer_it\n        ~run_immediately_and_ensure_tail_call:true\n        ~callback:(fun () -> handle_with_async_exception_hook g exn)\n        ~if_deferred:(fun () ->\n          let callback = callback_if_deferred () in\n          ((), callback, p.state))\n\n    | Pending p_callbacks ->\n      let callback = callback_if_deferred () in\n      add_implicitly_removed_callback p_callbacks callback\nend\ninclude Sequential_composition\n\n\n(* This belongs with the [protected] and such, but it depends on primitives from\n   [Sequential_composition]. *)\nlet wrap_in_cancelable p =\n let Internal p_internal = to_internal_promise p in\n let p_underlying = underlying p_internal in\n match p_underlying.state with\n | Fulfilled _ -> p\n | Rejected _ -> p\n | Pending _ ->\n   let p', r = task () in\n   on_cancel p' (fun () -> cancel p);\n   on_any p (wakeup r) (wakeup_exn r);\n   p'\n\n\nmodule Concurrent_composition :\nsig\n  val dont_wait : (unit -> _ t) -> (exn -> unit) -> unit\n  val async : (unit -> _ t) -> unit\n  val ignore_result : _ t -> unit\n\n  val both : 'a t -> 'b t -> ('a * 'b) t\n  val join : unit t list -> unit t\n  val all : ('a t) list -> ('a list) t\n\n  val choose : 'a t list -> 'a t\n  val pick : 'a t list -> 'a t\n\n  val nchoose : 'a t list -> 'a list t\n  val npick : 'a t list -> 'a list t\n\n  val nchoose_split : 'a t list -> ('a list * 'a t list) t\nend =\nstruct\n  external reraise : exn -> 'a = \"%reraise\"\n\n  let dont_wait f h =\n    let p =\n      try f ()\n      with exn when Exception_filter.run exn -> fail exn\n    in\n    let Internal p = to_internal_promise p in\n\n    match (underlying p).state with\n    | Fulfilled _ ->\n      ()\n    | Rejected exn ->\n      h exn\n\n    | Pending p_callbacks ->\n      let callback result =\n        match result with\n        | Fulfilled _ ->\n          ()\n        | Rejected exn ->\n          h exn\n      in\n      add_implicitly_removed_callback p_callbacks callback\n\n  let async f =\n    let p =\n      try f ()\n      with exn when Exception_filter.run exn -> fail exn\n    in\n    let Internal p = to_internal_promise p in\n\n    match (underlying p).state with\n    | Fulfilled _ ->\n      ()\n    | Rejected exn ->\n      !async_exception_hook exn\n\n    | Pending p_callbacks ->\n      let callback result =\n        match result with\n        | Fulfilled _ ->\n          ()\n        | Rejected exn ->\n          !async_exception_hook exn\n      in\n      add_implicitly_removed_callback p_callbacks callback\n\n  let ignore_result p =\n    let Internal p = to_internal_promise p in\n\n    match (underlying p).state with\n    | Fulfilled _ ->\n      ()\n    | Rejected exn ->\n      reraise exn\n\n    | Pending p_callbacks ->\n      let callback result =\n        match result with\n        | Fulfilled _ ->\n          ()\n        | Rejected exn ->\n          !async_exception_hook exn\n      in\n      add_implicitly_removed_callback p_callbacks callback\n\n\n\n  let join ps =\n    let p' = new_pending ~how_to_cancel:(propagate_cancel_to_several ps) in\n\n    let number_pending_in_ps = ref 0 in\n    let join_result = ref (Fulfilled ()) in\n\n    (* Callback attached to each promise in [ps] that is still pending at the\n       time [join] is called. *)\n    let callback new_result =\n      let State_may_now_be_pending_proxy p' = may_now_be_proxy p' in\n\n      begin match new_result with\n      | Fulfilled () -> ()\n      | Rejected _ ->\n      (* For the first promise in [ps] to be rejected, set the result of the\n         [join] to rejected with the same exception.. *)\n        match !join_result with\n        | Fulfilled () -> join_result := new_result\n        | Rejected _ -> ()\n      end;\n\n      (* In all cases, decrement the number of promises still pending, and\n         resolve the [join] once all promises resolve. *)\n      number_pending_in_ps := !number_pending_in_ps - 1;\n      if !number_pending_in_ps = 0 then begin\n        let p' = underlying p' in\n        let State_may_have_changed p' =\n          resolve ~allow_deferring:false (underlying p') !join_result in\n        ignore p'\n      end\n    in\n\n    (* Attach the above callback. Simultaneously count how many pending promises\n       there are in [ps] (initially). If that number is zero, the [join] must\n       resolve immediately. *)\n    let rec attach_callback_or_resolve_immediately ps =\n      match ps with\n      | [] ->\n        if !number_pending_in_ps = 0 then\n          to_public_promise {state = !join_result}\n        else\n          to_public_promise p'\n\n      | p::ps ->\n        let Internal p = to_internal_promise p in\n\n        match (underlying p).state with\n        | Pending p_callbacks ->\n          number_pending_in_ps := !number_pending_in_ps + 1;\n          add_implicitly_removed_callback p_callbacks callback;\n          attach_callback_or_resolve_immediately ps\n\n        | Rejected _ as p_result ->\n          (* As in the callback above, but for already-resolved promises in\n             [ps]: reject the [join] with the same exception as in the first\n             rejected promise found. [join] still waits for any pending promises\n             before actually resolving, though. *)\n          begin match !join_result with\n          | Fulfilled () -> join_result := p_result;\n          | Rejected _ -> ()\n          end;\n          attach_callback_or_resolve_immediately ps\n\n        | Fulfilled () ->\n          attach_callback_or_resolve_immediately ps\n    in\n\n    attach_callback_or_resolve_immediately ps\n\n  (* this is 3 words, smaller than the 2 times 2 words a pair of references\n     would take. *)\n  type ('a,'b) pair = {\n    mutable x1: 'a option;\n    mutable x2: 'b option;\n  }\n\n  let both p1 p2 =\n    let pair = {x1 = None; x2 = None} in\n    let p1' = bind p1 (fun v -> pair.x1 <- Some v; return_unit) in\n    let p2' = bind p2 (fun v -> pair.x2 <- Some v; return_unit) in\n    join [p1'; p2'] |> map (fun () ->\n      match pair.x1, pair.x2 with\n      | Some v1, Some v2 -> v1, v2\n      | _ -> assert false)\n\n  let all ps =\n    match ps with\n    | [] -> return_nil\n    | [x] -> map (fun y -> [y]) x\n    | [x; y] -> map (fun (x, y) -> [x; y]) (both x y)\n    | _ ->\n      let vs = Array.make (List.length ps) None in\n      ps\n      |> List.mapi (fun index p ->\n        bind p (fun v -> vs.(index) <- Some v; return_unit))\n      |> join\n      |> map (fun () ->\n          let rec to_list_unopt i acc =\n            if i < 0 then\n              acc\n            else\n              match Array.unsafe_get vs i with\n              | None -> assert false\n              | Some x -> to_list_unopt (i - 1) (x::acc)\n          in\n          to_list_unopt (Array.length vs - 1) [])\n\n  (* Maintainer's note: the next few functions are helpers for [choose] and\n     [pick]. Perhaps they should be factored into some kind of generic\n     [choose]/[pick] implementation, which may actually be optimal anyway with\n     Flambda. *)\n\n  let count_resolved_promises_in (ps : 'a t list) =\n    let rec count_and_gather_rejected total rejected ps =\n       match ps with\n       | [] -> Error (total, rejected)\n       | p :: ps ->\n            let Internal q = to_internal_promise p in\n            match (underlying q).state with\n            | Fulfilled _ -> count_and_gather_rejected total rejected ps\n            | Rejected _ -> count_and_gather_rejected (total + 1) (p :: rejected) ps\n            | Pending _ -> count_and_gather_rejected total rejected ps\n    in\n    let rec count_fulfilled total ps =\n       match ps with\n       | [] -> Ok total\n       | p :: ps ->\n            let Internal q = to_internal_promise p in\n            match (underlying q).state with\n            | Fulfilled _ -> count_fulfilled (total + 1) ps\n            | Rejected _ -> count_and_gather_rejected 1 [p] ps\n            | Pending _ -> count_fulfilled total ps\n    in\n    count_fulfilled 0 ps\n\n  (* Evaluates to the [n]th promise in [ps], among only those promises in [ps]\n     that are resolved. The caller is expected to ensure that there are at\n     least [n] resolved promises in [ps]. *)\n  let rec nth_resolved (ps : 'a t list) (n : int) : 'a t =\n    match ps with\n    | [] ->\n      assert false\n\n    | p::ps ->\n      let Internal p' = to_internal_promise p in\n      match (underlying p').state with\n      | Pending _ ->\n        nth_resolved ps n\n\n      | Fulfilled _ ->\n        if n <= 0 then p\n        else nth_resolved ps (n - 1)\n      | Rejected _ ->\n        if n <= 0 then p\n        else nth_resolved ps (n - 1)\n\n  (* Like [nth_resolved], but cancels all pending promises found while\n     traversing [ps]. *)\n  let rec nth_resolved_and_cancel_pending (ps : 'a t list) (n : int) : 'a t =\n    match ps with\n    | [] ->\n      assert false\n\n    | p::ps ->\n      let Internal p' = to_internal_promise p in\n      match (underlying p').state with\n      | Pending _ ->\n        cancel p;\n        nth_resolved_and_cancel_pending ps n\n\n      | Fulfilled _ ->\n        if n <= 0 then (List.iter cancel ps; p)\n        else nth_resolved_and_cancel_pending ps (n - 1)\n      | Rejected _ ->\n        if n <= 0 then (List.iter cancel ps; p)\n        else nth_resolved_and_cancel_pending ps (n - 1)\n\n  (* The PRNG state is initialized with a constant to make non-IO-based programs\n     deterministic. *)\n  (* Maintainer's note: is this necessary? *)\n  let prng = lazy (Random.State.make [||])\n\n  let choose ps =\n    if ps = [] then\n      invalid_arg\n        \"Lwt.choose [] would return a promise that is pending forever\";\n    match count_resolved_promises_in ps with\n    | Ok 0 ->\n      let p = new_pending ~how_to_cancel:(propagate_cancel_to_several ps) in\n\n      let callback result =\n        let State_may_now_be_pending_proxy p = may_now_be_proxy p in\n        let p = underlying p in\n        let State_may_have_changed p =\n          resolve ~allow_deferring:false p result in\n        ignore p\n      in\n      add_explicitly_removable_callback_to_each_of ps callback;\n\n      to_public_promise p\n\n    | Ok 1 ->\n      nth_resolved ps 0\n\n    | Ok n ->\n      nth_resolved ps (Random.State.int (Lazy.force prng) n)\n\n    | Error (n, ps) ->\n      nth_resolved ps (Random.State.int (Lazy.force prng) n)\n\n  let pick ps =\n    if ps = [] then\n      invalid_arg \"Lwt.pick [] would return a promise that is pending forever\";\n    match count_resolved_promises_in ps with\n    | Ok 0 ->\n      let p = new_pending ~how_to_cancel:(propagate_cancel_to_several ps) in\n\n      let callback result =\n        let State_may_now_be_pending_proxy p = may_now_be_proxy p in\n        List.iter cancel ps;\n        let p = underlying p in\n        let State_may_have_changed p =\n          resolve ~allow_deferring:false p result in\n        ignore p\n      in\n      add_explicitly_removable_callback_to_each_of ps callback;\n\n      to_public_promise p\n\n    | Ok 1 ->\n      nth_resolved_and_cancel_pending ps 0\n\n    | Ok n ->\n      nth_resolved_and_cancel_pending ps\n        (Random.State.int (Lazy.force prng) n)\n\n    | Error (n, qs) ->\n      List.iter cancel ps;\n      nth_resolved qs (Random.State.int (Lazy.force prng) n)\n\n\n\n  (* If [nchoose ps] or [npick ps] found all promises in [ps] pending, the\n     callback added to each promise in [ps] eventually calls this function. The\n     function collects promises in [ps] that have become fulfilled, or finds one\n     promise in [ps] that has been rejected. It then returns the desired state\n     of the final promise: either the list of results collected, or the\n     exception found. *)\n  let rec collect_fulfilled_promises_after_pending\n      (results : 'a list)\n      (ps : 'a t list) :\n        ('a list resolved_state) =\n\n    match ps with\n    | [] ->\n      Fulfilled (List.rev results)\n\n    | p::ps ->\n      let Internal p = to_internal_promise p in\n\n      match (underlying p).state with\n      | Fulfilled v ->\n        collect_fulfilled_promises_after_pending (v::results) ps\n\n      | Rejected _ as result ->\n        result\n\n      | Pending _ ->\n        collect_fulfilled_promises_after_pending results ps\n\n  let nchoose ps =\n    (* If at least one promise in [ps] is found fulfilled, this function is\n       called to find all such promises. *)\n    if ps = [] then\n      invalid_arg\n        \"Lwt.nchoose [] would return a promise that is pending forever\";\n    let rec collect_already_fulfilled_promises_or_find_rejected acc ps =\n      match ps with\n      | [] ->\n        return (List.rev acc)\n\n      | p::ps ->\n        let Internal p = to_internal_promise p in\n        match (underlying p).state with\n        | Fulfilled v ->\n          collect_already_fulfilled_promises_or_find_rejected (v::acc) ps\n\n        | Rejected _ as result ->\n          to_public_promise {state = result}\n\n        | Pending _ ->\n          collect_already_fulfilled_promises_or_find_rejected acc ps\n    in\n\n    (* Looks for already-resolved promises in [ps]. If none are fulfilled or\n       rejected, adds a callback to all promises in [ps] (all of which are\n       pending). *)\n    let rec check_for_already_resolved_promises ps' =\n      match ps' with\n      | [] ->\n        let p = new_pending ~how_to_cancel:(propagate_cancel_to_several ps) in\n\n        let callback _result =\n          let State_may_now_be_pending_proxy p = may_now_be_proxy p in\n          let p = underlying p in\n          let result = collect_fulfilled_promises_after_pending [] ps in\n          let State_may_have_changed p =\n            resolve ~allow_deferring:false p result in\n          ignore p\n        in\n        add_explicitly_removable_callback_to_each_of ps callback;\n\n        to_public_promise p\n\n      | p::ps ->\n        let Internal p = to_internal_promise p in\n        match (underlying p).state with\n        | Fulfilled v ->\n          collect_already_fulfilled_promises_or_find_rejected [v] ps\n\n        | Rejected _ as result ->\n          to_public_promise {state = result}\n\n        | Pending _ ->\n          check_for_already_resolved_promises ps\n    in\n\n    let p = check_for_already_resolved_promises ps in\n    p\n\n  (* See [nchoose]. This function differs only in having additional calls to\n     [cancel]. *)\n  let npick ps =\n    if ps = [] then\n      invalid_arg \"Lwt.npick [] would return a promise that is pending forever\";\n    let rec collect_already_fulfilled_promises_or_find_rejected acc ps' =\n      match ps' with\n      | [] ->\n        List.iter cancel ps;\n        return (List.rev acc)\n\n      | p::ps' ->\n        let Internal p = to_internal_promise p in\n        match (underlying p).state with\n        | Fulfilled v ->\n          collect_already_fulfilled_promises_or_find_rejected (v::acc) ps'\n\n        | Rejected _ as result ->\n          List.iter cancel ps;\n          to_public_promise {state = result}\n\n        | Pending _ ->\n          collect_already_fulfilled_promises_or_find_rejected acc ps'\n    in\n\n    let rec check_for_already_resolved_promises ps' =\n      match ps' with\n      | [] ->\n        let p = new_pending ~how_to_cancel:(propagate_cancel_to_several ps) in\n\n        let callback _result =\n          let State_may_now_be_pending_proxy p = may_now_be_proxy p in\n          let p = underlying p in\n          let result = collect_fulfilled_promises_after_pending [] ps in\n          List.iter cancel ps;\n          let State_may_have_changed p =\n            resolve ~allow_deferring:false p result in\n          ignore p\n        in\n        add_explicitly_removable_callback_to_each_of ps callback;\n\n        to_public_promise p\n\n      | p::ps' ->\n        let Internal p = to_internal_promise p in\n        match (underlying p).state with\n        | Fulfilled v ->\n          collect_already_fulfilled_promises_or_find_rejected [v] ps'\n\n        | Rejected _ as result ->\n          List.iter cancel ps;\n          to_public_promise {state = result}\n\n        | Pending _ ->\n          check_for_already_resolved_promises ps'\n    in\n\n    let p = check_for_already_resolved_promises ps in\n    p\n\n\n\n  (* Same general pattern as [npick] and [nchoose]. *)\n  let nchoose_split ps =\n    if ps = [] then\n      invalid_arg\n        \"Lwt.nchoose_split [] would return a promise that is pending forever\";\n    let rec finish\n        (to_resolve : ('a list * 'a t list, underlying, pending) promise)\n        (fulfilled : 'a list)\n        (pending : 'a t list)\n        (ps : 'a t list)\n          : ('a list * 'a t list, underlying, resolved) state_changed =\n\n      match ps with\n      | [] ->\n        resolve ~allow_deferring:false to_resolve\n          (Fulfilled (List.rev fulfilled, List.rev pending))\n\n      | p::ps ->\n        let Internal p_internal = to_internal_promise p in\n        match (underlying p_internal).state with\n        | Fulfilled v ->\n          finish to_resolve (v::fulfilled) pending ps\n\n        | Rejected _ as result ->\n          resolve ~allow_deferring:false to_resolve result\n\n        | Pending _ ->\n          finish to_resolve fulfilled (p::pending) ps\n    in\n\n    let rec collect_already_resolved_promises results pending ps =\n      match ps with\n      | [] ->\n        (* Maintainer's note: should the pending promise list also be\n           reversed? It is reversed in finish. *)\n        return (List.rev results, pending)\n\n      | p::ps ->\n        let Internal p_internal = to_internal_promise p in\n        match (underlying p_internal).state with\n        | Fulfilled v ->\n          collect_already_resolved_promises (v::results) pending ps\n\n        | Rejected _ as result ->\n          to_public_promise {state = result}\n\n        | Pending _ ->\n          collect_already_resolved_promises results (p::pending) ps\n    in\n\n    let rec check_for_already_resolved_promises pending_acc ps' =\n      match ps' with\n      | [] ->\n        let p = new_pending ~how_to_cancel:(propagate_cancel_to_several ps) in\n\n        let callback _result =\n          let State_may_now_be_pending_proxy p = may_now_be_proxy p in\n          let p = underlying p in\n          let State_may_have_changed p = finish p [] [] ps in\n          ignore p\n        in\n        add_explicitly_removable_callback_to_each_of ps callback;\n\n        to_public_promise p\n\n      | p::ps' ->\n        let Internal p_internal = to_internal_promise p in\n        match (underlying p_internal).state with\n        | Fulfilled v ->\n          collect_already_resolved_promises [v] pending_acc ps'\n\n        | Rejected _ as result ->\n          to_public_promise {state = result}\n\n        | Pending _ ->\n          check_for_already_resolved_promises (p::pending_acc) ps'\n    in\n\n    let p = check_for_already_resolved_promises [] ps in\n    p\nend\ninclude Concurrent_composition\n\n\n\nmodule Miscellaneous :\nsig\n  (* Promise state query *)\n  type 'a state =\n    | Return of 'a\n    | Fail of exn\n    | Sleep\n\n  val state : 'a t -> 'a state\n  val is_sleeping : 'a t -> bool\n  val debug_state_is : 'a state -> 'a t -> bool t\n\n  (* Function lifters *)\n  val apply : ('a -> 'b t) -> 'a -> 'b t\n\n  val wrap :\n    (unit -> 'b) ->\n    'b t\n  val wrap1 :\n    ('a1 -> 'b) ->\n    ('a1 -> 'b t)\n  val wrap2 :\n    ('a1 -> 'a2 -> 'b) ->\n    ('a1 -> 'a2 -> 'b t)\n  val wrap3 :\n    ('a1 -> 'a2 -> 'a3 -> 'b) ->\n    ('a1 -> 'a2 -> 'a3 -> 'b t)\n  val wrap4 :\n    ('a1 -> 'a2 -> 'a3 -> 'a4 -> 'b) ->\n    ('a1 -> 'a2 -> 'a3 -> 'a4 -> 'b t)\n  val wrap5 :\n    ('a1 -> 'a2 -> 'a3 -> 'a4 -> 'a5 -> 'b) ->\n    ('a1 -> 'a2 -> 'a3 -> 'a4 -> 'a5 -> 'b t)\n  val wrap6 :\n    ('a1 -> 'a2 -> 'a3 -> 'a4 -> 'a5 -> 'a6 -> 'b) ->\n    ('a1 -> 'a2 -> 'a3 -> 'a4 -> 'a5 -> 'a6 -> 'b t)\n  val wrap7 :\n    ('a1 -> 'a2 -> 'a3 -> 'a4 -> 'a5 -> 'a6 -> 'a7 -> 'b) ->\n    ('a1 -> 'a2 -> 'a3 -> 'a4 -> 'a5 -> 'a6 -> 'a7 -> 'b t)\n\n  (* Paused promises *)\n  val pause : unit -> unit t\n  val wakeup_paused : unit -> unit\n  val paused_count : unit -> int\n  val register_pause_notifier : (int -> unit) -> unit\n  val abandon_paused : unit -> unit\n\n  (* Internal interface for other modules in Lwt *)\n  val poll : 'a t -> 'a option\nend =\nstruct\n  type 'a state =\n    | Return of 'a\n    | Fail of exn\n    | Sleep\n\n  external reraise : exn -> 'a = \"%reraise\"\n\n  let state p =\n    let Internal p = to_internal_promise p in\n    match (underlying p).state with\n    | Fulfilled v -> Return v\n    | Rejected exn -> Fail exn\n    | Pending _ -> Sleep\n\n  let debug_state_is expected_state p =\n    return (state p = expected_state)\n\n  let is_sleeping p =\n    let Internal p = to_internal_promise p in\n    match (underlying p).state with\n    | Fulfilled _ -> false\n    | Rejected _ -> false\n    | Pending _ -> true\n\n  let poll p =\n    let Internal p = to_internal_promise p in\n    match (underlying p).state with\n    | Rejected e -> reraise e\n    | Fulfilled v -> Some v\n    | Pending _ -> None\n\n\n\n  let apply f x =\n    try f x with exn when Exception_filter.run exn -> fail exn\n\n  let wrap f =\n    try return (f ())\n    with exn when Exception_filter.run exn -> fail exn\n\n  let wrap1 f x1 =\n    try return (f x1)\n    with exn when Exception_filter.run exn -> fail exn\n\n  let wrap2 f x1 x2 =\n    try return (f x1 x2)\n    with exn when Exception_filter.run exn -> fail exn\n\n  let wrap3 f x1 x2 x3 =\n    try return (f x1 x2 x3)\n    with exn when Exception_filter.run exn -> fail exn\n\n  let wrap4 f x1 x2 x3 x4 =\n    try return (f x1 x2 x3 x4)\n    with exn when Exception_filter.run exn -> fail exn\n\n  let wrap5 f x1 x2 x3 x4 x5 =\n    try return (f x1 x2 x3 x4 x5)\n    with exn when Exception_filter.run exn -> fail exn\n\n  let wrap6 f x1 x2 x3 x4 x5 x6 =\n    try return (f x1 x2 x3 x4 x5 x6)\n    with exn when Exception_filter.run exn -> fail exn\n\n  let wrap7 f x1 x2 x3 x4 x5 x6 x7 =\n    try return (f x1 x2 x3 x4 x5 x6 x7)\n    with exn when Exception_filter.run exn -> fail exn\n\n\n\n  let pause_hook = ref ignore\n\n  let paused = Lwt_sequence.create ()\n  let paused_count = ref 0\n\n  let pause () =\n    let p = add_task_r paused in\n    incr paused_count;\n    !pause_hook !paused_count;\n    p\n\n  let wakeup_paused () =\n    if Lwt_sequence.is_empty paused then\n      paused_count := 0\n    else begin\n      let tmp = Lwt_sequence.create () in\n      Lwt_sequence.transfer_r paused tmp;\n      paused_count := 0;\n      Lwt_sequence.iter_l (fun r -> wakeup r ()) tmp\n    end\n\n  let register_pause_notifier f = pause_hook := f\n\n  let abandon_paused () =\n    Lwt_sequence.clear paused;\n    paused_count := 0\n\n  let paused_count () = !paused_count\nend\ninclude Miscellaneous\n\nmodule Let_syntax =\nstruct\n  module Let_syntax =\n  struct\n    let return = return\n    let map t ~f = map f t\n    let bind t ~f = bind t f\n    let both = both\n\n    module Open_on_rhs =\n    struct\n    end\n  end\nend\n\nmodule Infix =\nstruct\n  let (>>=) = bind\n  let (=<<) f p = bind p f\n  let (>|=) p f = map f p\n  let (=|<) = map\n  let (<&>) p p' = join [p; p']\n  let (<?>) p p' = choose [p; p']\n\n  include Let_syntax\nend\ninclude ( Infix : module type of Infix with module Let_syntax := Let_syntax.Let_syntax )\n\nmodule Syntax =\nstruct\n  let (let*) = bind\n  let (and*) = both\n\n  let (let+) x f = map f x\n  let (and+) = both\nend\n","(* Js_of_ocaml library\n * http://www.ocsigen.org/js_of_ocaml/\n * Copyright (C) 2010 Jérôme Vouillon\n * Laboratoire PPS - CNRS Université Paris Diderot\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, with linking exception;\n * either version 2.1 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *)\n\nopen Js_of_ocaml\nopen! Import\n\nlet sleep d =\n  let t, w = Lwt.task () in\n  let id = Dom_html.setTimeout (Lwt.wakeup w) (d *. 1000.) in\n  Lwt.on_cancel t (fun () -> Dom_html.clearTimeout id);\n  t\n\nlet yield () = sleep 0.\n\nlet wakeup = function\n  | 1 ->\n      ignore\n        (Dom_html.window##setTimeout (Js.wrap_callback Lwt.wakeup_paused) (Js.float 0.))\n  | _ -> ()\n\nlet () = Lwt.register_pause_notifier wakeup\n\nlet prerr_string s = Console.console##log (Js.string s)\n\nlet _ =\n  Lwt.async_exception_hook :=\n    fun exn ->\n      prerr_string \"Exception during Lwt.async: \";\n      prerr_string (Printexc.to_string exn);\n      Printexc.print_backtrace stderr\n","type t =\n  { len : int\n  ; bits : Bytes.t\n  }\n\nlet byte s i = Char.code (Bytes.unsafe_get s i)\nlet set_byte s i x = Bytes.unsafe_set s i (Char.chr x)\nlet length t = t.len\n\nlet unsafe_set v n b =\n  let i = n lsr 3 in\n  let c = byte v.bits i in\n  let mask = 1 lsl (n land 7) in\n  set_byte v.bits i (if b then c lor mask else c land lnot mask)\n;;\n\nlet set v n b =\n  if n < 0 || n >= v.len then invalid_arg \"Bit_vector.set\";\n  unsafe_set v n b\n;;\n\nlet unsafe_get v n =\n  let i = n lsr 3 in\n  byte v.bits i land (1 lsl (n land 7)) > 0\n;;\n\nlet get v n =\n  if n < 0 || n >= v.len then invalid_arg \"Bit_vector.get\";\n  unsafe_get v n\n;;\n\nlet reset_zero t = Bytes.fill t.bits 0 (Bytes.length t.bits) '\\000'\n\nlet create_zero len =\n  let bits =\n    let r = len land 7 in\n    let q = len lsr 3 in\n    let len = if r = 0 then q else q + 1 in\n    Bytes.make len '\\000'\n  in\n  { len; bits }\n;;\n\nlet pp fmt { len; bits } =\n  let len fmt () = Fmt.sexp fmt \"len\" Fmt.int len in\n  let bits fmt () = Fmt.sexp fmt \"bits\" Fmt.bytes bits in\n  Format.fprintf fmt \"%a@.%a@.\" len () bits ()\n;;\n","type t = int\n\nlet equal (x : int) (y : int) = x = y\nlet compare (x : int) (y : int) = compare x y\nlet to_int x = x\nlet pp = Format.pp_print_int\nlet intersect x y = x land y <> 0\nlet ( ++ ) x y = x lor y\nlet dummy = -1\nlet inexistant = 1\nlet letter = 2\nlet not_letter = 4\nlet newline = 8\nlet lastnewline = 16\nlet search_boundary = 32\nlet to_dyn = Dyn.int\n\nlet from_char = function\n  (* Should match [cword] definition *)\n  | 'a' .. 'z'\n  | 'A' .. 'Z'\n  | '0' .. '9'\n  | '_' | '\\170' | '\\181' | '\\186'\n  | '\\192' .. '\\214'\n  | '\\216' .. '\\246'\n  | '\\248' .. '\\255' -> letter\n  | '\\n' -> not_letter ++ newline\n  | _ -> not_letter\n;;\n","let make ~size ~f =\n  let cache = Array.init size f in\n  fun i -> cache.(i)\n;;\n","module List = Stdlib.ListLabels\n\nmodule Poly = struct\n  let equal = ( = )\n  let compare = compare\nend\n\nmodule Phys_equal = struct\n  let equal = ( == )\nend\n\nlet ( = ) = Int.equal\nlet ( == ) = [ `Use_phys_equal ]\nlet ( < ) (x : int) (y : int) = x < y\nlet ( > ) (x : int) (y : int) = x > y\nlet min = Int.min\nlet max = Int.max\nlet compare = Int.compare\n\nmodule Int = struct\n  let[@warning \"-32\"] hash (x : int) = Hashtbl.hash x\n\n  include Stdlib.Int\nend\n","module List = struct end\nopen Import\n\n(*\n   RE - A regular expression library\n\n   Copyright (C) 2001 Jerome Vouillon\n   email: Jerome.Vouillon@pps.jussieu.fr\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation, with\n   linking exception; either version 2.1 of the License, or (at\n   your option) any later version.\n\n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with this library; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n*)\n\ntype c = int\n\nlet equal_c = Int.equal\nlet to_int x = x\nlet of_int x = x\nlet to_char t = Char.chr t\nlet of_char c = Char.code c\nlet null_char = -1\n\ntype t = (c * c) list\n\nlet compare_pair (x, y) (x', y') =\n  match Int.compare x x' with\n  | 0 -> Int.compare y y'\n  | x -> x\n;;\n\nlet equal_pair (x, y) (x', y') = Int.equal x x' && Int.equal y y'\nlet equal x y = List.equal ~eq:equal_pair x y\nlet compare x y = List.compare ~cmp:compare_pair x y\n\nlet rec union l l' =\n  match l, l' with\n  | _, [] -> l\n  | [], _ -> l'\n  | (c1, c2) :: r, (c1', c2') :: r' ->\n    if c2 + 1 < c1'\n    then (c1, c2) :: union r l'\n    else if c2' + 1 < c1\n    then (c1', c2') :: union l r'\n    else if c2 < c2'\n    then union r ((min c1 c1', c2') :: r')\n    else union ((min c1 c1', c2) :: r) r'\n;;\n\nlet rec inter l l' =\n  match l, l' with\n  | _, [] -> []\n  | [], _ -> []\n  | (c1, c2) :: r, (c1', c2') :: r' ->\n    if c2 < c1'\n    then inter r l'\n    else if c2' < c1\n    then inter l r'\n    else if c2 < c2'\n    then (max c1 c1', c2) :: inter r l'\n    else (max c1 c1', c2') :: inter l r'\n;;\n\nlet rec diff l l' =\n  match l, l' with\n  | _, [] -> l\n  | [], _ -> []\n  | (c1, c2) :: r, (c1', c2') :: r' ->\n    if c2 < c1'\n    then (c1, c2) :: diff r l'\n    else if c2' < c1\n    then diff l r'\n    else (\n      let r'' = if c2' < c2 then (c2' + 1, c2) :: r else r in\n      if c1 < c1' then (c1, c1' - 1) :: diff r'' r' else diff r'' r')\n;;\n\nlet single =\n  let single c = [ c, c ] in\n  Dense_map.make (* an extra color for lnl *) ~size:257 ~f:single\n;;\n\nlet csingle i = single (Char.code i)\nlet add c l = union (single c) l\nlet seq c c' = if c <= c' then [ c, c' ] else [ c', c ]\n\nlet rec offset o l =\n  match l with\n  | [] -> []\n  | (c1, c2) :: r -> (c1 + o, c2 + o) :: offset o r\n;;\n\nlet empty : t = []\nlet cany = [ 0, 255 ]\nlet union_all ts = List.fold_left ~init:empty ~f:union ts\nlet intersect_all ts = List.fold_left ~init:cany ~f:inter ts\n\nlet rec mem (c : int) s =\n  match s with\n  | [] -> false\n  | (c1, c2) :: rem -> if c <= c2 then c >= c1 else mem c rem\n;;\n\n(****)\n\nlet rec hash_rec = function\n  | [] -> 0\n  | (i, j) :: r -> i + (13 * j) + (257 * hash_rec r)\n;;\n\nlet hash l = hash_rec l land 0x3FFFFFFF\n\n(****)\n\nlet print_one ch (c1, c2) =\n  if Int.equal c1 c2 then Format.fprintf ch \"%d\" c1 else Format.fprintf ch \"%d-%d\" c1 c2\n;;\n\nlet pp ts = Fmt.list ~pp_sep:(Fmt.lit \", \") print_one ts\n\nlet to_dyn t =\n  let open Dyn in\n  match t with\n  | [ (x, y) ] when Int.equal x y -> int x\n  | _ -> List.map t ~f:(fun (x, y) -> pair (int x) (int y)) |> list\n;;\n\nlet rec iter t ~f =\n  match t with\n  | [] -> ()\n  | (x, y) :: xs ->\n    f x y;\n    iter xs ~f\n;;\n\nlet one_char = function\n  | [ (i, j) ] when Int.equal i j -> Some i\n  | _ -> None\n;;\n\nmodule CSetMap = Map.Make (struct\n    type t = int * (int * int) list\n\n    let compare (i, u) (j, v) =\n      let c = Int.compare i j in\n      if c <> 0 then c else compare u v\n    ;;\n  end)\n\nlet fold_right t ~init ~f = List.fold_right ~f:(fun (x, y) acc -> f x y acc) t ~init\n\nlet is_empty = function\n  | [] -> true\n  | _ -> false\n;;\n\nlet rec prepend s x l =\n  match s, l with\n  | [], _ -> l\n  | _r, [] -> []\n  | (_c, c') :: r, ([ (d, _d') ], _x') :: _r' when c' < d -> prepend r x l\n  | (c, c') :: r, ([ (d, d') ], x') :: r' ->\n    if c <= d\n    then\n      if c' < d'\n      then ([ d, c' ], x @ x') :: prepend r x (([ c' + 1, d' ], x') :: r')\n      else ([ d, d' ], x @ x') :: prepend s x r'\n    else if c > d'\n    then ([ d, d' ], x') :: prepend s x r'\n    else ([ d, c - 1 ], x') :: prepend s x (([ c, d' ], x') :: r')\n  | _ -> assert false\n;;\n\nlet pick = function\n  | [] -> invalid_arg \"Re_cset.pick\"\n  | (x, _) :: _ -> x\n;;\n\nlet cseq c c' = seq (of_char c) (of_char c')\nlet rg = cseq\nlet char = csingle\nlet upper = union_all [ cseq 'A' 'Z'; cseq '\\192' '\\214'; cseq '\\216' '\\222' ]\nlet clower = offset 32 upper\nlet cdigit = cseq '0' '9'\nlet ascii = cseq '\\000' '\\127'\nlet cadd c s = add (of_char c) s\nlet space = add (of_char ' ') (cseq '\\009' '\\013')\nlet xdigit = union_all [ cdigit; cseq 'a' 'f'; cseq 'A' 'F' ]\n\nlet calpha =\n  List.fold_right\n    ~f:cadd\n    [ '\\170'; '\\181'; '\\186'; '\\223'; '\\255' ]\n    ~init:(union clower upper)\n;;\n\nlet calnum = union calpha cdigit\n\nlet case_insens s =\n  union_all [ s; offset 32 (inter s upper); offset (-32) (inter s clower) ]\n;;\n\nlet cword = cadd '_' calnum\nlet notnl = diff cany (csingle '\\n')\nlet nl = csingle '\\n'\n\nlet set str =\n  let s = ref empty in\n  for i = 0 to String.length str - 1 do\n    s := union (csingle str.[i]) !s\n  done;\n  !s\n;;\n\nlet blank = set \"\\t \"\n\n(* CR-someday rgrinberg: this [lower] doesn't match [clower] *)\nlet lower = union_all [ rg 'a' 'z'; char '\\181'; rg '\\223' '\\246'; rg '\\248' '\\255' ]\nlet alpha = union_all [ lower; upper; char '\\170'; char '\\186' ]\nlet alnum = union_all [ alpha; cdigit ]\nlet wordc = union_all [ alnum; char '_' ]\nlet cntrl = union_all [ rg '\\000' '\\031'; rg '\\127' '\\159' ]\nlet graph = union_all [ rg '\\033' '\\126'; rg '\\160' '\\255' ]\nlet print = union_all [ rg '\\032' '\\126'; rg '\\160' '\\255' ]\n\nlet punct =\n  union_all\n    [ rg '\\033' '\\047'\n    ; rg '\\058' '\\064'\n    ; rg '\\091' '\\096'\n    ; rg '\\123' '\\126'\n    ; rg '\\160' '\\169'\n    ; rg '\\171' '\\180'\n    ; rg '\\182' '\\185'\n    ; rg '\\187' '\\191'\n    ; char '\\215'\n    ; char '\\247'\n    ]\n;;\n","open Import\n\nmodule Array = struct\n  type nonrec t = Bytes.t\n\n  let words = 8\n  let[@inline] length t = Bytes.length t / words\n  let[@inline] unsafe_get t i = Int64.to_int (Bytes.get_int64_ne t (i * words))\n  let[@inline] unsafe_set t i x = Bytes.set_int64_ne t (i * words) (Int64.of_int x)\n\n  let[@inline] make len x =\n    let t = Bytes.create (len * words) in\n    for i = 0 to length t - 1 do\n      unsafe_set t i x\n    done;\n    t\n  ;;\n\n  let[@inline] make_absent len = Bytes.make (len * words) '\\255'\n  let clear t = Bytes.fill t 0 (Bytes.length t) '\\255'\n\n  let fold_left t ~init ~f =\n    let init = ref init in\n    for i = 0 to length t - 1 do\n      init := f !init (unsafe_get t i)\n    done;\n    !init\n  ;;\nend\n\n(* A specialized hash table that makes the following trade-offs:\n   - Open addresing. Bucketing is quite memory intensive and dune is already\n     a memory hog.\n   - No boxing for empty slots. We make use of the fact that id's are never\n     negative to achieve this.\n   - No saving of the hash. Recomputing the hash for id's is a no-op.\n*)\n\ntype nonrec table =\n  { mutable table : Array.t\n  ; mutable size : int\n  }\n\ntype t = table Option.t ref\n\nlet init t =\n  if Option.is_none !t then t := Option.some { size = 0; table = Array.make 0 (-1) };\n  Option.get !t\n;;\n\nlet[@inline] should_grow t =\n  let slots = Array.length t.table in\n  slots = 0 || (t.size > 0 && slots / t.size < 2)\n;;\n\nlet absent = -1\n\nlet () =\n  let x = Array.make_absent 1 in\n  assert (Array.unsafe_get x 0 = absent)\n;;\n\nlet create () = ref None\n\nlet[@inline] index_of_offset slots index i =\n  let i = index + !i in\n  if i >= slots then i - slots else i\n;;\n\nlet clear t =\n  match !t with\n  | None -> ()\n  | Some t ->\n    t.size <- 0;\n    Array.clear t.table\n;;\n\nlet add t x =\n  let hash = Int.hash x in\n  let slots = Array.length t.table in\n  let index = hash land (slots - 1) in\n  let inserting = ref true in\n  let i = ref 0 in\n  while !inserting do\n    let idx = index_of_offset slots index i in\n    let elem = Array.unsafe_get t.table idx in\n    if elem = absent\n    then (\n      Array.unsafe_set t.table idx x;\n      inserting := false)\n    else incr i\n  done;\n  t.size <- t.size + 1\n;;\n\nlet resize t =\n  let old_table = t.table in\n  let slots = Array.length old_table in\n  let table = Array.make_absent (if slots = 0 then 1 else slots lsl 1) in\n  t.table <- table;\n  for i = 0 to slots - 1 do\n    let elem = Array.unsafe_get old_table i in\n    if elem <> absent then add t elem\n  done\n;;\n\nlet add t x =\n  let t = init t in\n  if should_grow t then resize t;\n  add t x\n;;\n\nlet[@inline] is_empty t =\n  let t = !t in\n  if Option.is_none t\n  then true\n  else (\n    let t = Option.get t in\n    t.size = 0)\n;;\n\nlet mem t x =\n  let t = !t in\n  if Option.is_none t || (Option.get t).size = 0\n  then false\n  else (\n    let t = Option.get t in\n    let hash = Int.hash x in\n    let slots = Array.length t.table in\n    let index = hash land (slots - 1) in\n    let i = ref 0 in\n    let found = ref false in\n    while (not !found) && !i < slots do\n      let idx = index_of_offset slots index i in\n      let elem = Array.unsafe_get t.table idx in\n      if Int.equal elem x\n      then found := true\n      else if Int.equal elem absent\n      then i := slots\n      else incr i\n    done;\n    !found)\n;;\n\nlet pp fmt t =\n  let { table; size } = init t in\n  let table =\n    Array.fold_left table ~init:[] ~f:(fun acc i -> if i = absent then acc else i :: acc)\n    |> List.rev\n    |> Stdlib.Array.of_list\n  in\n  let table fmt () = Fmt.sexp fmt \"table\" Fmt.(array int) table in\n  let size fmt () = Fmt.sexp fmt \"size\" Fmt.int size in\n  Format.fprintf fmt \"%a@.%a@.\" table () size ()\n;;\n","open Import\n\ntype t = int array\n\nlet make marks =\n  let len = 1 + List.fold_left ~f:(fun ma (i, _) -> max ma i) ~init:(-1) marks in\n  let t = Array.make len (-1) in\n  let set (i, v) = t.(i) <- v in\n  List.iter ~f:set marks;\n  t\n;;\n\nlet test t i = if 2 * i >= Array.length t then false else t.(2 * i) <> -1\n\nmodule Offset = struct\n  type t = int\n\n  let is_present t = t >= 0\n  let get_no_check t = t\nend\n\nlet start_offset t i =\n  let start_i = 2 * i in\n  if start_i + 1 >= Array.length t then -1 else t.(start_i)\n;;\n\nlet stop_offset t i =\n  let stop_i = (2 * i) + 1 in\n  if stop_i >= Array.length t then -1 else t.(stop_i)\n;;\n\nlet offset t i =\n  let start_i = 2 * i in\n  let stop_i = start_i + 1 in\n  if stop_i >= Array.length t\n  then None\n  else (\n    let start = t.(start_i) in\n    if start = -1\n    then None\n    else (\n      let stop = t.(stop_i) in\n      Some (start, stop)))\n;;\n\nlet iteri t ~f =\n  for i = 0 to (Array.length t / 2) - 1 do\n    let idx = 2 * i in\n    let start = t.(idx) in\n    if start <> -1\n    then (\n      let stop = t.(idx + 1) in\n      f i start stop)\n  done\n;;\n","# 1 \"lib/fake/mutex.ml\"\n(*\n   RE - A regular expression library\n\n   Copyright (C) 2025 Jerome Vouillon\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation, with\n   linking exception; either version 2.1 of the License, or (at\n   your option) any later version.\n\n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with this library; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n*)\n\ntype t = unit\n\nlet create _ = ()\nlet lock _ = ()\nlet unlock _ = ()\n","module Pmark = struct\n  type t = int\n\n  let equal (x : int) (y : int) = x = y\n  let compare (x : int) (y : int) = compare x y\n  let r = Atomic.make 1\n  let gen () = Atomic.fetch_and_add r 1\n  let pp = Format.pp_print_int\nend\n\ninclude Pmark\n\nmodule Set = struct\n  module Set = Set.Make (Pmark)\n\n  let[@warning \"-32\"] to_list x =\n    let open Set in\n    to_seq x |> List.of_seq\n  ;;\n\n  include Set\nend\n\nlet to_dyn = Dyn.int\n","open Import\n\n(*\n   RE - A regular expression library\n\n   Copyright (C) 2001 Jerome Vouillon\n   email: Jerome.Vouillon@pps.jussieu.fr\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation, with\n   linking exception; either version 2.1 of the License, or (at\n   your option) any later version.\n\n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with this library; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n*)\n\nlet hash_combine h accu = (accu * 65599) + h\n\nmodule Ids : sig\n  module Id : sig\n    type t\n\n    val equal : t -> t -> bool\n    val zero : t\n    val hash : t -> int\n    val pp : t Fmt.t\n\n    module Hash_set : sig\n      type id := t\n      type t\n\n      val create : unit -> t\n      val mem : t -> id -> bool\n      val add : t -> id -> unit\n      val clear : t -> unit\n    end\n  end\n\n  type t\n\n  val create : unit -> t\n  val next : t -> Id.t\nend = struct\n  module Id = struct\n    type t = int\n\n    module Hash_set = Hash_set\n\n    let equal = Int.equal\n    let zero = 0\n    let hash x = x\n    let pp = Fmt.int\n  end\n\n  type t = int ref\n\n  let create () = ref 0\n\n  let next t =\n    incr t;\n    !t\n  ;;\nend\n\nmodule Id = Ids.Id\n\nmodule Sem = struct\n  type t =\n    [ `Longest\n    | `Shortest\n    | `First\n    ]\n\n  let to_string = function\n    | `Shortest -> \"short\"\n    | `Longest -> \"long\"\n    | `First -> \"first\"\n  ;;\n\n  let to_dyn t = Dyn.enum (to_string t)\n  let equal = Poly.equal\n  let pp ch k = Format.pp_print_string ch (to_string k)\nend\n\nmodule Rep_kind = struct\n  type t =\n    [ `Greedy\n    | `Non_greedy\n    ]\n\n  let to_string = function\n    | `Greedy -> \"Greedy\"\n    | `Non_greedy -> \"Non_greedy\"\n  ;;\n\n  let to_dyn t = Dyn.enum (to_string t)\n  let pp fmt t = Format.pp_print_string fmt (to_string t)\nend\n\nmodule Mark : sig\n  type t = private int\n\n  val compare : t -> t -> int\n  val equal : t -> t -> bool\n  val pp : t Fmt.t\n  val to_dyn : t -> Dyn.t\n  val start : t\n  val prev : t -> t\n  val next : t -> t\n  val next2 : t -> t\n  val group_count : t -> int\n  val outside_range : t -> start_inclusive:t -> stop_inclusive:t -> bool\nend = struct\n  type t = int\n\n  let equal = Int.equal\n  let compare = Int.compare\n  let pp = Format.pp_print_int\n  let to_dyn = Dyn.int\n  let start = 0\n  let prev x = pred x\n  let next x = succ x\n  let next2 x = x + 2\n  let group_count x = x / 2\n\n  let outside_range t ~start_inclusive ~stop_inclusive =\n    t < start_inclusive || t > stop_inclusive\n  ;;\nend\n\nmodule Idx : sig\n  type t = private int\n\n  val pp : t Fmt.t\n  val to_dyn : t -> Dyn.t\n  val to_int : t -> int\n  val unknown : t\n  val initial : t\n  val used : t -> bool\n  val make : int -> t\n  val equal : t -> t -> bool\nend = struct\n  type t = int\n\n  let to_dyn = Dyn.int\n  let to_int x = x\n  let pp = Format.pp_print_int\n  let used t = t >= 0\n  let make x = x\n  let equal = Int.equal\n  let unknown = -1\n  let initial = 0\nend\n\nmodule Expr = struct\n  type t =\n    { id : Id.t\n    ; def : def\n    }\n\n  and def =\n    | Cst of Cset.t\n    | Alt of t list\n    | Seq of Sem.t * t * t\n    | Eps\n    | Rep of Rep_kind.t * Sem.t * t\n    | Mark of Mark.t\n    | Erase of Mark.t * Mark.t\n    | Before of Category.t\n    | After of Category.t\n    | Pmark of Pmark.t\n\n  let wrap_sem sem sem' v =\n    let open Dyn in\n    let name = Sem.to_string sem' in\n    match sem with\n    | Some sem when Sem.equal sem sem' -> v\n    | None | Some _ ->\n      (match v with\n       | List v -> variant name v\n       | _ -> variant name [ v ])\n  ;;\n\n  let rec seq_as_list sem = function\n    | Eps -> []\n    | Cst cs -> [ Cst cs ]\n    | Seq (sem', x, y) ->\n      if Sem.equal sem sem'\n      then x.def :: seq_as_list sem y.def\n      else raise_notrace Not_found\n    | _ -> raise_notrace Not_found\n  ;;\n\n  let seq_as_list sem t =\n    match seq_as_list sem t with\n    | exception Not_found -> None\n    | s -> Some s\n  ;;\n\n  let rec dyn_of_def sem =\n    let open Dyn in\n    function\n    | Cst cset -> Cset.to_dyn cset\n    | Alt alt -> variant \"Alt\" (List.map ~f:(to_dyn sem) alt)\n    | Seq (sem', x, y) ->\n      let to_dyn = to_dyn (Some sem') in\n      let x =\n        match seq_as_list sem' y.def with\n        | None -> variant \"Seq\" [ to_dyn x; to_dyn y ]\n        | Some y -> variant \"Seq\" (to_dyn x :: List.map y ~f:(dyn_of_def sem))\n      in\n      wrap_sem sem sem' x\n    | Eps -> Enum \"Eps\"\n    | Rep (_, sem', t) -> wrap_sem sem sem' (variant \"Rep\" [ to_dyn (Some sem') t ])\n    | Mark m -> variant \"Mark\" [ Mark.to_dyn m ]\n    | Pmark m -> variant \"Pmark\" [ Pmark.to_dyn m ]\n    | Erase (x, y) -> variant \"Erase\" [ Mark.to_dyn x; Mark.to_dyn y ]\n    | Before c -> variant \"Before\" [ Category.to_dyn c ]\n    | After c -> variant \"After\" [ Category.to_dyn c ]\n\n  and to_dyn sem { id = _; def } = dyn_of_def sem def\n\n  let rec pp_with_sem sem ch e =\n    let open Fmt in\n    match e.def with\n    | Cst l -> sexp ch \"cst\" Cset.pp l\n    | Alt l -> sexp ch \"alt\" (list (pp_with_sem sem)) l\n    | Seq (k, e, e') ->\n      sexp ch \"seq\" (triple Sem.pp (pp_with_sem sem) (pp_with_sem sem)) (k, e, e')\n    | Eps -> str ch \"eps\"\n    | Rep (_rk, k, e) -> sexp ch \"rep\" (pair Sem.pp (pp_with_sem (Some k))) (k, e)\n    | Mark i -> sexp ch \"mark\" Mark.pp i\n    | Pmark i -> sexp ch \"pmark\" Pmark.pp i\n    | Erase (b, e) -> sexp ch \"erase\" (pair Mark.pp Mark.pp) (b, e)\n    | Before c -> sexp ch \"before\" Category.pp c\n    | After c -> sexp ch \"after\" Category.pp c\n  ;;\n\n  let pp = pp_with_sem None\n  let eps_expr = { id = Id.zero; def = Eps }\n  let mk ids def = { id = Ids.next ids; def }\n  let empty ids = mk ids (Alt [])\n  let cst ids s = if Cset.is_empty s then empty ids else mk ids (Cst s)\n  let eps ids = mk ids Eps\n  let rep ids kind sem x = mk ids (Rep (kind, sem, x))\n  let mark ids m = mk ids (Mark m)\n  let pmark ids i = mk ids (Pmark i)\n  let erase ids m m' = mk ids (Erase (m, m'))\n  let before ids c = mk ids (Before c)\n  let after ids c = mk ids (After c)\n\n  let alt ids = function\n    | [] -> empty ids\n    | [ c ] -> c\n    | l -> mk ids (Alt l)\n  ;;\n\n  let seq ids (kind : Sem.t) x y =\n    match x.def, y.def with\n    | Alt [], _ -> x\n    | _, Alt [] -> y\n    | Eps, _ -> y\n    | _, Eps when Sem.equal kind `First -> x\n    | _ -> mk ids (Seq (kind, x, y))\n  ;;\n\n  let is_eps expr =\n    match expr.def with\n    | Eps -> true\n    | _ -> false\n  ;;\n\n  let rec rename ids x =\n    match x.def with\n    | Cst _ | Eps | Mark _ | Pmark _ | Erase _ | Before _ | After _ -> mk ids x.def\n    | Alt l -> mk ids (Alt (List.map ~f:(rename ids) l))\n    | Seq (k, y, z) -> mk ids (Seq (k, rename ids y, rename ids z))\n    | Rep (g, k, y) -> mk ids (Rep (g, k, rename ids y))\n  ;;\nend\n\ntype expr = Expr.t\n\ninclude Expr\n\nmodule Marks = struct\n  type t =\n    { marks : (Mark.t * Idx.t) list\n    ; pmarks : Pmark.Set.t\n    }\n\n  let to_dyn { marks; pmarks } : Dyn.t =\n    let open Dyn in\n    record\n      [ ( \"marks\"\n        , List.map marks ~f:(fun (m, idx) -> pair (Mark.to_dyn m) (Idx.to_dyn idx))\n          |> list )\n      ; \"pmarks\", Pmark.Set.to_list pmarks |> List.map ~f:Pmark.to_dyn |> list\n      ]\n  ;;\n\n  let equal { marks; pmarks } t =\n    List.equal\n      ~eq:(fun (x, y) (x', y') -> Mark.equal x x' && Idx.equal y y')\n      marks\n      t.marks\n    && Pmark.Set.equal pmarks t.pmarks\n  ;;\n\n  let empty = { marks = []; pmarks = Pmark.Set.empty }\n\n  let hash_marks_offset =\n    let f acc ((a : Mark.t), (i : Idx.t)) =\n      hash_combine (a :> int) (hash_combine (i :> int) acc)\n    in\n    fun l init -> List.fold_left l ~init ~f\n  ;;\n\n  let hash m accu = hash_marks_offset m.marks (hash_combine (Hashtbl.hash m.pmarks) accu)\n\n  let marks_set_idx =\n    let rec marks_set_idx idx marks =\n      match marks with\n      | [] -> []\n      | (a, idx') :: rem ->\n        if Idx.equal idx' Idx.unknown then (a, idx) :: marks_set_idx idx rem else marks\n    in\n    fun marks idx -> { marks with marks = marks_set_idx idx marks.marks }\n  ;;\n\n  let filter t (b : Mark.t) (e : Mark.t) =\n    { t with\n      marks =\n        List.filter t.marks ~f:(fun ((i : Mark.t), _) ->\n          Mark.outside_range i ~start_inclusive:b ~stop_inclusive:e)\n    }\n  ;;\n\n  let set_mark t (i : Mark.t) =\n    { t with marks = (i, Idx.unknown) :: List.remove_assq i t.marks }\n  ;;\n\n  let set_pmark t i = { t with pmarks = Pmark.Set.add i t.pmarks }\n\n  let pp fmt { marks; pmarks } =\n    Format.pp_open_box fmt 1;\n    (match marks with\n     | [] -> ()\n     | _ :: _ ->\n       Format.fprintf\n         fmt\n         \"@[<2>marks@ %a@]\"\n         (Format.pp_print_list (fun fmt (a, i) ->\n            Format.fprintf fmt \"%a-%a\" Mark.pp a Idx.pp i))\n         marks);\n    (match Pmark.Set.to_list pmarks with\n     | [] -> ()\n     | pmarks ->\n       Format.fprintf fmt \"@[<2>pmarks %a@]\" (Format.pp_print_list Pmark.pp) pmarks);\n    Format.pp_close_box fmt ()\n  ;;\nend\n\nmodule Status = struct\n  type t =\n    | Failed\n    | Match of Mark_infos.t * Pmark.Set.t\n    | Running\nend\n\nmodule Desc : sig\n  type t\n\n  val pp : t Fmt.t\n\n  module E : sig\n    type nonrec t = private\n      | TSeq of Sem.t * t * Expr.t\n      | TExp of Marks.t * Expr.t\n      | TMatch of Marks.t\n  end\n\n  val to_dyn : t -> Dyn.t\n  val fold_right : t -> init:'acc -> f:(E.t -> 'acc -> 'acc) -> 'acc\n  val tseq : Sem.t -> t -> Expr.t -> t -> t\n  val initial : Expr.t -> t\n  val empty : t\n  val set_idx : Idx.t -> t -> t\n  val hash : t -> int -> int\n  val equal : t -> t -> bool\n  val status : t -> Status.t\n  val first_match : t -> Marks.t option\n  val remove_matches : t -> t\n  val split_at_match : t -> t * t\n  val add_match : t -> Marks.t -> t\n  val add_eps : t -> Marks.t -> t\n  val add_expr : t -> E.t -> t\n  val iter_marks : t -> f:(Marks.t -> unit) -> unit\n  val remove_duplicates : Id.Hash_set.t -> t -> Expr.t -> t\nend = struct\n  module E = struct\n    type t =\n      | TSeq of Sem.t * t list * Expr.t\n      | TExp of Marks.t * Expr.t\n      | TMatch of Marks.t\n\n    let rec equal_list l1 l2 = List.equal ~eq:equal l1 l2\n\n    and equal x y =\n      match x, y with\n      | TSeq (_, l1, e1), TSeq (_, l2, e2) -> Id.equal e1.id e2.id && equal_list l1 l2\n      | TExp (marks1, e1), TExp (marks2, e2) ->\n        Id.equal e1.id e2.id && Marks.equal marks1 marks2\n      | TMatch marks1, TMatch marks2 -> Marks.equal marks1 marks2\n      | _, _ -> false\n    ;;\n\n    let rec hash (t : t) accu =\n      match t with\n      | TSeq (_, l, e) ->\n        hash_combine 0x172a1bce (hash_combine (Id.hash e.id) (hash_list l accu))\n      | TExp (marks, e) ->\n        hash_combine 0x2b4c0d77 (hash_combine (Id.hash e.id) (Marks.hash marks accu))\n      | TMatch marks -> hash_combine 0x1c205ad5 (Marks.hash marks accu)\n\n    and hash_list =\n      let f acc x = hash x acc in\n      fun l init -> List.fold_left l ~init ~f\n    ;;\n  end\n\n  type t = E.t list\n\n  let rec to_dyn sem t = Dyn.list (List.map ~f:(dyn_of_e sem) t)\n\n  and dyn_of_e sem =\n    let open Dyn in\n    function\n    | E.TSeq (sem', x, y) ->\n      wrap_sem\n        sem\n        sem'\n        (variant \"TSeq\" [ to_dyn (Some sem') x; Expr.to_dyn (Some sem') y ])\n    | TExp (marks, e) ->\n      let e =\n        let base = [ Expr.to_dyn sem e ] in\n        if Marks.(equal empty marks) then base else Marks.to_dyn marks :: base\n      in\n      variant \"TExp\" e\n    | TMatch m -> variant \"TMarks\" [ Marks.to_dyn m ]\n  ;;\n\n  let to_dyn t = to_dyn None t\n\n  open E\n\n  let equal = E.equal_list\n  let hash = E.hash_list\n\n  let tseq' kind x y =\n    match x with\n    | [] -> []\n    | [ TExp (marks, { def = Eps; _ }) ] -> [ TExp (marks, y) ]\n    | _ -> [ TSeq (kind, x, y) ]\n  ;;\n\n  let tseq kind x y rem = tseq' kind x y @ rem\n\n  let rec fold_right t ~init ~f =\n    match t with\n    | [] -> init\n    | x :: xs -> f x (fold_right xs ~init ~f)\n  ;;\n\n  let rec iter_marks t ~f =\n    List.iter t ~f:(fun (e : E.t) ->\n      match e with\n      | TSeq (_, l, _) -> iter_marks l ~f\n      | TExp (marks, _) | TMatch marks -> f marks)\n  ;;\n\n  let rec print_state_rec ch e (y : Expr.t) =\n    match e with\n    | TMatch marks -> Format.fprintf ch \"@[<2>(TMatch@ %a)@]\" Marks.pp marks\n    | TSeq (sem, l', x) ->\n      Format.fprintf ch \"@[<2>(TSeq@ %a@ \" Sem.pp sem;\n      print_state_lst ch l' x;\n      Format.fprintf ch \"@ %a)@]\" Expr.pp x\n    | TExp (marks, { def = Eps; _ }) ->\n      Format.fprintf ch \"@[<2>(TExp@ %a@ (%a)@ (eps))@]\" Id.pp y.id Marks.pp marks\n    | TExp (marks, x) ->\n      Format.fprintf ch \"@[<2>(TExp@ %a@ (%a)@ %a)@]\" Id.pp x.id Marks.pp marks Expr.pp x\n\n  and print_state_lst ch l y =\n    match l with\n    | [] -> Format.fprintf ch \"()\"\n    | e :: rem ->\n      print_state_rec ch e y;\n      List.iter rem ~f:(fun e ->\n        Format.fprintf ch \"@ | \";\n        print_state_rec ch e y)\n  ;;\n\n  let pp ch t = print_state_lst ch [ t ] { id = Id.zero; def = Eps }\n\n  let rec first_match = function\n    | [] -> None\n    | TMatch marks :: _ -> Some marks\n    | _ :: r -> first_match r\n  ;;\n\n  let remove_matches t =\n    List.filter t ~f:(function\n      | TMatch _ -> false\n      | _ -> true)\n  ;;\n\n  let split_at_match =\n    let rec split_at_match_rec l = function\n      | [] -> assert false\n      | TMatch _ :: r -> List.rev l, remove_matches r\n      | x :: r -> split_at_match_rec (x :: l) r\n    in\n    fun l -> split_at_match_rec [] l\n  ;;\n\n  let status : _ -> Status.t = function\n    | [] -> Failed\n    | TMatch m :: _ -> Match (Mark_infos.make (m.marks :> (int * int) list), m.pmarks)\n    | _ -> Running\n  ;;\n\n  let set_idx =\n    let rec f idx = function\n      | TMatch marks -> TMatch (Marks.marks_set_idx marks idx)\n      | TSeq (kind, l, x) -> TSeq (kind, set_idx idx l, x)\n      | TExp (marks, x) -> TExp (Marks.marks_set_idx marks idx, x)\n    and set_idx idx xs = List.map xs ~f:(f idx) in\n    set_idx\n  ;;\n\n  let[@ocaml.warning \"-32\"] pp fmt t =\n    Format.fprintf fmt \"[%a]\" (Format.pp_print_list ~pp_sep:(Fmt.lit \"; \") pp) t\n  ;;\n\n  let empty = []\n  let initial expr = [ TExp (Marks.empty, expr) ]\n  let add_match t marks = TMatch marks :: t\n  let add_eps t marks = TExp (marks, eps_expr) :: t\n  let add_expr t expr = expr :: t\n\n  let remove_duplicates =\n    let rec loop seen l y =\n      match l with\n      | [] -> []\n      | (TMatch _ as x) :: _ ->\n        (* Truncate after first match *)\n        [ x ]\n      | TSeq (kind, l, x) :: r ->\n        let l = loop seen l x in\n        let r = loop seen r y in\n        tseq kind l x r\n      | (TExp (_marks, { def = Eps; _ }) as e) :: r ->\n        if Id.Hash_set.mem seen y.id\n        then loop seen r y\n        else (\n          Id.Hash_set.add seen y.id;\n          e :: loop seen r y)\n      | (TExp (_marks, x) as e) :: r ->\n        if Id.Hash_set.mem seen x.id\n        then loop seen r y\n        else (\n          Id.Hash_set.add seen x.id;\n          e :: loop seen r y)\n    in\n    fun seen l y ->\n      Id.Hash_set.clear seen;\n      loop seen l y\n  ;;\nend\n\nmodule E = Desc.E\n\nmodule State = struct\n  type t =\n    { idx : Idx.t\n    ; category : Category.t\n    ; desc : Desc.t\n    ; mutable status : Status.t option\n    ; hash : int\n    }\n  (* Thread-safety: We use double-checked locking to access field\n     [status] in function [status] below. *)\n\n  let pp fmt t = Desc.pp fmt t.desc\n  let[@inline] idx t = t.idx\n  let to_dyn t = Desc.to_dyn t.desc\n\n  let dummy =\n    { idx = Idx.unknown\n    ; category = Category.dummy\n    ; desc = Desc.empty\n    ; status = None\n    ; hash = -1\n    }\n  ;;\n\n  let hash idx cat desc =\n    Desc.hash desc (hash_combine idx (hash_combine (Category.to_int cat) 0))\n    land 0x3FFFFFFF\n  ;;\n\n  let mk idx cat desc =\n    { idx; category = cat; desc; status = None; hash = hash (idx :> int) cat desc }\n  ;;\n\n  let create cat e = mk Idx.initial cat (Desc.initial e)\n\n  let equal { idx; category; desc; status = _; hash } t =\n    Int.equal hash t.hash\n    && Idx.equal idx t.idx\n    && Category.equal category t.category\n    && Desc.equal desc t.desc\n  ;;\n\n  (* To be called when the mutex has already been acquired *)\n  let status_no_mutex s =\n    match s.status with\n    | Some s -> s\n    | None ->\n      let st = Desc.status s.desc in\n      s.status <- Some st;\n      st\n  ;;\n\n  let status m s =\n    match s.status with\n    | Some s -> s\n    | None ->\n      Mutex.lock m;\n      let st = status_no_mutex s in\n      Mutex.unlock m;\n      st\n  ;;\n\n  module Table = Hashtbl.Make (struct\n      type nonrec t = t\n\n      let equal = equal\n      let hash t = t.hash\n    end)\nend\n\n(**** Find a free index ****)\n\nmodule Working_area = struct\n  type t =\n    { mutable ids : Bit_vector.t\n    ; seen : Id.Hash_set.t\n    ; index_count : int Atomic.t\n    }\n\n  let create () =\n    { ids = Bit_vector.create_zero 1\n    ; seen = Id.Hash_set.create ()\n    ; index_count = Atomic.make 0\n    }\n  ;;\n\n  let index_count w = Atomic.get w.index_count\n\n  let mark_used_indices tbl =\n    Desc.iter_marks ~f:(fun marks ->\n      List.iter marks.marks ~f:(fun (_, i) ->\n        if Idx.used i then Bit_vector.set tbl (i :> int) true))\n  ;;\n\n  let rec find_free tbl idx len =\n    if idx = len || not (Bit_vector.get tbl idx) then idx else find_free tbl (idx + 1) len\n  ;;\n\n  let free_index t l =\n    Bit_vector.reset_zero t.ids;\n    mark_used_indices t.ids l;\n    let len = Bit_vector.length t.ids in\n    let idx = find_free t.ids 0 len in\n    if idx = len\n    then (\n      t.ids <- Bit_vector.create_zero (2 * len);\n      (* This function is only called when the mutex is locked. So we\n         are sure that this is always coherent with the length of\n         [t.ids]. *)\n      Atomic.set t.index_count (2 * len));\n    Idx.make idx\n  ;;\nend\n\n(**** Computation of the next state ****)\n\ntype ctx =\n  { c : Cset.c\n  ; prev_cat : Category.t\n  ; next_cat : Category.t\n  }\n\nlet rec delta_expr ({ c; _ } as ctx) marks (x : Expr.t) rem =\n  (*Format.eprintf \"%d@.\" x.id;*)\n  match x.def with\n  | Cst s -> if Cset.mem c s then Desc.add_eps rem marks else rem\n  | Alt l -> delta_alt ctx marks l rem\n  | Seq (kind, y, z) ->\n    let y = delta_expr ctx marks y Desc.empty in\n    delta_seq ctx kind y z rem\n  | Rep (rep_kind, kind, y) -> delta_rep ctx marks x rep_kind kind y rem\n  | Eps -> Desc.add_match rem marks\n  | Mark i -> Desc.add_match rem (Marks.set_mark marks i)\n  | Pmark i -> Desc.add_match rem (Marks.set_pmark marks i)\n  | Erase (b, e) -> Desc.add_match rem (Marks.filter marks b e)\n  | Before cat ->\n    if Category.intersect ctx.next_cat cat then Desc.add_match rem marks else rem\n  | After cat ->\n    if Category.intersect ctx.prev_cat cat then Desc.add_match rem marks else rem\n\nand delta_rep ctx marks x rep_kind kind y rem =\n  let y, marks' =\n    let y = delta_expr ctx marks y Desc.empty in\n    match Desc.first_match y with\n    | None -> y, marks\n    | Some marks -> Desc.remove_matches y, marks\n  in\n  match rep_kind with\n  | `Greedy -> Desc.tseq kind y x (Desc.add_match rem marks')\n  | `Non_greedy -> Desc.add_match (Desc.tseq kind y x rem) marks\n\nand delta_alt ctx marks l rem = List.fold_right l ~init:rem ~f:(delta_expr ctx marks)\n\nand delta_seq ctx (kind : Sem.t) y z rem =\n  match Desc.first_match y with\n  | None -> Desc.tseq kind y z rem\n  | Some marks ->\n    (match kind with\n     | `Longest -> Desc.tseq kind (Desc.remove_matches y) z (delta_expr ctx marks z rem)\n     | `Shortest -> delta_expr ctx marks z (Desc.tseq kind (Desc.remove_matches y) z rem)\n     | `First ->\n       let y, y' = Desc.split_at_match y in\n       Desc.tseq kind y z (delta_expr ctx marks z (Desc.tseq kind y' z rem)))\n;;\n\nlet rec delta_e ctx marks (x : E.t) rem =\n  match x with\n  | TSeq (kind, y, z) ->\n    let y = delta_desc ctx marks y Desc.empty in\n    delta_seq ctx kind y z rem\n  | TExp (marks, e) -> delta_expr ctx marks e rem\n  | TMatch _ -> Desc.add_expr rem x\n\nand delta_desc ctx marks (l : Desc.t) rem =\n  Desc.fold_right l ~init:rem ~f:(fun y acc -> delta_e ctx marks y acc)\n;;\n\nlet delta (tbl_ref : Working_area.t) next_cat char (st : State.t) =\n  let expr =\n    let prev_cat = st.category in\n    let ctx = { c = char; next_cat; prev_cat } in\n    Desc.remove_duplicates\n      tbl_ref.seen\n      (delta_desc ctx Marks.empty st.desc Desc.empty)\n      Expr.eps_expr\n  in\n  let idx = Working_area.free_index tbl_ref expr in\n  let expr = Desc.set_idx idx expr in\n  State.mk idx next_cat expr\n;;\n","(* In reality, this can really be represented as a bool array.\n\n   The representation is best thought of as a list of all chars along with a\n   flag:\n\n   (a, 0), (b, 1), (c, 0), (d, 0), ...\n\n   characters belonging to the same color are represented by sequnces of\n   characters with the flag set to 0.\n*)\n\ntype t = Bytes.t\n\nmodule Repr = struct\n  type t = string\n\n  let repr t color = t.[Cset.to_int color]\n  let length = String.length\nend\n\nmodule Table = struct\n  type t = string\n\n  let get_char t c = t.[Cset.to_int c]\n  let get t c = Cset.of_char (String.unsafe_get t (Char.code c))\n\n  let translate_colors (cm : t) cset =\n    Cset.fold_right cset ~init:Cset.empty ~f:(fun i j l ->\n      let start = get_char cm i in\n      let stop = get_char cm j in\n      Cset.union (Cset.cseq start stop) l)\n  ;;\nend\n\nlet make () = Bytes.make 257 '\\000'\n\nlet flatten cm =\n  let c = Bytes.create 256 in\n  let color_repr = Bytes.create 256 in\n  let v = ref 0 in\n  Bytes.set c 0 '\\000';\n  Bytes.set color_repr 0 '\\000';\n  for i = 1 to 255 do\n    if Bytes.get cm i <> '\\000' then incr v;\n    Bytes.set c i (Char.chr !v);\n    Bytes.set color_repr !v (Char.chr i)\n  done;\n  Bytes.unsafe_to_string c, Bytes.sub_string color_repr 0 (!v + 1)\n;;\n\n(* mark all the endpoints of the intervals of the char set with the 1 byte *)\nlet split t set =\n  Cset.iter set ~f:(fun i j ->\n    Bytes.set t (Cset.to_int i) '\\001';\n    Bytes.set t (Cset.to_int j + 1) '\\001')\n;;\n","open Import\n\ntype ('a, _) ast =\n  | Alternative : 'a list -> ('a, [> `Uncased ]) ast\n  | No_case : 'a -> ('a, [> `Cased ]) ast\n  | Case : 'a -> ('a, [> `Cased ]) ast\n\nlet dyn_of_ast f =\n  let open Dyn in\n  function\n  | Alternative xs -> variant \"Alternative\" (List.map xs ~f)\n  | No_case a -> variant \"No_case\" [ f a ]\n  | Case a -> variant \"Case\" [ f a ]\n;;\n\nlet empty_alternative : ('a, 'b) ast = Alternative []\n\nlet equal_ast (type a) eq (x : (a, [ `Uncased ]) ast) (y : (a, [ `Uncased ]) ast) =\n  match x, y with\n  | Alternative a, Alternative b -> List.equal ~eq a b\n;;\n\nlet pp_ast (type a b) f fmt (ast : (a, b) ast) =\n  let open Fmt in\n  let var s re = sexp fmt s f re in\n  match ast with\n  | Alternative alt -> sexp fmt \"Alternative\" (list f) alt\n  | Case c -> var \"Case\" c\n  | No_case c -> var \"No_case\" c\n;;\n\ntype cset =\n  | Cset of Cset.t\n  | Intersection of cset list\n  | Complement of cset list\n  | Difference of cset * cset\n  | Cast of (cset, [ `Cased | `Uncased ]) ast\n\nlet rec dyn_of_cset =\n  let open Dyn in\n  function\n  | Cset cset -> variant \"Cset\" [ Cset.to_dyn cset ]\n  | Intersection xs -> variant \"Intersection\" (List.map xs ~f:dyn_of_cset)\n  | Complement xs -> variant \"Complement\" (List.map xs ~f:dyn_of_cset)\n  | Difference (x, y) -> variant \"Difference\" [ dyn_of_cset x; dyn_of_cset y ]\n  | Cast c -> variant \"Cast\" [ dyn_of_ast dyn_of_cset c ]\n;;\n\ntype ('a, 'case) gen =\n  | Set of 'a\n  | Ast of (('a, 'case) gen, 'case) ast\n  | Sequence of ('a, 'case) gen list\n  | Repeat of ('a, 'case) gen * int * int option\n  | Beg_of_line\n  | End_of_line\n  | Beg_of_word\n  | End_of_word\n  | Not_bound\n  | Beg_of_str\n  | End_of_str\n  | Last_end_of_line\n  | Start\n  | Stop\n  | Group of string option * ('a, 'case) gen\n  | No_group of ('a, 'case) gen\n  | Nest of ('a, 'case) gen\n  | Pmark of Pmark.t * ('a, 'case) gen\n  | Sem of Automata.Sem.t * ('a, 'case) gen\n  | Sem_greedy of Automata.Rep_kind.t * ('a, 'case) gen\n\nlet rec dyn_of_gen f =\n  let open Dyn in\n  function\n  | Set a -> variant \"Set\" [ f a ]\n  | Ast ast -> variant \"Ast\" [ dyn_of_ast (dyn_of_gen f) ast ]\n  | Sequence xs -> variant \"Sequence\" (List.map xs ~f:(dyn_of_gen f))\n  | Repeat (gen, min, max) ->\n    let base =\n      match max with\n      | None -> []\n      | Some x -> [ int x ]\n    in\n    variant \"Repeat\" (dyn_of_gen f gen :: int min :: base)\n  | Beg_of_line -> enum \"Beg_of_line\"\n  | End_of_line -> enum \"End_of_line\"\n  | Beg_of_word -> enum \"Beg_of_word\"\n  | End_of_word -> enum \"End_of_word\"\n  | Not_bound -> enum \"Not_bound\"\n  | Beg_of_str -> enum \"Beg_of_str\"\n  | End_of_str -> enum \"End_of_str\"\n  | Last_end_of_line -> enum \"Last_end_of_line\"\n  | Start -> enum \"Start\"\n  | Stop -> enum \"Stop\"\n  | Group (name, t) ->\n    let args =\n      let args = [ dyn_of_gen f t ] in\n      match name with\n      | None -> args\n      | Some name -> string name :: args\n    in\n    variant \"Group\" args\n  | No_group x -> variant \"No_group\" [ dyn_of_gen f x ]\n  | Nest x -> variant \"Nest\" [ dyn_of_gen f x ]\n  | Pmark (pmark, t) -> variant \"Pmark\" [ Pmark.to_dyn pmark; dyn_of_gen f t ]\n  | Sem (sem, t) -> variant \"Sem\" [ Automata.Sem.to_dyn sem; dyn_of_gen f t ]\n  | Sem_greedy (rep, t) ->\n    variant \"Sem_greedy\" [ Automata.Rep_kind.to_dyn rep; dyn_of_gen f t ]\n;;\n\nlet rec pp_gen pp_cset fmt t =\n  let open Format in\n  let open Fmt in\n  let pp = pp_gen pp_cset in\n  let var s re = sexp fmt s pp re in\n  let seq s rel = sexp fmt s (list pp) rel in\n  match t with\n  | Set cset -> pp_cset fmt cset\n  | Sequence sq -> seq \"Sequence\" sq\n  | Repeat (re, start, stop) ->\n    let pp' fmt () = fprintf fmt \"%a@ %d%a\" pp re start optint stop in\n    sexp fmt \"Repeat\" pp' ()\n  | Beg_of_line -> str fmt \"Beg_of_line\"\n  | End_of_line -> str fmt \"End_of_line\"\n  | Beg_of_word -> str fmt \"Beg_of_word\"\n  | End_of_word -> str fmt \"End_of_word\"\n  | Not_bound -> str fmt \"Not_bound\"\n  | Beg_of_str -> str fmt \"Beg_of_str\"\n  | End_of_str -> str fmt \"End_of_str\"\n  | Last_end_of_line -> str fmt \"Last_end_of_line\"\n  | Start -> str fmt \"Start\"\n  | Stop -> str fmt \"Stop\"\n  | Group (None, c) -> var \"Group\" c\n  | Group (Some n, c) -> sexp fmt \"Named_group\" (pair str pp) (n, c)\n  | Nest c -> var \"Nest\" c\n  | Pmark (m, r) -> sexp fmt \"Pmark\" (pair Pmark.pp pp) (m, r)\n  | Ast a -> pp_ast pp fmt a\n  | Sem (sem, a) -> sexp fmt \"Sem\" (pair Automata.Sem.pp pp) (sem, a)\n  | Sem_greedy (k, re) -> sexp fmt \"Sem_greedy\" (pair Automata.Rep_kind.pp pp) (k, re)\n  | No_group c -> var \"No_group\" c\n;;\n\nlet rec pp_cset fmt cset =\n  let open Fmt in\n  let seq s rel = sexp fmt s (list pp_cset) rel in\n  match cset with\n  | Cast s -> pp_ast pp_cset fmt s\n  | Cset s -> sexp fmt \"Set\" Cset.pp s\n  | Intersection c -> seq \"Intersection\" c\n  | Complement c -> seq \"Complement\" c\n  | Difference (a, b) -> sexp fmt \"Difference\" (pair pp_cset pp_cset) (a, b)\n;;\n\nlet rec equal cset x1 x2 =\n  match x1, x2 with\n  | Set s1, Set s2 -> cset s1 s2\n  | Sequence l1, Sequence l2 -> List.equal ~eq:(equal cset) l1 l2\n  | Repeat (x1', i1, j1), Repeat (x2', i2, j2) ->\n    Int.equal i1 i2 && Option.equal Int.equal j1 j2 && equal cset x1' x2'\n  | Beg_of_line, Beg_of_line\n  | End_of_line, End_of_line\n  | Beg_of_word, Beg_of_word\n  | End_of_word, End_of_word\n  | Not_bound, Not_bound\n  | Beg_of_str, Beg_of_str\n  | End_of_str, End_of_str\n  | Last_end_of_line, Last_end_of_line\n  | Start, Start\n  | Stop, Stop -> true\n  | Group _, Group _ ->\n    (* Do not merge groups! *)\n    false\n  | Pmark (m1, r1), Pmark (m2, r2) -> Pmark.equal m1 m2 && equal cset r1 r2\n  | Nest x, Nest y -> equal cset x y\n  | Ast x, Ast y -> equal_ast (equal cset) x y\n  | Sem (sem, a), Sem (sem', a') -> Poly.equal sem sem' && equal cset a a'\n  | Sem_greedy (rep, a), Sem_greedy (rep', a') -> Poly.equal rep rep' && equal cset a a'\n  | _ -> false\n;;\n\ntype t = (cset, [ `Cased | `Uncased ]) gen\ntype no_case = (Cset.t, [ `Uncased ]) gen\n\nlet to_dyn = dyn_of_gen dyn_of_cset\nlet pp = pp_gen pp_cset\nlet cset cset = Set (Cset cset)\n\nlet rec handle_case_cset ign_case = function\n  | Cset s -> if ign_case then Cset.case_insens s else s\n  | Cast (Alternative l) -> List.map ~f:(handle_case_cset ign_case) l |> Cset.union_all\n  | Complement l ->\n    List.map ~f:(handle_case_cset ign_case) l |> Cset.union_all |> Cset.diff Cset.cany\n  | Difference (r, r') ->\n    Cset.inter\n      (handle_case_cset ign_case r)\n      (Cset.diff Cset.cany (handle_case_cset ign_case r'))\n  | Intersection l -> List.map ~f:(handle_case_cset ign_case) l |> Cset.intersect_all\n  | Cast (No_case a) -> handle_case_cset true a\n  | Cast (Case a) -> handle_case_cset false a\n;;\n\nlet rec handle_case ign_case : t -> (Cset.t, [ `Uncased ]) gen = function\n  | Set s -> Set (handle_case_cset ign_case s)\n  | Sequence l -> Sequence (List.map ~f:(handle_case ign_case) l)\n  | Ast (Alternative l) ->\n    let l = List.map ~f:(handle_case ign_case) l in\n    Ast (Alternative l)\n  | Repeat (r, i, j) -> Repeat (handle_case ign_case r, i, j)\n  | ( Beg_of_line\n    | End_of_line\n    | Beg_of_word\n    | End_of_word\n    | Not_bound\n    | Beg_of_str\n    | End_of_str\n    | Last_end_of_line\n    | Start\n    | Stop ) as r -> r\n  | Sem (k, r) -> Sem (k, handle_case ign_case r)\n  | Sem_greedy (k, r) -> Sem_greedy (k, handle_case ign_case r)\n  | Group (n, r) -> Group (n, handle_case ign_case r)\n  | No_group r -> No_group (handle_case ign_case r)\n  | Nest r -> Nest (handle_case ign_case r)\n  | Ast (Case r) -> handle_case false r\n  | Ast (No_case r) -> handle_case true r\n  | Pmark (i, r) -> Pmark (i, handle_case ign_case r)\n;;\n\nmodule Export = struct\n  type nonrec t = t\n\n  let pp = pp\n\n  let seq = function\n    | [ r ] -> r\n    | l -> Sequence l\n  ;;\n\n  let char =\n    let f = Dense_map.make ~size:256 ~f:(fun i -> cset (Cset.csingle (Char.chr i))) in\n    fun c -> f (Char.code c)\n  ;;\n\n  let any = cset Cset.cany\n\n  let str s : t =\n    let l = ref [] in\n    for i = String.length s - 1 downto 0 do\n      l := char s.[i] :: !l\n    done;\n    seq !l\n  ;;\n\n  let as_set_elems elems =\n    match\n      List.map elems ~f:(function\n        | Set e -> e\n        | _ -> raise_notrace Exit)\n    with\n    | exception Exit -> None\n    | e -> Some e\n  ;;\n\n  let empty : t = Ast empty_alternative\n\n  let alt (elems : t list) : t =\n    match elems with\n    | [] -> empty\n    | [ x ] -> x\n    | _ ->\n      (match as_set_elems elems with\n       | None -> Ast (Alternative elems)\n       | Some elems -> Set (Cast (Alternative elems)))\n  ;;\n\n  let epsilon = seq []\n\n  let repn r i j =\n    if i < 0 then invalid_arg \"Re.repn\";\n    match j, i with\n    | Some j, _ when j < i -> invalid_arg \"Re.repn\"\n    | Some 0, 0 -> epsilon\n    | Some 1, 1 -> r\n    | _ -> Repeat (r, i, j)\n  ;;\n\n  let rep r = repn r 0 None\n  let rep1 r = repn r 1 None\n  let opt r = repn r 0 (Some 1)\n  let bol = Beg_of_line\n  let eol = End_of_line\n  let bow = Beg_of_word\n  let eow = End_of_word\n  let word r = seq [ bow; r; eow ]\n  let not_boundary = Not_bound\n  let bos = Beg_of_str\n  let eos = End_of_str\n  let whole_string r = seq [ bos; r; eos ]\n  let leol = Last_end_of_line\n  let start = Start\n  let stop = Stop\n\n  type 'b f = { f : 'a. 'a -> ('a, 'b) ast }\n\n  let make_set f t =\n    match t with\n    | Set x -> Set (Cast (f.f x))\n    | _ -> Ast (f.f t)\n  ;;\n\n  let preserve_set f t =\n    match t with\n    | Set _ -> t\n    | _ -> f t\n  ;;\n\n  let longest = preserve_set (fun t -> Sem (`Longest, t))\n  let shortest = preserve_set (fun t -> Sem (`Shortest, t))\n  let first = preserve_set (fun t -> Sem (`First, t))\n  let greedy = preserve_set (fun t -> Sem_greedy (`Greedy, t))\n  let non_greedy = preserve_set (fun t -> Sem_greedy (`Non_greedy, t))\n  let group ?name r = Group (name, r)\n  let no_group = preserve_set (fun t -> No_group t)\n  let nest r = Nest r\n  let set str = cset (Cset.set str)\n\n  let mark r =\n    let i = Pmark.gen () in\n    i, Pmark (i, r)\n  ;;\n\n  (**** Character sets ****)\n  let as_set_or_error name elems =\n    match as_set_elems elems with\n    | None -> invalid_arg name\n    | Some s -> s\n  ;;\n\n  let inter elems = Set (Intersection (as_set_or_error \"Re.inter\" elems))\n  let compl elems = Set (Complement (as_set_or_error \"Re.compl\" elems))\n\n  let diff r r' =\n    match r, r' with\n    | Set r, Set r' -> Set (Difference (r, r'))\n    | _, _ -> invalid_arg \"Re.diff\"\n  ;;\n\n  let case =\n    let f = { f = (fun r -> Case r) } in\n    fun t -> make_set f t\n  ;;\n\n  let no_case =\n    let f = { f = (fun r -> No_case r) } in\n    fun t -> make_set f t\n  ;;\n\n  let witness t =\n    let rec witness (t : no_case) =\n      match t with\n      | Set c -> String.make 1 (Cset.to_char (Cset.pick c))\n      | Sequence xs -> String.concat \"\" (List.map ~f:witness xs)\n      | Ast (Alternative (x :: _)) -> witness x\n      | Ast (Alternative []) -> assert false\n      | Repeat (r, from, _to) ->\n        let w = witness r in\n        let b = Buffer.create (String.length w * from) in\n        for _i = 1 to from do\n          Buffer.add_string b w\n        done;\n        Buffer.contents b\n      | No_group r -> witness r\n      | Sem_greedy (_, r) | Sem (_, r) | Nest r | Pmark (_, r) | Group (_, r) -> witness r\n      | Beg_of_line\n      | End_of_line\n      | Beg_of_word\n      | End_of_word\n      | Not_bound\n      | Beg_of_str\n      | Last_end_of_line\n      | Start\n      | Stop\n      | End_of_str -> \"\"\n    in\n    witness (handle_case false t)\n  ;;\nend\n\nopen Export\n\nlet rec merge_sequences = function\n  | [] -> []\n  | Ast (Alternative l') :: r -> merge_sequences (l' @ r)\n  | Sequence (x :: y) :: r ->\n    (match merge_sequences r with\n     | Sequence (x' :: y') :: r' when equal Cset.equal x x' ->\n       Sequence [ x; Ast (Alternative [ seq y; seq y' ]) ] :: r'\n     | r' -> Sequence (x :: y) :: r')\n  | x :: r -> x :: merge_sequences r\n;;\n\n(*XXX Use a better algorithm allowing non-contiguous regions? *)\n\nlet colorize color_map (regexp : no_case) =\n  let lnl = ref false in\n  let rec colorize regexp =\n    match (regexp : no_case) with\n    | Set s -> Color_map.split color_map s\n    | Sequence l -> List.iter ~f:colorize l\n    | Ast (Alternative l) -> List.iter ~f:colorize l\n    | Repeat (r, _, _) -> colorize r\n    | Beg_of_line | End_of_line -> Color_map.split color_map Cset.nl\n    | Beg_of_word | End_of_word | Not_bound -> Color_map.split color_map Cset.cword\n    | Beg_of_str | End_of_str | Start | Stop -> ()\n    | Last_end_of_line -> lnl := true\n    | No_group r | Group (_, r) | Nest r | Pmark (_, r) -> colorize r\n    | Sem (_, r) | Sem_greedy (_, r) -> colorize r\n  in\n  colorize regexp;\n  !lnl\n;;\n\nlet rec anchored_ast : (t, _) ast -> bool = function\n  | Alternative als -> List.for_all ~f:anchored als\n  | No_case r | Case r -> anchored r\n\nand anchored : t -> bool = function\n  | Ast a -> anchored_ast a\n  | Sequence l -> List.exists ~f:anchored l\n  | Repeat (r, i, _) -> i > 0 && anchored r\n  | No_group r | Sem (_, r) | Sem_greedy (_, r) | Group (_, r) | Nest r | Pmark (_, r) ->\n    anchored r\n  | Set _\n  | Beg_of_line\n  | End_of_line\n  | Beg_of_word\n  | End_of_word\n  | Not_bound\n  | End_of_str\n  | Last_end_of_line\n  | Stop -> false\n  | Beg_of_str | Start -> true\n;;\n\nlet t_of_cset x = Set x\n","(* Result of a successful match. *)\ntype t =\n  { (* Input string. Matched strings are substrings of s *)\n    s : string\n      (* Mapping from group indices to positions in gpos. group i has positions 2*i\n         - 1, 2*i + 1 in gpos. If the group wasn't matched, then its corresponding\n           values in marks will be -1,-1 *)\n  ; marks : Mark_infos.t\n  ; (* Marks positions. i.e. those marks created with Re.marks *)\n    pmarks : Pmark.Set.t\n  ; (* Group positions. Adjacent elements are (start, stop) of group match.\n       indexed by the values in marks. So group i in an re would be the substring:\n\n       start = t.gpos.(marks.(2*i)) - 1\n       stop = t.gpos.(marks.(2*i + 1)) - 1 *)\n    gpos : int array\n  ; (* Number of groups the regular expression contains. Matched or not *)\n    gcount : int\n  }\n\nlet create s ~gcount ~gpos marks pmarks = { s; gcount; gpos; marks; pmarks }\n\nmodule Offset = struct\n  type t = int\n\n  let absent = -1\n  let is_present t = t >= 0\n  let get_no_check t = t\nend\n\nlet start_offset t i =\n  let i = Mark_infos.start_offset t.marks i in\n  if Mark_infos.Offset.is_present i\n  then t.gpos.(Mark_infos.Offset.get_no_check i)\n  else Offset.absent\n;;\n\nlet stop_offset t i =\n  let i = Mark_infos.stop_offset t.marks i in\n  if Mark_infos.Offset.is_present i\n  then t.gpos.(Mark_infos.Offset.get_no_check i)\n  else Offset.absent\n;;\n\nlet offset_opt t i =\n  Mark_infos.offset t.marks i\n  |> Option.map (fun (start, stop) -> t.gpos.(start), t.gpos.(stop))\n;;\n\nlet or_not_found = function\n  | None -> raise Not_found\n  | Some s -> s\n;;\n\nlet offset t i = offset_opt t i |> or_not_found\n\nlet get_opt t i =\n  offset_opt t i |> Option.map (fun (p1, p2) -> String.sub t.s p1 (p2 - p1))\n;;\n\nlet pmarks t = t.pmarks\nlet get t i = get_opt t i |> or_not_found\nlet start_opt subs i = offset_opt subs i |> Option.map fst\nlet start subs i = start_opt subs i |> or_not_found\nlet stop_opt subs i = offset_opt subs i |> Option.map snd\nlet stop subs i = stop_opt subs i |> or_not_found\nlet test t i = Mark_infos.test t.marks i\nlet get_opt t i = if test t i then Some (get t i) else None\nlet dummy_offset = -1, -1\n\nlet all_offset t =\n  let res = Array.make t.gcount dummy_offset in\n  Mark_infos.iteri t.marks ~f:(fun i start stop ->\n    let p1 = t.gpos.(start) in\n    let p2 = t.gpos.(stop) in\n    res.(i) <- p1, p2);\n  res\n;;\n\nlet dummy_string = \"\"\n\nlet all t =\n  let res = Array.make t.gcount dummy_string in\n  Mark_infos.iteri t.marks ~f:(fun i start stop ->\n    let p1 = t.gpos.(start) in\n    let p2 = t.gpos.(stop) in\n    res.(i) <- String.sub t.s p1 (p2 - p1));\n  res\n;;\n\nlet pp fmt t =\n  let matches =\n    let offsets = all_offset t in\n    let strs = all t in\n    Array.to_list (Array.init (Array.length strs) (fun i -> strs.(i), offsets.(i)))\n  in\n  let open Format in\n  let open Fmt in\n  let pp_match fmt (str, (start, stop)) = fprintf fmt \"@[(%s (%d %d))@]\" str start stop in\n  sexp fmt \"Group\" (list pp_match) matches\n;;\n\nlet nb_groups t = t.gcount\n","open Import\n\nlet rec iter n f v = if Int.equal n 0 then v else iter (n - 1) f (f v)\n\nmodule Idx : sig\n  type t [@@immediate]\n\n  val unknown : t\n  val make_break : Automata.Idx.t -> t\n  val of_idx : Automata.Idx.t -> t\n  val is_idx : t -> bool\n  val is_break : t -> bool\n  val is_unknown : t -> bool\n  val idx : t -> int\n  val break_idx : t -> int\nend = struct\n  type t = int\n\n  let unknown = -2\n  let break = -3\n  let of_idx (x : Automata.Idx.t) = Automata.Idx.to_int x [@@inline always]\n  let is_idx t = t >= 0 [@@inline always]\n  let is_break x = x <= break [@@inline always]\n  let is_unknown x = x = unknown [@@inline always]\n  let idx t = t [@@inline always]\n  let make_break (idx : Automata.Idx.t) = -5 - Automata.Idx.to_int idx [@@inline always]\n  let break_idx t = (t + 5) * -1 [@@inline always]\nend\n\ntype match_info =\n  | Match of Group.t\n  | Failed\n  | Running of { no_match_starts_before : int }\n\ntype state_info =\n  { idx : Idx.t\n  ; (* Index of the current position in the position table.\n       Not yet computed transitions point to a dummy state where\n       [idx] is set to [unknown];\n       If [idx] is set to [break] for states that either always\n       succeed or always fail. *)\n    mutable final : (Category.t * (Automata.Idx.t * Automata.Status.t)) list\n  ; (* Mapping from the category of the next character to\n       - the index where the next position should be saved\n       - possibly, the list of marks (and the corresponding indices)\n         corresponding to the best match *)\n    desc : Automata.State.t (* Description of this state of the automata *)\n  }\n\n(* Thread-safety: we use double-checked locking to access field [final]. *)\n\n(* A state [t] is a pair composed of some information about the\n   state [state_info] and a transition table [t array], indexed by\n   color. For performance reason, to avoid an indirection, we manually\n   unbox the transition table: we allocate a single array, with the\n   state information at index 0, followed by the transitions. *)\nmodule State : sig\n  type t\n\n  val make : ncol:int -> state_info -> t\n  val make_break : state_info -> t\n  val get_info : t -> state_info\n  val follow_transition : t -> color:Cset.c -> t\n  val set_transition : t -> color:Cset.c -> t -> unit\n  val is_unknown_transition : t -> color:Cset.c -> bool\nend = struct\n  type t = Table of t array [@@unboxed]\n\n  (* Thread-safety:\n     We store the state information at index 0. For other elements\n     of the transition table, which are lazily computed, we use\n     double-checked locking. *)\n\n  let get_info (Table st) : state_info = Obj.magic (Array.unsafe_get st 0)\n  [@@inline always]\n  ;;\n\n  let set_info (Table st) (info : state_info) = st.(0) <- Obj.magic info\n\n  let follow_transition (Table st) ~color = Array.unsafe_get st (1 + Cset.to_int color)\n  [@@inline always]\n  ;;\n\n  let set_transition (Table st) ~color st' = st.(1 + Cset.to_int color) <- st'\n\n  let is_unknown_transition st ~color =\n    let st' = follow_transition st ~color in\n    let info = get_info st' in\n    Idx.is_unknown info.idx\n  ;;\n\n  let dummy (info : state_info) = Table [| Obj.magic info |]\n  let unknown_state = dummy { idx = Idx.unknown; final = []; desc = Automata.State.dummy }\n\n  let make ~ncol state =\n    let st = Table (Array.make (ncol + 1) unknown_state) in\n    set_info st state;\n    st\n  ;;\n\n  let make_break state = Table [| Obj.magic state |]\nend\n\n(* Automata (compiled regular expression) *)\ntype re =\n  { initial : Automata.expr\n  ; (* The whole regular expression *)\n    mutable initial_states : (Category.t * State.t) list\n  ; (* Initial states, indexed by initial category *)\n    colors : Color_map.Table.t\n  ; (* Color table *)\n    color_repr : Color_map.Repr.t\n  ; (* Table from colors to one character of this color *)\n    ncolor : int\n  ; (* Number of colors. *)\n    lnl : Cset.c\n  ; (* Color of the last newline. [Cset.null_char] if unnecessary *)\n    tbl : Automata.Working_area.t\n  ; (* Temporary table used to compute the first available index\n       when computing a new state *)\n    states : State.t Automata.State.Table.t\n  ; (* States of the deterministic automata *)\n    group_names : (string * int) list\n  ; (* Named groups in the regular expression *)\n    group_count : int\n  ; (* Number of groups in the regular expression *)\n    mutex : Mutex.t\n  }\n\n(* Thread-safety:\n   We use double-checked locking to access field [initial_states]. The\n   state table [states] and the working area [tbl] are only accessed\n   with the mutex [mutex] locked.\n   The working area is shared between all threads. This might be\n   inefficient if many threads are updating the automaton. It seems\n   complicated to manage a working area per domain and per regular\n   expression. So, if this becomes an issue, it might just be simpler\n   to allocate a fresh working area whenever needed.\n*)\n\nlet pp_re ch re = Automata.pp ch re.initial\nlet group_count re = re.group_count\nlet group_names re = re.group_names\n\nmodule Positions = struct\n  (* Information used during matching *)\n  type t =\n    { mutable positions : int array\n    ; (* Array of mark positions\n         The mark are off by one for performance reasons *)\n      mutable length : int\n    }\n\n  let empty = { positions = [||]; length = 0 }\n  let length t = t.length\n  let unsafe_set t idx pos = Array.unsafe_set t.positions idx pos\n\n  let rec resize idx t =\n    t.length <- 2 * t.length;\n    if idx >= t.length\n    then resize idx t\n    else (\n      let pos = t.positions in\n      t.positions <- Array.make t.length 0;\n      Array.blit pos 0 t.positions 0 (Array.length pos))\n  ;;\n\n  let set t idx pos =\n    if idx >= length t then resize idx t;\n    unsafe_set t idx pos\n  ;;\n\n  let all t = t.positions\n  let first t = t.positions.(0)\n\n  let make ~groups re =\n    if groups\n    then (\n      (* We initialize this table with a reasonable size. The required\n         size may change when the automaton gets updated. So we are\n         always checking whether it is large enough before modifying it. *)\n      let length = Automata.Working_area.index_count re.tbl + 1 in\n      { positions = Array.make length 0; length })\n    else empty\n  ;;\nend\n\n(****)\n\nlet category re ~color =\n  if Cset.equal_c color Cset.null_char\n  then Category.inexistant (* Special category for the last newline *)\n  else if Cset.equal_c color re.lnl\n  then Category.(lastnewline ++ newline ++ not_letter)\n  else Category.from_char (Color_map.Repr.repr re.color_repr color)\n;;\n\n(****)\n\nlet find_state re desc =\n  try Automata.State.Table.find re.states desc with\n  | Not_found ->\n    let st =\n      let break_state =\n        match Automata.State.status_no_mutex desc with\n        | Running -> false\n        | Failed | Match _ -> true\n      in\n      let st =\n        { idx =\n            (let idx = Automata.State.idx desc in\n             if break_state then Idx.make_break idx else Idx.of_idx idx)\n        ; final = []\n        ; desc\n        }\n      in\n      if break_state then State.make_break st else State.make ~ncol:re.ncolor st\n    in\n    Automata.State.Table.add re.states desc st;\n    st\n;;\n\n(**** Match with marks ****)\n\nlet delta re cat ~color st = Automata.delta re.tbl cat color st.desc\n\nlet validate re (s : string) ~pos st =\n  let color = Color_map.Table.get re.colors s.[pos] in\n  Mutex.lock re.mutex;\n  if State.is_unknown_transition st ~color\n  then (\n    let st' =\n      let desc' =\n        let cat = category re ~color in\n        delta re cat ~color (State.get_info st)\n      in\n      find_state re desc'\n    in\n    State.set_transition st ~color st');\n  Mutex.unlock re.mutex\n;;\n\nlet next colors st s pos =\n  State.follow_transition st ~color:(Color_map.Table.get colors (String.unsafe_get s pos))\n;;\n\nlet rec loop re ~colors ~positions s ~pos ~last st0 st =\n  if pos < last\n  then (\n    let st' = next colors st s pos in\n    let idx = (State.get_info st').idx in\n    if Idx.is_idx idx\n    then\n      if Idx.idx idx < Positions.length positions\n      then (\n        Positions.unsafe_set positions (Idx.idx idx) pos;\n        loop re ~colors ~positions s ~pos:(pos + 1) ~last st' st')\n      else (\n        (* Resize position array *)\n        Positions.set positions (Idx.idx idx) pos;\n        loop re ~colors ~positions s ~pos:(pos + 1) ~last st' st')\n    else if Idx.is_break idx\n    then (\n      Positions.set positions (Idx.break_idx idx) pos;\n      st')\n    else (\n      (* Unknown *)\n      validate re s ~pos st0;\n      loop re ~colors ~positions s ~pos ~last st0 st0))\n  else st\n;;\n\nlet rec loop_no_mark re ~colors s ~pos ~last st0 st =\n  if pos < last\n  then (\n    let st' = next colors st s pos in\n    let idx = (State.get_info st').idx in\n    if Idx.is_idx idx\n    then loop_no_mark re ~colors s ~pos:(pos + 1) ~last st' st'\n    else if Idx.is_break idx\n    then st'\n    else (\n      (* Unknown *)\n      validate re s ~pos st0;\n      loop_no_mark re ~colors s ~pos ~last st0 st0))\n  else st\n;;\n\nlet final re st cat =\n  try List.assq cat st.final with\n  | Not_found ->\n    Mutex.lock re.mutex;\n    let res =\n      try List.assq cat st.final with\n      | Not_found ->\n        let st' = delta re cat ~color:Cset.null_char st in\n        let res = Automata.State.idx st', Automata.State.status_no_mutex st' in\n        st.final <- (cat, res) :: st.final;\n        res\n    in\n    Mutex.unlock re.mutex;\n    res\n;;\n\nlet find_initial_state re cat =\n  try List.assq cat re.initial_states with\n  | Not_found ->\n    Mutex.lock re.mutex;\n    let res =\n      try List.assq cat re.initial_states with\n      | Not_found ->\n        let st = find_state re (Automata.State.create cat re.initial) in\n        re.initial_states <- (cat, st) :: re.initial_states;\n        st\n    in\n    Mutex.unlock re.mutex;\n    res\n;;\n\nlet get_color re (s : string) pos =\n  if pos < 0\n  then Cset.null_char\n  else (\n    let slen = String.length s in\n    if pos >= slen\n    then Cset.null_char\n    else if pos = slen - 1\n            && (not (Cset.equal_c re.lnl Cset.null_char))\n            && Char.equal (String.unsafe_get s pos) '\\n'\n    then (* Special case for the last newline *)\n      re.lnl\n    else Color_map.Table.get re.colors (String.unsafe_get s pos))\n;;\n\nlet rec handle_last_newline re positions ~pos st ~groups =\n  let st' = State.follow_transition st ~color:re.lnl in\n  let info = State.get_info st' in\n  if Idx.is_idx info.idx\n  then (\n    if groups then Positions.set positions (Idx.idx info.idx) pos;\n    st')\n  else if Idx.is_break info.idx\n  then (\n    if groups then Positions.set positions (Idx.break_idx info.idx) pos;\n    st')\n  else (\n    (* Unknown *)\n    let color = re.lnl in\n    Mutex.lock re.mutex;\n    if State.is_unknown_transition st ~color\n    then (\n      let st' =\n        let desc =\n          let cat = category re ~color in\n          let real_c = Color_map.Table.get re.colors '\\n' in\n          delta re cat ~color:real_c (State.get_info st)\n        in\n        find_state re desc\n      in\n      State.set_transition st ~color st');\n    Mutex.unlock re.mutex;\n    handle_last_newline re positions ~pos st ~groups)\n;;\n\nlet rec scan_str re positions (s : string) initial_state ~last ~pos ~groups =\n  if last = String.length s\n     && (not (Cset.equal_c re.lnl Cset.null_char))\n     && last > pos\n     && Char.equal (String.get s (last - 1)) '\\n'\n  then (\n    let last = last - 1 in\n    let st = scan_str re positions ~pos s initial_state ~last ~groups in\n    if Idx.is_break (State.get_info st).idx\n    then st\n    else handle_last_newline re positions ~pos:last st ~groups)\n  else if groups\n  then loop re ~colors:re.colors ~positions s ~pos ~last initial_state initial_state\n  else loop_no_mark re ~colors:re.colors s ~pos ~last initial_state initial_state\n;;\n\n(* This function adds a final boundary check on the input.\n   This is useful to indicate that the output failed because\n   of insufficient input, or to verify that the output actually\n   matches for regex that have boundary conditions with respect\n   to the input string.\n*)\nlet final_boundary_check re positions ~last ~slen s state_info ~groups =\n  let idx, res =\n    let final_cat =\n      Category.(\n        search_boundary\n        ++ if last = slen then inexistant else category re ~color:(get_color re s last))\n    in\n    final re state_info final_cat\n  in\n  (match groups, res with\n   | true, Match _ -> Positions.set positions (Automata.Idx.to_int idx) last\n   | _ -> ());\n  res\n;;\n\nlet make_match_str re positions ~len ~groups ~partial s ~pos =\n  let slen = String.length s in\n  let last = if len = -1 then slen else pos + len in\n  let st =\n    let initial_state =\n      let initial_cat =\n        Category.(\n          search_boundary\n          ++ if pos = 0 then inexistant else category re ~color:(get_color re s (pos - 1)))\n      in\n      find_initial_state re initial_cat\n    in\n    scan_str re positions s initial_state ~pos ~last ~groups\n  in\n  let state_info = State.get_info st in\n  if Idx.is_break state_info.idx || (partial && not groups)\n  then Automata.State.status re.mutex state_info.desc\n  else if partial && groups\n  then (\n    match Automata.State.status re.mutex state_info.desc with\n    | (Match _ | Failed) as status -> status\n    | Running ->\n      (* This could be because it's still not fully matched, or it\n         could be that because we need to run special end of input\n         checks. *)\n      (match final_boundary_check re positions ~last ~slen s state_info ~groups with\n       | Match _ as status -> status\n       | Failed | Running ->\n         (* A failure here just means that we need more data, i.e.\n            it's a partial match. *)\n         Running))\n  else final_boundary_check re positions ~last ~slen s state_info ~groups\n;;\n\nmodule Stream = struct\n  type nonrec t =\n    { state : State.t\n    ; re : re\n    }\n\n  type 'a feed =\n    | Ok of 'a\n    | No_match\n\n  let create re =\n    let category = Category.(search_boundary ++ inexistant) in\n    let state = find_initial_state re category in\n    { state; re }\n  ;;\n\n  let feed t s ~pos ~len =\n    (* TODO bound checks? *)\n    let last = pos + len in\n    let state = loop_no_mark t.re ~colors:t.re.colors s ~last ~pos t.state t.state in\n    let info = State.get_info state in\n    if Idx.is_break info.idx\n       &&\n       match Automata.State.status t.re.mutex info.desc with\n       | Failed -> true\n       | Match _ | Running -> false\n    then No_match\n    else Ok { t with state }\n  ;;\n\n  let finalize t s ~pos ~len =\n    (* TODO bound checks? *)\n    let last = pos + len in\n    let state = scan_str t.re Positions.empty s t.state ~last ~pos ~groups:false in\n    let info = State.get_info state in\n    match\n      let _idx, res =\n        let final_cat = Category.(search_boundary ++ inexistant) in\n        final t.re info final_cat\n      in\n      res\n    with\n    | Running | Failed -> false\n    | Match _ -> true\n  ;;\n\n  module Group = struct\n    type nonrec t =\n      { t : t\n      ; positions : Positions.t\n      ; slices : Slice.L.t\n      ; abs_pos : int\n      ; first_match_pos : int\n      }\n\n    let no_match_starts_before t = t.first_match_pos\n\n    let create t =\n      { t\n      ; positions = Positions.make ~groups:true t.re\n      ; slices = []\n      ; abs_pos = 0\n      ; first_match_pos = 0\n      }\n    ;;\n\n    module Match = struct\n      type t =\n        { pmarks : Pmark.Set.t\n        ; slices : Slice.L.t\n        ; marks : Mark_infos.t\n        ; positions : int array\n        ; start_pos : int\n        }\n\n      let test_mark t mark = Pmark.Set.mem mark t.pmarks\n\n      let get t i =\n        Mark_infos.offset t.marks i\n        |> Option.map (fun (start, stop) ->\n          let start = t.positions.(start) - t.start_pos in\n          let stop = t.positions.(stop) - t.start_pos in\n          Slice.L.get_substring t.slices ~start ~stop)\n      ;;\n\n      let make ~start_pos ~pmarks ~slices ~marks ~positions =\n        let positions = Positions.all positions in\n        { pmarks; slices; positions; marks; start_pos }\n      ;;\n    end\n\n    let rec loop re ~abs_pos ~colors ~positions s ~pos ~last st0 st =\n      if pos < last\n      then (\n        let st' = next colors st s pos in\n        let idx = (State.get_info st').idx in\n        if Idx.is_idx idx\n        then\n          if Idx.idx idx < Positions.length positions\n          then (\n            Positions.unsafe_set positions (Idx.idx idx) (abs_pos + pos);\n            loop re ~abs_pos ~colors ~positions s ~pos:(pos + 1) ~last st' st')\n          else (\n            (* Resize position array *)\n            Positions.set positions (Idx.idx idx) (abs_pos + pos);\n            loop re ~abs_pos ~colors ~positions s ~pos:(pos + 1) ~last st' st')\n        else if Idx.is_break idx\n        then (\n          Positions.set positions (Idx.break_idx idx) (abs_pos + pos);\n          st')\n        else (\n          (* Unknown *)\n          validate re s ~pos st0;\n          loop re ~abs_pos ~colors ~positions s ~pos ~last st0 st0))\n      else st\n    ;;\n\n    let feed ({ t; positions; slices; abs_pos; first_match_pos = _ } as tt) s ~pos ~len =\n      let state =\n        (* TODO bound checks? *)\n        let last = pos + len in\n        loop t.re ~abs_pos ~colors:t.re.colors s ~positions ~last ~pos t.state t.state\n      in\n      let info = State.get_info state in\n      if Idx.is_break info.idx\n         &&\n         match Automata.State.status t.re.mutex info.desc with\n         | Failed -> true\n         | Match _ | Running -> false\n      then No_match\n      else (\n        let t = { t with state } in\n        let slices = { Slice.s; pos; len } :: slices in\n        let first_match_pos = Positions.first positions in\n        let slices = Slice.L.drop_rev slices (first_match_pos - tt.first_match_pos) in\n        let abs_pos = abs_pos + len in\n        Ok { tt with t; slices; abs_pos; first_match_pos })\n    ;;\n\n    let finalize\n      ({ t; positions; slices; abs_pos; first_match_pos = _ } as tt)\n      s\n      ~pos\n      ~len\n      : Match.t feed\n      =\n      (* TODO bound checks? *)\n      let last = pos + len in\n      let info =\n        let state =\n          loop t.re ~abs_pos ~colors:t.re.colors s ~positions ~last ~pos t.state t.state\n        in\n        State.get_info state\n      in\n      match\n        match Automata.State.status t.re.mutex info.desc with\n        | (Match _ | Failed) as s -> s\n        | Running ->\n          let idx, res =\n            let final_cat = Category.(search_boundary ++ inexistant) in\n            final t.re info final_cat\n          in\n          (match res with\n           | Running | Failed -> ()\n           | Match _ -> Positions.set positions (Automata.Idx.to_int idx) (abs_pos + last));\n          res\n      with\n      | Running | Failed -> No_match\n      | Match (marks, pmarks) ->\n        let first_match_position = Positions.first positions in\n        let slices =\n          let slices =\n            let slices = { Slice.s; pos; len } :: slices in\n            Slice.L.drop_rev slices (first_match_position - tt.first_match_pos)\n          in\n          List.rev slices\n        in\n        Ok (Match.make ~start_pos:first_match_position ~pmarks ~marks ~slices ~positions)\n    ;;\n  end\nend\n\nlet match_str_no_bounds ~groups ~partial re s ~pos ~len =\n  let positions = Positions.make ~groups re in\n  match make_match_str re positions ~len ~groups ~partial s ~pos with\n  | Match (marks, pmarks) ->\n    Match\n      (Group.create s marks pmarks ~gpos:(Positions.all positions) ~gcount:re.group_count)\n  | Failed -> Failed\n  | Running ->\n    let no_match_starts_before = if groups then Positions.first positions else 0 in\n    Running { no_match_starts_before }\n;;\n\nlet match_str_p re s ~pos ~len =\n  if pos < 0 || len < -1 || pos + len > String.length s\n  then invalid_arg \"Re.exec: out of bounds\";\n  match make_match_str re Positions.empty ~len ~groups:false ~partial:false s ~pos with\n  | Match _ -> true\n  | _ -> false\n;;\n\nlet match_str ~groups ~partial re s ~pos ~len =\n  if pos < 0 || len < -1 || pos + len > String.length s\n  then invalid_arg \"Re.exec: out of bounds\";\n  match_str_no_bounds ~groups ~partial re s ~pos ~len\n;;\n\nlet mk_re ~initial ~colors ~color_repr ~ncolor ~lnl ~group_names ~group_count =\n  { initial\n  ; initial_states = []\n  ; colors\n  ; color_repr\n  ; ncolor\n  ; lnl\n  ; tbl = Automata.Working_area.create ()\n  ; states = Automata.State.Table.create 97\n  ; group_names\n  ; group_count\n  ; mutex = Mutex.create ()\n  }\n;;\n\n(**** Compilation ****)\n\nmodule A = Automata\n\nlet enforce_kind ids kind kind' cr =\n  match kind, kind' with\n  | `First, `First -> cr\n  | `First, k -> A.seq ids k cr (A.eps ids)\n  | _ -> cr\n;;\n\ntype context =\n  { ids : A.Ids.t\n  ; kind : A.Sem.t\n  ; ign_group : bool\n  ; greedy : A.Rep_kind.t\n  ; pos : A.Mark.t ref\n  ; names : (string * int) list ref\n  ; cache : Cset.t Cset.CSetMap.t ref\n  ; colors : Color_map.Table.t\n  }\n\nlet trans_set cache (cm : Color_map.Table.t) s =\n  match Cset.one_char s with\n  | Some i -> Cset.csingle (Color_map.Table.get_char cm i)\n  | None ->\n    let v = Cset.hash s, s in\n    (try Cset.CSetMap.find v !cache with\n     | Not_found ->\n       let l = Color_map.Table.translate_colors cm s in\n       cache := Cset.CSetMap.add v l !cache;\n       l)\n;;\n\nlet make_repeater ids cr kind greedy =\n  match greedy with\n  | `Greedy -> fun rem -> A.alt ids [ A.seq ids kind (A.rename ids cr) rem; A.eps ids ]\n  | `Non_greedy ->\n    fun rem -> A.alt ids [ A.eps ids; A.seq ids kind (A.rename ids cr) rem ]\n;;\n\n(* XXX should probably compute a category mask *)\nlet rec translate\n  ({ ids; kind; ign_group; greedy; pos; names; cache; colors } as ctx)\n  (ast : Ast.no_case)\n  =\n  match ast with\n  | Set s -> A.cst ids (trans_set cache colors s), kind\n  | Sequence l -> trans_seq ctx l, kind\n  | Ast (Alternative l) ->\n    (match Ast.merge_sequences l with\n     | [ r' ] ->\n       let cr, kind' = translate ctx r' in\n       enforce_kind ids kind kind' cr, kind\n     | merged_sequences ->\n       ( A.alt\n           ids\n           (List.map merged_sequences ~f:(fun r' ->\n              let cr, kind' = translate ctx r' in\n              enforce_kind ids kind kind' cr))\n       , kind ))\n  | Repeat (r', i, j) ->\n    let cr, kind' = translate ctx r' in\n    let rem =\n      match j with\n      | None -> A.rep ids greedy kind' cr\n      | Some j ->\n        let f = make_repeater ids cr kind' greedy in\n        iter (j - i) f (A.eps ids)\n    in\n    iter i (fun rem -> A.seq ids kind' (A.rename ids cr) rem) rem, kind\n  | Beg_of_line -> A.after ids Category.(inexistant ++ newline), kind\n  | End_of_line -> A.before ids Category.(inexistant ++ newline), kind\n  | Beg_of_word ->\n    ( A.seq\n        ids\n        `First\n        (A.after ids Category.(inexistant ++ not_letter))\n        (A.before ids Category.letter)\n    , kind )\n  | End_of_word ->\n    ( A.seq\n        ids\n        `First\n        (A.after ids Category.letter)\n        (A.before ids Category.(inexistant ++ not_letter))\n    , kind )\n  | Not_bound ->\n    ( A.alt\n        ids\n        [ A.seq ids `First (A.after ids Category.letter) (A.before ids Category.letter)\n        ; (let cat = Category.(inexistant ++ not_letter) in\n           A.seq ids `First (A.after ids cat) (A.before ids cat))\n        ]\n    , kind )\n  | Beg_of_str -> A.after ids Category.inexistant, kind\n  | End_of_str -> A.before ids Category.inexistant, kind\n  | Last_end_of_line -> A.before ids Category.(inexistant ++ lastnewline), kind\n  | Start -> A.after ids Category.search_boundary, kind\n  | Stop -> A.before ids Category.search_boundary, kind\n  | Sem (kind', r') ->\n    let cr, kind'' = translate { ctx with kind = kind' } r' in\n    enforce_kind ids kind' kind'' cr, kind'\n  | Sem_greedy (greedy', r') -> translate { ctx with greedy = greedy' } r'\n  | Group (n, r') ->\n    if ign_group\n    then translate ctx r'\n    else (\n      let p = !pos in\n      let () =\n        match n with\n        | Some name -> names := (name, A.Mark.group_count p) :: !names\n        | None -> ()\n      in\n      pos := A.Mark.next2 !pos;\n      let cr, kind' = translate ctx r' in\n      ( A.seq ids `First (A.mark ids p) (A.seq ids `First cr (A.mark ids (A.Mark.next p)))\n      , kind' ))\n  | No_group r' -> translate { ctx with ign_group = true } r'\n  | Nest r' ->\n    let b = !pos in\n    let cr, kind' = translate ctx r' in\n    let e = A.Mark.prev !pos in\n    if A.Mark.compare e b = -1\n    then cr, kind'\n    else A.seq ids `First (A.erase ids b e) cr, kind'\n  | Pmark (i, r') ->\n    let cr, kind' = translate ctx r' in\n    A.seq ids `First (A.pmark ids i) cr, kind'\n\nand trans_seq ({ ids; kind; _ } as ctx) = function\n  | [] -> A.eps ids\n  | [ r ] ->\n    let cr', kind' = translate ctx r in\n    enforce_kind ids kind kind' cr'\n  | r :: rem ->\n    let cr', kind' = translate ctx r in\n    let cr'' = trans_seq ctx rem in\n    if A.is_eps cr'' then cr' else if A.is_eps cr' then cr'' else A.seq ids kind' cr' cr''\n;;\n\nlet compile_1 regexp =\n  let regexp = Ast.handle_case false regexp in\n  let color_map = Color_map.make () in\n  let need_lnl = Ast.colorize color_map regexp in\n  let colors, color_repr = Color_map.flatten color_map in\n  let ncolor = Color_map.Repr.length color_repr in\n  let lnl = if need_lnl then Cset.of_int ncolor else Cset.null_char in\n  let ncolor = if need_lnl then ncolor + 1 else ncolor in\n  let ctx =\n    { ids = A.Ids.create ()\n    ; kind = `First\n    ; ign_group = false\n    ; greedy = `Greedy\n    ; pos = ref A.Mark.start\n    ; names = ref []\n    ; cache = ref Cset.CSetMap.empty\n    ; colors\n    }\n  in\n  let r, kind = translate ctx regexp in\n  let r = enforce_kind ctx.ids `First kind r in\n  (*Format.eprintf \"<%d %d>@.\" !ids ncol;*)\n  mk_re\n    ~initial:r\n    ~colors\n    ~color_repr\n    ~ncolor\n    ~lnl\n    ~group_names:(List.rev !(ctx.names))\n    ~group_count:(A.Mark.group_count !(ctx.pos))\n;;\n\nlet compile r =\n  let open Ast.Export in\n  compile_1 (if Ast.anchored r then group r else seq [ shortest (rep any); group r ])\n;;\n","(*\n   RE - A regular expression library\n\n   Copyright (C) 2001 Jerome Vouillon\n   email: Jerome.Vouillon@pps.jussieu.fr\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation, with\n   linking exception; either version 2.1 of the License, or (at\n   your option) any later version.\n\n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with this library; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n*)\n\nopen Import\n\ninclude struct\n  let cset = Ast.cset\n  let rg c c' = cset (Cset.cseq c c')\n  let notnl = cset Cset.notnl\n  let lower = cset Cset.lower\n  let upper = cset Cset.upper\n  let alpha = cset Cset.alpha\n  let digit = cset Cset.cdigit\n  let alnum = cset Cset.alnum\n  let wordc = cset Cset.wordc\n  let ascii = cset Cset.ascii\n  let blank = cset Cset.blank\n  let cntrl = cset Cset.cntrl\n  let graph = cset Cset.graph\n  let print = cset Cset.print\n  let punct = cset Cset.punct\n  let space = cset Cset.space\n  let xdigit = cset Cset.xdigit\nend\n\ninclude Ast.Export\n\nlet exec_internal ?(pos = 0) ?(len = -1) ~partial ~groups re s =\n  Compile.match_str ~groups ~partial re s ~pos ~len\n;;\n\nlet exec ?pos ?len re s =\n  match exec_internal ?pos ?len ~groups:true ~partial:false re s with\n  | Match substr -> substr\n  | _ -> raise Not_found\n;;\n\nlet exec_opt ?pos ?len re s =\n  match exec_internal ?pos ?len ~groups:true ~partial:false re s with\n  | Match substr -> Some substr\n  | _ -> None\n;;\n\nlet execp ?(pos = 0) ?(len = -1) re s = Compile.match_str_p ~pos ~len re s\n\nlet exec_partial ?pos ?len re s =\n  match exec_internal ~groups:false ~partial:true ?pos ?len re s with\n  | Match _ -> `Full\n  | Running _ -> `Partial\n  | Failed -> `Mismatch\n;;\n\nlet exec_partial_detailed ?pos ?len re s =\n  match exec_internal ~groups:true ~partial:true ?pos ?len re s with\n  | Match group -> `Full group\n  | Running { no_match_starts_before } -> `Partial no_match_starts_before\n  | Failed -> `Mismatch\n;;\n\nmodule Mark = struct\n  type t = Pmark.t\n\n  let test (g : Group.t) p = Pmark.Set.mem p (Group.pmarks g)\n  let all (g : Group.t) = Group.pmarks g\n\n  module Set = Pmark.Set\n\n  let equal = Pmark.equal\n  let compare = Pmark.compare\nend\n\ntype split_token =\n  [ `Text of string\n  | `Delim of Group.t\n  ]\n\nmodule Gen = struct\n  type 'a gen = unit -> 'a option\n\n  let gen_of_seq (s : 'a Seq.t) : 'a gen =\n    let r = ref s in\n    fun () ->\n      match !r () with\n      | Seq.Nil -> None\n      | Seq.Cons (x, tl) ->\n        r := tl;\n        Some x\n  ;;\n\n  let split ?pos ?len re s : _ gen = Search.split ?pos ?len re s |> gen_of_seq\n  let split_full ?pos ?len re s : _ gen = Search.split_full ?pos ?len re s |> gen_of_seq\n  let all ?pos ?len re s = Search.all ?pos ?len re s |> gen_of_seq\n  let matches ?pos ?len re s = Search.matches ?pos ?len re s |> gen_of_seq\nend\n\nmodule Group = Group\n\n(** {2 Deprecated functions} *)\n\nlet split_full_seq = Search.split_full\nlet split_seq = Search.split\nlet matches_seq = Search.matches\nlet all_seq = Search.all\n\ntype 'a gen = 'a Gen.gen\n\nlet all_gen = Gen.all\nlet matches_gen = Gen.matches\nlet split_gen = Gen.split\nlet split_full_gen = Gen.split_full\n\ntype substrings = Group.t\n\nlet get = Group.get\nlet get_ofs = Group.offset\nlet get_all = Group.all\nlet get_all_ofs = Group.all_offset\nlet test = Group.test\n\ntype markid = Mark.t\n\nlet marked = Mark.test\nlet mark_set = Mark.all\n\ntype groups = Group.t\n\nmodule List = struct\n  let list_of_seq (s : 'a Seq.t) : 'a list =\n    Seq.fold_left (fun l x -> x :: l) [] s |> List.rev\n  ;;\n\n  let all ?pos ?len re s = Search.all ?pos ?len re s |> list_of_seq\n  let matches ?pos ?len re s = Search.matches ?pos ?len re s |> list_of_seq\n  let split_full ?pos ?len re s = Search.split_full ?pos ?len re s |> list_of_seq\n  let split ?pos ?len re s = Search.split ?pos ?len re s |> list_of_seq\n  let split_delim ?pos ?len re s = Search.split_delim ?pos ?len re s |> list_of_seq\nend\n\ninclude List\n\ninclude struct\n  open Compile\n\n  type nonrec re = re\n\n  let compile = compile\n  let pp_re = pp_re\n  let print_re = pp_re\n  let group_names = group_names\n  let group_count = group_count\nend\n\nmodule Seq = Search\nmodule Stream = Compile.Stream\n","# 1 \"lib/fake/domain.ml\"\nmodule DLS = struct\n  let new_key f = ref (f())\n  let set x y = x := y\n  let get x = !x\nend\n","type t =\n  { str : string\n  ; mutable pos : int\n  }\n\nexception Parse_error\n\nlet create str = { str; pos = 0 }\nlet unget t = t.pos <- t.pos - 1\nlet junk t = t.pos <- t.pos + 1\nlet eos t = t.pos = String.length t.str\nlet test t c = (not (eos t)) && t.str.[t.pos] = c\n\nlet test2 t c c' =\n  t.pos + 1 < String.length t.str && t.str.[t.pos] = c && t.str.[t.pos + 1] = c'\n;;\n\nlet accept t c =\n  let r = test t c in\n  if r then t.pos <- t.pos + 1;\n  r\n;;\n\nlet get t =\n  let r = t.str.[t.pos] in\n  t.pos <- t.pos + 1;\n  r\n;;\n\nlet accept_s t s' =\n  let len = String.length s' in\n  try\n    for j = 0 to len - 1 do\n      (* CR-someday rgrinberg: stop relying on bound checks *)\n      try if s'.[j] <> t.str.[t.pos + j] then raise_notrace Exit with\n      | _ -> raise_notrace Exit\n    done;\n    t.pos <- t.pos + len;\n    true\n  with\n  | Exit -> false\n;;\n\nlet rec integer' t i =\n  if eos t\n  then Some i\n  else (\n    match get t with\n    | '0' .. '9' as d ->\n      let i' = (10 * i) + (Char.code d - Char.code '0') in\n      if i' < i then raise Parse_error;\n      integer' t i'\n    | _ ->\n      unget t;\n      Some i)\n;;\n\nlet integer t =\n  if eos t\n  then None\n  else (\n    match get t with\n    | '0' .. '9' as d -> integer' t (Char.code d - Char.code '0')\n    | _ ->\n      unget t;\n      None)\n;;\n","(*\n   RE - A regular expression library\n\n   Copyright (C) 2001 Jerome Vouillon\n   email: Jerome.Vouillon@pps.jussieu.fr\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation, with\n   linking exception; either version 2.1 of the License, or (at\n   your option) any later version.\n\n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with this library; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n*)\n\nmodule Re = Core\n\nexception Parse_error\nexception Not_supported\n\nlet by_code f c c' =\n  let c = Char.code c in\n  let c' = Char.code c' in\n  Char.chr (f c c')\n;;\n\nlet parse ~emacs_only s =\n  let buf = Parse_buffer.create s in\n  let accept = Parse_buffer.accept buf in\n  let eos () = Parse_buffer.eos buf in\n  let test2 = Parse_buffer.test2 buf in\n  let get () = Parse_buffer.get buf in\n  let rec regexp () = regexp' [ branch () ]\n  and regexp' left =\n    if Parse_buffer.accept_s buf {|\\||}\n    then regexp' (branch () :: left)\n    else Re.alt (List.rev left)\n  and branch () = branch' []\n  and branch' left =\n    if eos () || test2 '\\\\' '|' || test2 '\\\\' ')'\n    then Re.seq (List.rev left)\n    else branch' (piece () :: left)\n  and piece () =\n    let r = atom () in\n    if accept '*'\n    then Re.rep r\n    else if accept '+'\n    then Re.rep1 r\n    else if accept '?'\n    then Re.opt r\n    else r\n  and atom () =\n    if accept '.'\n    then Re.notnl\n    else if accept '^'\n    then Re.bol\n    else if accept '$'\n    then Re.eol\n    else if accept '['\n    then if accept '^' then Re.compl (bracket []) else Re.alt (bracket [])\n    else if accept '\\\\'\n    then\n      if accept '('\n      then (\n        let r = regexp () in\n        if not (Parse_buffer.accept_s buf {|\\)|}) then raise Parse_error;\n        Re.group r)\n      else if emacs_only && accept '`'\n      then Re.bos\n      else if emacs_only && accept '\\''\n      then Re.eos\n      else if accept '='\n      then Re.start\n      else if accept 'b'\n      then Re.alt [ Re.bow; Re.eow ]\n      else if emacs_only && accept 'B'\n      then Re.not_boundary\n      else if emacs_only && accept '<'\n      then Re.bow\n      else if emacs_only && accept '>'\n      then Re.eow\n      else if accept 'w'\n      then Re.alt [ Re.alnum; Re.char '_' ]\n      else if accept 'W'\n      then Re.compl [ Re.alnum; Re.char '_' ]\n      else (\n        if eos () then raise Parse_error;\n        match get () with\n        | ('*' | '+' | '?' | '[' | ']' | '.' | '^' | '$' | '\\\\') as c -> Re.char c\n        | '0' .. '9' -> raise Not_supported\n        | c -> if emacs_only then raise Parse_error else Re.char c)\n    else (\n      if eos () then raise Parse_error;\n      match get () with\n      | '*' | '+' | '?' -> raise Parse_error\n      | c -> Re.char c)\n  and bracket s =\n    if s <> [] && accept ']'\n    then s\n    else (\n      let c = char () in\n      if accept '-'\n      then\n        if accept ']'\n        then Re.char c :: Re.char '-' :: s\n        else (\n          let c' = char () in\n          let c' = by_code Int.max c c' in\n          bracket (Re.rg c c' :: s))\n      else bracket (Re.char c :: s))\n  and char () =\n    if eos () then raise Parse_error;\n    get ()\n  in\n  let res = regexp () in\n  if not (eos ()) then raise Parse_error;\n  res\n;;\n\nlet re ?(case = true) s =\n  let r = parse s ~emacs_only:true in\n  if case then r else Re.no_case r\n;;\n\nlet re_no_emacs ~case s =\n  let r = parse s ~emacs_only:false in\n  if case then r else Re.no_case r\n;;\n\nlet re_result ?case s =\n  match re ?case s with\n  | s -> Ok s\n  | exception Not_supported -> Error `Not_supported\n  | exception Parse_error -> Error `Parse_error\n;;\n\nlet compile = Re.compile\nlet compile_pat ?(case = true) s = compile (re ~case s)\n","(***********************************************************************)\n(*                                                                     *)\n(*                           Objective Caml                            *)\n(*                                                                     *)\n(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)\n(*                                                                     *)\n(*  Copyright 1996 Institut National de Recherche en Informatique et   *)\n(*  en Automatique.  All rights reserved.  This file is distributed    *)\n(*  under the terms of the GNU Library General Public License, with    *)\n(*  linking exception.                                                 *)\n(*                                                                     *)\n(***********************************************************************)\n\n(* Modified by Jerome.Vouillon@pps.jussieu.fr for integration in RE *)\n\n(* $Id: re_str.ml,v 1.3 2002/07/03 15:47:54 vouillon Exp $ *)\n\nmodule Ast = Ast.Export\n\ninclude struct\n  open Core\n\n  let exec = exec\n  let exec_partial = exec_partial\nend\n\ntype regexp =\n  { mtch : Compile.re Lazy.t\n  ; srch : Compile.re Lazy.t\n  }\n\nlet compile_regexp s c =\n  let re = Emacs.re_no_emacs ~case:(not c) s in\n  { mtch = lazy (Compile.compile (Ast.seq [ Ast.start; re ]))\n  ; srch = lazy (Compile.compile re)\n  }\n;;\n\nlet state = Domain.DLS.new_key (fun () -> None)\n\nlet string_match re s p =\n  match exec ~pos:p (Lazy.force re.mtch) s with\n  | res ->\n    Domain.DLS.set state (Some res);\n    true\n  | exception Not_found ->\n    Domain.DLS.set state None;\n    false\n;;\n\nlet string_partial_match re s p =\n  match exec_partial ~pos:p (Lazy.force re.mtch) s with\n  | `Full -> string_match re s p\n  | `Partial -> true\n  | `Mismatch -> false\n;;\n\nlet search_forward re s p =\n  match exec ~pos:p (Lazy.force re.srch) s with\n  | res ->\n    Domain.DLS.set state (Some res);\n    fst (Group.offset res 0)\n  | exception Not_found ->\n    Domain.DLS.set state None;\n    raise Not_found\n;;\n\nlet rec search_backward re s p =\n  match exec ~pos:p (Lazy.force re.mtch) s with\n  | res ->\n    Domain.DLS.set state (Some res);\n    p\n  | exception Not_found ->\n    Domain.DLS.set state None;\n    if p = 0 then raise Not_found else search_backward re s (p - 1)\n;;\n\nlet valid_group n =\n  n >= 0\n  && n < 10\n  &&\n  match Domain.DLS.get state with\n  | None -> false\n  | Some m -> n < Group.nb_groups m\n;;\n\nlet offset_group i =\n  match Domain.DLS.get state with\n  | Some m -> Group.offset m i\n  | None -> raise Not_found\n;;\n\nlet group_len i =\n  match offset_group i with\n  | b, e -> e - b\n  | exception Not_found -> 0\n;;\n\nlet rec repl_length repl p q len =\n  if p < len\n  then\n    if repl.[p] <> '\\\\'\n    then repl_length repl (p + 1) (q + 1) len\n    else (\n      let p = p + 1 in\n      if p = len then failwith \"Str.replace: illegal backslash sequence\";\n      let q =\n        match repl.[p] with\n        | '\\\\' -> q + 1\n        | '0' .. '9' as c -> q + group_len (Char.code c - Char.code '0')\n        | _ -> q + 2\n      in\n      repl_length repl (p + 1) q len)\n  else q\n;;\n\nlet rec replace orig repl p res q len =\n  if p < len\n  then (\n    let c = repl.[p] in\n    if c <> '\\\\'\n    then (\n      Bytes.set res q c;\n      replace orig repl (p + 1) res (q + 1) len)\n    else (\n      match repl.[p + 1] with\n      | '\\\\' ->\n        Bytes.set res q '\\\\';\n        replace orig repl (p + 2) res (q + 1) len\n      | '0' .. '9' as c ->\n        let d =\n          let group = Char.code c - Char.code '0' in\n          match offset_group group with\n          | exception Not_found -> 0\n          | b, e ->\n            let d = e - b in\n            if d > 0 then String.blit orig b res q d;\n            d\n        in\n        replace orig repl (p + 2) res (q + d) len\n      | c ->\n        Bytes.set res q '\\\\';\n        Bytes.set res (q + 1) c;\n        replace orig repl (p + 2) res (q + 2) len))\n;;\n\nlet replacement_text repl orig =\n  let len = String.length repl in\n  let res = Bytes.create (repl_length repl 0 0 len) in\n  replace orig repl 0 res 0 (String.length repl);\n  Bytes.unsafe_to_string res\n;;\n\nlet quote s =\n  let len = String.length s in\n  let buf = Buffer.create (2 * len) in\n  for i = 0 to len - 1 do\n    match s.[i] with\n    | ('[' | ']' | '*' | '.' | '\\\\' | '?' | '+' | '^' | '$') as c ->\n      Buffer.add_char buf '\\\\';\n      Buffer.add_char buf c\n    | c -> Buffer.add_char buf c\n  done;\n  Buffer.contents buf\n;;\n\nlet string_before s n = String.sub s 0 n\nlet string_after s n = String.sub s n (String.length s - n)\nlet first_chars s n = String.sub s 0 n\nlet last_chars s n = String.sub s (String.length s - n) n\nlet regexp e = compile_regexp e false\nlet regexp_case_fold e = compile_regexp e true\nlet regexp_string s = compile_regexp (quote s) false\nlet regexp_string_case_fold s = compile_regexp (quote s) true\n\nlet group_beginning n =\n  if not (valid_group n) then invalid_arg \"Str.group_beginning\";\n  let pos = fst (offset_group n) in\n  if pos = -1 then raise Not_found else pos\n;;\n\nlet group_end n =\n  if not (valid_group n) then invalid_arg \"Str.group_end\";\n  let pos = snd (offset_group n) in\n  if pos = -1 then raise Not_found else pos\n;;\n\nlet matched_group n txt =\n  let b, e = offset_group n in\n  String.sub txt b (e - b)\n;;\n\nlet replace_matched repl matched = replacement_text repl matched\n\nlet match_beginning () = group_beginning 0\nand match_end () = group_end 0\nand matched_string txt = matched_group 0 txt\n\nlet substitute_first expr repl_fun text =\n  try\n    let pos = search_forward expr text 0 in\n    String.concat\n      \"\"\n      [ string_before text pos; repl_fun text; string_after text (match_end ()) ]\n  with\n  | Not_found -> text\n;;\n\nlet global_substitute expr repl_fun text =\n  let rec replace accu start last_was_empty =\n    let startpos = if last_was_empty then start + 1 else start in\n    if startpos > String.length text\n    then string_after text start :: accu\n    else (\n      match search_forward expr text startpos with\n      | pos ->\n        let end_pos = match_end () in\n        let repl_text = repl_fun text in\n        replace\n          (repl_text :: String.sub text start (pos - start) :: accu)\n          end_pos\n          (end_pos = pos)\n      | exception Not_found -> string_after text start :: accu)\n  in\n  String.concat \"\" (List.rev (replace [] 0 false))\n;;\n\nlet global_replace expr repl text = global_substitute expr (replacement_text repl) text\nand replace_first expr repl text = substitute_first expr (replacement_text repl) text\n\nlet search_forward_progress re s p =\n  let pos = search_forward re s p in\n  if match_end () > p\n  then pos\n  else if p < String.length s\n  then search_forward re s (p + 1)\n  else raise Not_found\n;;\n\nlet bounded_split expr text num =\n  let start = if string_match expr text 0 then match_end () else 0 in\n  let rec split accu start n =\n    if start >= String.length text\n    then accu\n    else if n = 1\n    then string_after text start :: accu\n    else (\n      match search_forward_progress expr text start with\n      | pos -> split (String.sub text start (pos - start) :: accu) (match_end ()) (n - 1)\n      | exception Not_found -> string_after text start :: accu)\n  in\n  List.rev (split [] start num)\n;;\n\nlet split expr text = bounded_split expr text 0\n\nlet bounded_split_delim expr text num =\n  let rec split accu start n =\n    if start > String.length text\n    then accu\n    else if n = 1\n    then string_after text start :: accu\n    else (\n      match search_forward_progress expr text start with\n      | pos -> split (String.sub text start (pos - start) :: accu) (match_end ()) (n - 1)\n      | exception Not_found -> string_after text start :: accu)\n  in\n  if text = \"\" then [] else List.rev (split [] 0 num)\n;;\n\nlet split_delim expr text = bounded_split_delim expr text 0\n\ntype split_result =\n  | Text of string\n  | Delim of string\n\nlet bounded_full_split expr text num =\n  let rec split accu start n =\n    if start >= String.length text\n    then accu\n    else if n = 1\n    then Text (string_after text start) :: accu\n    else (\n      match search_forward_progress expr text start with\n      | pos ->\n        let s = matched_string text in\n        if pos > start\n        then\n          split\n            (Delim s :: Text (String.sub text start (pos - start)) :: accu)\n            (match_end ())\n            (n - 1)\n        else split (Delim s :: accu) (match_end ()) (n - 1)\n      | exception Not_found -> Text (string_after text start) :: accu)\n  in\n  List.rev (split [] 0 num)\n;;\n\nlet full_split expr text = bounded_full_split expr text 0\n","# 1 \"src/OCamlFlat.ml\"\r\n(*\r\n * OCamlFlat.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * feb/2021 (amd) - New module.\r\n *)\r\n\r\nlet ocamlFlatVersion = \"1.0\"\r\n# 1 \"src/Configuration.ml\"\r\n(*\r\n * Configuration.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * jan/2021 (amd) - Module in an independent file.\r\n * jun/2019 (amd) - Initial version, inside the big file \"OCamlFlatSupport.ml\".\r\n *)\r\n\r\nmodule type ConfigurationSig =\r\nsig\r\n\tval diagnosticsOn : unit -> bool\r\nend\r\n\r\nmodule Configuration : ConfigurationSig =\r\nstruct\r\n\tlet automaticDiagnostics = ref true\r\n\r\n\tlet diagnosticsOn () = !automaticDiagnostics\r\nend\r\n# 1 \"src/Error.ml\"\r\n(*\r\n * Error.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * jan/2024 (amd) - Error groupings and support for setting of viewer.\r\n * jul/2021 (amd) - Simplified module.\r\n * jan/2021 (amd) - Module in an independent file.\r\n * jun/2019 (amd) - Initial version, inside the big file \"OCamlFlatSupport.ml\".\r\n *)\r\n\r\n(*\r\n * Description: Supports a log of errors. Probably, a text-based application\r\n * will use the error log differently from a graphical-based application.\r\n * The errors are handled in a imperative style to simplify the signature of\r\n * many functions - this modules implements a kind of error log monad.\r\n *)\r\n\r\n\r\nmodule ErrorViewer =\r\nstruct\r\n\tlet errorViewer: (string -> unit) ref =\r\n\t\tref print_string\r\n\r\n\tlet quietViewer (_: string): unit =\r\n\t\t()\r\n\r\n\tlet defaultViewer (mesg: string): unit =\r\n\t\tprint_string mesg\r\n\r\n\tlet setViewer (f: string -> unit): unit =\r\n\t\terrorViewer := f\r\n\r\n\tlet adjust (mesg: string) =\r\n\t\tlet len = String.length mesg in\r\n\t\tlet last = if len > 0 then mesg.[len-1] else ' ' in\r\n\t\t\tif len = 0 then\r\n\t\t\t\t\"EMPTY MESG\"\r\n\t\t\telse if last = '.' then\r\n\t\t\t\tmesg ^ \"\\n\"\r\n\t\t\telse\r\n\t\t\t\tmesg ^ \".\\n\"\r\n\r\n\tlet view (mesg: string): unit =\r\n\t\tif Configuration.diagnosticsOn () then\r\n\t\t\t!errorViewer (adjust mesg)\r\n\t\t\r\n\tlet fatal (mesg: string) =\r\n\t\tview (\"FATAL ERROR - \" ^ mesg);\r\n\t\tfailwith mesg\r\n\r\n\tlet warning (mesg: string) =\r\n\t\tview (\"WARNING - \" ^ mesg);\r\nend\r\n\r\n\r\nmodule ErrorGrouping =\r\nstruct\r\n\topen ErrorViewer\r\n\r\n\tlet gouping: bool ref =\r\n\t\tref false\r\n\r\n\tlet errors: string list ref =\r\n\t\tref []\r\n\r\n\tlet startGroup (): unit =\r\n\t\tgouping := true;\r\n\t\terrors := []\r\n\r\n\tlet makeMesg (culprit: string) (str: string) =\r\n\t\tif !gouping || culprit = \"\" || culprit = \"_\" then \" - \" ^ str ^ \"\\n\"\r\n\t\telse culprit ^ \" - \" ^ str ^ \"\\n\"\r\n\r\n\tlet error (culprit: string) (str: string) (res: 'a): 'a =\r\n\t\tlet mesg = makeMesg culprit str in\r\n\t\t\t(if !gouping then\r\n\t\t\t\terrors := !errors @ [mesg]\r\n\t\t\telse\r\n\t\t\t\tview mesg);\r\n\t\t\tres\r\n\r\n\tlet endGroup (expectedKind: string) (name: string): bool =\r\n\t\tgouping := false;\r\n\t\tif !errors = [] then\r\n\t\t\ttrue\r\n\t\telse\r\n\t\t\tlet mesg =\r\n\t\t\t\t  \"--------------------------\\n\"\r\n\t\t\t\t^ expectedKind^\" \\\"\"^name^ \"\\\" has errors:\\n\"\r\n\t\t\t\t^ String.concat \"\" !errors\r\n\t\t\t\t^ \"--------------------------\\n\"\r\n\t\t\tin view mesg;\r\n\t\t\terrors := [];\r\n\t\t\tfalse\r\n\r\n\tlet get (): string list =\r\n\t\t!errors\r\nend\r\n\r\nmodule Error =\r\nstruct\r\n\topen ErrorViewer\r\n\topen ErrorGrouping\r\n\r\n\tlet quietViewer = quietViewer\r\n\tlet defaultViewer = defaultViewer\r\n\tlet setViewer = setViewer\r\n\r\n\tlet startGroup = startGroup\r\n\tlet error = error\r\n\tlet endGroup = endGroup\r\n\tlet get = get\r\n\t\t\r\n\tlet fatal = fatal\r\n\tlet warning = warning\r\nend\r\n# 1 \"src/Set.ml\"\r\n(*\r\n * Set.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * mar/2022 (amd) - More functions; stable ordering.\r\n * may/2021 (amd) - New projection functions; new fixed point function.\r\n * jan/2021 (amd) - Module in an independent file.\r\n * jun/2019 (amd) - Initial version, inside the big file \"OCamlFlatSupport.ml\".\r\n *)\r\n\r\n(*\r\n * Description: Polymorphic sets. Naive implementation.\r\n *\r\n * TODO: Improve the implementation or move to the functorized sets of\r\n * the ocaml standard library.\r\n *)\r\n \r\n\r\n# 36 \"src/Set.ml\"\r\nmodule type SetSig =\r\nsig\r\n\r\n\t\r\n# 40 \"src/Set.ml\"\r\n type 'a t (* opaque *)\r\n\r\n\t\r\n# 45 \"src/Set.ml\"\r\n val make : 'a list -> 'a t\r\n\tval singleton : 'a -> 'a t\r\n\tval empty : 'a t\r\n\tval toList : 'a t -> 'a list\r\n\r\n\tval makeSorted : 'a list -> 'a t\r\n\tval sort: 'a t -> 'a t\r\n\r\n\tval isEmpty : 'a t -> bool\r\n\tval size : 'a t -> int\r\n\tval compare_sizes: 'a t -> 'b t -> int\r\n\tval compare_size_with : 'a t -> int -> int\r\n\tval cons : 'a -> 'a t -> 'a t\r\n\tval hd : 'a t -> 'a\r\n\tval tl : 'a t -> 'a t\r\n\tval cut : 'a t -> 'a * 'a t\r\n\tval match_ : 'a t -> (unit -> 'b) -> ('a -> 'a t -> 'b) -> 'b\r\n\tval nth : 'a t -> int -> 'a\r\n\tval nth_opt : 'a t -> int -> 'a option\r\n\tval init : int -> (int -> 'a) -> 'a t\r\n\tval flatten : 'a t t -> 'a t\r\n\t\r\n\tval iter : ('a -> unit) -> 'a t -> unit\r\n\tval iteri : (int -> 'a -> unit) -> 'a t -> unit\r\n\tval map : ('a -> 'b) -> 'a t -> 'b t\r\n\tval mapi : (int -> 'a -> 'b) -> 'a t -> 'b t\r\n\tval flatMap : ('a -> 'b t) -> 'a t -> 'b t\r\n\tval flat_map : ('a -> 'b t) -> 'a t -> 'b t\r\n\tval fold_left: ('a -> 'b -> 'a) -> 'a -> 'b t -> 'a\r\n\tval fold_right: ('a -> 'b -> 'b) -> 'a t -> 'b -> 'b\r\n\tval fold_left_s: ('a t -> 'b -> 'a t) -> 'a t -> 'b t -> 'a t\r\n\tval fold_right_s: ('a -> 'b t -> 'b t) -> 'a t -> 'b t -> 'b t\r\n\r\n\tval for_all : ('a -> bool) -> 'a t -> bool\r\n\tval exists : ('a -> bool) -> 'a t -> bool\r\n\tval belongs : 'a -> 'a t -> bool\r\n\tval subset : 'a t -> 'a t -> bool\r\n\tval equals : 'a t -> 'a t -> bool\r\n\t\r\n\tval find : ('a -> bool) -> 'a t -> 'a\r\n\tval find_opt : ('a -> bool) -> 'a t -> 'a option\r\n\tval filter : ('a -> bool) -> 'a t -> 'a t\r\n\r\n\tval fmap : ('a -> bool) -> ('a -> 'b) -> 'a t -> 'b t\r\n\tval mapf : ('a -> 'b) -> ('b -> bool) -> 'a t -> 'b t\r\n\t\r\n\tval partition : ('a -> bool) -> 'a t -> 'a t * 'a t\r\n\t\r\n\tval split : ('a * 'b) t -> 'a t * 'b t\r\n\tval combine : 'a t -> 'b t -> ('a * 'b) t\r\n\r\n\tval add : 'a -> 'a t -> 'a t\r\n\tval remove : 'a -> 'a t -> 'a t\r\n\tval inter : 'a t -> 'a t -> 'a t\r\n\tval diff : 'a t -> 'a t -> 'a t\r\n\tval union : 'a t -> 'a t -> 'a t\r\n\tval unionUnsafe : 'a t -> 'a t -> 'a t\r\n\r\n\tval product : 'a t -> 'b t -> ('a * 'b) t\r\n\tval star : 'a list t -> int -> 'a list t\r\n\tval allDistinct : ('a -> 'b) -> 'a t -> bool\r\n\tval hasDuplicates : 'a t -> bool\r\n\tval validate : 'a list -> string -> 'a t\r\n\tval fixedPoint : ('a -> 'a) -> 'a -> 'a\r\n\tval acumFixedPoint : ('a t -> 'a t) -> ('a t) -> 'a t\r\n\tval historicalFixedPoint : ('a t -> 'a t) -> ('a t) -> 'a t\r\n\tval historicalFixedPointTracing : ('a t -> 'a t) -> ('a t) -> 'a t list\r\n\t\r\n\tval proj3_1 : ('a * 'b * 'c) t -> 'a t\r\n\tval proj3_2 : ('a * 'b * 'c) t -> 'b t\r\n\tval proj3_3 : ('a * 'b * 'c) t -> 'c t\r\n\tval proj3_12 : ('a * 'b * 'c) t -> ('a * 'b) t\r\n\tval proj3_23 : ('a * 'b * 'c) t -> ('b * 'c) t\r\n\t\r\n\tval test: unit -> int list list\r\nend\r\n\r\nmodule Set : SetSig =\r\nstruct\r\n\ttype 'a t = 'a list\r\n\tlet delX (v :'a) = List.filter (fun x -> x <> v)\r\n\r\n\tlet rec make (l: 'a list): 'a t =\r\n\t\tmatch l with\r\n\t\t| [] -> []\r\n\t\t| x::xs -> x::make (delX x xs)\r\n\tlet singleton (x : 'a) : 'a t = [x]\r\n\tlet empty: 'a t = []\r\n\tlet toList (s: 'a t): 'a list = s\r\n\r\n\tlet makeSorted (l: 'a list): 'a t = List.sort_uniq compare l\r\n\tlet sort (s: 'a t): 'a list = List.sort compare s\r\n\r\n\tlet isEmpty (s: 'a t): bool = s = []\r\n\tlet size: 'a t -> int = List.length\r\n\tlet compare_sizes: 'a t -> 'b t -> int = List.compare_lengths\r\n\tlet compare_size_with: 'a t -> int -> int = List.compare_length_with\r\n(* cons: add 'x' at the begin if 'x' is new in 's' *)\r\n\tlet cons (v :'a) (s: 'a t): 'a t = if List.mem v s then s else v::s\r\n(* add: add 'x' at the end if 'x' is new in 's' *)\r\n\tlet add (v :'a) (s: 'a t): 'a t = if List.mem v s then s else s@[v]\r\n\tlet hd: 'a t -> 'a = List.hd\r\n\tlet tl: 'a t -> 'a t = List.tl\r\n\tlet cut (s: 'a t) = (List.hd s, List.tl s)\r\n\tlet match_ s e n = if isEmpty s then e () else n (hd s) (tl s)\r\n\tlet nth: 'a t -> int -> 'a = List.nth\r\n\tlet nth_opt: 'a t -> int -> 'a option = List.nth_opt\r\n\tlet init: int -> (int -> 'a) -> 'a t = List.init\r\n\tlet flatten (ss: 'a t t): 'a t = make (List.flatten ss)\r\n\t\r\n\tlet iter: ('a -> unit) -> 'a t -> unit = List.iter\t\r\n\tlet iteri: (int -> 'a -> unit) -> 'a t -> unit = List.iteri\t\r\n\tlet map (f: 'a -> 'b) (s: 'a t): 'b t = make (List.map f s)\r\n\tlet mapi (f: int -> 'a -> 'b) (s: 'a t): 'b t = make (List.mapi f s)\r\n\tlet flatMap (f: 'a -> 'b t) (s: 'a t): 'b t = flatten (List.map f s)\r\n\tlet flat_map: ('a -> 'b t) -> 'a t -> 'b t = flatMap\r\n\tlet fold_left: ('a -> 'b -> 'a) -> 'a -> 'b t -> 'a = List.fold_left\r\n\tlet fold_right: ('a -> 'b -> 'b) -> 'a t -> 'b -> 'b = List.fold_right\r\n\tlet fold_left_s f u (s: 'a t): 'b t = make (List.fold_left f u s)\r\n\tlet fold_right_s f u (s: 'a t): 'b t = make (List.fold_right f u s)\r\n\t\r\n\tlet for_all: ('a -> bool) -> 'a t -> bool = List.for_all\r\n\tlet exists: ('a -> bool) -> 'a t -> bool = List.exists\r\n(* The following three functions use the equality '=' and may not work well for sets of sets *)\r\n\tlet belongs: 'a -> 'a t -> bool = List.mem\r\n\tlet subset (s1: 'a t) (s2: 'a t): bool = List.for_all (fun v -> belongs v s2) s1\r\n\tlet equals (s1: 'a t) (s2: 'a t): bool = compare_sizes s1 s2 = 0 && subset s1 s2\r\n\r\n\tlet find: ('a -> bool) -> 'a t -> 'a = List.find\r\n\tlet find_opt: ('a -> bool) -> 'a t -> 'a option = List.find_opt\t\r\n\tlet filter: ('a -> bool) -> 'a t -> 'a t = List.filter\t(* already distinct *)\r\n\t\r\n\t(* let fmap (f: 'a -> bool) (m: 'a -> 'b) (s: 'a t) = map m (filter f s) SLOW *)\r\n\tlet fmap (f: 'a -> bool) (m: 'a -> 'b) (s: 'a t) =\r\n\t\tlet rec  fmapX s accu =\r\n\t\t\tmatch s with\r\n\t\t\t| [] -> accu\r\n\t\t\t| x::xs -> if f x then fmapX xs (m x::accu) else fmapX xs accu\r\n\t\tin\r\n\t\tList.rev (fmapX s [])\r\n\r\n\tlet mapf (m: 'a -> 'b) (f: 'b -> bool) (s: 'a t) =\r\n\t\tlet rec  mapfX s accu =\r\n\t\t\tmatch s with\r\n\t\t\t| [] -> accu\r\n\t\t\t| x::xs -> let r = m x in\r\n\t\t\t\t\t\tif f r then mapfX xs (r::accu) else mapfX xs accu\r\n\t\tin\r\n\t\tList.rev (mapfX s [])\r\n\r\n(*\r\nlet rev_filter t ~f =\r\n  let rec find ~f accu = function\r\n    | [] -> accu\r\n    | x :: l -> if f x then find ~f (x :: accu) l else find ~f accu l\r\n  in\r\n  find ~f [] t\r\n;;\r\n*)\r\n\t\r\n\tlet partition: ('a -> bool) -> 'a t -> 'a t * 'a t = List.partition\t(* already distinct *)\r\n\t\r\n\tlet split (s: ('a * 'b) t): 'a t * 'b t = let (a, b) = List.split s in (make a, make b)\r\n\tlet combine: 'a t -> 'b t -> ('a * 'b) t = List.combine\r\n\t\r\n\tlet remove: 'a -> 'a t -> 'a t = delX\r\n\tlet inter (s1: 'a t) (s2: 'a t): 'a t = List.filter (fun v -> belongs v s2) s1\r\n\tlet diff (s1: 'a t) (s2: 'a t): 'a t = List.filter (fun v -> not (belongs v s2)) s1\r\n(* union: join s1 with the new elements of s2 *)\r\n\tlet union (s1: 'a t) (s2: 'a t): 'a t = s1 @ (diff s2 s1)\r\n(* pre: inter s1 s2 = [] *)\r\n\tlet unionUnsafe (s1: 'a t) (s2: 'a t): 'a t = s1 @ s2\r\n\r\n\tlet product (s1: 'a t) (s2: 'b t): ('a * 'b) t =\r\n\t\tflatMap (fun x -> List.map (fun y -> (x,y)) s2) s1\t(* already distinct *)\r\n\tlet starOne (s: 'a list t) (n: int) (l: 'a t): 'a list t = (* private auxiliary *)\r\n\t\tlet z = n - (List.length l) in\r\n\t\tlet sel = filter (fun k -> List.length k <= z) s in\r\n\t\t\tmap (fun k -> k @ l) sel\r\n\tlet rec fixedPoint (f: 'a -> 'a) (x: 'a): 'a =\r\n\t\tlet next = f x in\r\n\t\t\tif x = next then x\r\n\t\t\telse fixedPoint f next\r\n\tlet star (s: 'a list t) (n: int): 'a list t =\r\n\t\tfixedPoint (fun v -> union v (flatMap (starOne v n) s)) [[]]\r\n\r\n\tlet allDistinct f (s: 'a t): bool = size s = size (map f s)\r\n\tlet hasDuplicates (s: 'a t): bool = size s <> size (make s)\r\n\tlet validate (l: 'a list) (culprit: string): 'a t =\r\n\t\tif hasDuplicates l\r\n\t\t\tthen Error.error culprit \"Repetitions in set\" empty\r\n\t\t\telse make l\r\n\r\n\tlet rec acumFixedPoint (f: 'a t -> 'a t) (v: 'a t): 'a t =\r\n\t\tlet next = union v (f v) in\r\n\t\t\tif v = next then v\r\n\t\t\telse acumFixedPoint f next\r\n\r\n\tlet historicalFixedPoint (f: 'a t -> 'a t) (v: 'a t): 'a t =\r\n\t\tlet rec historicalFixedPointX (f: 'a t -> 'a t) (v: 'a t) (acum: 'a t): 'a t =\r\n\t\t\tlet next = f v in\r\n\t\t\tlet newAcum = union v acum in\r\n\t\t\tif acum = newAcum then v\r\n\t\t\telse historicalFixedPointX f next newAcum\r\n\t\tin\r\n\t\t\thistoricalFixedPointX f v empty\r\n\r\n\tlet historicalFixedPointTracing (f: 'a t -> 'a t) (v: 'a t): 'a t list =\r\n\t\tlet rec historicalFixedPointX (f: 'a t -> 'a t) (v: 'a t) (acum: 'a t) (trace: 'a t list): 'a t list =\r\n\t\t\tlet next = f v in\r\n\t\t\tlet newTrace = trace@[next] in\r\n\t\t\tlet newAcum = union v acum in\r\n\t\t\tif acum = newAcum then trace\r\n\t\t\telse historicalFixedPointX f next newAcum newTrace\r\n\t\tin\r\n\t\t\thistoricalFixedPointX f v empty [v]\r\n\r\n\tlet proj3_1 s3 = map (fun (a,_,_) -> a) s3\r\n\tlet proj3_2 s3 = map (fun (_,b,_) -> b) s3\r\n\tlet proj3_3 s3 = map (fun (_,_,c) -> c) s3\r\n\tlet proj3_12 s3 = map (fun (a,b,_) -> (a,b)) s3\r\n\tlet proj3_23 s3 = map (fun (_,b,c) -> (b,c)) s3\r\n\r\n\tlet test (): int list list =\t(* Set.test () *)\r\n\t\ttoList (star (make[ [1]; [2;3]]) 4)\r\nend\r\n\r\nmodule type UPSetSig = (* unordered pair set *)\r\nsig\r\n\ttype 'a t\r\n\tval make : ('a * 'a) list -> 'a t\r\n\tval toList : 'a t -> ('a * 'a) list\r\n\tval empty : 'a t\r\n\tval size : 'a t -> int\r\n\tval belongs : 'a * 'a -> 'a t -> bool\r\n\tval union : 'a t -> 'a t -> 'a t\r\n\tval add : 'a * 'a -> 'a t -> 'a t\r\n\tval inter : 'a t -> 'a t -> 'a t\r\n\tval diff : 'a t -> 'a t -> 'a t\r\n\tval subset : 'a t -> 'a t -> bool\r\n\tval map : ('a * 'a -> 'b * 'b) -> 'a t -> 'b t\r\n\tval filter : ('a * 'a -> bool) -> 'a t -> ('a * 'a) Set.t\r\n\tval for_all : ('a * 'a -> bool) -> 'a t -> bool\r\n\tval exists : ('a * 'a -> bool) -> 'a t -> bool\r\n\tval exists : ('a * 'a -> bool) -> 'a t -> bool\r\n\tval flatten : 'a t t -> 'a t\r\n\tval flatMap : ('a -> 'b t) -> 'a t -> 'b t\r\n\tval iter : ('a * 'a -> unit) -> 'a t -> unit\r\n\tval partition : ('a * 'a -> bool) -> 'a t -> ('a * 'a) Set.t * ('a * 'a) Set.t\r\n\tval combinations : 'a t -> 'b t -> ('a * 'b) t\r\n\tval star : 'a list t -> int -> 'a list t\r\n\tval allDistinct : ('a * 'a -> 'b) -> 'a t -> bool\r\n\tval hasDuplicates : 'a t -> bool\r\n\tval validate : ('a * 'a) list -> string -> 'a t\r\n\tval test: unit -> (int * int) list\r\nend\r\n\r\nmodule UPSet : UPSetSig =\r\nstruct\r\n\ttype 'a t = ('a*'a) Set.t\r\n\r\n\t(* invariant: a < b for all pairs (a,b) *)\r\n\tlet ord (a,b) = if a < b then (a, b)\t\t(* keep *)\r\n\t\t\t\t\telse if b < a then (b, a)\t(* swap *)\r\n\t\t\t\t\telse Error.fatal \"UPSet.ord\" (* error *)\r\n\r\n\tlet make (l: ('a*'a) list): 'a t =\r\n\t\tlet l1 = List.filter (fun (a,b) -> a <> b) l in\r\n\t\tlet l2 = List.map ord l1 in\r\n\t\t\tSet.make l2\r\n\tlet toList (s: 'a t): ('a*'a) list = Set.toList s\r\n\r\n\tlet empty: 'a t = Set.empty\r\n\tlet size (s: 'a t): int = Set.size s\r\n\tlet belongs (v: 'a*'a) (s: 'a t): bool = Set.belongs (ord v) s\r\n\tlet union (s1: 'a t) (s2: 'a t): 'a t = Set.union s1 s2\r\n\tlet add (v: 'a*'a) (s: 'a t): 'a t = Set.add (ord v) s\r\n\tlet inter (s1: 'a t) (s2: 'a t): 'a t = Set.inter s1 s2\r\n\tlet diff (s1: 'a t) (s2: 'a t): 'a t = Set.diff s1 s2\r\n\tlet subset (s1: 'a t) (s2: 'a t): bool = Set.subset s1 s2\r\n\r\n\tlet map f (s: 'a t) = make (Set.toList (Set.map f s))\r\n\tlet filter f (s: 'a t) = Set.filter f s\r\n\tlet for_all f (s: 'a t) = Set.for_all f s\r\n\tlet exists f (s: 'a t) = Set.exists f s\r\n\tlet flatten (ss: 'a t t) = Error.fatal \"UPSet.flatten\"\r\n\tlet flatMap f (s: 'a t) = Error.fatal \"UPSet.flatMap\"\r\n\tlet iter f (s: 'a t) = Set.iter f s\r\n\tlet partition f (s: 'a t) = Set.partition f s\r\n\tlet combinations (s1: 'a t) (s2: 'b t): ('a * 'b) t = Error.fatal \"UPSet.combinations\"\r\n\tlet star (s: 'a list t) (n: int): 'a list t = Error.fatal \"UPSet.star\"\r\n\r\n\tlet allDistinct f (s: 'a t) = Set.allDistinct f s\r\n\tlet hasDuplicates (s: 'a t): bool = Set.hasDuplicates s\r\n\tlet validate (l: ('a*'a) list) (culprit: string): 'a t = Error.fatal \"UPSet.validate\"\r\n\tlet test () =\t(* UPSet.test () *)\r\n\t\ttoList (make [(1,1);(1,2);(2,2);(3,2);(3,2);(2,3)])\r\nend\r\n\r\n\r\n# 1 \"src/BasicTypes.ml\"\r\n(*\r\n * BasicTypes.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * apr/2022 (amd) - The type 'symbol' is now opaque type an can be internally\r\n *\t\t\t\t\t\trepresented using a char or a string. Required several changes\r\n *\t\t\t\t\t\tall over the code of several modules.\r\n * mar/2021 (amd) - New types 'property', 'properties'.\r\n * jan/2021 (amd) - Module in an independent file.\r\n * jun/2019 (amd) - Initial version, inside the big file \"OCamlFlatSupport.ml\".\r\n *)\r\n\r\n(*\r\n * Description: Some types and constants used across all the modules.\r\n *)\r\n\r\n\r\n# 36 \"src/BasicTypes.ml\"\r\nmodule type SymbolOpaqueSig =\r\nsig\r\n\r\n\t\r\n# 40 \"src/BasicTypes.ml\"\r\n type symbol (* opaque *)\r\n\r\n\t\r\n# 48 \"src/BasicTypes.ml\"\r\n type symbolX = string\r\n\t\r\n# 50 \"src/BasicTypes.ml\"\r\n val char2symb : char -> symbol\r\n\tval symb2char : symbol -> char\r\n\tval str2symb : string -> symbol\r\n\tval symb2str : symbol -> string\r\n\r\n\tval symbolTypeName : string\r\n\tval symbDisplayQuote: string\r\n\t\r\n\tval symbI : symbolX -> symbol\r\n\tval symbX : symbol -> symbolX\r\nend\r\n\r\nmodule SymbolOpaque : SymbolOpaqueSig =\r\nstruct\r\n\t\r\n# 77 \"src/BasicTypes.ml\"\r\n type symbol = string\r\n\ttype symbolX = string\r\n\r\n\tlet char2symb c: symbol = Char.escaped c\r\n\tlet symb2char s: char = if String.length s > 0 then String.get s 0 else '?'\r\n\tlet str2symb s: symbol = s\r\n\tlet symb2str s: string = s\r\n\r\n\tlet symbolTypeName = \"string\"\r\n\tlet symbDisplayQuote = \"\\\"\" \r\n\r\n\t\r\n# 89 \"src/BasicTypes.ml\"\r\n (* Internalize/Externalize *)\r\n\tlet symbI (x: symbolX): symbol = x\r\n\tlet symbX (s: symbol): symbolX = s\r\nend\r\n\r\nmodule Symbol =\r\nstruct\r\n\tinclude SymbolOpaque\r\n\r\n\ttype 'a set = 'a Set.t\r\n\t\r\n\ttype symbols = symbol set\r\n\r\n\tlet symb (s: string): symbol  = str2symb s\r\n\r\n\tlet epsilon: symbol = symb \"~\" (* used for representing the empty transitions *)\r\n\tlet dollar: symbol = symb \"$\"\r\n\tlet empty: symbol = symb \"B\"\r\n\r\n\tlet str2symbX (s: string): symbolX = symbX (str2symb s)\r\n\tlet symbX2str (s: symbolX): string = symb2str (symbI s)\r\n\r\n\tlet symbolsI (ss: symbolX list): symbols = Set.make (List.map symbI ss)\r\n\tlet symbolsX (ss: symbols): symbolX list = List.map symbX (Set.toList ss)\r\n\r\n\t(* Display *)\r\n\tlet listD f l = \"[\" ^ (String.concat \"; \" (List.map f l)) ^ \"]\"\r\n\tlet symbD (s: symbol): string = symbDisplayQuote ^ (symb2str s) ^ symbDisplayQuote\r\n\tlet symbXD (s: symbolX): string = symbDisplayQuote ^ (symbX2str s) ^ symbDisplayQuote\r\n\tlet symbolsXD (l: symbolX list): string = listD symbXD l\r\n\tlet symbolsD (s: symbols): string = listD symbD (Set.toList s)\r\nend\r\n\r\nmodule Terminal =\r\nstruct\r\n\topen Symbol\r\n\t\r\n\ttype terminal = symbol\r\n\ttype terminalX = symbolX\r\n\ttype terminals = terminal set\r\nend\r\n\r\nmodule Variable =\r\nstruct\r\n\topen Symbol\r\n\t\r\n\ttype variable = symbol\r\n\ttype variableX = symbolX\r\n\ttype variables = variable set\r\n\t\r\n\tlet draftVar: variable = symb \"_\"\r\nend\r\n\r\nmodule BString =\r\nstruct\r\n\topen Symbol\r\n\r\n\ttype strings = string set\r\n\t\r\n\t(* Display *)\r\n\tlet strD (s: string): string = \"\\\"\" ^ s ^ \"\\\"\"\r\n\tlet stringsD (l: string list) = listD strD l\r\nend\r\n\r\nmodule Word =\r\nstruct\r\n\topen Symbol\r\n\t\r\n\ttype word = symbol list\r\n\ttype wordX = symbolX list\r\n\ttype words = word set\r\n\r\n\tlet wordX2word = List.map symbI\r\n\tlet word2wordX = List.map symbX\r\n\t\r\n\tlet str2word (s: string): word =\r\n\t\tList.init (String.length s) (fun i -> char2symb s.[i])\r\n\tlet word (s: string): word = str2word s\r\n\r\n\tlet word2str (w: word): string =\r\n\t\tlet strs = List.map symb2str w in\r\n\t\t\tString.concat \"\" strs\r\n\t\t\r\n\tlet symbols (s: string): symbols = Set.make (word s)\r\n\r\n\t(* Internalize/Externalize *)\r\n\tlet wordI = str2word\r\n\tlet wordX = word2str\r\n\tlet wordsI (ss: string list): words = Set.make (List.map str2word ss)\r\n\tlet wordsX (ws: words): string list = List.map word2str (Set.toList ws)\r\nend\r\n\r\nmodule type StateOpaqueSig =\r\nsig\r\n\topen Symbol\r\n\t\r\n\ttype state = string (* will be opaque *)\r\n\ttype states = state set\r\n\t\r\n\tval state2str : state -> string\r\n\tval str2state : string -> state\r\n\tval state : string -> state\r\n\tval draftState: state\r\nend\r\n\r\nmodule StateOpaque: StateOpaqueSig =\r\nstruct\r\n\topen Symbol\r\n\t\r\n\ttype state = string\r\n\ttype states = state set\r\n\r\n\tlet state2str (s: state): string = s\r\n\tlet str2state (s: string): state = s\r\n\tlet state (s: string): state = str2state s\r\n\r\n\tlet draftState: state = state \"_\"\r\n\t\r\n\t(* Display *)\r\n\tlet stateXD (s: state): string = \"\\\"\" ^ (state2str s) ^ \"\\\"\"\r\n\tlet statesXD (l: state list) = listD stateXD l\r\nend\r\n\r\nmodule State =\r\nstruct\r\n\tinclude StateOpaque\r\n\topen Symbol\r\n\t\r\n\t(* Display *)\r\n\tlet stateXD (s: state): string = \"\\\"\" ^ (state2str s) ^ \"\\\"\"\r\n\tlet statesXD (l: state list) = listD stateXD l\r\nend\r\n\r\nmodule Property =\r\nstruct\r\n\topen Symbol\r\n\t\r\n\ttype property = string\r\n\ttype properties = property set\r\nend\r\n\r\nmodule Path =\r\nstruct\r\n\topen Symbol\r\n\t\r\n\ttype 'config path = 'config list\r\n\ttype 'configX pathX = 'configX list\r\n\r\n\tlet pathX (configX: 'config -> 'configX) (p: 'config path): 'configX pathX =\r\n\t\tList.map configX p\r\nend\r\n\r\nmodule Trail =\r\nstruct\r\n\topen Symbol\r\n\t\r\n\ttype 'config trail = 'config set list\r\n\ttype 'configX trailX = 'configX list list\r\n\r\n\tlet trailX (configX: 'config -> 'configX) (t: 'config trail): 'configX trailX =\r\n\t\tList.map (fun cs -> List.map configX (Set.toList cs)) t\r\nend\r\n\r\nmodule Direction =\r\nstruct\r\n\ttype direction = L | S | R\r\n\r\n(*\t\r\n\tlet direction2string (dir: direction): string =\r\n\t\tList.assoc dir [(L,\"L\");(S,\"S\");(R,\"R\")]\r\n\tlet string2direction (dirS: string) : direction =\r\n\t\tList.assoc dirS [(\"L\",L);(\"S\",S);(\"R\",S)]\r\n\tlet char2direction (dirC: char) : direction =\r\n\t\tList.assoc dirC [('L',L);('S',S);('R',S)]\r\n\tlet charIsDirection (dirC: char) : bool =\r\n\t\tList.mem dirC ['L'; 'S'; 'R'] *)\r\n\t\t\r\n\tlet allDirections =\r\n\t\tSet.make [L; S; R]\r\n\tlet isDirX (dirX: string): bool =\r\n\t\tList.mem dirX [\"L\"; \"S\"; \"R\"]\r\n\tlet dirI (dirX: string): direction =\r\n\t\tList.assoc dirX [(\"L\",L);(\"S\",S);(\"R\",R)]\r\n\tlet dirX (dir: direction): string =\r\n\t\tList.assoc dir [(L,\"L\");(S,\"S\");(R,\"R\")]\r\nend\r\n\r\nmodule ToScreen =\r\nstruct\r\n\topen Word\r\n\t\r\n\tlet pairS (a: string) (b: string): string =\r\n\t\t\"(\" ^ a ^ \", \" ^ b ^ \")\"\r\n\t\t\r\n\tlet wordS (w: word): string = \r\n\t\twordX w\r\n\t\t\r\n\tlet listS (l: string list): string =\r\n\t\t\"[\" ^ String.concat \", \" l ^ \"]\"\r\n\t\t\r\n\tlet setS (s: string Set.t): string =\r\n\t\t\"{\" ^ String.concat \", \" (Set.toList s) ^ \"}\"\r\n\r\n\tlet confsS (confS: 'config -> string) (c: 'config Set.t): string =\r\n\t\tsetS (Set.map confS c)\r\nend\r\n\r\nmodule BasicTypes =\r\nstruct\r\n\tinclude Symbol\r\n\tinclude Terminal\r\n\tinclude Variable\r\n\tinclude BString\r\n\tinclude Word\r\n\tinclude State\r\n\tinclude Property\r\n\tinclude Path\r\n\tinclude Trail\r\n\tinclude Direction\r\n\tinclude ToScreen\r\nend\r\n# 1 \"src/Util.ml\"\r\n(*\r\n * Util.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * may/2021 (amd) - Lots of miscellaneous new stuff.\r\n * jan/2021 (amd) - Module in an independent file.\r\n * jun/2019 (amd) - Initial version, inside the big file \"OCamlFlatSupport.ml\".\r\n *)\r\n\r\n(*\r\n * Description: Miscellaneous utility functions. \r\n *\r\n * TODO: Check if this is the right place for some of this functions.\r\n *)\r\n \r\nopen BasicTypes\r\n\r\nmodule IdGenerator =\r\nstruct\r\n\tlet current = ref 0\r\n\r\n\tlet reset () =\r\n\t\tcurrent := 0\r\n\r\n\tlet gen (s: string) =\r\n\t\tlet res = Printf.sprintf \"%s%02d\" s (!current) in\r\n\t\t\tcurrent := !current+1;\r\n\t\t\tres\r\n\t\r\n\tlet genVar (s: string) =\r\n\t\t\"<\" ^ gen s ^ \">\"\r\nend\r\n\r\nmodule type RuntimeControlSig =\r\nsig\r\n\tval start: unit -> unit\r\n\tval update: int -> unit\r\n\tval giveUp: unit -> bool\r\n\tval stats: unit -> bool * int * float\r\nend\r\n\r\nmodule RuntimeControl : RuntimeControlSig =\r\nstruct\r\n\tlet _CONFIGS_ALLOWANCE = 5000\r\n\tlet _TIME_ALLOWANCE = 10.0\r\n\t\r\n\tlet timeStart = ref 0.0\r\n\tlet exactResult = ref false\r\n\tlet runconfigs = ref 0\r\n\tlet runtime = ref 0.0\t\t(* in seconds *)\r\n\r\n\tlet start () =\r\n\t\ttimeStart := Sys.time();\r\n\t\texactResult := true;\r\n\t\trunconfigs := 0;\r\n\t\truntime := 0.0\r\n\r\n\tlet update n =\r\n\t\trunconfigs := !runconfigs + n;\r\n\t\truntime := Sys.time() -. !timeStart;\r\n\t\tif false then\r\n\t\t\tPrintf.printf \"(%d, %d, %f, [%d])\\n\" n !runconfigs !runtime ((Gc.quick_stat()).Gc.heap_words)\r\n\r\n\tlet giveUp () =\r\n\t\tif !runtime > _TIME_ALLOWANCE || !runconfigs > _CONFIGS_ALLOWANCE then begin\r\n\t\t\texactResult := false;\r\n\t\t\ttrue\r\n\t\tend\r\n\t\telse\r\n\t\t\tfalse\r\n\r\n\tlet stats () =\r\n\t\t(!exactResult, !runconfigs, !runtime)\r\nend\r\n\r\n(*\r\nORIGINAL\r\n\r\n\tlet giveUp n =\t\r\n\t\trunconfigs := !runconfigs + n;\r\n\t\truntime := Sys.time() -. !timeStart;\r\n\t\t(*Printf.printf \"(%6d, %f)\\n\" !configs !time;*)\r\n\t\tif !runtime > _TIME_ALLOWANCE || !runconfigs > _CONFIGS_ALLOWANCE then begin\r\n\t\t\texactResult := false;\r\n\t\t\ttrue\r\n\t\tend\r\n\t\telse\r\n\t\t\tfalse\r\n\r\n\r\n*)\r\n\r\nmodule UtilStrings =\r\nstruct\r\n\tlet stripChars (s: string) (cs: string): string =\r\n\t\tlet len = String.length s in\r\n\t\tlet j = ref 0 in\r\n\t\tlet res = Bytes.create len in\r\n\t\t\tfor i = 0 to len-1 do\r\n\t\t\t\tif not (String.contains cs s.[i]) then begin\r\n\t\t\t\t\tBytes.set res !j s.[i];\r\n\t\t\t\t\tj := !j + 1\r\n\t\t\t\tend\r\n\t\t\tdone;\r\n\t\t\tBytes.to_string (Bytes.sub res 0 !j)\r\n\r\n\tlet stripHead (s: string): string =\r\n\t\tlet len = String.length s in\r\n\t\tlet n = ref 0 in\r\n\t\tlet skip = ref (-1) in\r\n\t\tlet j = ref 0 in\r\n\t\tlet res = Bytes.create len in\r\n\t\t\tfor i = 1 to len-1 do\r\n\t\t\t\tif !skip < 0 then begin\r\n\t\t\t\t\tif s.[i] = '\\t' then\r\n\t\t\t\t\t\tn := !n + 1\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tskip := 0\r\n\t\t\t\tend;\r\n\t\t\t\tif !skip >= 0 then begin\r\n\t\t\t\t\tif !skip > 0 && s.[i] = '\\t' then\r\n\t\t\t\t\t\tskip := !skip - 1\r\n\t\t\t\t\telse begin\r\n\t\t\t\t\t\tif s.[i] = '\\n' then\r\n\t\t\t\t\t\t\tskip := !n\r\n\t\t\t\t\t\telse ();\r\n\t\t\t\t\t\tBytes.set res !j s.[i];\r\n\t\t\t\t\t\tj := !j + 1\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\tdone;\r\n\t\t\tBytes.to_string (Bytes.sub res 0 !j)\r\n\r\n\tlet capitalize (s: string): string =\r\n\t\tlet l = String.split_on_char ' ' s in\r\n\t\tlet l = List.map String.capitalize_ascii l in\r\n\t\t\tString.concat \"\" l\r\n\t\r\n\tlet rec wrap (s: string) (width: int): string =\r\n\t\tlet cut =\r\n\t\t\tif (String.length s) < width then\r\n\t\t\t\t0\r\n\t\t\telse\r\n\t\t\t\tlet last = min width (String.length s - 1) in\r\n\t\t\t\tlet cut = try String.rindex_from s last ' ' with _ -> 0 in\r\n\t\t\t\tif cut = 0 then\r\n\t\t\t\t\ttry String.index_from s last ' ' with _ -> 0\r\n\t\t\t\telse\r\n\t\t\t\t\tcut\r\n\t\tin\r\n\t\t\tif cut = 0 then\r\n\t\t\t\ts\r\n\t\t\telse\r\n\t\t\t\tlet head = String.sub s 0 cut in\r\n\t\t\t\tlet tail = String.sub s (cut+1) (String.length s - cut - 1) in\r\n\t\t\t\t\thead ^ \"\\n\" ^ wrap tail width\r\nend\r\n\r\nmodule UtilOps =\r\nstruct\r\n\tlet flatMap (f: 'a -> 'b list) (l: 'a list): 'b list =\r\n\t\tList.flatten (List.map f l)\r\n\r\n\tlet addAll (symb: 'a) (ll: 'a list list): 'a list list =\r\n\t\tList.map (fun l -> symb::l) ll\r\n\r\n\tlet concatAll (w: 'a list) (ll: 'a list list): 'a list list =\r\n\t\tList.map (fun l -> w@l) ll\r\n\r\n\tlet distrib2 (f: 'a -> 'b -> 'c) ((a: 'a), (b: 'b)): 'c =\r\n\t\tf a b\r\n\r\n\tlet rec fixedPoint (f: 'a -> 'a) (x: 'a): 'a =\r\n\t\tlet next = f x in\r\n\t\t\tif x = next then x\r\n\t\t\telse fixedPoint f next\r\n\t\r\n\tlet indexOf (e: 'a) (l: 'a list): int =\r\n\t\tlet rec index e l n =\r\n\t\t\tmatch l with\r\n\t\t\t\t[] -> -1\r\n\t\t\t\t|x::xs -> if e = x then n else index e xs (n+1)\r\n\t\tin\r\n\t\t\tindex e l 0\r\nend\r\n\r\nmodule UtilFiles =\r\nstruct\r\n\tlet loadFile (filename: string): string =\r\n\t\ttry\r\n\t\t\tlet ic = open_in filename in\r\n\t\t\tlet n = in_channel_length ic in\r\n\t\t\tlet s = Bytes.create n in\r\n\t\t\t\treally_input ic s 0 n;\r\n\t\t\t\tclose_in ic;\r\n\t\t\t\tBytes.to_string s\r\n\t\twith\r\n\t\t\tSys_error str ->\r\n\t\t\t\tError.error \"FileReader\" str \"\"\r\n\r\n\r\n\tlet rec print (l: string list): unit =\r\n\t\tmatch l with\r\n\t\t| [] -> ()\r\n\t\t| x::xs -> print_string x; print xs\r\n\r\n\tlet println (l: string list): unit =\r\n\t\tprint l ;\r\n\t\tprint_newline()\r\n\r\n\tlet sep (): unit =\r\n\t\tprintln [\"------------------------------------------------\"]\r\n\r\n\tlet header (str: string): unit =\r\n\t\tsep ();\r\n\t\tprintln [str]\r\n\r\n\tlet printAlphabet (a: symbols): unit =\r\n\t\tSet.iter (fun x -> print [symb2str x; \", \"]) a;\r\n\t\tprintln []\r\n\r\n\tlet printStates (st:states): unit =\r\n\t\tSet.iter (fun x -> print [state2str x; \", \"]) st;\r\n\t\tprintln []\r\n\r\n\tlet printTransition (a:string) (b:symbol) (c:string): unit =\r\n\t\tprintln [\"(\"; a; \", \"; symb2str b; \", \"; c; \")\"]\r\n\r\n\tlet printWord (w:word): unit =\r\n\t\tprintln [\"'\"; word2str w; \"'\"]\r\n\r\n\tlet printWords (s: words): unit =\r\n\t\tSet.iter printWord s\r\n\t\t\r\n\tlet printString (s: string): unit =\r\n\t\tprintln [\"'\"; s; \"'\"]\r\n\r\n\tlet printStrings (s: strings): unit =\r\n\t\tSet.iter printString s\r\n\t\t\r\n\tlet show (s: string): unit =\r\n\t\tprint_string (\"|\" ^ s ^ \"|\\n\")\r\n\t\t\r\n\tlet handleHomeDir (s: string): string =\r\n\t\tmatch String.length s with\r\n\t\t| 0 ->\r\n\t\t\t\"\"\r\n\t\t| 1 ->\r\n\t\t\tif s = \"~\" then Sys.getenv(\"HOME\") else s\r\n\t\t| n ->\r\n\t\t\tif s.[0] = '~' then\r\n\t\t\t\tif s.[1] = '/' then\r\n\t\t\t\t\tSys.getenv(\"HOME\") ^ String.sub s 1 (n - 1)\r\n\t\t\t\telse\r\n\t\t\t\t\t\"/home/\" ^ String.sub s 1 (n - 1)\r\n\t\t\telse s\r\nend\r\n\r\nmodule Util =\r\nstruct\r\n\tinclude UtilStrings\r\n\tinclude UtilOps\r\n\tinclude UtilFiles\r\n\r\n\tlet benchmark f =\r\n\t\tlet t0 = Sys.time() in\r\n\t\tlet res = f() in\r\n\t\tlet t1 = Sys.time() in\r\n\t\t\t(res, t1 -. t0)\r\n\r\n\tlet testing active moduleName =\r\n\t\tlet forceActive = false in\r\n\t\tlet regularActive = (active && try ignore (Sys.getenv(\"TESTING\")); true with _ -> false) in\r\n\t\tlet active = forceActive || regularActive in\r\n\t\t\tif active then\r\n\t\t\t\theader (\"### Testing \\\"\" ^ moduleName ^ \"\\\" ###\");\r\n\t\t\tactive\r\nend\r\n\r\nmodule UtilTests : sig end =\r\nstruct\r\n\tlet active = false\r\n\r\n\tlet test0 () =\r\n\t\tUtil.println [Util.loadFile \"examples/fa_abc.json\"]\r\n\r\n\tlet test1 () =\r\n\t\tlet a = word2str [symb \"e\";symb \"r\";symb \"t\"] in\r\n\t\tlet b = word2str [symb \"4\";symb \"5\";symb \"y\"] in\r\n\t\t\tUtil.println [a; b]\r\n\r\n\tlet runAll : unit =\r\n\t\tif Util.testing active \"Util\" then begin\r\n\t\t\ttest0 ();\r\n\t\t\ttest1 ()\r\n\t\tend\r\nend\r\n# 1 \"src/Scanner.ml\"\r\n(*\r\n * Scanner.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * jan/2021 (amd) - Initial version, for the JSon parser.\r\n *)\r\n\r\n(*\r\n * Description: Simple lexical analyzer that assumes that the tokens are\r\n * the individual non-blank characters. The function getToken is available\r\n * to handle the rare cases where we need a multi-char token. This module is\r\n * suitable for the three parsers defined in the OCamlFLAT library.\r\n * The tokens are handled in a imperative style to simplify the signature of\r\n * of the client parsing functions.\r\n *)\r\n\r\nmodule CharType =\r\nstruct\r\n\tlet isBlank (c: char): bool =\r\n\t\tc = ' ' || c = '\\t' || c = '\\n' || c = '\\r'\r\n\r\n\tlet isAlpha (c: char): bool =\r\n\t\t'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z'\r\n\r\n\tlet isDigit (c: char): bool =\r\n\t\t'0' <= c && c <= '9'\r\n\r\n\tlet isAlphaNum (c: char): bool =\r\n\t\tisAlpha c || isDigit c\r\n\r\n\tlet isId (c: char): bool =\r\n\t\tisAlpha c || isDigit c || c = '_'\r\n\r\n\tlet asStr (c: char): string =\r\n\t\tChar.escaped c\r\n\r\n\tlet strQuoted (s: string): string =\r\n\t\t\"'\" ^ s ^ \"'\"\r\n\r\n\tlet asStrQuoted (c: char): string =\r\n\t\tstrQuoted (Char.escaped c)\r\nend\r\n\r\nmodule ScannerPrivate =\r\nstruct\r\n\topen CharType\r\n\r\n\tlet parserName = ref \"\"\r\n\tlet inputString = ref \"\"\r\n\tlet inputStringLength = ref 0\r\n\tlet inputStringPosition = ref 0\r\n\r\n\tlet expecting (exp: string) (got: char): 'a =\r\n\t\tlet g = if got = ' ' then \"'EOL'\" else \"'\" ^ asStr got ^ \"'\" in\r\n\t\tlet mesg =\"Expecting \" ^ exp ^ \", got \" ^ g in\r\n\t\t\tError.error !parserName mesg ();\r\n\t\t\traise Not_found\r\n\r\n\tlet invalid (str: string): 'a =\r\n\t\tError.error !parserName str ();\r\n\t\traise Not_found\r\n\r\n\tlet isInside (): bool =\r\n\t\t!inputStringPosition < !inputStringLength\r\n\r\n\tlet slice (from: int): string =\r\n\t\tlet len = !inputStringPosition - from in\r\n\t\t\tString.sub !inputString from len\r\n\r\n\tlet start (name: string) (s: string): unit =\r\n\t\tparserName := name;\r\n\t\tinputString := s;\r\n\t\tinputStringLength := String.length s;\r\n\t\tinputStringPosition := 0\r\n\r\n\tlet skip (): unit =\r\n\t\tinputStringPosition := !inputStringPosition + 1\r\n\r\n\tlet current (): char =\r\n\t\tString.get !inputString !inputStringPosition\r\n\r\n\tlet skipWhile good =\r\n\t\twhile isInside () && good (current ()) do skip() done\r\n\r\n\tlet skipBlanks (): unit =\r\n\t\tskipWhile isBlank\r\n\r\n\tlet peek (): char =\r\n\t\tskipBlanks ();\r\n\t\tif isInside () then\r\n\t\t\tcurrent ()\r\n\t\telse\r\n\t\t\t' '\r\n\r\n\tlet get (): char =\r\n\t\tlet res = peek() in\r\n\t\t\tskip();\r\n\t\t\tres\r\n\r\n\tlet getToken (good: char -> bool): string =\r\n\t\tlet start = !inputStringPosition in\r\n\t\t\tskipWhile good;\r\n\t\t\tslice start\r\n\t\r\n\tlet getId (): string =\r\n\t\tgetToken isId\r\n\r\n\tlet getUntil (ch: char): string =\r\n\t\tgetToken (fun c -> c <> ch)\r\n\r\n\tlet getChar (e: char): char =\r\n\t\tif peek() = e then\r\n\t\t\tget ()\r\n\t\telse\r\n\t\t\texpecting (asStrQuoted e) (peek())\r\n\r\n\tlet getOne (l: char list): char =\r\n\t\tlet rec charListAsStr (l: char list): string =\r\n\t\t\tmatch l with\r\n\t\t\t| [] -> \"\"\r\n\t\t\t| [x] -> asStrQuoted x\r\n\t\t\t| [x; y] -> asStrQuoted x  ^ \" or \" ^ asStrQuoted y\r\n\t\t\t| x::xs -> asStrQuoted x ^ \", \" ^ charListAsStr xs\r\n\t\tin\t\r\n\t\t\tif List.mem (peek()) l then\r\n\t\t\t\tget ()\r\n\t\t\telse\r\n\t\t\t\texpecting (charListAsStr l) (peek())\r\n\r\n\tlet getAlpha (): char =\r\n\t\tif isAlpha (peek()) then\r\n\t\t\tget ()\r\n\t\telse\r\n\t\t\texpecting \"alphabetic\" (peek())\r\n\r\n\tlet getInt (): int =\r\n\t\tlet digits = getToken isDigit in\r\n\t\t\tif digits = \"\" then\r\n\t\t\t\texpecting \"integer\" (peek())\r\n\t\t\telse\r\n\t\t\t\tint_of_string digits\t\t\t\t\t\r\n\r\n\tlet getCharInt (): char * int =\r\n\t\tlet a = getAlpha () in\r\n\t\t\tif isDigit (current ()) then\r\n\t\t\t\t(a, getInt ())\r\n\t\t\telse\r\n\t\t\t\t(a, -1)\r\n\t\r\n\tlet getDelim (a: char) (b: char): string =\r\n\t\tlet _ = getChar a in\r\n\t\tlet res = getToken (fun c -> c <> b) in\r\n\t\t\tif peek () = b then (\r\n\t\t\t\tskip ();\r\n\t\t\t\tres\r\n\t\t\t)\r\n\t\t\telse\r\n\t\t\t\texpecting (\"closing \" ^ asStrQuoted b) (peek ())\r\n\r\n\tlet rec checkStr (str: string) (i: int): bool =\r\n\t\tif String.length str = i then true\r\n\t\telse if str.[i] <> current () then false\r\n\t\telse (skip (); checkStr str (i+1))\r\n\r\n\tlet getStr (str: string): unit =\r\n\t\tif (peek ()) = ' ' || not (checkStr str 0) then\r\n\t\t\texpecting (strQuoted str) (peek ())\t\t\r\n\r\n\tlet expecting0 (exp: string): 'a =\r\n\t\texpecting exp (peek ())\r\n\r\n\tlet rubbish (str: string): 'a =\r\n\t\tinvalid (\"Rubbish [\" ^ asStrQuoted (peek ()) ^ \"] \" ^ str)\r\nend\r\n\r\n\r\nmodule Scanner =\r\nstruct\r\n\topen ScannerPrivate\r\n\r\n\tlet expecting = expecting  (* discontinued *)\r\n\tlet invalid = invalid\r\n\r\n\tlet start = start\r\n\tlet skip = skip\r\n\tlet peek = peek\r\n\tlet curr = peek  (* discontinued *)\r\n\tlet get = get\r\n\tlet getId = getId\r\n\tlet getUntil = getUntil\r\n\r\n\tlet getChar = getChar\r\n\tlet getOne = getOne\r\n\tlet getAlpha = getAlpha\r\n\tlet getInt = getInt\r\n\tlet getCharInt = getCharInt\r\n\tlet getDelim = getDelim\r\n\tlet getStr = getStr\r\n\r\n\tlet expecting0 = expecting0\r\n\tlet rubbish = rubbish\r\nend\r\n# 1 \"src/JSon.ml\"\r\n(*\r\n * JSon.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * apr/2022 (amd) - Added the \"make\" family of functions. Required several changes\r\n *\t\t\t\t\t\tall over the code of several modules.\r\n * may/2021 (amd) - Added a second parser, for OCaml values syntax. The output\r\n *                  is regular JSon.\r\n * jan/2021 (amd) - Added a very simple recursive descent parser for JSon.\r\n * jan/2021 (amd) - Module in an independent file.\r\n * jun/2019 (amd) - Initial version, inside the big file \"OCamlFlatSupport.ml\".\r\n *)\r\n\r\n(*\r\n * Description: Very simple JSon parser, plus some JSon handling functions.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\n(*\r\nmodule type JSonSig =\r\nsig\r\n\ttype t =\r\n\t\t| JNull\r\n\t\t| JString of string\r\n\t\t| JAssoc of (string * t) list\r\n\t\t| JList of t list\r\n\r\n\tval parse : string -> t\r\n\tval parseOon : string -> t\r\n\tval fromFile : string -> t\r\n\r\n\tval toStringN : int -> t -> string\r\n\tval toString : t -> string\r\n\tval show : t -> unit\r\n\tval remove : t -> string list -> t\r\n\r\n\tval isNull : t -> bool\r\n\tval hasField : t -> string -> bool\r\n\tval getField: string -> t -> t\r\n\t\r\n\tval fieldSymbol : t -> string -> symbol\r\n(*\tval fieldSymbolList : t -> string -> symbol list *)\r\n\tval fieldSymbolSet : t -> string -> symbols\r\n\t\r\n\tval fieldString : t -> string -> string\r\n(*\tval fieldStringList : t -> string -> string list *)\r\n\tval fieldStringSet : t -> string -> strings\r\n\r\n\tval fieldState : t -> string -> state\r\n(*\tval fieldStateList : t -> string -> state list *)\r\n\tval fieldStateSet : t -> string -> states\r\n\t\r\n\tval fieldBool : t -> string -> bool\r\n\r\n(*\tval fieldTriplesList : t -> string -> (state * symbol * state) list *)\r\n\tval fieldTriplesSet : t -> string -> (state * symbol * state) set\r\n\r\n(*\tval fieldQuintupletsList : t -> string -> (state * symbol * symbol * state * symbol set) list *)\r\n\tval fieldQuintupletsSet : t -> string -> (state * symbol * symbol * state * word) set\r\n\r\n\r\n\tval fieldTMTransitionSet : t -> string -> (state * symbol * state * symbol * direction) set\r\n\t\r\n\tval append: t -> t -> t\r\n\t\r\n\tval makeSymbol : symbol -> t\r\n\tval makeSymbolSet : symbols -> t\r\n\tval makeString : string -> t\r\n\tval makeStringSet : strings -> t\r\n\tval makeState : state -> t\r\n\tval makeStateSet : states -> t\r\n\tval makeBool : bool -> t\r\n    val makeTriplesSet : (state * symbol * state) set -> t\r\n    val makeQuintupletsSet : (state * symbol * symbol * state * word) set -> t\r\n\tval makeTMTransitionsSet : (state * symbol * state * symbol * direction) set -> t\r\n\tval makeAssoc : (string * t) list -> t\r\nend\r\n*)\r\n\r\nmodule JSon =\r\nstruct\r\n\topen Scanner\r\n\r\n\ttype t =\r\n\t\t| JNull\r\n\t\t| JString of string\r\n\t\t| JAssoc of (string * t) list\r\n\t\t| JList of t list\r\n\r\n\tlet parseString delim =\r\n\t\tskip();\t(* skip quotation mark *)\r\n\t\tlet tk = getUntil delim in\r\n\t\t\tmatch peek () with\r\n\t\t\t\t| x when x = delim -> skip(); tk\r\n\t\t\t\t| _ -> expecting0 (\"closing '\" ^ (Char.escaped delim) ^ \"'\")\r\n\t\t\t\t\r\n\tlet parseWord () =\r\n\t\tgetId ()\r\n\r\n\tlet parseLabel () =\r\n\t\tmatch peek() with\r\n\t\t\t| '\"' -> parseString '\"'\r\n\t\t\t| 'a'..'z' -> parseWord ()\r\n\t\t\t| _ -> expecting0 \"'STRING' or '}'\"\r\n\r\n\tlet checkEOF () =\r\n\t\tmatch peek() with\r\n\t\t\t| ' ' -> ()\r\n\t\t\t| _ -> expecting0 \"'EOF'\"\r\n\r\n\r\n\tmodule JSonParsing = (* JSon syntax *)\r\n\tstruct\r\n\t\tlet rec parsePair () =\r\n\t\t\tlet label = parseLabel () in\r\n\t\t\t\tmatch peek() with\r\n\t\t\t\t\t| ':' -> skip(); (label, parseJSon ())\r\n\t\t\t\t\t| _ -> expecting0 \"':'\"\r\n\r\n\t\tand parseAssocCont () =\r\n\t\t\tlet p = parsePair () in\r\n\t\t\t\tmatch peek() with\r\n\t\t\t\t\t| ',' -> skip(); p::parseAssocCont ()\r\n\t\t\t\t\t| '}' -> skip(); [p]\r\n\t\t\t\t\t| _ -> expecting0 \"',' or '}'\" \r\n\r\n\t\tand parseAssoc () =\r\n\t\t\tskip();\t(* skip { *)\r\n\t\t\tmatch peek() with\r\n\t\t\t\t| '}' -> skip(); []\r\n\t\t\t\t| ' ' -> expecting0 \"'}' or 'STRING'\"\r\n\t\t\t\t| _ -> parseAssocCont ()\r\n\r\n\t\tand parseListCont () =\r\n\t\t\tlet j = parseJSon () in\r\n\t\t\t\tmatch peek() with\r\n\t\t\t\t\t| ',' -> skip(); j::parseListCont ()\r\n\t\t\t\t\t| ']' -> skip(); [j]\r\n\t\t\t\t\t| _ -> expecting0 \"',' or ']'\"\r\n\r\n\t\tand parseList () =\r\n\t\t\tskip();\t(* skip [ *)\r\n\t\t\tmatch peek() with\r\n\t\t\t\t| ']' -> skip(); []\r\n\t\t\t\t| ' ' -> expecting0 \"']' or 'JSON'\"\r\n\t\t\t\t| _ -> parseListCont ()\r\n\r\n\t\tand parseJSon s =\r\n\t\t\tmatch peek() with\r\n\t\t\t\t| '\"' -> JString (parseString '\"')\r\n\t\t\t\t| '[' -> JList (parseList ())\r\n\t\t\t\t| '{' -> JAssoc (parseAssoc ())\r\n\t\t\t\t| _ -> expecting0 \"'JSON'\"\r\n\r\n\t\tlet parse s =\r\n\t\t\tScanner.start \"JSon\" s;\r\n\t\t\ttry\r\n\t\t\t\tlet j = parseJSon () in\r\n\t\t\t\t\tcheckEOF (); j\r\n\t\t\twith Not_found ->\r\n\t\t\t\tJNull\r\n\tend\r\n\r\n\tmodule OCamlValueParsing = (* OCaml value syntax *)\r\n\tstruct\r\n\t\tlet rec parsePair () =\r\n\t\t\tlet label = parseLabel () in\r\n\t\t\t\tmatch peek() with\r\n\t\t\t\t\t| '=' -> skip(); (label, parseOon ())\r\n\t\t\t\t\t| _ -> expecting0 \"'='\"\r\n\r\n\t\tand parseAssocCont () =\r\n\t\t\tlet p = parsePair () in\r\n\t\t\t\tmatch peek() with\r\n\t\t\t\t\t| ';' -> skip(); p::parseAssocCont ()\r\n\t\t\t\t\t| '}' -> skip(); [p]\r\n\t\t\t\t\t| _ -> expecting0 \"';' or '}'\"\r\n\r\n\t\tand parseAssoc () =\r\n\t\t\tskip();\t(* skip { *)\r\n\t\t\tmatch peek() with\r\n\t\t\t\t| '}' -> skip(); []\r\n\t\t\t\t| ' ' -> expecting0 \"'}' or 'STRING'\"\r\n\t\t\t\t| _ -> parseAssocCont ()\r\n\r\n\t\tand parseListCont () =\r\n\t\t\tlet j = parseOon () in\r\n\t\t\t\tmatch peek() with\r\n\t\t\t\t\t| ';' -> skip(); j::parseListCont ()\r\n\t\t\t\t\t| ']' -> skip(); [j]\r\n\t\t\t\t\t| _ -> expecting0 \"';' or ']'\"\r\n\r\n\t\tand parseList () =\r\n\t\t\tskip();\t(* skip [ *)\r\n\t\t\tmatch peek() with\r\n\t\t\t\t| ']' -> skip(); []\r\n\t\t\t\t| ' ' -> expecting0 \"']' or 'Oon'\"\r\n\t\t\t\t| _ -> parseListCont ()\r\n\r\n\t\tand parseTupleCont () =\r\n\t\t\tlet j = parseOon () in\r\n\t\t\t\tmatch peek() with\r\n\t\t\t\t\t| ',' -> skip(); j::parseTupleCont ()\r\n\t\t\t\t\t| ')' -> skip(); [j]\r\n\t\t\t\t\t| _ -> expecting0 \"',' or ')'\"\r\n\r\n\t\tand parseTuple () =\r\n\t\t\tskip();\t(* skip [ *)\r\n\t\t\tmatch peek() with\r\n\t\t\t\t| ')' -> skip(); []\r\n\t\t\t\t| ' ' -> expecting0 \"')' or 'Oon'\"\r\n\t\t\t\t| _ -> parseTupleCont ()\r\n\r\n\t\tand parseOon s =\r\n\t\t\tmatch peek() with\r\n\t\t\t\t| '\"' -> JString (parseString '\"')\r\n\t\t\t\t| '\\''-> JString (parseString '\\'')\r\n\t\t\t\t| '[' -> JList (parseList ())\r\n\t\t\t\t| '(' -> JList (parseTuple ())\r\n\t\t\t\t| '{' -> JAssoc (parseAssoc ())\r\n\t\t\t\t| _ -> expecting0 \"'OON'\"\r\n\t\t\t\t\r\n\t\tlet parse s =\r\n\t\t\tScanner.start \"OON\" s;\r\n\t\t\ttry\r\n\t\t\t\tlet j = parseOon () in\r\n\t\t\t\t\tcheckEOF (); j\r\n\t\t\twith Not_found ->\r\n\t\t\t\tJNull\r\n\tend\r\n\r\n\tlet parse s =\r\n\t    JSonParsing.parse s\r\n\r\n\tlet parseOon s =\r\n\t\tOCamlValueParsing.parse s\r\n\r\n\tlet fromFile filename =\r\n\t\tlet txt = Util.loadFile filename in\r\n\t\t\tif txt = \"\" then JNull\r\n\t\t\telse parse txt\r\n\r\n(* PRETTY PRINT *)\r\n\tlet tab n =\r\n\t\tString.make n '\\t'\r\n\r\n\tlet isComplex j =\r\n\t\tmatch j with\r\n\t\t| JList l -> true\r\n\t\t| JAssoc l -> true\r\n\t\t| _ -> false\r\n\r\n\tlet rec textual (tab1: int) (tab2: int) (j: t) : string =\r\n\t\ttab tab1\r\n\t\t^\r\n\t\tmatch j with\r\n\t\t| JNull ->\r\n\t\t\t\"null\"\r\n\t\t| JString s ->\r\n\t\t\t\t\"\\\"\" ^ s ^ \"\\\"\"\r\n\t\t| JList l when List.exists isComplex l ->\r\n\t\t\t\tlet elems = List.map (textual (tab2+1) (tab2+1)) l in (\r\n\t\t\t\t\t\t\"[\\n\"\r\n\t\t\t\t\t\t^ String.concat (\",\\n\") elems ^ \"\\n\"\r\n\t\t\t\t\t\t^ tab tab2 ^ \"]\"\r\n\t\t\t\t\t)\r\n\t\t| JList l ->\r\n\t\t\t\tlet elems = List.map (textual 0 0) l in\r\n\t\t\t\t\t(\"[\" ^ String.concat \", \" elems ^ \"]\")\r\n\t\t| JAssoc [] ->\r\n\t\t\t\t\"{}\"\r\n\t\t| JAssoc l ->\r\n\t\t\t\tlet field (s,j) = tab (tab2+1) ^ s ^ \" : \" ^ textual 0 (tab2+1) j in\r\n\t\t\t\t\tlet elems = List.map field l in (\r\n\t\t\t\t\t\t\"{\\n\"\r\n\t\t\t\t\t\t^ String.concat \",\\n\" elems ^ \"\\n\"\r\n\t\t\t\t\t\t^ tab tab2 ^ \"}\"\r\n\t\t\t\t\t)\r\n\r\n\tlet rec textualOCaml (tab1: int) (tab2: int) (j: t) : string =\r\n\t\ttab tab1\r\n\t\t^\r\n\t\tmatch j with\r\n\t\t| JNull ->\r\n\t\t\t\"null\"\r\n\t\t| JString s ->\r\n\t\t\t\t\"\\\"\" ^ s ^ \"\\\"\"\r\n\t\t| JList l when List.exists isComplex l ->\r\n\t\t\t\tlet elems = List.map (textualOCaml (tab2+1) (tab2+1)) l in (\r\n\t\t\t\t\t\t\"[\\n\"\r\n\t\t\t\t\t\t^ String.concat (\",\\n\") elems ^ \"\\n\"\r\n\t\t\t\t\t\t^ tab tab2 ^ \"]\"\r\n\t\t\t\t\t)\r\n\t\t| JList l ->\r\n\t\t\t\tlet elems = List.map (textualOCaml 0 0) l in\r\n\t\t\t\t\t(\"[\" ^ String.concat \", \" elems ^ \"]\")\r\n\t\t| JAssoc [] ->\r\n\t\t\t\t\"{}\"\r\n\t\t| JAssoc l ->\r\n\t\t\t\tlet field (s,j) = tab (tab2+1) ^ s ^ \" : \" ^ textualOCaml 0 (tab2+1) j in\r\n\t\t\t\t\tlet elems = List.map field l in (\r\n\t\t\t\t\t\t\"{\\n\"\r\n\t\t\t\t\t\t^ String.concat \",\\n\" elems ^ \"\\n\"\r\n\t\t\t\t\t\t^ tab tab2 ^ \"}\"\r\n\t\t\t\t\t)\r\n\r\n\tlet toStringN n j =\r\n\t\ttextual 0 n j\r\n\r\n\tlet toString j =\r\n\t\ttoStringN 0 j\r\n\r\n\tlet show (j: t) =\r\n\t\tUtil.println [toString j]\r\n\r\n\tlet remove (j: t) r =\r\n\t\tmatch j with\r\n\t\t| JAssoc l ->\r\n\t\t\tJAssoc (List.filter (fun (a,_) -> not (List.mem a r)) l)\r\n\t\t| _ ->\r\n\t\t\tj\r\n\r\n\r\n(* MEMBERSHIP *)\r\n\tlet isNull j =\r\n\t\tj = JNull\r\n\r\n\tlet hasField j name =\r\n\t\tmatch j with\r\n\t\t| JAssoc obj -> (\r\n\t\t\t\ttry\r\n\t\t\t\t\tignore (List.assoc name obj); true\r\n\t\t\t\twith Not_found -> false\r\n\t\t\t)\r\n\t\t| _ ->\r\n\t\t\tfalse\r\n\r\n\tlet getField name j =\r\n\t\tmatch j with\r\n\t\t| JAssoc obj -> (\r\n\t\t\t\ttry\r\n\t\t\t\t\tList.assoc name obj\r\n\t\t\t\twith Not_found -> JNull\r\n\t\t\t)\r\n\t\t| _ ->\r\n\t\t\tJNull\r\n\r\n(* MORE *)\r\n\r\n\tlet error = Error.error\r\n\t\r\n\tlet dummySymb = symb \"#\"\r\n\tlet dummyState = state \"#\"\r\n\tlet dummyDirection = L\r\n\r\n\tlet fieldSymbol (j: t) (field: string): symbol =\r\n\t\tmatch j |> getField field with\r\n\t\t| JNull -> error field \"Missing field\" dummySymb\r\n\t\t| JString s -> str2symb s\r\n\t\t| _ -> error field \"Expected symbol\" dummySymb\r\n\r\n\tlet asSymbol (j: t) (field: string): symbol =\r\n\t\tmatch j with\r\n\t\t| JString s -> str2symb s\r\n\t\t| _ -> error field \"Expected symbol\" dummySymb\r\n\r\n\tlet asSymbolList (j: t) (field: string): symbol list =\r\n\t\tmatch j with\r\n\t\t| JList l -> List.map (fun j -> asSymbol j field) l\r\n\t\t| _ -> error field \"Expected symbol list\" []\r\n\r\n\tlet fieldSymbolList (j: t) (field: string): symbol list =\r\n\t\tmatch j |> getField field with\r\n\t\t| JNull -> error field \"Missing field\" []\r\n\t\t| JList l -> List.map (fun j -> asSymbol j field) l\r\n\t\t| _ -> error field \"Expected symbol list\" []\r\n\r\n\tlet fieldSymbolSet (j: t) (field: string): symbols =\r\n\t\tSet.validate (fieldSymbolList j field) field\r\n\r\n\r\n\tlet fieldString (j: t) (field: string) =\r\n\t\tmatch j |> getField field with\r\n\t\t| JNull -> error field \"Missing field\" \"#\"\r\n\t\t| JString s -> s\r\n\t\t| _ -> error field \"Expected string\" \"#\"\r\n\r\n\tlet asString (j: t) (field: string) =\r\n\t\tmatch j with\r\n\t\t| JString s -> s\r\n\t\t| _ -> error field \"Expected string\" \"#\"\r\n\r\n\tlet fieldStringList (j: t) (field: string) =\r\n\t\tmatch j |> getField field with\r\n\t\t| JNull -> error field \"Missing field\" []\r\n\t\t| JList l -> List.map (fun j -> asString j field) l\r\n\t\t| _ -> error field \"Expected string list\" []\r\n\r\n\tlet fieldStringSet (j: t) (field: string) =\r\n\t\tSet.validate (fieldStringList j field) field\r\n\r\n\r\n\tlet asState (j: t) (field: string) =\r\n\t\tmatch j with\r\n\t\t| JString s -> state s\r\n\t\t| _ -> error field \"Expected state\" dummyState\r\n\r\n\tlet fieldState (j: t) (field: string) =\r\n\t\tstate (fieldString j field)\r\n\t\t\r\n\tlet fieldStateList (j: t) (field: string) =\r\n\t\tList.map state (fieldStringList j field)\r\n\t\t\r\n\tlet fieldStateSet (j: t) (field: string) =\r\n\t\tSet.validate (fieldStateList j field) field\r\n\r\n\tlet fieldBool (j: t) (field: string) =\r\n\t\tmatch fieldString j field with\r\n\t\t| \"false\" -> false\r\n\t\t| \"true\" -> true\r\n\t\t| _ -> error field \"Expected bool\" false\r\n\r\n\tlet fieldDirection (j: t) (field: string) =\r\n\t\tmatch fieldString j field with\r\n\t\t| \"L\" -> L\r\n\t\t| \"S\" -> S\r\n\t\t| \"R\" -> R\r\n\t\t| _ -> error field \"Expected L|S|R\" dummyDirection\r\n\r\n\r\n\tlet asStateSymbolState (j: t) (field: string) =\r\n\t\tmatch j with\r\n\t\t| JList [a; b; c] -> (asState a field, asSymbol b field, asState c field)\r\n\t\t| _ -> error field \"Malformed triple\" (dummyState,dummySymb,dummyState)\r\n\r\n\tlet fieldTriplesList (j: t) (field: string) =\r\n\t\tmatch j |> getField field with\r\n\t\t| JNull -> error field \"Missing field\" []\r\n\t\t| JList l -> List.map (fun j -> asStateSymbolState j field) l\r\n\t\t| _ -> []\r\n\r\n\tlet fieldTriplesSet (j: t) (field: string) =\r\n\t\tSet.validate (fieldTriplesList j field) field\r\n\r\n\r\n\tlet asStateSymbolSymbolState (j: t) (field: string) =\r\n\t\tmatch j with\r\n\t\t| JList [a; b; c; d] -> (asState a field, asSymbol b field, asSymbol c field, asState d field)\r\n\t\t| _ -> error field \"Malformed quad\" (dummyState,dummySymb,dummySymb,dummyState)\r\n\r\n\tlet fieldQuadsList (j: t) (field: string) =\r\n\t\tmatch j |> getField field with\r\n\t\t| JNull -> error field \"Missing field\" []\r\n\t\t| JList l -> List.map (fun j -> asStateSymbolSymbolState j field) l\r\n\t\t| _ -> []\r\n\r\n\tlet fieldQuadsSet (j: t) (field: string) =\r\n\t\tSet.validate (fieldQuadsList j field) field\r\n\r\n\r\n\tlet asWord (j: t) (field: string): word =\r\n\t\tmatch j with\r\n\t\t\t| JString s -> str2word s\r\n\t\t\t| _ -> error field \"Expected word\" []\r\n\r\n\tlet asStateSymbolSymbolStateWord (j: t) (field: string) =\r\n\t\tmatch j with\r\n\t\t| JList [a; b; c; d; e] ->\r\n\t\t\t(\tasState a field,\r\n\t\t\t\tasSymbol b field,\r\n\t\t\t\tasSymbol c field,\r\n\t\t\t\tasState d field,\r\n\t\t\t\tasWord e field\r\n\t\t\t)\r\n\t\t| _ -> error field \"Malformed quintuplet\" (dummyState,dummySymb,dummySymb,dummyState,[])\r\n\r\n\t\r\n\tlet fieldQuintupletsList (j: t) (field: string) =\r\n\t\tmatch j |> getField field with\r\n\t\t| JNull -> error field \"Missing field\" []\r\n\t\t| JList l -> List.map (fun j -> asStateSymbolSymbolStateWord j field) l\r\n\t\t| _ -> []\r\n\r\n\tlet fieldQuintupletsSet (j: t) (field: string) =\r\n\t\tSet.validate (fieldQuintupletsList j field) field\r\n\r\n\tlet append j1 j2 =\r\n\t\tmatch j1, j2 with\r\n\t\t| JAssoc l1, JAssoc l2 -> JAssoc (l1 @ l2)\r\n\t\t| _, _ -> Error.fatal \"JSon.append: not Assoc\"\r\n\r\n\tlet makeSymbol s =\r\n\t\tJString (symb2str s)\r\n\r\n\tlet makeSymbolList (l: symbol list) =\r\n\t\tJList (List.map makeSymbol l)\r\n\r\n\tlet makeSymbolSet (s: symbols) =\r\n\t\tmakeSymbolList (Set.toList s)\r\n\t\t\r\n\tlet makeString s =\r\n\t\tJString s\r\n\r\n\tlet makeStringSet s =\r\n\t\tJList (List.map makeString (Set.toList s))\r\n\t\t\r\n\tlet makeState s =\r\n\t\tmakeString (state2str s)\r\n\t\t\r\n\tlet makeStateSet s =\r\n\t\tJList (List.map makeState (Set.toList s))\r\n\r\n\tlet makeBool b =\r\n\t\tmakeString (if b then \"true\" else \"false\")\r\n\t\t\r\n\tlet makeTriplesSet s =\r\n\t\tJList (List.map (fun (a,b,c) ->\r\n\t\t\t\tJList [JString (state2str a); JString (symb2str b);\r\n\t\t\t\t\t\tJString (state2str c)]) (Set.toList s))\r\n\t\t\r\n\tlet makeQuadsSet s =\r\n\t\tJList (List.map (fun (a,b,c,d) ->\r\n\t\t\t\tJList [JString (state2str a); JString (symb2str b);\r\n\t\t\t\t\t\tJString (symb2str c); JString (state2str d)])\r\n\t\t\t\t\t\t\t(Set.toList s))\r\n\r\n\tlet makeQuintupletsSet s =\r\n\t\tJList (List.map (fun (a,b,c,d,e) ->\r\n\t\t\t\t\t\t\tJList [\tJString (state2str a);\r\n\t\t\t\t\t\t\t\t\tJString (symb2str b);\r\n\t\t\t\t\t\t\t\t\tJString (symb2str c);\r\n\t\t\t\t\t\t\t\t\tJString (state2str d);\r\n\t\t\t\t\t\t\t\t\tJString (word2str e)])\r\n\t\t\t\t\t\t\t(Set.toList s))\r\n\r\n\tlet makeAssoc l =\r\n\t\tJAssoc l\r\nend\r\n\r\n# 1 \"src/Examples.ml\"\r\n(*\r\n * Examples.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by João Gonçalves (jg)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * dec/2020 (amd) - Collected the examples in a single module.\r\n * sep/2019 (jg) - Initial version, each example in an individual file.\r\n *)\r\n\r\n(*\r\n * Description: A set of good predefined examples.\r\n *\r\n * TODO: Check if these examples are really good and improve.\r\n *)\r\n\r\nmodule type ExamplesSig =\r\nsig\r\n\tval examplesTable : (string * (string * string) list) list\r\n\tval examples : string list\r\n\tval example : string -> string\r\n\tval jsonExample : string -> JSon.t\r\n\tval see : string -> unit\r\nend\r\n\r\nmodule Examples : ExamplesSig =\r\nstruct\r\n(* FA examples *)\r\n\tlet dfa_1 = {| {\r\n\t\t\tkind : \"finite automaton\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"dfa_1\",\r\n\t\t\talphabet: [\"a\", \"b\"],\r\n\t\t\tstates : [\"START\", \"A\", \"B\", \"C\"],\r\n\t\t\tinitialState : \"START\",\r\n\t\t\ttransitions : [\r\n\t\t\t\t\t[\"START\", \"a\", \"A\"], [\"A\", \"b\", \"B\"], [\"B\", \"a\", \"C\"], [\"C\", \"b\", \"B\"],\r\n\t\t\t\t\t[\"C\", \"a\", \"A\"]\r\n\t\t\t\t],\r\n\t\t\tacceptStates : [\"START\", \"B\", \"C\"]\r\n\t\t} |}\r\n\r\n\tlet dfa_2 = {| {\r\n\t\t\tkind : \"finite automaton\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"dfa_2\",\r\n\t\t\talphabet: [\"0\", \"1\"],\r\n\t\t\tstates : [\"START\", \"1\", \"2\", \"3\"],\r\n\t\t\tinitialState : \"START\",\r\n\t\t\ttransitions : [\r\n\t\t\t\t[\"START\", \"1\", \"1\"], [\"1\", \"1\", \"START\"], [\"1\", \"0\", \"2\"], [\"2\", \"0\", \"1\"],\r\n\t\t\t\t[\"2\", \"1\", \"3\"], [\"3\", \"1\", \"2\"], [\"3\", \"0\", \"START\"], [\"START\", \"0\", \"3\"]\r\n\t\t\t],\r\n\t\t\tacceptStates : [\"1\"]\r\n\t\t\t} |}\r\n\r\n\tlet dfa_astar = {| {\r\n\t\t\tkind : \"finite automaton\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"dfa_astar\",\r\n\t\t\talphabet: [\"a\"],\r\n\t\t\tstates : [\"START\"],\r\n\t\t\tinitialState : \"START\",\r\n\t\t\ttransitions : [\r\n\t\t\t\t[\"START\", \"a\", \"START\"]\r\n\t\t\t],\r\n\t\t\tacceptStates : [\"START\"]\r\n\t\t\t} |}\r\n\r\n\tlet fa_abc = {| {\r\n\t\t\tkind : \"finite automaton\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"fa_abc\",\r\n\t\t\talphabet : [\"a\", \"b\", \"c\", \"d\"],\r\n\t\t\tstates : [\"START\", \"A\", \"AB\", \"SUCCESS\"],\r\n\t\t\tinitialState : \"START\",\r\n\t\t\ttransitions : [\r\n\t\t\t\t\t[\"START\",\"a\",\"A\"], [\"START\",\"b\",\"START\"], [\"START\",\"c\",\"START\"], [\"START\",\"d\",\"START\"],\r\n\t\t\t\t\t[\"A\",\"a\",\"A\"], [\"A\",\"b\",\"AB\"], [\"A\",\"c\",\"START\"], [\"A\",\"d\",\"START\"],\r\n\t\t\t\t\t[\"AB\",\"a\",\"A\"], [\"AB\",\"b\",\"START\"], [\"AB\",\"c\",\"SUCCESS\"], [\"AB\",\"d\",\"START\"],\r\n\t\t\t\t\t[\"SUCCESS\",\"a\",\"SUCCESS\"], [\"SUCCESS\",\"b\",\"SUCCESS\"], [\"SUCCESS\",\"c\",\"SUCCESS\"], [\"SUCCESS\",\"d\",\"SUCCESS\"]\r\n\t\t\t\t],\r\n\t\t\tacceptStates : [\"SUCCESS\"]\r\n\t\t} |}\r\n\r\n\tlet fa_error = {| {\r\n\t\t\tkind : \"finite automaton\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"fa_error\",\r\n\t\t\talphabet : [\"a\"],\r\n\t\t\tstates : [\"A\"],\r\n\t\t\tinitialState : \"START\",\r\n\t\t\ttransitions : [],\r\n\t\t\tacceptStates : [\"SUCCESS\"]\r\n\t\t} |}\r\n\r\n\tlet nfa_1 = {| {\r\n\t\t\tkind : \"finite automaton\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"nfa_1\",\r\n\t\t\talphabet: [\"a\", \"b\"],\r\n\t\t\tstates : [\"START\", \"A\", \"B\"],\r\n\t\t\tinitialState : \"START\",\r\n\t\t\ttransitions : [\r\n\t\t\t\t\t[\"START\", \"a\", \"A\"], [\"A\", \"b\", \"B\"], [\"A\", \"b\", \"START\"], [\"B\", \"a\", \"START\"]\r\n\t\t\t\t],\r\n\t\t\tacceptStates : [\"START\"]\r\n\t\t\t} |}\r\n\r\n\tlet nfa_2 = {| {\r\n\t\t\tkind : \"finite automaton\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"nfa_2\",\r\n\t\t\talphabet : [\"a\", \"b\", \"c\", \"d\", \"e\"],\r\n\t\t\tstates : [\"START\", \"A\", \"AB\", \"SUCCESS\", \"UNREACHABLE\", \"UNPRODUCTIVE\"],\r\n\t\t\tinitialState : \"START\",\r\n\t\t\ttransitions : [\r\n\t\t\t\t\t[\"START\",\"a\",\"A\"], [\"START\",\"b\",\"START\"], [\"START\",\"c\",\"START\"], [\"START\",\"d\",\"START\"],\r\n\t\t\t\t\t[\"A\",\"a\",\"A\"], [\"A\",\"b\",\"AB\"], [\"A\",\"c\",\"START\"], [\"A\",\"d\",\"START\"],\r\n\t\t\t\t\t[\"AB\",\"a\",\"A\"], [\"AB\",\"b\",\"START\"], [\"AB\",\"c\",\"SUCCESS\"], [\"AB\",\"d\",\"START\"],\r\n\t\t\t\t\t[\"SUCCESS\",\"a\",\"SUCCESS\"], [\"SUCCESS\",\"b\",\"SUCCESS\"], [\"SUCCESS\",\"c\",\"SUCCESS\"], [\"SUCCESS\",\"d\",\"SUCCESS\"], [\"A\",\"a\",\"AB\"], [\"UNREACHABLE\", \"a\", \"SUCCESS\"],\r\n\t\t\t\t\t[\"SUCCESS\", \"e\", \"UNPRODUCTIVE\"], [\"UNPRODUCTIVE\", \"a\", \"UNPRODUCTIVE\"]\r\n\t\t\t\t],\r\n\t\t\tacceptStates : [\"SUCCESS\"]\r\n\t\t} |}\r\n\r\n(* RE examples *)\r\n\tlet re_abc = {| {\r\n\t\t\tkind : \"regular expression\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"re_abc\",\r\n\t\t\tre : \"((a+b)*(cd)*)*\"\r\n\t\t} |}\r\n\r\n\tlet re_complex = {| {\r\n\t\t\tkind : \"regular expression\",\r\n\t\t\tdescription : \"this is a complex example\",\r\n\t\t\tname : \"re_complex\",\r\n\t\t\tre : \"(a+(b(c+d)+ea))*f*g\"\r\n\t\t} |}\r\n\r\n\tlet re_convoluted = {| {\r\n\t\t\tkind : \"regular expression\",\r\n\t\t\tdescription : \"this is a convoluted example\",\r\n\t\t\tname : \"re_convoluted\",\r\n\t\t\tre : \"((((a+b)*(cd)*)*+(e(f+gh*i)*jk)*+lmn)op+q)\"\r\n\t\t} |}\r\n\r\n\tlet re_simple = {| {\r\n\t\t\tkind : \"regular expression\",\r\n\t\t\tdescription : \"this is a simple example\",\r\n\t\t\tname : \"re_simple\",\r\n\t\t\tre : \"a+a*+bc*\"\r\n\t\t} |}\r\n\r\n\tlet re_astar = {| {\r\n\t\t\tkind : \"regular expression\",\r\n\t\t\tdescription : \"this is a simple example\",\r\n\t\t\tname : \"re_astar\",\r\n\t\t\tre : \"a*\"\r\n\t\t} |}\r\n\r\n(* FE examples *)\r\n\tlet fe_colors = {| {\r\n\t\tkind : \"finite enumeration\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"fe_colors\",\r\n\t\twords : [\"Red\", \"Yellow\", \"Blue\"]\r\n\t} |}\r\n\r\n(* CFG examples *)\r\n\tlet cfg_simple = {| {\r\n\t\t\tkind : \"context free grammar\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"cfg_simple\",\r\n\t\t\talphabet : [\"0\", \"1\"],\r\n\t\t\tvariables : [\"S\", \"P\"],\r\n\t\t\tinitial : \"S\",\r\n\t\t\trules : [\t\"S -> 1S0 | P\",\r\n\t\t\t\t\t\t\"P -> 0P1 | ~\" ]\r\n\t\t} |}\r\n\t\t\r\n\tlet cfg_balanced = {| {\r\n\t\t\tkind : \"context free grammar\",\r\n\t\t\tdescription : \"CFG: Language of balanced square bracket parentheses\",\r\n\t\t\tname : \"cfg_balanced\",\r\n\t\t\talphabet : [\"[\", \"]\"],\r\n\t\t\tvariables : [\"S\"],\r\n\t\t\tinitial : \"S\",\r\n\t\t\trules : [ \"S -> [S] | SS | ~\"]\r\n\t\t} |}\r\n\r\n(* LL parsing *)\r\n\r\n\tlet cfg_ll_thesis_g1 = {| {\r\n\t\t\tkind : \"context free grammar\",\r\n\t\t\tdescription : \"Grammar G1 from thesis document\",\r\n\t\t\tname : \"cfg_ll_thesis_g1\",\r\n\t\t\talphabet : [\"a\", \"b\", \"c\"],\r\n\t\t\tvariables : [\"A\", \"B\", \"C\", \"S\"],\r\n\t\t\tinitial : \"S\",\r\n\t\t\trules : [\"A -> a\", \"A -> aAB\", \"B -> Bb\", \"B -> C\", \"C -> c\", \"S -> ABC\"]\r\n\t\t} |}\r\n\r\n\tlet cfg_ll_thesis_g2 = {| {\r\n\t\t\tkind : \"context free grammar\",\r\n\t\t\tdescription : \"Grammar G2 from thesis document\",\r\n\t\t\tname : \"cfg_ll_thesis_g2\",\r\n\t\t\talphabet : [\"a\", \"b\", \"c\"],\r\n\t\t\tvariables : [\"A\", \"B\", \"C\", \"D\", \"E\", \"S\"],\r\n\t\t\tinitial : \"S\",\r\n\t\t\trules : [\"A -> aD\", \"B -> CE\", \"C -> c\", \"D -> \", \"D -> AB\", \"E -> \", \"E -> bE\", \"S -> ABC\"]\r\n\t} |}\r\n\r\n\tlet cfg_ll_1 = {| {\r\n\t\t\tkind : \"context free grammar\",\r\n\t\t\tdescription : \"Example from old pratical classes\",\r\n\t\t\tname : \"cfg_ll_1\",\r\n\t\t\talphabet : [\"(\", \")\", \"*\", \"+\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"],\r\n\t\t\tvariables : [\"D\", \"E\", \"F\", \"I\", \"S\", \"T\", \"X\", \"Y\", \"Z\"],\r\n\t\t\tinitial : \"S\",\r\n\t\t\trules : [\"D -> 0\", \"D -> 1\", \"D -> 2\", \"D -> 3\", \"D -> 4\", \"D -> 5\", \"D -> 6\", \"D -> 7\", \"D -> 8\", \"D -> 9\", \"E -> TX\", \"F -> (E)\", \"F -> I\", \"I -> DZ\", \"S -> E\", \"T -> FY\", \"X -> \", \"X -> +TX\", \"Y -> \", \"Y -> *FY\", \"Z -> \", \"Z -> DZ\"]\r\n\t\t} |}\r\n\r\n\tlet cfg_ll_2 = {| {\r\n\t\t\tkind : \"context free grammar\",\r\n\t\t\tdescription : \"classic grammar\",\r\n\t\t\tname : \"cfg_ll_2\",\r\n\t\t\talphabet : [\"*\", \"+\", \"0\", \"1\"],\r\n\t\t\tvariables : [\"D\", \"E\"],\r\n\t\t\tinitial : \"E\",\r\n\t\t\trules : [\"D -> 0\", \"D -> 1\", \"E -> D\", \"E -> E*E\", \"E -> E+E\"]\r\n\t\t} |}\r\n\r\n\tlet cfg_ll_3 = {| {\r\n\t\t\tkind : \"context free grammar\",\r\n\t\t\tdescription : \"_\",\r\n\t\t\tname : \"cfg_ll_3\",\r\n\t\t\talphabet : [\"(\", \")\", \"*\", \"+\", \"i\"],\r\n\t\t\tvariables : [\"E\", \"F\", \"T\"],\r\n\t\t\tinitial : \"E\",\r\n\t\t\trules : [\"E -> E+T\", \"E -> T\", \"F -> (E)\", \"F -> i\", \"T -> F\", \"T -> T*F\"]\r\n\t\t} |}\r\n\r\n\tlet cfg_ll_4 = {| {\r\n\t\t\tkind : \"context free grammar\",\r\n\t\t\tdescription : \"_\",\r\n\t\t\tname : \"cfg_ll_4\",\r\n\t\t\talphabet : [\"a\", \"b\", \"d\", \"g\", \"h\"],\r\n\t\t\tvariables : [\"A\", \"B\", \"C\", \"S\"],\r\n\t\t\tinitial : \"S\",\r\n\t\t\trules : [\"A -> BC\", \"A -> da\", \"B -> \", \"B -> g\", \"C -> \", \"C -> h\", \"S -> ACB\", \"S -> Ba\", \"S -> CbB\"]\r\n\t\t} |}\r\n\r\n\tlet cfg_ll_5 = {| {\r\n\t\t\tkind : \"context free grammar\",\r\n\t\t\tdescription : \"_\",\r\n\t\t\tname : \"cfg_ll_5\",\r\n\t\t\talphabet : [\"a\", \"b\", \"c\", \"d\", \"e\"],\r\n\t\t\tvariables : [\"A\", \"B\", \"C\", \"D\", \"E\", \"S\"],\r\n\t\t\tinitial : \"S\",\r\n\t\t\trules : [\"A -> \", \"A -> a\", \"B -> \", \"B -> b\", \"C -> c\", \"D -> \", \"D -> d\", \"E -> \", \"E -> e\", \"S -> ABCDE\"]\t\r\n\t\t} |}\r\n\r\n\tlet cfg_ll_6 = {| {\r\n\t\t\tkind : \"context free grammar\",\r\n\t\t\tdescription : \"Exemplo 9\",\r\n\t\t\tname : \"cfg_ll_6\",\r\n\t\t\talphabet : [\"a\", \"b\"],\r\n\t\t\tvariables : [\"A\", \"B\", \"C\", \"N\"],\r\n\t\t\tinitial : \"N\",\r\n\t\t\trules : [\"A -> CAC\", \"A -> a\", \"B -> CBC\", \"B -> b\", \"C -> a\", \"C -> b\", \"N -> AB\", \"N -> BA\"]\t\r\n\t\t} |}\r\n\r\n(* LR parsing *)\r\n\tlet cfg_lr0_thesis = {| {\r\n\t\t\tkind : \"context free grammar\",\r\n\t\t\tdescription : \"This is an example for LR0\",\r\n\t\t\tname : \"cfg_lr0_thesis\",\r\n\t\t\talphabet : [\"a\", \"b\", \"$\"],\r\n\t\t\tvariables : [\"S\", \"X\", \"A\"],\r\n\t\t\tinitial : \"S\",\r\n\t\t\trules : [\t\"S -> X$\",\r\n\t\t\t\t\t\t\"X -> XA | A\",\r\n\t\t\t\t\t\t\"A -> aXb | ab\" ]\r\n\t\t} |}\r\n\t\t\r\n\tlet cfg_slr1 = {| {\r\n\t\t\tkind : \"context free grammar\",\r\n\t\t\tdescription : \"This is another example for SLR1\",\r\n\t\t\tname : \"cfg_slr1\",\r\n\t\t\talphabet : [\"a\", \"c\", \"d\",\"z\", \"$\"],\r\n\t\t\tvariables : [\"T\", \"S\",\"A\",\"B\"],\r\n\t\t\tinitial : \"T\",\r\n\t\t\trules : [\t\"T -> S$\",\r\n\t\t\t\t\t\t\"S -> aAc | aBd\",\r\n\t\t\t\t\t\t\"A -> z\",\r\n\t\t\t\t\t\t\"B -> z\"]\r\n\t\t} |}\r\n\t\t\r\n\tlet cfg_lr0_thesis = {| {\r\n\t\t\tkind : \"context free grammar\",\r\n\t\t\tdescription : \"This is the example for LR0 in the thesis\",\r\n\t\t\tname : \"cfg_lr0_thesis\",\r\n\t\t\talphabet : [\"a\", \"b\", \"$\"],\r\n\t\t\tvariables : [\"S\", \"X\", \"A\"],\r\n\t\t\tinitial : \"S\",\r\n\t\t\trules : [\t\"S -> X$\",\r\n\t\t\t\t\t\t\"X -> XA | A\",\r\n\t\t\t\t\t\t\"A -> aXb | ab\" ]\r\n\t\t} |}\r\n\t\t\r\n\tlet cfg_slr1_thesis = {| {\r\n\t\t\tkind : \"context free grammar\",\r\n\t\t\tdescription : \"This is the example for SLR1 in the thesis\",\r\n\t\t\tname : \"cfg_slr1_thesis\",\r\n\t\t\talphabet : [\"$\",\"a\", \"b\", \"c\"],\r\n\t\t\tvariables : [\"T\", \"S\", \"A\", \"B\", \"C\"],\r\n\t\t\tinitial : \"T\",\r\n\t\t\trules : [\t\"T -> S$\",\r\n\t\t\t\t\t\t\"S -> aBbA | aA\",\r\n\t\t\t\t\t\t\"A -> b | ~\",\r\n\t\t\t\t\t\t\"B -> b | bC\",\r\n\t\t\t\t\t\t\"C -> c\" ]\r\n\t\t} |}\r\n\t\t\r\n\tlet cfg_lr1_thesis = {| {\r\n\t\t\tkind : \"context free grammar\",\r\n\t\t\tdescription : \"This is the example for LR1 in the thesis\",\r\n\t\t\tname : \"cfg_lr1_thesis\",\r\n\t\t\talphabet : [\"a\", \"c\", \"d\", \"z\", \"$\"],\r\n\t\t\tvariables : [\"S\", \"X\", \"A\", \"B\"],\r\n\t\t\tinitial : \"S\",\r\n\t\t\trules : [\t\"S -> X$\",\r\n\t\t\t\t\t\t\"X -> aAc | aBd | Bc\",\r\n\t\t\t\t\t\t\"A -> z\",\r\n\t\t\t\t\t\t\"B -> z\"]\r\n\t\t} |}\r\n\t\t\r\n\tlet cfg_lalr1_thesis = {| {\r\n\t\t\tkind : \"context free grammar\",\r\n\t\t\tdescription : \"This is the example for LALR1 in the thesis\",\r\n\t\t\tname : \"cfg_lalr1_thesis\",\r\n\t\t\talphabet : [\"c\", \"d\", \"$\"],\r\n\t\t\tvariables : [\"S\", \"X\",\"C\"],\r\n\t\t\tinitial : \"S\",\r\n\t\t\trules : [\t\"S -> X$\",\r\n\t\t\t\t\t\t\"X -> CC\",\r\n\t\t\t\t\t\t\"C -> cC | d\"]\r\n\t\t} |}\r\n\t\t\r\n\tlet cfg_onlylr1 = {| {\r\n\t\t\tkind : \"context free grammar\",\r\n\t\t\tdescription : \"This is an example for a LR1-only grammar\",\r\n\t\t\tname : \"cfg_onlylr1\",\r\n\t\t\talphabet : [\"$\", \"a\", \"c\", \"d\", \"b\", \"z\"],\r\n\t\t\tvariables : [\"S\", \"X\", \"A\", \"B\"],\r\n\t\t\tinitial : \"S\",\r\n\t\t\trules : [\"S -> X$\", \"X -> aAc\", \"X -> aBd\", \"X -> bA\", \"X -> bBc\", \"A -> z\", \"B -> z\"]\r\n\t\t} |}\r\n\t\t\r\n\tlet cfg_notlr1 = {| {\r\n\t\t\tkind : \"context free grammar\",\r\n\t\t\tdescription : \"This is an example for an LR2 Grammar, so it should return 'It's not LR1'\",\r\n\t\t\tname : \"cfg_notlr1\",\r\n\t\t\talphabet : [\"a\", \"c\", \"d\", \"z\", \"$\"],\r\n\t\t\tvariables : [\"S\", \"X\", \"A\", \"B\"],\r\n\t\t\tinitial : \"S\",\r\n\t\t\trules : [\t\"S -> X$\",\r\n\t\t\t\t\t\t\"X -> aAc | aBcd\",\r\n\t\t\t\t\t\t\"A -> z\",\r\n\t\t\t\t\t\t\"B -> z\"]\r\n\t\t} |}\t\t\t\r\n\r\n(* UG examples *)\r\n\tlet ug_simple = {| {\r\n\t\t\tkind : \"grammar\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"ug_simple\",\r\n\t\t\talphabet : [\"0\", \"1\"],\r\n\t\t\tvariables : [\"S\", \"P\"],\r\n\t\t\tinitial : \"S\",\r\n\t\t\trules : [\t\"S -> 1S0 | P\",\r\n\t\t\t\t\t\t\"1P0 -> 0P1 | ~\" ]\r\n\t\t} |}\r\n\t\t\r\n\r\n(* Pushdown Automata *)\r\n\tlet pda_WW_1 = {| {\r\n\t\t\tkind: \"pushdown automaton\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"pda_WW-1\",\r\n\t\t\tinputAlphabet : [\"a\",\"b\"],\r\n\t\t\tstackAlphabet: [\"z\",\"a\",\"b\"],\r\n\t\t\tstates : [\"S1\",\"S2\",\"S3\",\"S4\"],\r\n\t\t\tinitialState : \"S1\",\r\n\t\t\tinitialStackSymbol: \"z\",\r\n\t\t\ttransitions : [\r\n\t\t\t\t\t[\"S1\",\"z\",\"a\",\"S2\",\"az\"], \r\n\t\t\t\t\t[\"S1\",\"z\",\"b\",\"S2\",\"bz\"],\r\n\t\t\t\t\t[\"S2\",\"a\",\"a\",\"S2\",\"aa\"],\r\n\t\t\t\t\t[\"S2\",\"a\",\"a\",\"S3\",\"\"],\r\n\t\t\t\t\t[\"S2\",\"a\",\"b\",\"S2\",\"ba\"],\r\n\t\t\t\t\t[\"S2\",\"b\",\"a\",\"S2\",\"ab\"],\r\n\t\t\t\t\t[\"S2\",\"b\",\"b\",\"S2\",\"bb\"],\r\n\t\t\t\t\t[\"S2\",\"b\",\"b\",\"S3\",\"\"],\r\n\t\t\t\t\t[\"S3\",\"a\",\"a\",\"S3\",\"\"],\r\n\t\t\t\t\t[\"S3\",\"b\",\"b\",\"S3\",\"\"],\r\n\t\t\t\t\t[\"S3\",\"z\",\"~\",\"S4\",\"z\"]\r\n\t\t\t\t],\r\n\t\t\tacceptStates : [\"S1\",\"S4\"],\r\n\t\t\tcriteria: \"true\"\r\n\t\t} |}\r\n\r\n\tlet pda_AABB_old = {| {\r\n\t\t\tkind: \"pushdown automaton\",\r\n\t\t\tdescription: \"this is an example\",\r\n\t\t\tname: \"pda_AABB\",\r\n\t\t\tinputAlphabet: [\"a\", \"b\"],\r\n\t\t\tstackAlphabet: [\"a\", \"z\"],\r\n\t\t\tstates: [\"S1\", \"S2\", \"S3\"],\r\n\t\t\tinitialState: \"S1\",\r\n\t\t\tinitialStackSymbol: \"z\",\r\n\t\t\ttransitions: [\r\n\t\t\t\t[\"S1\", \"z\", \"a\", \"S1\", \"az\"],\r\n\t\t\t\t[\"S1\", \"a\", \"a\", \"S1\", \"aa\"],\r\n\t\t\t\t[\"S1\", \"a\", \"~\", \"S2\", \"a\"],\r\n\t\t\t\t[\"S2\", \"a\", \"b\", \"S2\", \"\"],\r\n\t\t\t\t[\"S2\", \"z\", \"~\", \"S3\", \"z\"]\r\n\t\t\t],\r\n\t\t\tacceptStates: [\"S3\"],\r\n\t\t\tcriteria: \"true\"\r\n\t\t} |}\r\n\t\r\n\t (* pda_AABB - versao PEDRO CARLOS. Porque? *)\r\n\tlet pda_AABB = {| {\r\n\t\t\tkind: \"pushdown automaton\",\r\n\t\t\tdescription: \"this is an example\",\r\n\t\t\tname: \"pda_AABB\",\r\n\t\t\tinputAlphabet: [\"a\", \"b\"],\r\n\t\t\tstackAlphabet: [\"a\", \"z\"],\r\n\t\t\tstates: [\"S1\", \"S2\", \"S3\"],\r\n\t\t\tinitialState: \"S1\",\r\n\t\t\tinitialStackSymbol: \"z\",\r\n\t\t\ttransitions: [\r\n\t\t\t\t[\"S1\", \"z\", \"a\", \"S1\", \"az\"],\r\n\t\t\t\t[\"S1\", \"a\", \"a\", \"S1\", \"aa\"],\r\n\t\t\t\t[\"S1\", \"a\", \"~\", \"S2\", \"\"],\r\n\t\t\t\t[\"S2\", \"a\", \"b\", \"S2\", \"\"],\r\n\t\t\t\t[\"S2\", \"z\", \"~\", \"S3\", \"\"]\r\n\t\t\t],\r\n\t\t\tacceptStates: [\"S3\"],\r\n\t\t\tcriteria: \"true\"\r\n\t\t} |}\r\n\r\n\t\tlet pda_Explode = {| {\r\n\t\t\tkind : \"pushdown automaton\",\r\n\t\t\tdescription : \"_\",\r\n\t\t\tname : \"pda_Explode\",\r\n\t\t\tinputAlphabet : [\"a\"],\r\n\t\t\tstackAlphabet : [\"a\", \"b\", \"z\"],\r\n\t\t\tstates : [\"START\", \"A\"],\r\n\t\t\tinitialState : \"START\",\r\n\t\t\tinitialStackSymbol : \"z\",\r\n\t\t\ttransitions : [\r\n\t\t\t\t[\"START\", \"z\", \"a\", \"START\", \"az\"],\r\n\t\t\t\t[\"START\", \"a\", \"a\", \"START\", \"aa\"],\r\n\t\t\t\t[\"A\", \"a\", \"a\", \"A\", \"bb\"],\r\n\t\t\t\t[\"A\", \"b\", \"a\", \"A\", \"aa\"],\r\n\t\t\t\t[\"START\", \"a\", \"a\", \"A\", \"a\"],\r\n\t\t\t\t[\"START\", \"a\", \"a\", \"A\", \"b\"],\r\n\t\t\t\t[\"A\", \"a\", \"a\", \"START\", \"ab\"]\r\n\t\t\t],\r\n\t\t\tacceptStates : [],\r\n\t\t\tcriteria : \"true\"\r\n\t\t} |}\r\n\t\t\r\n(* Turing Machine *)\r\n\r\n   (* AMD multifita test *)\r\n\tlet tm_translate_lb = {| {\r\n\t\tkind: \"turing machine\",\r\n\t\tdescription: \"this is an example\",\r\n\t\tname: \"tm_translate_lb\",\r\n\t\tentryAlphabet: [\"a\", \"b\", \"[\", \"]\"],\r\n\t\ttapeAlphabet: [\"a\", \"b\", \"B\", \"[\", \"]\"],\r\n\t\tempty: \"B\",\r\n\t\tstates: [\"q1\", \"q2\"],\r\n\t\tinitialState: \"q1\",\r\n\t\ttransitions: [\r\n\t\t\t[\"q1\", [\"a\", \"B\"], \"q1\", [\"b\", \"B\"], [\"R\", \"R\"]],\r\n\t\t\t[\"q1\", [\"b\", \"B\"], \"q1\", [\"a\", \"B\"], [\"R\", \"R\"]],\r\n\t\t\t[\"q1\", [\"B\", \"B\"], \"q2\", [\"B\", \"B\"], [\"L\", \"L\"]],\r\n\t\t\t[\"q2\", [\"a\", \"B\"], \"q2\", [\"a\", \"B\"], [\"L\", \"L\"]],\r\n\t\t\t[\"q2\", [\"b\", \"B\"], \"q2\", [\"b\", \"B\"], [\"L\", \"L\"]]\r\n\t\t],\r\n\t\tacceptStates: [],\r\n\t\tcriteria: \"false\",\r\n\t\tmarkers: [\"[\", \"]\"]\r\n\t\t} |}\r\n\r\n\r\n   (* AMD multifita test *)\r\n\tlet tm_translate = {| {\r\n\t\tkind: \"turing machine\",\r\n\t\tdescription: \"this is an example\",\r\n\t\tname: \"tm_translate\",\r\n\t\tentryAlphabet: [\"a\", \"b\"],\r\n\t\ttapeAlphabet: [\"a\", \"b\", \"B\"],\r\n\t\tempty: \"B\",\r\n\t\tstates: [\"q1\", \"q2\"],\r\n\t\tinitialState: \"q1\",\r\n\t\ttransitions: [\r\n\t\t\t[\"q1\", [\"a\", \"B\"], \"q1\", [\"b\", \"B\"], [\"R\", \"L\"]],\r\n\t\t\t[\"q1\", [\"b\", \"B\"], \"q1\", [\"a\", \"B\"], [\"R\", \"L\"]],\r\n\t\t\t[\"q1\", [\"B\", \"B\"], \"q2\", [\"B\", \"B\"], [\"L\", \"L\"]],\r\n\t\t\t[\"q2\", [\"a\", \"B\"], \"q2\", [\"a\", \"B\"], [\"L\", \"L\"]],\r\n\t\t\t[\"q2\", [\"b\", \"B\"], \"q2\", [\"b\", \"B\"], [\"L\", \"L\"]]\r\n\t\t],\r\n\t\tacceptStates: [],\r\n\t\tcriteria: \"false\"\r\n\t\t} |}\r\n\r\n\tlet tm_astar1 = {| {\r\n\t\tkind: \"turing machine\",\r\n\t\tdescription: \"this is an example\",\r\n\t\tname: \"tm_astar1\",\r\n\t\tentryAlphabet: [\"a\", \"b\"],\r\n\t\ttapeAlphabet: [\"a\", \"b\", \"B\"],\r\n\t\tempty: \"B\",\r\n\t\tstates: [\"q1\", \"q2\"],\r\n\t\tinitialState: \"q1\",\r\n\t\ttransitions: [\r\n\t\t\t[\"q1\", \"B\", \"q2\", \"B\", \"L\"],\r\n\t\t\t[\"q1\", \"a\", \"q1\", \"b\", \"R\"],\r\n\t\t\t[\"q1\", \"b\", \"q1\", \"a\", \"R\"],\r\n\t\t\t[\"q2\", \"a\", \"q2\", \"a\", \"L\"],\r\n\t\t\t[\"q2\", \"b\", \"q2\", \"b\", \"L\"]\r\n\t\t],\r\n\t\tacceptStates: [],\r\n\t\tcriteria: \"false\",\r\n\t\tmarkers: []\r\n\t\t} |}\r\n\r\n\t\r\n\tlet tm_astar2 = {| {\r\n\t\tkind: \"turing machine\",\r\n\t\tdescription: \"this is an example\",\r\n\t\tname: \"tm_astar2\",\r\n\t\tentryAlphabet: [\"a\", \"b\"],\r\n\t\ttapeAlphabet: [\"a\", \"b\", \"X\", \"Y\",\"B\"],\r\n\t\tempty: \"B\",\r\n\t\tstates: [\"q1\", \"q2\", \"q3\", \"q4\", \"q5\", \"q6\", \"q7\"],\r\n\t\tinitialState: \"q1\",\r\n\t\ttransitions: [\r\n\t\t\t[\"q1\", \"a\", \"q2\", \"X\", \"R\"],\r\n\t\t\t[\"q1\", \"b\", \"q5\", \"Y\", \"R\"],\r\n\t\t\t[\"q1\", \"B\", \"q7\", \"B\", \"L\"],\r\n\r\n\t\t\t[\"q2\", \"a\", \"q2\", \"a\", \"R\"],\r\n\t\t\t[\"q2\", \"b\", \"q2\", \"b\", \"R\"],\r\n\t\t\t[\"q2\", \"B\", \"q3\", \"B\", \"R\"],\r\n\r\n\t\t\t[\"q3\", \"a\", \"q3\", \"a\", \"R\"],\r\n\t\t\t[\"q3\", \"b\", \"q3\", \"b\", \"R\"],\r\n\t\t\t[\"q3\", \"B\", \"q4\", \"a\", \"L\"],\r\n\r\n\t\t\t[\"q4\", \"a\", \"q4\", \"a\", \"L\"],\r\n\t\t\t[\"q4\", \"b\", \"q4\", \"b\", \"L\"],\r\n\t\t\t[\"q4\", \"B\", \"q4\", \"B\", \"L\"],\r\n\t\t\t[\"q4\", \"X\", \"q1\", \"X\", \"R\"],\r\n\t\t\t[\"q4\", \"Y\", \"q1\", \"Y\", \"R\"],\r\n\r\n\t\t\t[\"q5\", \"a\", \"q5\", \"a\", \"R\"],\r\n\t\t\t[\"q5\", \"b\", \"q5\", \"b\", \"R\"],\r\n\t\t\t[\"q5\", \"B\", \"q6\", \"B\", \"R\"],\r\n\r\n\t\t\t[\"q6\", \"a\", \"q6\", \"a\", \"R\"],\r\n\t\t\t[\"q6\", \"b\", \"q6\", \"b\", \"R\"],\r\n\t\t\t[\"q6\", \"B\", \"q4\", \"b\", \"L\"],\r\n\r\n\t\t\t[\"q7\", \"X\", \"q7\", \"a\", \"L\"],\r\n\t\t\t[\"q7\", \"Y\", \"q7\", \"b\", \"L\"]\r\n\t\t],\r\n\t\tacceptStates: [],\r\n\t\tcriteria: \"false\",\r\n\t\tlbMarkers: []\r\n\t\t} |}\r\n\r\n\tlet tm_astar3 = {| {\r\n\t\t\tkind: \"turing machine\",\r\n\t\t\tdescription: \"this is an example changed\",\r\n\t\t\tname: \"tm_astar3\",\r\n\t\t\tentryAlphabet: [\"a\", \"b\"],\r\n\t\t\ttapeAlphabet: [\"a\", \"b\", \"B\"],\r\n\t\t\tempty: \"B\",\r\n\t\t\tstates: [\"q1\", \"q2\", \"q3\"],\r\n\t\t\tinitialState: \"q1\",\r\n\t\t\ttransitions: [\r\n\t\t\t\t[\"q1\", \"a\", \"q2\", \"a\", \"R\"],\r\n\t\t\t\t[\"q1\", \"b\", \"q1\", \"b\", \"R\"],\r\n\t\t\t\t[\"q2\", \"a\", \"q3\", \"a\", \"R\"],\r\n\t\t\t\t[\"q2\", \"b\", \"q1\", \"b\", \"R\"]\r\n\t\t\t],\r\n\t\t\tacceptStates: [\"q3\"],\r\n\t\t\tcriteria: \"true\",\r\n\t\t\tlbMarkers: []\r\n\t\t\t} |}\r\n\r\n\tlet tm_astar4 = {| {\r\n\t\t\tkind: \"turing machine\",\r\n\t\t\tdescription: \"this is an example\",\r\n\t\t\tname: \"tm_astar4\",\r\n\t\t\tentryAlphabet: [\"a\", \"b\", \"c\"],\r\n\t\t\ttapeAlphabet: [\"a\", \"b\", \"c\", \"X\", \"Y\", \"Z\", \"B\"],\r\n\t\t\tempty: \"B\",\r\n\t\t\tstates: [\"q1\", \"q2\", \"q3\", \"q4\", \"q5\", \"q6\"],\r\n\t\t\tinitialState: \"q1\",\r\n\t\t\ttransitions: [\r\n\t\t\t\t[\"q1\", \"B\", \"q6\", \"B\", \"R\"],\r\n\t\t\t\t[\"q1\", \"Y\", \"q5\", \"Y\", \"R\"],\r\n\t\t\t\t[\"q1\", \"a\", \"q2\", \"X\", \"R\"],\r\n\r\n\t\t\t\t[\"q2\", \"a\", \"q2\", \"a\", \"R\"],\r\n\t\t\t\t[\"q2\", \"Y\", \"q2\", \"Y\", \"R\"],\r\n\t\t\t\t[\"q2\", \"b\", \"q3\", \"Y\", \"R\"],\r\n\r\n\t\t\t\t[\"q3\", \"b\", \"q3\", \"b\", \"R\"],\r\n\t\t\t\t[\"q3\", \"Z\", \"q3\", \"Z\", \"R\"],\r\n\t\t\t\t[\"q3\", \"c\", \"q4\", \"Z\", \"L\"],\r\n\r\n\t\t\t\t[\"q4\", \"Z\", \"q4\", \"Z\", \"L\"],\r\n\t\t\t\t[\"q4\", \"Y\", \"q4\", \"Y\", \"L\"],\r\n\t\t\t\t[\"q4\", \"b\", \"q4\", \"b\", \"L\"],\r\n\t\t\t\t[\"q4\", \"a\", \"q4\", \"a\", \"L\"],\r\n\r\n\t\t\t\t[\"q5\", \"Y\", \"q5\", \"Y\", \"R\"],\r\n\t\t\t\t[\"q5\", \"Z\", \"q5\", \"Z\", \"R\"],\r\n\t\t\t\t[\"q5\", \"B\", \"q6\", \"B\", \"R\"]\r\n\t\t\t],\r\n\t\t\tacceptStates: [\"q6\"],\r\n\t\t\tcriteria: \"true\",\r\n\t\t\tlbMarkers: []\r\n\t\t\t} |}\r\n\r\n\tlet tm_astar5 = {| {\r\n\t\t\tkind: \"turing machine\",\r\n\t\t\tdescription: \"this is an example\",\r\n\t\t\tname: \"tm_astar5\",\r\n\t\t\tentryAlphabet: [\"a\", \"b\"],\r\n\t\t\ttapeAlphabet: [\"a\", \"b\", \"B\"],\r\n\t\t\tempty: \"B\",\r\n\t\t\tstates: [\"q1\", \"q2\", \"q3\", \"q4\"],\r\n\t\t\tinitialState: \"q1\",\r\n\t\t\ttransitions: [\r\n\t\t\t\t[\"q1\", \"a\", \"q2\", \"a\", \"R\"],\r\n\t\t\t\t[\"q1\", \"b\", \"q1\", \"b\", \"R\"],\r\n\t\t\t\t[\"q1\", \"B\", \"q4\", \"B\", \"R\"],\r\n\r\n\t\t\t\t[\"q2\", \"a\", \"q3\", \"a\", \"R\"],\r\n\t\t\t\t[\"q2\", \"b\", \"q1\", \"b\", \"R\"],\r\n\t\t\t\t[\"q2\", \"B\", \"q4\", \"B\", \"R\"],\r\n\r\n\t\t\t\t[\"q4\", \"a\", \"q4\", \"a\", \"R\"],\r\n\t\t\t\t[\"q4\", \"b\", \"q4\", \"b\", \"R\"],\r\n\t\t\t\t[\"q4\", \"B\", \"q4\", \"B\", \"R\"]\r\n\t\t\t],\r\n\t\t\tacceptStates: [],\r\n\t\t\tcriteria: \"false\",\r\n\t\t\tlbMarkers: []\r\n\t\t\t} |}\r\n\r\n\tlet tm_astar6 = {| {\r\n\t\t\tkind: \"turing machine\",\r\n\t\t\tdescription: \"this is an example\",\r\n\t\t\tname: \"tm_astar6\",\r\n\t\t\tentryAlphabet: [\"a\", \"b\", \"c\"],\r\n\t\t\ttapeAlphabet: [\"a\", \"b\", \"c\", \"B\"],\r\n\t\t\tempty: \"B\",\r\n\t\t\tstates: [\"q1\", \"q2\", \"q3\", \"q4\", \"q5\", \"q6\", \"q7\"],\r\n\t\t\tinitialState: \"q1\",\r\n\t\t\ttransitions: [\r\n\t\t\t\t[\"q1\", \"a\", \"q1\", \"a\", \"R\"],\r\n\t\t\t\t[\"q1\", \"b\", \"q1\", \"b\", \"R\"],\r\n\t\t\t\t[\"q1\", \"c\", \"q1\", \"c\", \"R\"],\r\n\r\n\t\t\t\t[\"q1\", \"c\", \"q2\", \"c\", \"R\"],\r\n\t\t\t\t[\"q1\", \"c\", \"q5\", \"c\", \"L\"],\r\n\r\n\t\t\t\t[\"q2\", \"a\", \"q3\", \"a\", \"R\"],\r\n\r\n\t\t\t\t[\"q3\", \"b\", \"q4\", \"b\", \"R\"],\r\n\r\n\t\t\t\t[\"q5\", \"b\", \"q6\", \"b\", \"L\"],\r\n\r\n\t\t\t\t[\"q6\", \"a\", \"q7\", \"a\", \"L\"]\r\n\t\t\t],\r\n\t\t\tacceptStates: [\"q4\", \"q7\"],\r\n\t\t\tcriteria: \"true\",\r\n\t\t\tlbMarkers: []\r\n\t\t\t} |}\r\n\r\n\tlet tm_astar7 = {| {\r\n\t\t\tkind: \"turing machine\",\r\n\t\t\tdescription: \"this is an example\",\r\n\t\t\tname: \"tm_astar7\",\r\n\t\t\tentryAlphabet: [\"a\", \"b\", \"c\", \"d\", \"e\"],\r\n\t\t\ttapeAlphabet: [\"a\", \"b\", \"c\", \"d\", \"e\", \"B\"],\r\n\t\t\tempty: \"B\",\r\n\t\t\tstates: [\"q1\", \"q2\", \"q3\"],\r\n\t\t\tinitialState: \"q1\",\r\n\t\t\ttransitions: [\r\n\t\t\t\t[\"q1\", \"a\", \"q2\", \"a\", \"R\"],\r\n\r\n\t\t\t\t[\"q1\", \"a\", \"q1\", \"a\", \"R\"],\r\n\t\t\t\t[\"q1\", \"b\", \"q1\", \"b\", \"R\"],\r\n\t\t\t\t[\"q1\", \"c\", \"q1\", \"c\", \"R\"],\r\n\t\t\t\t[\"q1\", \"d\", \"q1\", \"d\", \"R\"],\r\n\t\t\t\t[\"q1\", \"e\", \"q1\", \"e\", \"R\"],\r\n\r\n\t\t\t\t[\"q2\", \"c\", \"q3\", \"c\", \"R\"]\r\n\t\t\t],\r\n\t\t\tacceptStates: [\"q3\"],\r\n\t\t\tcriteria: \"true\",\r\n\t\t\tlbMarkers: []\r\n\t\t\t} |}\r\n\r\n\tlet tm_astar8 = {| {\r\n\t\t\tkind: \"turing machine\",\r\n\t\t\tdescription: \"this is an example\",\r\n\t\t\tname: \"tm_astar8\",\r\n\t\t\tentryAlphabet: [\"a\"],\r\n\t\t\ttapeAlphabet: [\"a\", \"B\"],\r\n\t\t\tempty: \"B\",\r\n\t\t\tstates: [\"q1\", \"q2\", \"q3\"],\r\n\t\t\tinitialState: \"q1\",\r\n\t\t\ttransitions: [\r\n\t\t\t\t[\"q1\", \"B\", \"q2\", \"B\", \"R\"],\r\n\t\t\t\t[\"q2\", \"B\", \"q1\", \"B\", \"L\"],\r\n\r\n\t\t\t\t[\"q2\", \"a\", \"q3\", \"a\", \"R\"]\r\n\t\t\t],\r\n\t\t\tacceptStates: [\"q3\"],\r\n\t\t\tcriteria: \"true\",\r\n\t\t\tlbMarkers: []\r\n\t\t\t} |}\r\n\r\n\tlet tm_astar9 = {| {\r\n\t\t\tkind: \"turing machine\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname: \"tm_astar9\",\r\n\t\t\tentryAlphabet: [\"a\", \"b\", \"c\"],\r\n\t\t\ttapeAlphabet: [\"a\", \"b\", \"c\", \"X\", \"Y\", \"Z\", \"B\"],\r\n\t\t\tempty: \"B\",\r\n\t\t\tstates: [\"q1\", \"q2\", \"q3\", \"q4\", \"q5\", \"q6\", \"q7\", \"q8\", \"q9\"],\r\n\t\t\tinitialState: \"q1\",\r\n\t\t\ttransitions: [\r\n\r\n\t\t\t\t[\"q1\", \"B\", \"q6\", \"B\", \"R\"],\r\n\t\t\t\t[\"q1\", \"Y\", \"q5\", \"Y\", \"R\"],\r\n\t\t\t\t[\"q1\", \"a\", \"q2\", \"X\", \"R\"],\r\n\r\n\t\t\t\t[\"q2\", \"a\", \"q2\", \"a\", \"R\"],\r\n\t\t\t\t[\"q2\", \"Y\", \"q2\", \"Y\", \"R\"],\r\n\t\t\t\t[\"q2\", \"b\", \"q3\", \"Y\", \"R\"],\r\n\r\n\t\t\t\t[\"q3\", \"b\", \"q3\", \"b\", \"R\"],\r\n\t\t\t\t[\"q3\", \"Z\", \"q3\", \"Z\", \"R\"],\r\n\t\t\t\t[\"q3\", \"c\", \"q4\", \"Z\", \"L\"],\r\n\r\n\t\t\t\t[\"q4\", \"Z\", \"q4\", \"Z\", \"L\"],\r\n\t\t\t\t[\"q4\", \"Y\", \"q4\", \"Y\", \"L\"],\r\n\t\t\t\t[\"q4\", \"b\", \"q4\", \"b\", \"L\"],\r\n\t\t\t\t[\"q4\", \"a\", \"q4\", \"a\", \"L\"],\r\n\t\t\t\t\r\n\t\t\t\t[\"q4\", \"X\", \"q1\", \"X\", \"R\"],\r\n\r\n\t\t\t\t[\"q5\", \"Y\", \"q5\", \"Y\", \"R\"],\r\n\t\t\t\t[\"q5\", \"Z\", \"q5\", \"Z\", \"R\"],\r\n\t\t\t\t[\"q5\", \"B\", \"q6\", \"B\", \"R\"],\r\n\r\n\t\t\t\t[\"q5\", \"b\", \"q9\", \"c\", \"R\"],\r\n\r\n\t\t\t\t[\"q7\", \"b\", \"q8\", \"c\", \"R\"],\r\n\t\t\t\t[\"q7\", \"B\", \"q6\", \"B\", \"R\"]\r\n\r\n\t\t\t],\r\n\t\t\tacceptStates: [\"q6\"],\r\n\t\t\tcriteria: \"true\",\r\n\t\t\tlbMarkers: []\r\n\t\t} |}\r\n\r\n\tlet tm_astar10 = {| {\r\n\t\tkind: \"turing machine\",\r\n\t\tdescription: \"this is an example\",\r\n\t\tname: \"tm_astar10\",\r\n\t\tentryAlphabet: [\"a\", \"b\", \"c\"],\r\n\t\ttapeAlphabet: [\"a\", \"b\", \"c\", \"B\"],\r\n\t\tempty: \"B\",\r\n\t\tstates: [\"q1\"],\r\n\t\tinitialState: \"q1\",\r\n\t\ttransitions: [\r\n\t\t\t[\"q1\", \"B\", \"q1\", \"c\", \"R\"],\r\n\t\t\t[\"q1\", \"a\", \"q1\", \"a\", \"R\"],\r\n\t\t\t[\"q1\", \"b\", \"q1\", \"b\", \"R\"],\r\n\t\t\t[\"q1\", \"c\", \"q1\", \"c\", \"R\"]\r\n\t\t],\r\n\t\tacceptStates: [],\r\n\t\tcriteria: \"false\",\r\n\t\tlbMarkers: []\r\n\t\t} |}\r\n\r\n\tlet tm_astar11 = {| {\r\n\t\tkind : \"turing machine\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"tm_astar11\",\r\n\t\tentryAlphabet: [\"a\", \"b\", \"c\"],\r\n\t\ttapeAlphabet: [\"a\", \"b\", \"c\", \"B\"],\r\n\t\tempty: \"B\",\r\n\t\tstates : [\"q1\", \"q2\", \"q3\"],\r\n\t\tinitialState : \"q1\",\r\n\t\ttransitions : [\r\n\t\t\t[\"q1\", \"a\", \"q2\", \"c\", \"R\"],\r\n\t\t\t[\"q1\", \"b\", \"q1\", \"b\", \"R\"],\r\n\t\t\t[\"q1\", \"c\", \"q1\", \"a\", \"R\"],\r\n\t\t\t[\"q2\", \"b\", \"q1\", \"b\", \"L\"],\r\n\t\t\t[\"q2\", \"c\", \"q3\", \"c\", \"R\"]\r\n\t\t],\r\n\t\tacceptStates : [],\r\n\t\tcriteria : \"false\",\r\n\t\tlbMarkers: []\r\n\t\t} |}\r\n\r\n\r\n(* Composition *)\r\n\tlet comp_abc = {| {\r\n\t\t\tkind : \"composition\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"comp_abc\",\r\n\t\t\tcomp : \"[tm_astar11]^[tm_astar11]\"\r\n\t} |}\r\n\r\n\r\n(* Exercises *)\r\n\tlet exer_balanced_cfg = {| {\r\n\t\t\tkind : \"exercise\",\r\n\t\t\tdescription : \"CFG: Create a CONTEXT FREE GRAMMAR that generates the language of balanced square bracket parentheses\",\r\n\t\t\tname : \"exer_balanced_cfg\",\r\n\t\t\tproblem : \"CFG for the language of balanced parentheses\",\r\n\t\t\tinside : [\"\",\"[]\",\"[[]]\",\"[][]\",\"[[][][][[]]][]\"],\r\n\t\t\toutside : [\"[\",\"][\",\"[[]\",\"[[]]]\"],\r\n\t\t\tproperties : [\"context free grammar\"]\r\n\t\t} |}\r\n\r\n(* PEDRO CARLOS *)\r\n\tlet exer_anbncn_csg = {| {\r\n\t\t\tkind : \"exercise\",\r\n\t\t\tdescription : \"CSG: Create a CONTEXT SENSITIVE GRAMMAR that generates words of the form a^n b^n c^n (n >= 1).\",\r\n\t\t\tname : \"exer_anbncn_csg\",\r\n\t\t\tproblem : \"Construct a Context-Sensitive Grammar for L = {a^n b^n c^n | n >= 1}. The grammar should ensure that the number of a's, b's, and c's are equal and appear in order.\",\r\n\t\t\tinside : [\"abc\", \"aabbcc\", \"aaabbbccc\"],\r\n\t\t\toutside : [\"\", \"a\", \"ab\", \"aabbc\", \"abcc\", \"acb\", \"aabbcb\"],\r\n\t\t\tproperties : [\"context sensitive grammar strict\"]\r\n\t\t} |}\r\n\r\n\tlet exer_monotonic_simple = {| {\r\n\t\t\tkind : \"exercise\",\r\n\t\t\tdescription : \"Monotonic: Create a MONOTONIC GRAMMAR where rule bodies are not shorter than heads.\",\r\n\t\t\tname : \"exer_monotonic_simple\",\r\n\t\t\tproblem : \"Construct a Monotonic Grammar. A common example could be one that generates strings with at least as many 'b's as 'a's. Ensure all rules are length-increasing or length-preserving (except S -> epsilon if S is not in RHS of any rule, though for simplicity, avoid epsilon rules here).\",\r\n\t\t\tinside : [\"ab\", \"aabb\", \"aaabbb\"],\r\n\t\t\toutside : [\"a\", \"ba\", \"aab\", \"b\", \"bb\"],\r\n\t\t\tproperties : [\"monotonic grammar\"]\r\n\t\t} |}\r\n\r\n\tlet exer_monotonic_strict_simple = {| {\r\n\t\t\tkind : \"exercise\",\r\n\t\t\tdescription : \"Monotonic Strict: Create a MONOTONIC STRICT GRAMMAR where rule bodies are strictly equal in length or longer than heads.\",\r\n\t\t\tname : \"exer_monotonic_strict_simple\",\r\n\t\t\tproblem : \"Construct a Monotonic Strict Grammar. Ensure all rules strictly maintain or increase length.\",\r\n\t\t\tinside : [\"ab\", \"aabb\", \"aaabbb\"],\r\n\t\t\toutside : [\"a\", \"ba\", \"aab\", \"b\", \"bb\"],\r\n\t\t\tproperties : [\"monotonic grammar strict\"]\r\n\t\t} |}\r\n\r\n\tlet exer_noncontracting_anbn = {| {\r\n\t\t\tkind : \"exercise\",\r\n\t\t\tdescription : \"Noncontracting: Create a NONCONTRACTING GRAMMAR for a^n b^n (n >= 0).\",\r\n\t\t\tname : \"exer_noncontracting_anbn\",\r\n\t\t\tproblem : \"Construct a Noncontracting Grammar for L = {a^n b^n | n >= 0}. This is similar to monotonic, allowing S -> epsilon if S is not on RHS of any rule.\",\r\n\t\t\tinside : [\"\", \"ab\", \"aabb\", \"aaabbb\"],\r\n\t\t\toutside : [\"a\", \"b\", \"aba\", \"baab\"],\r\n\t\t\tproperties : [\"noncontracting grammar\"]\r\n\t\t} |}\r\n\r\n\tlet exer_linear_palindromes = {| {\r\n\t\t\tkind : \"exercise\",\r\n\t\t\tdescription : \"Linear: Create a LINEAR GRAMMAR for simple palindromes over {0,1} of odd length.\",\r\n\t\t\tname : \"exer_linear_palindromes\",\r\n\t\t\tproblem : \"Construct a Linear Grammar for palindromes of odd length over {0,1}.\",\r\n\t\t\tinside : [\"c\", \"0c0\", \"1c1\", \"01c10\", \"10c01\"],\r\n\t\t\toutside : [\"\", \"00\", \"11\", \"0c1\", \"1c0\", \"01c01\"],\r\n\t\t\tproperties : [\"linear grammar\"]\r\n\t\t} |}\r\n\r\n\tlet exer_right_linear_abstar = {| {\r\n\t\t\tkind : \"exercise\",\r\n\t\t\tdescription : \"Right Linear: Create a RIGHT LINEAR GRAMMAR for a*b*.\",\r\n\t\t\tname : \"exer_right_linear_abstar\",\r\n\t\t\tproblem : \"Construct a Right Linear Grammar for the language a*b*. Rules should be of the form A -> wB or A -> w.\",\r\n\t\t\tinside : [\"\", \"a\", \"b\", \"aa\", \"bb\", \"ab\", \"aabb\"],\r\n\t\t\toutside : [\"ba\", \"aba\", \"bab\"],\r\n\t\t\tproperties : [\"right linear grammar\", \"context free grammar\"]\r\n\t\t} |}\r\n\r\n\tlet exer_left_linear_astarbc = {| {\r\n\t\t\tkind : \"exercise\",\r\n\t\t\tdescription : \"Left Linear: Create a LEFT LINEAR GRAMMAR for a*bc.\",\r\n\t\t\tname : \"exer_left_linear_astarbc\",\r\n\t\t\tproblem : \"Construct a Left Linear Grammar for the language a*bc. Rules should be of the form A -> Bw or A -> w.\",\r\n\t\t\tinside : [\"bc\", \"abc\", \"aabc\", \"aaabc\"],\r\n\t\t\toutside : [\"\", \"a\", \"b\", \"c\", \"ac\", \"ab\", \"bac\", \"bca\"],\r\n\t\t\tproperties : [\"left linear grammar\", \"context free grammar\"]\r\n\t\t} |}\r\n\r\n\t\tlet csg = {| {\r\n\t\t\tkind: \"grammar\",\r\n\t\t\tdescription: \"a^nb^nc^n\",\r\n\t\t\tname: \"custom_csg\",\r\n\t\t\talphabet: [\"a\", \"b\", \"c\"],\r\n\t\t\tvariables: [\"S\", \"B\", \"C\", \"Z\", \"W\"],\r\n\t\t\tinitial: \"S\",\r\n\t\t\trules: [\r\n\t\t\t\"S -> aBC\",\r\n\t\t\t\"S -> aSBC\",\r\n\t\t\t\"CB -> CZ\",\r\n\t\t\t\"CZ -> WZ\",\r\n\t\t\t\"WZ -> WC\",\r\n\t\t\t\"WC -> BC\",\r\n\t\t\t\"aB -> ab\",\r\n\t\t\t\"bB -> bb\",\r\n\t\t\t\"bC -> bc\",\r\n\t\t\t\"cC -> cc\"]\r\n\t\t} |}\r\n\r\n\t\tlet non_contracting = {| {\r\n\tkind: \"grammar\",\r\n\tdescription: \"a^nb^nc^n\",\r\n\tname: \"custom_non_contracting\",\r\n\talphabet: [\"a\", \"b\", \"c\"],\r\n\tvariables: [\"S\", \"B\"],\r\n\tinitial: \"S\",\r\n\trules: [\r\n\t\"S -> abc\",\r\n\t\"S -> aSBc\",\r\n\t\"cB -> Bc\",\r\n\t\"bB -> bb\"]\r\n} |}\r\n(* PEDRO CARLOS *)\r\n\r\n\tlet exer_astar_fa = {| {\r\n\t\t\tkind : \"exercise\",\r\n\t\t\tdescription : \"FA: all sequences of 'a's\",\r\n\t\t\tname : \"exer_astar_fa\",\r\n\t\t\tproblem : \"Create a deterministic FINITE AUTOMATON that recognizes all sequences of 'a's\",\r\n\t\t\tinside : [\"\",\"a\",\"aa\",\"aaa\",\"aaaaaaa\"],\r\n\t\t\toutside : [\"d\",\"b\",\"ava\"],\r\n\t\t\tproperties : [\"finite automaton\", \"deterministic\"]\r\n\t\t} |}\r\n\r\n\tlet exer_astar_re = {| {\r\n\t\t\tkind : \"exercise\",\r\n\t\t\tdescription : \"RE: all sequences of 'a's\",\r\n\t\t\tname : \"exer_astar_re\",\r\n\t\t\tproblem : \"Create a REGULAR EXPRESSION that generates all sequences of 'a's\",\r\n\t\t\tinside : [\"\",\"a\",\"aa\",\"aaa\",\"aaaaaaa\"],\r\n\t\t\toutside : [\"d\",\"b\",\"ava\"],\r\n\t\t\tproperties : [\"regular expression\"]\r\n\t\t} |}\r\n\r\n\tlet exer_abcd = {| {\r\n\t\t\tkind : \"exercise\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"exer_abcd\",\r\n\t\t\tproblem : \"Convert the regular expression (a+b)*(c+d) to finite automaton.\",\r\n\t\t\tinside : [\"abc\",\"c\",\"abd\",\"d\",\"abac\"],\r\n\t\t\toutside : [\"\",\"aba\",\"bab\",\"abba\",\"baab\",\"abcd\"],\r\n\t\t\tproperties : [\"finite automaton\"]\r\n\t\t} |}\r\n\r\n\tlet exer_ab = {| {\r\n\t\t\tkind : \"exercise\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"exer_ab\",\r\n\t\t\tproblem : \"Convert the regular expression ab*+ba* to finite automaton.\",\r\n\t\t\tinside : [\"a\",\"ab\",\"abb\",\"abbbbbbbb\",\"b\",\"ba\",\"baa\",\"baaaaaa\"],\r\n\t\t\toutside : [\"\",\"aba\",\"bab\",\"abba\",\"baab\",\"c\"],\r\n\t\t\tproperties : [\"finite automaton\"]\r\n\t\t} |}\r\n\r\n\tlet exer_re2fa = {| {\r\n\t\t\tkind : \"exercise\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"exer_re2fa\",\r\n\t\t\tproblem : \"Converta o autómato finito com alfabeto: [x, y, z], estados: [S, T, V], estado inicial: S, transições [[S, x, S], [S, y, T], [S, z, V], [T, x, T], [T, z, T], [T, y, V], [V, x, T]], e estados finais: [V] em expressão regular.\",\r\n\t\t\tinside : [\"z\", \"xz\", \"yy\", \"yzy\", \"xyy\", \"zxxy\"],\r\n\t\t\toutside : [\"x\",\"y\",\"xy\", \"xyz\", \"yyx\", \"xzxz\", \"xyxz\"],\r\n\t\t\tproperties : [\"regular expression\"]\r\n\t\t} |}\r\n\r\n\tlet exer_readwrite = {| {\r\n\t\t\tkind : \"exercise\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"exer_readwrite\",\r\n\t\t\tproblem : \"open,close,read,write\",\r\n\t\t\tinside : [\"\",\"orc\",\"owc\",\"orwc\",\"owwrwrrc\",\"ocorwc\"],\r\n\t\t\toutside : [\"or\",\"oo\",\"o\",\"w\",\"r\",\"c\",\"orw\",\"owrrww\",\"corwc\"],\r\n\t\t\tproperties : [\"finite automaton\"]\r\n\t\t} |}\r\n\r\n  let examplesTable = [\r\n  (\"Finite Automata\",\r\n  [\r\n    (\"dfa_1\", dfa_1);\r\n    (\"dfa_2\", dfa_2);\r\n    (\"dfa_astar\", dfa_astar);\r\n    (\"fa_abc\", fa_abc);\r\n    (\"nfa_1\", nfa_1);\r\n    (\"nfa_2\", nfa_2)\r\n  ]);\r\n\r\n  (\"Regular Expressions\",\r\n  [\r\n    (\"re_abc\", re_abc);\r\n    (\"re_complex\", re_complex);\r\n    (\"re_convoluted\", re_convoluted);\r\n    (\"re_simple\", re_simple);\r\n    (\"re_astar\", re_astar)\r\n  ]);\r\n\r\n  (\"Context Free Grammars\",\r\n  [\r\n    (\"cfg_simple\", cfg_simple);\r\n    (\"cfg_balanced\", cfg_balanced);\r\n    (\"ll_thesis_g1\", cfg_ll_thesis_g1);\r\n    (\"ll_thesis_g2\", cfg_ll_thesis_g2);\r\n    (\"ll_1\", cfg_ll_1);\r\n    (\"ll_2\", cfg_ll_2);\r\n    (\"ll_3\", cfg_ll_3);\r\n    (\"ll_4\", cfg_ll_4);\r\n    (\"ll_5\", cfg_ll_5);\r\n    (\"ll_6\", cfg_ll_6);\r\n    (\"lr0_thesis\", cfg_lr0_thesis);\r\n    (\"slr1_thesis\", cfg_slr1_thesis);\r\n    (\"slr1\", cfg_slr1);\r\n    (\"lr1_thesis\", cfg_lr1_thesis);\r\n    (\"lalr1_thesis\", cfg_lalr1_thesis);\r\n    (\"only_lr1\", cfg_onlylr1);\r\n    (\"not_lr1\", cfg_notlr1);\r\n    (\"ug_simple\", ug_simple)\r\n  ]);\r\n\r\n  (\"Pushdown Automata\",\r\n  [\r\n    (\"pda_WW_1\", pda_WW_1);\r\n    (\"pda_AABB\", pda_AABB);\r\n    (\"pda_Explode\", pda_Explode)\r\n  ]);\r\n\r\n  (\"Turing Machine\",\r\n  [\r\n    (\"tm_astar1\", tm_astar1);\r\n    (\"tm_astar2\", tm_astar2);\r\n    (\"tm_astar3\", tm_astar3);\r\n    (\"tm_astar4\", tm_astar4);\r\n    (\"tm_astar5\", tm_astar5);\r\n    (\"tm_astar6\", tm_astar6);\r\n    (\"tm_astar7\", tm_astar7);\r\n    (\"tm_astar8\", tm_astar8);\r\n    (\"tm_astar9\", tm_astar9);\r\n    (\"tm_astar10\", tm_astar10);\r\n    (\"tm_astar11\", tm_astar11)\r\n  ]);\r\n\r\n  (\"Composition\",\r\n  [\r\n    (\"comp_abc\", comp_abc)\r\n  ]);\r\n\r\n  (\"Grammars\",\r\n  [\r\n    (\"a_nb_nc_nGrammar\", csg);\r\n    (\"a_nb_nc_nGrammar2\", non_contracting)\r\n  ]);\r\n\r\n  (\"Exercises\",\r\n  [\r\n    (\"exer_balanced_cfg\", exer_balanced_cfg);\r\n    (\"exer_anbncn_csg\", exer_anbncn_csg);\r\n    (\"exer_monotonic_simple\", exer_monotonic_simple);\r\n    (\"exer_monotonic_strict_simple\", exer_monotonic_strict_simple);\r\n    (\"exer_noncontracting_anbn\", exer_noncontracting_anbn);\r\n    (\"exer_linear_palindromes\", exer_linear_palindromes);\r\n    (\"exer_right_linear_abstar\", exer_right_linear_abstar);\r\n    (\"exer_left_linear_astarbc\", exer_left_linear_astarbc);\r\n    (\"exer_astar_fa\", exer_astar_fa);\r\n    (\"exer_astar_re\", exer_astar_re);\r\n    (\"exer_abcd\", exer_abcd);\r\n    (\"exer_ab\", exer_ab);\r\n    (\"exer_re2fa\", exer_re2fa);\r\n    (\"exer_readwrite\", exer_readwrite)\r\n  ])]\r\n\r\n\tlet examplesAll =\r\n\t\tList.flatten (List.map snd examplesTable)\r\n\r\n\tlet examples =\r\n\t\t\tList.map fst examplesAll\r\n\r\n\tlet example name =\r\n\t\tList.assoc name examplesAll\r\n\r\n\tlet jsonExample name =\r\n\t\tlet j = JSon.parse (example name) in\r\n\t\t\tif JSon.isNull j then\r\n\t\t\t\tError.error \"Invalid example\" name ();\r\n\t\t\tj\r\n\t\t\t\r\n\tlet see name =\r\n\t\tUtil.println [example name]\r\n\r\n\tlet validate () =\r\n\t\tList.iter (fun n -> ignore (jsonExample n)) examples\r\n\r\n\tlet _ =\r\n\t\tif true then\r\n\t\t\tvalidate ()\t\r\nend\r\n# 1 \"src/Entity.ml\"\r\n(*\r\n * Entity.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * set/2022 (amd) - Full restructuration.\r\n * jul/2021 (amd) - Improved error handling.\r\n * may/2021 (amd) - Added support for an extern representation.\r\n * may/2021 (amd) - Centralized the handling of kind/description/name.\r\n * feb/2021 (amd) - Added the alternative Predef.\r\n * jan/2021 (amd) - Module in an independent file.\r\n * jun/2019 (amd) - Initial version, inside the big file \"OCamlFlat.ml\".\r\n *)\r\n\r\n(*\r\n * Description: An entity is a named instance of a concept. As now, the entities\r\n * are the exercises and the FLAT models. The type \"alternatives\" is to allow\r\n * the constructor to be used with several kind of parameter forms.\r\n *)\r\n\r\nmodule Arg =\r\nstruct\t\r\n\ttype 'r alternatives =\r\n\t\t| JSon of JSon.t\r\n\t\t| Text of string\r\n\t\t| File of string\r\n\t\t| Predef of string\r\n\t\t| Representation of 'r\r\n\r\n\tlet fromAlternatives alt =\r\n\t\tmatch alt with\r\n\t\t| JSon j -> j\r\n\t\t| Text str -> JSon.parse str\r\n\t\t| File str -> JSon.fromFile str \r\n\t\t| Predef str -> JSon.parse (Examples.example str)\r\n\t\t| _ -> JSon.JNull\r\nend\r\n\r\nmodule EntityBasics =\r\nstruct\r\n\ttype t = {\r\n\t\tkind : string;\r\n\t\tdescription : string;\r\n\t\tname : string\r\n\t}\r\n\ttype tx =\r\n\t\tt \r\nend\r\n\r\nmodule EntityConversions =\r\nstruct\r\n\topen EntityBasics\r\n\r\n\tlet dummyId (k: string): t = {\r\n\t\tkind = k;\r\n\t\tdescription = \"_\";\r\n\t\tname = \"_\"\r\n\t}\r\n\r\n\tlet fromJSon (j: JSon.t) (kind: string): t =\r\n\t\tif JSon.isNull j then (\r\n\t\t\tdummyId kind )\r\n\t\telse (\r\n\t\t {\r\n\t\t\tkind = JSon.fieldString j \"kind\";\r\n\t\t\tdescription = JSon.fieldString j \"description\";\r\n\t\t\tname = JSon.fieldString j \"name\"\r\n\t\t})\r\n\t\t\r\n\tlet toJSon (rep: t): JSon.t =\r\n\t\tJSon.makeAssoc [\r\n\t\t\t(\"kind\", JSon.makeString rep.kind);\r\n\t\t\t(\"description\", JSon.makeString rep.description);\r\n\t\t\t(\"name\", JSon.makeString rep.name)\r\n\t\t]\r\nend\r\n\r\nmodule EntitySupport =\r\nstruct\r\n\tinclude EntityBasics\r\n\tinclude EntityConversions\r\nend\r\n\r\nmodule EntityPrivate =\r\nstruct\r\n\tinclude EntitySupport\r\n\r\n\tlet startCreation () =\r\n\t\tError.startGroup ()\r\n\t\r\n\tlet createId (arg: 'r Arg.alternatives) (kind: string): t =\r\n\t\tstartCreation ();\r\n\t\tmatch arg with\r\n\t\t| Arg.Representation r -> dummyId kind\r\n\t\t| _ -> fromJSon (Arg.fromAlternatives arg) kind\r\n\r\n\tlet create (arg: 'r Arg.alternatives) fromJSon: 'r =\r\n\t\tmatch arg with\r\n\t\t\t| Arg.Representation r -> r\r\n\t\t\t| _ -> fromJSon (Arg.fromAlternatives arg)\r\n\r\n\tlet endCreation (id: t) rep kind validate: unit =\r\n\t\tif id.kind <> kind then\r\n\t\t\tError.error id.kind \"Wrong kind\" ();\r\n\t\tvalidate id.name rep;\r\n\t\tignore (Error.endGroup kind id.name)\r\nend\r\n\r\nmodule Entity =\r\nstruct\r\n\topen EntityPrivate\r\n\tinclude EntitySupport\r\n\r\n\tlet make2 (arg: 'r Arg.alternatives) (fromJSon: JSon.t -> 'r)\r\n\t\t\t(kind: string) (validate: string -> 'r -> unit): t * 'r =\r\n\t\tlet id = createId arg kind in\r\n\t\tlet m = create arg fromJSon in\r\n\t\t\tendCreation id m kind validate;\r\n\t\t\t(id, m)\r\n\r\n\tclass virtual entity (data: t * 'r) =\r\n\t\tobject(self)\r\n\t\t\tval id: t = fst data\r\n\t\t\tval representation: 'r = snd data\r\n\t\t\tval errors = Error.get ()\r\n\t\t(* Representation *)\r\n\t\t\tmethod id: t = id\r\n\t\t\tmethod errors: string list = errors\r\n\t\t(* Kind *)\r\n\t\t\tmethod isFiniteAutomaton : bool = false\r\n\t\t\tmethod isRegularExpression : bool = false\r\n\t\t\tmethod isGrammar : bool = false\r\n\t\t\tmethod isContextFreeGrammar : bool = false\r\n\t\t\tmethod isPushdownAutomaton : bool = false\r\n\t\t\tmethod isTuringMachine : bool = false\r\n\t\t\tmethod isExercise : bool = false\r\n\t\t\tmethod isComposition : bool = false\r\n\t\t(* Show *)\t\t\t\r\n\t\t\tmethod virtual toJSon: JSon.t\r\n\t\t\tmethod virtual toJSon2: JSon.t\r\n\t\t\tmethod virtual show : unit\r\n\t\t\tmethod virtual show2 : unit\r\n\tend\r\nend\r\n\r\nmodule EntityTests : sig end =\r\nstruct\r\n\tlet active = false\r\n\r\n\tlet test0 () =\r\n\t\t()\r\n\r\n\tlet runAll =\r\n\t\tif Util.testing active \"Entity\" then begin\r\n\t\t\ttest0 ()\r\n\t\tend\r\nend\r\n# 1 \"src/ExerciseSupport.ml\"\r\n(*\r\n * ExerciseSupport.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * oct/2022 (amd) - New module\r\n *)\r\n\r\n(*\r\n * Description: Support to pedagogical exercises. The solutions are validated\r\n * using unit tests.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule ExerciseBasics =\r\nstruct\r\n\ttype tx = {\r\n\t\tproblem : string;\r\n\t\tinside : wordX list;\r\n\t\toutside : wordX list;\r\n\t\tproperties : properties\r\n\t}\r\n\t\r\n\ttype t = {\r\n\t\tproblem : string;\r\n\t\tinside : words;\r\n\t\toutside : words;\r\n\t\tproperties : properties\r\n\t}\r\n\t\r\n\tlet kind = \"exercise\"\r\n\r\n\tlet exer_zero: t = {\r\n\t\tproblem = \"_\";\r\n\t\tinside = Set.empty;\r\n\t\toutside = Set.empty;\r\n\t\tproperties = Set.empty\r\n\t}\r\nend\r\n\r\nmodule ExerciseConversions =\r\nstruct\r\n\topen ExerciseBasics\r\n\r\n\tlet internalize (e: tx): t = {\r\n\t\tproblem = e.problem;\r\n\t\tinside = Set.make (List.map wordX2word e.inside);\r\n\t\toutside = Set.make (List.map wordX2word e.outside);\r\n\t\tproperties = e.properties\r\n\t}\r\n\r\n\tlet externalize (e: t): tx = {\r\n\t\tproblem = e.problem;\r\n\t\tinside = List.map word2wordX (Set.toList e.inside);\r\n\t\toutside = List.map word2wordX (Set.toList e.outside);\r\n\t\tproperties = e.properties\r\n\t}\r\n\r\n\tlet fromJSon (j: JSon.t): t =\r\n\t\tif JSon.isNull j || not (JSon.hasField j \"kind\") then\r\n\t\t\texer_zero\r\n\t\telse {\r\n\t\t\tproblem = JSon.fieldString j \"problem\";\r\n\t\t\tinside = Set.map str2word (JSon.fieldStringSet j \"inside\");\r\n\t\t\toutside = Set.map str2word (JSon.fieldStringSet j \"outside\");\r\n\t\t\tproperties = JSon.fieldStringSet j \"properties\"\r\n\t\t}\r\n\t\r\n\tlet toJSon (rep: t): JSon.t =\r\n\t\tJSon.makeAssoc [\r\n\t\t\t(\"problem\", JSon.makeString rep.problem);\r\n\t\t\t(\"inside\", JSon.makeStringSet (Set.map word2str rep.inside));\r\n\t\t\t(\"outside\", JSon.makeStringSet (Set.map word2str rep.outside));\r\n\t\t\t(\"properties\", JSon.makeStringSet rep.properties)\r\n\t\t]\r\n\t\r\n\tlet toJSon2 (id: Entity.t) (rep: t): JSon.t =\r\n\t\t JSon.append (Entity.toJSon id) (toJSon rep)\r\nend\r\n\r\nmodule ExerciseShow =\r\nstruct\r\n\topen ExerciseBasics\r\n\topen ExerciseConversions\r\n\r\n\tlet show (rep: t): unit =\r\n\t\tlet j = toJSon rep in\r\n\t\t\tJSon.show j\r\n\r\n\tlet show2 (id: Entity.t) (rep: t): unit =\r\n\t\tlet j = toJSon2 id rep in\r\n\t\t\tJSon.show j\r\n\t\r\n\tlet showRes (ins,outs,props): unit =\r\n\t\tUtil.println [\"INS: \"]; Util.printWords ins;\r\n\t\tUtil.println [\"OUTS: \"]; Util.printWords outs;\r\n\t\tUtil.println [\"PROPS: \"]; Util.printStrings props\r\nend\r\n\r\nmodule ExerciseSupport =\r\nstruct\r\n\tinclude ExerciseBasics\r\n\tinclude ExerciseConversions\r\n\tinclude ExerciseShow\r\nend\r\n# 1 \"src/Exercise.ml\"\r\n(*\r\n * Exercise.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * jul/2021 (amd) - Improved error handling.\r\n * mar/2021 (amd) - Added semantic constrains (properties) to the exercises.\r\n * jan/2021 (amd) - Module in an independent file.\r\n * set/2019 (amd) - Initial version, inside the big file \"OCamlFlat.ml\"\r\n *)\r\n\r\n(*\r\n * Description: Support to pedagogical exercises. The solutions are validated\r\n * using unit tests.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule Exercise =\r\nstruct\r\n\tinclude ExerciseSupport\r\n\t\t\r\n\t(* Make *)\r\n\tlet validate (name: string) (rep: t): unit =\r\n\t\t()\r\n\r\n\tlet make2 (arg: t Arg.alternatives): Entity.t * t =\r\n\t\tEntity.make2 arg fromJSon kind validate\r\n\r\n\tlet make (arg: t Arg.alternatives): t =\r\n\t\tsnd (make2 arg)\r\n\r\n\tclass exercise (arg: t Arg.alternatives) =\r\n\t\tobject(self) inherit Entity.entity (make2 arg) as super\r\n\t\t(* Representation *)\r\n\t\t\tmethod representation = representation\r\n\t\t\tmethod representationx = externalize representation\r\n\t\t(* Kind *)\r\n\t\t\tmethod isExercise : bool = true\r\n\t\t(* Show *)\t\t\t\r\n\t\t\tmethod toJSon: JSon.t = toJSon representation\r\n\t\t\tmethod toJSon2: JSon.t = toJSon2 id representation\r\n\t\t\tmethod show: unit = show representation\r\n\t\t\tmethod show2: unit = show2 id representation\r\n\t\t(* Learn-OCaml support *)\t\t\t\t\r\n\t\t\tmethod moduleName =\r\n\t\t\t\t\"Exercice\"\r\n\tend\r\nend\r\n\r\nmodule ExerciseTests : sig end =\r\nstruct\r\n\tlet active = false\r\n\r\n\tlet test0 () =\r\n\t\tlet e = Exercise.make (Arg.Predef \"exer_balanced_cfg\") in\r\n\t\t\tExercise.show e\r\n\r\n\tlet test1 () =\r\n\t\tlet (id, e) = Exercise.make2 (Arg.Predef \"exer_balanced_cfg\") in\r\n\t\t\tExercise.show2 id e\r\n\r\n\tlet test2 () =\r\n\t\tlet e = new Exercise.exercise (Arg.Predef \"exer_balanced_cfg\") in\r\n\t\tlet j = e#toJSon2 in\r\n\t\t\tJSon.show j\r\n\r\n\tlet runAll =\r\n\t\tif Util.testing active \"Exercice\" then begin\r\n\t\t\ttest0 ();\r\n\t\t\ttest1 ();\r\n\t\t\ttest2 ()\r\n\t\tend\r\nend\r\n\r\n\r\n# 1 \"src/Model.ml\"\r\n(*\r\n * Model.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * jun/2023 (amd) - Added generic 'accept' and 'generate' methods.\r\n * set/2022 (amd) - Full restructuration.\r\n * jul/2021 (amd) - Improved Learn-OCaml support.\r\n * mar/2021 (amd) - Added support for semantic constrains (properties) in\r\n *                  the exercises, in this class and in all its subclasses.\r\n * jan/2021 (amd) - Module in an independent file.\r\n * jun/2019 (amd) - Initial version, inside the big file \"OCamlFlat.ml\".\r\n *)\r\n\r\n(*\r\n * Description: Abstract FLAT model.\r\n *\r\n * TODO: Probably add a new method \"canonical\" to generate a\r\n * normalized/simplified version of the FLAT model.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule ModelBasics =\r\nstruct\r\nend\r\n\r\nmodule ModelExercises =\r\nstruct\r\n\tlet checkProperty (prop: string) =\r\n\t\tmatch prop with\r\n\t\t\t| \"fail\" | \"false\" -> false\r\n\t\t\t| \"true\" -> true\r\n\t\t\t| _ ->\r\n\t\t\t\tlet mesg = \"checkProperty: unknown property (\"\r\n\t\t\t\t\t\t\t\t^ prop ^ \")\" in\r\n\t\t\t\t\tError.fatal mesg\r\n\r\n\tlet checkExercise (ex: Exercise.t) accept checkProperty =\r\n\t\t   Set.for_all accept ex.inside\r\n\t\t&& Set.for_all (fun w -> not (accept w)) ex.outside\r\n\t\t&& Set.for_all checkProperty ex.properties\r\n\r\n\tlet checkExerciseFailures (ex: Exercise.t) ac cp = (\r\n\t\tSet.filter (fun w -> not (ac w)) ex.inside,\r\n\t\tSet.filter ac ex.outside,\r\n\t\tSet.filter (fun w -> not (cp w)) ex.properties\r\n\t)\r\nend\r\n\r\nmodule ModelSupport =\r\nstruct\r\n\tinclude ModelBasics\r\n\tinclude ModelExercises\r\nend\r\n\r\nmodule ModelPrivate =\r\nstruct\r\n\tlet stats () =\r\n\t\tRuntimeControl.stats ()\r\n\r\n\tlet checkWord (alphabet: symbols) (w: word): bool =\r\n\t\tlet ok = Set.subset (Set.make w) alphabet in\r\n\t\tlet str = word2str w in\r\n\t\tlet mesg = \"Word \\\"\" ^ str ^ \"\\\" contains symbols not belonging to the alphabet\" in\r\n\t\t\tif not ok then Error.warning mesg;\r\n\t\t\tok\r\n\r\n\t(* The result is true is the word is accepted. *)\r\n\tlet accept (m: 'm) (w: word)\r\n\t\t\t\t(initial: 'm -> word -> 'c set)\r\n\t\t\t\t(next: 'm -> 'c -> 'c set)\r\n\t\t\t\t(isAccepting: 'm -> 'c -> bool): bool =\r\n\t\tlet rec acceptX (configs: 'c set) (seen: 'c set): bool =\r\n\t\t\tlet newConfigs = Set.diff configs seen in\r\n\t\t\tlet newSeen = Set.unionUnsafe newConfigs seen in\r\n\t\t\tlet _ = RuntimeControl.update (Set.size newConfigs) in\r\n\t\t\tif Set.isEmpty newConfigs then\r\n\t\t\t\tfalse\r\n\t\t\telse if Set.exists (isAccepting m) newConfigs then\r\n\t\t\t\ttrue\r\n\t\t\telse if RuntimeControl.giveUp () then\r\n\t\t\t\tfalse\r\n\t\t\telse\r\n\t\t\t\tlet nextConfigs = Set.flatMap (next m) newConfigs in\r\n\t\t\t\t\tacceptX nextConfigs newSeen\r\n\t\tin\t\r\n\t\tlet _ = RuntimeControl.start () in\r\n\t\tlet initialConfigs = initial m w in\r\n\t\t\tacceptX initialConfigs Set.empty\r\n\r\n\t(* The result is a triple: acceptance, one path, trail with all the alternatives.  *)\r\n\tlet acceptFull (m: 'm) (w: word)\r\n\t\t\t\t(initial: 'm -> word -> 'c set)\r\n\t\t\t\t(next: 'm -> 'c -> 'c set)\r\n\t\t\t\t(isAccepting: 'm -> 'c -> bool): bool * 'c path * 'c trail =\r\n\t\tlet base (r: bool) (configs: 'c set): bool * 'c path * 'c trail =\r\n\t\t\tlet accepting = Set.filter (isAccepting m) configs in\r\n\t\t\tlet c = Set.hd (if Set.isEmpty accepting then configs else accepting) in\r\n\t\t\t\t(r, [c], [configs])\r\n\t\tin\r\n\t\tlet rec acceptX (configs: 'c set) (seen: 'c set) : bool * 'c path * 'c trail =\r\n\t\t\tlet newConfigs = Set.diff configs seen in\r\n\t\t\tlet newSeen = Set.unionUnsafe newConfigs seen in\r\n\t\t\tlet _ = RuntimeControl.update (Set.size newConfigs) in\r\n\t\t\tif Set.isEmpty newConfigs then\r\n\t\t\t\t(false, [], [])\r\n\t\t\telse if Set.exists (isAccepting m) newConfigs then\r\n\t\t\t\tbase true newConfigs\r\n\t\t\telse if RuntimeControl.giveUp () then\r\n\t\t\t\tbase false newConfigs\r\n\t\t\telse\r\n\t\t\t\tlet nextConfigs = Set.flatMap (next m) newConfigs in\r\n\t\t\t\tlet (r,p,t) = acceptX nextConfigs newSeen in\r\n\t\t\t\t\tmatch p with\r\n\t\t\t\t\t| [] ->\r\n\t\t\t\t\t\tbase r newConfigs\r\n\t\t\t\t\t| x::_ ->\r\n\t\t\t\t\t\tlet c = Set.find (fun c -> Set.belongs x (next m c)) newConfigs in\r\n\t\t\t\t\t\t\t(r, c::p, newConfigs::t)\r\n\t\tin\r\n\t\tlet _ = RuntimeControl.start () in\r\n\t\tlet initialConfigs = initial m w in\r\n\t\t\tacceptX initialConfigs Set.empty\r\n\t\r\n\t(* invariant - for_all c in seen: c <= len *)\r\n\tlet generate (m: 'm) (len: int)\r\n\t\t\t\t(initial: 'm -> word -> 'c set)\r\n\t\t\t\t(next2: 'm -> int -> 'c -> 'c set)\r\n\t\t\t\t(isAccepting: 'm -> 'c -> bool)\r\n\t\t\t\t(getWord: 'c -> word): words =\r\n\r\n\t\tlet strict = len < 0 in\r\n\t\tlet len = abs len in\r\n\t\tlet lenWord c = List.length (getWord c) in\r\n\t\t\r\n\t\t(* PEDRO CARLOS VER!!! porque?\r\n\t\tlet isNew seen c = lenWord c <= len && not (Set.belongs c seen) in\r\n\t\tlet isExpanding c = lenWord c < len || not (isAccepting m c) in\r\n\t\t\r\n\t\tlenWord c <= len    <= nao funciona com gramaticas irrestritas que nao sejam monotonicas!!!#######<<<<<!!!!BOOM\r\n\t\t*)\r\n\r\n\t\tlet isNew seen c = lenWord c <= len && not (Set.belongs c seen) in\r\n\t\tlet isExpanding c = lenWord c < len || not (isAccepting m c) in\r\n\t\tlet finalSelection =\r\n\t\t\tif strict then (fun c -> isAccepting m c && lenWord c = len) \r\n\t\t\t\t\telse (fun c -> isAccepting m c) \r\n\t\tin\r\n\t\tlet rec generateX (configs: 'c set) (seen: 'c set): 'c set =\r\n\t\t\tlet newConfigs = Set.filter (isNew seen) configs in\r\n\t\t\tlet newSeen = Set.union newConfigs seen in\r\n\t\t\tlet _ = RuntimeControl.update (Set.size newConfigs) in (* ???, e também stack overflow, reutime controlo tem de ter varias instancias *) (* comparar o accept e o generate do joao pinto *)\r\n\t\t\tlet toExpand = Set.filter isExpanding newConfigs in\r\n\t\t\t\tif Set.isEmpty toExpand || RuntimeControl.giveUp () then\r\n\t\t\t\t\tnewSeen\r\n\t\t\t\telse\r\n\t\t\t\t\tlet nextConfigs = Set.flatMap (next2 m len) toExpand in\r\n\t\t\t\t\t\tif RuntimeControl.giveUp () then\r\n\t\t\t\t\t\t\tnewSeen\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tgenerateX nextConfigs newSeen\r\n\t\tin\r\n\t\tlet _ = RuntimeControl.start () in\r\n\t\tlet initialConfigs = initial m (word \"\") in\r\n\t\tlet collected = generateX initialConfigs Set.empty in\r\n\t\tlet selected = Set.filter finalSelection collected in\r\n\t\t\tSet.map getWord selected\r\n\r\n\t(* generate and test. Will be improved.\r\n\t   Used for TMs because the \"rest of the word\" is not part of the configuration *)\r\n\tlet generateDumb (m: 'm) (alphabet : symbols) (len: int)\r\n\t\t\t\t(initial: 'm -> word -> 'c set)\r\n\t\t\t\t(next: 'm -> 'c -> 'c set)\r\n\t\t\t\t(isAccepting: 'm -> 'c -> bool): words =\r\n\t\t\t\t\r\n\t\tlet addAll symb = List.map (fun l -> symb::l) in\r\n\t\tlet rec combinations n l =\r\n\t\t\tif n = 0 then [[]]\r\n\t\t\telse let p = combinations (n-1) l in\r\n\t\t\t\t\tList.flatten (List.map  (fun x -> addAll x p) l)\r\n\t\tin\r\n\t\tlet rec combinations2 n l =\r\n\t\t\tif n = 0 then [[]] else combinations2 (n-1) l @ combinations n l in\r\n\t\tlet strict = len < 0 in\r\n\t\tlet len: int = abs len in\r\n\t\tlet s: word = Set.toList alphabet in\r\n\t\tlet comb: word list = if strict then combinations len s else combinations2 len s in\r\n\t\tlet accept w: bool = accept m w initial next isAccepting in\r\n\t\tlet selected: word list = List.filter accept comb in\r\n\t\t\tSet.make selected\r\n\r\nend\r\n\r\nmodule Model =\r\nstruct\r\n\tinclude ModelSupport\r\n\r\n\tlet stats = ModelPrivate.stats\r\n\tlet checkWord = ModelPrivate.checkWord\r\n\tlet accept = ModelPrivate.accept\r\n\tlet acceptFull = ModelPrivate.acceptFull\r\n\tlet generate = ModelPrivate.generate\t\r\n\tlet generateDumb =  ModelPrivate.generateDumb\r\n\r\n\tclass virtual model (data: Entity.t * 'r) =\r\n\t\tobject(self) inherit Entity.entity data\r\n\r\n\t\t\tmethod virtual accept: word -> bool\r\n\t\t\t(*method virtual acceptFull: 'c. word ->  bool * 'c path * 'c trail*)\r\n\t\t\tmethod virtual generate: int -> words\r\n\t\t\t(*method virtual generateDumb: int -> words*)\r\n\t\t\r\n\t\t(* Exercices support *)\r\n\t\t\tmethod checkProperty (prop: string) = checkProperty prop\r\n\t\t\tmethod checkExercise (exercise: Exercise.exercise) =\r\n\t\t\t\tcheckExercise exercise#representation self#accept self#checkProperty\r\n\t\t\tmethod checkExerciseFailures (exercise: Exercise.exercise) =\r\n\t\t\t\tcheckExerciseFailures exercise#representation self#accept self#checkProperty\r\n\r\n\t\t(* Learn-OCaml support *)\r\n\t\t\tmethod virtual moduleName: string\r\n\t\t\tmethod virtual xTypeName: string\r\n\t\t\tmethod virtual xTypeDeclString : string\r\n\t\t\tmethod virtual toDisplayString: string -> string\r\n\t\t\tmethod virtual example : JSon.t\r\n\tend\r\n\r\nend\r\n\r\n(*\r\n\r\n(* this is only a test *)\r\nclass virtual cModel (arg: 'r Arg.alternatives) (expectedKind: string) =\r\n\tlet open Model in\r\n\tobject(self) inherit Entity.entity arg expectedKind\r\n\r\n\t\tmethod virtual accept: word -> bool\r\n\t\tmethod virtual acceptFull: 'c. word ->  bool * 'c path * 'c trail\r\n\t\tmethod virtual generate: int -> words\r\n\t\tmethod virtual generateDumb: int -> words\r\n\t\t\r\n\t(* Exercices support *)\r\n\t\tmethod checkProperty (prop: string) = checkProperty prop\r\n\t\tmethod checkExercise (exercise: Exercise.exercise) =\r\n\t\t\tcheckExercise exercise#representation self#accept self#checkProperty\r\n\t\tmethod checkExerciseFailures (exercise: Exercise.exercise) =\r\n\t\t\tcheckExerciseFailures exercise#representation self#accept self#checkProperty\r\n\r\n\t(* Learn-OCaml support *)\r\n\t\tmethod virtual moduleName: string\r\n\t\tmethod virtual xTypeName: string\r\n\t\tmethod virtual xTypeDeclString : string\r\n\t\tmethod virtual toDisplayString: string -> string\r\n\t\tmethod virtual example : JSon.t\r\nend\r\n\r\n*)\r\n\r\n(*\r\nSAVE- old versions that might be useful again\r\n\r\n\t(* trail alone *)\r\n\tlet acceptTrail (m: 'm) (w: word)\r\n\t\t\t\t(initial: 'm -> word -> 'c set)\r\n\t\t\t\t(next: 'm -> 'c -> 'c set)\r\n\t\t\t\t(isAccepting: 'm -> 'c -> bool): bool * 'c trail =\r\n\r\n\t\tlet rec acceptX (configs: 'c set) (seen: 'c set) (trail: 'c trail): bool * 'c trail =\r\n\t\t\tlet newConfigs = Set.diff configs seen in\r\n\t\t\tlet newSeen = Set.unionUnsafe newConfigs seen in\r\n\t\t\tlet newTrail = newConfigs::trail in\r\n\t\t\tif Set.isEmpty newConfigs then (false, trail)\r\n\t\t\telse if Set.exists (isAccepting m) newConfigs then (true, newTrail)\r\n\t\t\telse if RuntimeControl.giveUp (Set.size newSeen) then (false, newTrail)\r\n\t\t\telse\r\n\t\t\t\tlet nextConfigs = Set.flatMap (next m) newConfigs in\r\n\t\t\t\t\tacceptX nextConfigs newSeen newTrail\r\n\t\tin\r\n\t\tlet _ = RuntimeControl.start () in\r\n\t\tlet initialConfigs = initial m w in\r\n\t\tlet (b, trail) = acceptX initialConfigs Set.empty [] in\r\n\t\t\t(b, List.rev trail)\r\n\r\n\t(* path calculated from the trail *)\r\n\tlet acceptPath (m: 'm) (w: word)\r\n\t\t\t\t(initial: 'm -> word -> 'c set)\r\n\t\t\t\t(next: 'm -> 'c -> 'c set)\r\n\t\t\t\t(isAccepting: 'm -> 'c -> bool): 'c path =\r\n\r\n\t\tlet rec acceptX (trail: 'c trail): 'c path =\r\n\t\t\tmatch trail with\r\n\t\t\t| [] -> Error.fatal \"acceptX\"\r\n\t\t\t| [c] ->\r\n\t\t\t\tlet a = Set.filter (isAccepting m) c in\r\n\t\t\t\t\t[Set.hd (if Set.isEmpty a then c else a)]\r\n\t\t\t| c::cs ->\r\n\t\t\t\t(match acceptX cs with\r\n\t\t\t\t| [] ->  Error.fatal \"acceptX\"\r\n\t\t\t\t| p::ps ->\r\n\t\t\t\t\tlet n = Set.find (fun c -> Set.belongs p (next m c)) c in\r\n\t\t\t\t\t\tn::p::ps)\r\n\t\tin\r\n\t\tlet (_, trail) = acceptTrail m w initial next isAccepting in\r\n\t\t\tacceptX trail\r\n\r\n\t\t\tlet acceptPaths (m: 'm) (w: word)\r\n\t\t\t\t(initial: 'm -> word -> 'c)\r\n\t\t\t\t(next: 'm -> 'c -> 'c set)\r\n\t\t\t\t(isAccepting: 'm -> 'c -> bool): 'c path set =\r\n\r\n\r\n\t(* all the paths alone *)\r\n\t\tlet rec acceptX (paths: 'c path set) (seen: 'c set): 'c path set =\r\n\t\t\tlet configs = Set.map List.hd paths in\r\n\t\t\tlet newConfigs = Set.diff configs seen in\t\t\t\t(* select the new *)\r\n\t\t\tlet seen = Set.unionUnsafe newConfigs seen in\t\t\t(* build new seen *)\r\n\t\t\tif Set.isEmpty newConfigs then\t\t\t\t\t\t\t(* case repetition *)\r\n\t\t\t\tSet.map List.tl paths\r\n\t\t\telse if Set.exists (isAccepting m) newConfigs then\t\t(* case accept *)\r\n\t\t\t\tSet.filter (fun p -> isAccepting m (List.hd p)) paths\r\n\t\t\telse\r\n\t\t\t\tlet isNewPath p = Set.belongs (List.hd p) newConfigs in\r\n\t\t\t\tlet nextPathsOne p = Set.map (fun c -> c::p) (next m (List.hd p))  in\r\n\t\t\t\tlet newPaths = Set.filter isNewPath paths in\r\n\t\t\t\tlet nextPaths = Set.flatMap nextPathsOne newPaths in\r\n\t\t\t\tif Set.size nextPaths = 0 then paths\t\t\t\t(* case no-followup *)\r\n\t\t\t\telse\tacceptX nextPaths seen\r\n\t\tin\t\r\n\t\tlet initialConfig = initial m w in\r\n\t\tlet paths = acceptX (Set.make [[initialConfig]]) Set.empty in\r\n\t\t\tSet.map List.rev paths\r\n\tlet acceptPath (m: 'm) (w: word)\r\n\t\t\t\t(initial: 'm -> word -> 'c)\r\n\t\t\t\t(next: 'm -> 'c -> 'c set)\r\n\t\t\t\t(isAccepting: 'm -> 'c -> bool): 'c path =\r\n\t\tlet ps = acceptPaths m w initial next isAccepting in\r\n\t\tlet min p1 p2 = if List.length p1 <= List.length p2 then p1 else p2 in\r\n\t\t\tSet.fold_left min (Set.hd ps) (Set.tl ps)\r\n\r\n\t(* trail and all the paths  *)\r\n\tlet acceptFull (m: 'm) (w: word)\r\n\t\t\t\t(initial: 'm -> word -> 'c set)\r\n\t\t\t\t(next: 'm -> 'c -> 'c set)\r\n\t\t\t\t(isAccepting: 'm -> 'c -> bool): bool * 'c path * 'c trail =\r\n\r\n\t\tlet rec acceptX (paths: 'c path set) (trail: 'c trail) (seen: 'c set)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t: bool * 'c path set * 'c trail =\r\n\t\t\tlet configs = Set.map List.hd paths in\r\n\t\t\t\tif Set.exists (isAccepting m) configs then\t\t\t(* case accept *)\r\n\t\t\t\t\t(true, paths, trail)\r\n\t\t\t\telse if RuntimeControl.giveUp (Set.size seen) then\r\n\t\t\t\t\t(false, paths, trail)\r\n\t\t\t\telse\r\n\t\t\t\t\tlet nextConfigsOne p = next m (List.hd p) in\r\n\t\t\t\t\tlet newConfigsOne p = Set.diff (nextConfigsOne p) seen in\r\n\t\t\t\t\tlet newPathsOne p = Set.map (fun c -> c::p) (newConfigsOne p) in\r\n\t\t\t\t\tlet newPaths = Set.flatMap newPathsOne paths in\r\n\t\t\t\t\tlet newConfigs = Set.map List.hd newPaths in\r\n\t\t\t\t\tlet newTrail = newConfigs::trail in\r\n\t\t\t\t\tlet newSeen = Set.unionUnsafe newConfigs seen in\r\n\t\t\t\t\t\tif Set.isEmpty newConfigs then\t\t\t\t(* case reject *)\r\n\t\t\t\t\t\t\t(false, paths, trail)\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tacceptX newPaths newTrail newSeen\r\n\t\tin\r\n\t\tlet _ = RuntimeControl.start () in\r\n\t\tlet initialConfigs = initial m w in\r\n\t\tlet initialPaths = Set.map (fun c -> [c]) initialConfigs in\r\n\t\tlet initialTrail = [initialConfigs] in\r\n\t\tlet initialSeen = initialConfigs in\r\n\t\tlet (r, ps, t) = acceptX initialPaths initialTrail initialSeen in\r\n\t\tlet (r, ps, t) = (r, Set.map List.rev ps, List.rev t) in\r\n\t\tlet fps = Set.filter (fun p -> isAccepting m (List.hd p)) ps in\r\n\t\t\t(r, Set.hd (if Set.isEmpty fps then ps else fps), t)\r\n\r\n\t(* full from trail and path  *)\r\n\tlet acceptFull (m: 'm) (w: word)\r\n\t\t\t\t(initial: 'm -> word -> 'c)\r\n\t\t\t\t(next: 'm -> 'c -> 'c set)\r\n\t\t\t\t(isAccepting: 'm -> 'c -> bool): bool * 'c path * 'c trail =\r\n\t\tlet p = acceptPath m w initial next isAccepting in\r\n\t\tlet (r,t) = acceptTrail m w initial next isAccepting in\r\n\t\t\t(r, p, t)\r\n*)\r\n# 1 \"src/FiniteEnumerationSupport.ml\"\r\n(*\r\n * FiniteEnumerationSupport.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * sep/2022 (amd) - New module\r\n *)\r\n\r\n(*\r\n * Description: Support types and functions for FEs.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule FiniteEnumerationBasics =\r\nstruct\r\n\ttype t = words\r\n\r\n\tlet kind = \"finite enumeration\"\r\n\t\r\n\tlet fe_zero: t = Set.empty\r\nend\r\n\r\nmodule FiniteEnumerationConversions =\r\nstruct\r\n\topen FiniteEnumerationBasics\r\n\r\n\tlet fromJSon (j: JSon.t): t =\r\n\t\tif JSon.isNull j || not (JSon.hasField j \"kind\") then\r\n\t\t\tfe_zero\r\n\t\telse\r\n\t\t\tlet strings = JSon.fieldStringSet j \"words\" in\r\n\t\t\tlet words = Set.map str2word strings in\r\n\t\t\t\twords\r\n\t\r\n\tlet toJSon (rep: t): JSon.t =\r\n\t\tJSon.makeAssoc [\r\n\t\t\t(\"words\", JSon.makeStringSet (Set.map word2str rep))\r\n\t\t]\r\n\r\n\tlet toJSon2 (id: Entity.t) (rep: t): JSon.t =\r\n\t\t JSon.append (Entity.toJSon id) (toJSon rep)\r\nend\r\n\r\nmodule FiniteEnumerationBasicFunctions =\r\nstruct\r\n\topen FiniteEnumerationBasics\r\n\topen FiniteEnumerationConversions\r\n\r\n\tlet make2 (arg: t Arg.alternatives) validate: Entity.t * t =\r\n\t\tEntity.make2 arg fromJSon kind validate\r\n\r\n\tlet make (arg: t Arg.alternatives) validate: t =\r\n\t\tsnd (make2 arg validate)\r\n\r\n\tlet show (rep: t): unit =\r\n\t\tlet j = toJSon rep in\r\n\t\t\tJSon.show j\r\n\r\n\tlet show2 (id: Entity.t) (rep: t): unit =\r\n\t\tlet j = toJSon2 id rep in\r\n\t\t\tJSon.show j\r\nend\r\n\r\nmodule FiniteEnumerationX =\r\nstruct\r\n\topen FiniteEnumerationBasics\r\n\t\r\n\ttype tx = string list\r\n\r\n\tlet internalize (fe: tx): t =\r\n\t\twordsI fe\r\n\r\n\tlet externalize (fe: t): tx =\r\n\t\twordsX fe\r\nend\r\n\r\nmodule FiniteEnumerationLearnOCaml =\r\nstruct\r\n\topen FiniteEnumerationBasics\r\n\topen FiniteEnumerationX\r\n\r\n\tlet xTypeName =\r\n\t\tlet l = String.split_on_char ' ' kind in\r\n\t\t\tList.nth l 0 ^ String.capitalize_ascii (List.nth l 1)\r\n\t\t\r\n\tlet moduleName =\r\n\t\tString.capitalize_ascii xTypeName\r\n\r\n\tlet displayHeader (name: string) (xTypeName: string) =\r\n\t\tif name = \"\" then \"\"\r\n\t\telse (\"let \" ^ name ^ \": \" ^ xTypeName ^ \" =\\n\\t\\t\")\r\n\r\n\tlet solution (name: string) (rep: t): string =\r\n\t\tlet repx = externalize rep in\r\n\t\tPrintf.sprintf {zzz|\r\n\t\t%s\t%s\r\n\t\t|zzz}\t(* please, do not change this line *)\r\n\t\t\t(displayHeader name xTypeName)\r\n\t\t\t(stringsD repx)\r\n\r\n\tlet prelude : string = {| {\r\n\t\ttype symbol = char\r\n\t\ttype state = string\r\n\t\ttype transition = state * symbol * state\r\n\r\n\t\ttype finiteENNNNN = {\r\n\t\t\talphabet : symbol list;\r\n\t\t\tstates : state list;\r\n\t\t\tinitialState : state;\r\n\t\t\ttransitions : transition list;\r\n\t\t\tacceptStates : state list\r\n\t\t}\r\n\t\t|}\t(* please, do not change this line *)\r\n\r\n\tlet example : JSon.t =\r\n\t\tJSon.parse {| {\r\n\t\t\tkind : \"finite enumeration\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"fe example\",\r\n\t\t\twords : [\"Red\", \"Yellow\", \"Blue\"]\r\n\t\t}\r\n\t\t|}\t(* please, do not change this line *)\r\nend\r\n\r\nmodule FiniteEnumerationSupport =\r\nstruct\r\n\tinclude FiniteEnumerationBasics\r\n\tinclude FiniteEnumerationConversions\r\n\tinclude FiniteEnumerationBasicFunctions\r\n\tinclude FiniteEnumerationLearnOCaml\r\nend\r\n# 1 \"src/FiniteEnumeration.ml\"\r\n(*\r\n * FiniteEnumeration.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by João Gonçalves (jg)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * set/2022 (amd) - Full restructuration.\r\n * jul/2021 (amd) - Improved Learn-OCaml support and error handling.\r\n * may/2021 (amd) - Added support for an extern representation.\r\n * mar/2021 (amd) - New module\r\n *)\r\n\r\n(*\r\n * Description: Finite language, directly defined as a set of words.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule FiniteEnumerationPrivate =\r\nstruct\r\n\topen FiniteEnumerationSupport\r\n\t\r\n\tlet validate (name: string) (rep: t): unit =\r\n\t\t()\r\n\r\n\tlet accept (fe: t) (w: word): bool =\r\n\t\tSet.belongs w fe\r\n\r\n\tlet generate (fe: t) (length: int): words =\r\n\t\tSet.filter (fun w -> List.length w == length) fe\r\nend\r\n\r\nmodule FiniteEnumeration =\r\nstruct\r\n\tinclude FiniteEnumerationSupport\r\n\topen FiniteEnumerationPrivate\r\n\r\n\t(* Make *)\r\n\tlet make2 (arg: t Arg.alternatives): Entity.t * t =\r\n\t\tmake2 arg validate\r\n\r\n\tlet make (arg: t Arg.alternatives): t =\r\n\t\tmake arg validate\r\n\r\n\t(* Exercices support *)\r\n\tlet checkProperty (fe: t) (prop: string) =\r\n\t\tmatch prop with\r\n\t\t\t| \"finite enumeration\" -> true\r\n\t\t\t| _ -> Model.checkProperty prop\r\n\r\n\tlet checkExercise ex fe =\r\n\t\tModel.checkExercise ex (accept fe) (checkProperty fe)\t\r\n\r\n\tlet checkExerciseFailures ex fe =\r\n\t\tModel.checkExerciseFailures ex (accept fe) (checkProperty fe)\t\r\n\r\n\t(* Ops *)\r\n\tlet accept = accept\r\n\tlet generate = generate\t\r\n\r\n\tclass model (arg: t Arg.alternatives) =\r\n\t\tobject(self) inherit Model.model (make2 arg) as super\r\n\t\t(* Representation *)\r\n\t\t\tmethod representation: t = representation\r\n\t\t(* Show *)\t\t\t\r\n\t\t\tmethod toJSon: JSon.t = toJSon representation\r\n\t\t\tmethod toJSon2: JSon.t = toJSon2 id representation\r\n\t\t\tmethod show: unit = show representation\r\n\t\t\tmethod show2: unit = show2 id representation\r\n\t\t(* Ops *)\t\t\t\t\r\n\t\t\tmethod accept (w: word): bool = accept representation w\r\n\t\t\tmethod generate (length: int): words = generate representation length\r\n\t\t(* Exercices support *)\r\n\t\t\tmethod checkProperty (prop: string) = checkProperty representation prop\r\n\t\t(* Learn-OCaml support *)\r\n\t\t\tmethod moduleName = moduleName\r\n\t\t\tmethod xTypeName = xTypeName\r\n\t\t\tmethod xTypeDeclString : string = prelude\r\n\t\t\tmethod toDisplayString (name: string): string = solution name self#representation\r\n\t\t\tmethod example : JSon.t = example\r\n\t\tend\r\nend\r\n# 1 \"src/FiniteAutomatonSupport.ml\"\r\n(*\r\n * FiniteAutomatonSupport.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * sep/2022 (amd) - New module\r\n *)\r\n\r\n(*\r\n * Description: Support types and functions for FAs.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule FiniteAutomatonBasics =\r\nstruct\r\n\ttype transition3 = state * symbol * state\r\n\ttype transitions3 = transition3 set\r\n\ttype t = {\r\n\t\talphabet : symbols;\r\n\t\tstates : states;\r\n\t\tinitialState : state;\r\n\t\ttransitions : transitions3;\r\n\t\tacceptStates : states\r\n\t}\r\n\r\n\ttype configuration = state * word\r\n\ttype configurations = configuration set\r\n\ttype path = configuration list\r\n\ttype trail = configurations list\r\n\r\n\tlet kind = \"finite automaton\"\r\n\r\n\tlet fa_zero: t = {\r\n\t\talphabet = Set.empty;\r\n\t\tstates = Set.make [draftState];\r\n\t\tinitialState = draftState;\r\n\t\ttransitions = Set.empty;\r\n\t\tacceptStates = Set.empty\r\n\t}\r\nend\r\n\r\nmodule FiniteAutomatonConversions =\r\nstruct\r\n\topen FiniteAutomatonBasics\r\n\r\n\tlet fromJSon (j: JSon.t): t =\r\n\t\tif JSon.isNull j || not (JSon.hasField j \"kind\") then\r\n\t\t\tfa_zero\r\n\t\telse {\r\n\t\t\talphabet = JSon.fieldSymbolSet j \"alphabet\";\r\n\t\t\tstates = JSon.fieldStateSet j \"states\";\r\n\t\t\tinitialState = JSon.fieldState j \"initialState\";\r\n\t\t\ttransitions = JSon.fieldTriplesSet j \"transitions\";\r\n\t\t\tacceptStates = JSon.fieldStateSet j \"acceptStates\"\r\n\t\t}\r\n\r\n\tlet toJSon0 (rep: t): JSon.t =\r\n\t\tJSon.makeAssoc [\r\n\t\t\t(\"alphabet\", JSon.makeSymbolSet rep.alphabet);\r\n\t\t\t(\"states\", JSon.makeStateSet rep.states);\r\n\t\t\t(\"initialState\", JSon.makeState rep.initialState);\r\n\t\t\t(\"transitions\", JSon.makeTriplesSet rep.transitions);\r\n\t\t\t(\"acceptStates\", JSon.makeStateSet rep.acceptStates)\r\n\t\t]\r\n\t\r\n\tlet toJSon2 (id: Entity.t) (rep: t): JSon.t =\r\n\t\t JSon.append (Entity.toJSon id) (toJSon0 rep)\r\n\t\r\n\tlet toJSon (rep: t): JSon.t =\r\n\t\t toJSon2 (Entity.dummyId kind) rep\r\nend\r\n\r\nmodule FiniteAutomatonBasicFunctions =\r\nstruct\r\n\topen FiniteAutomatonBasics\r\n\topen FiniteAutomatonConversions\r\n\r\n\tlet make2 (arg: t Arg.alternatives) validate: Entity.t * t =\r\n\t\tEntity.make2 arg fromJSon kind validate\r\n\r\n\tlet make (arg: t Arg.alternatives) validate: t =\r\n\t\tsnd (make2 arg validate)\r\n\r\n\tlet show (rep: t): unit =\r\n\t\tlet j = toJSon rep in\r\n\t\t\tJSon.show j\r\n\r\n\tlet show2 (id: Entity.t) (rep: t): unit =\r\n\t\tlet j = toJSon2 id rep in\r\n\t\t\tJSon.show j\r\nend\r\n\r\nmodule FiniteAutomatonX =\r\nstruct\r\n\topen FiniteAutomatonBasics\r\n\r\n\ttype transition3X = state * symbolX * state\r\n\ttype tx = {\r\n\t\talphabet : symbolX list;\r\n\t\tstates : state list;\r\n\t\tinitialState : state;\r\n\t\ttransitions : transition3X list;\r\n\t\tacceptStates : state list\r\n\t}\r\n\r\n\tlet transitions3I (l: transition3X list): transitions3 =\r\n\t\tlet trans3I (a,b,c): transition3 = (a, symbI b, c) in\r\n\t\t\tSet.make (List.map trans3I l)\r\n\t\t\t\r\n\tlet transitions3X (s: transitions3): transition3X list =\r\n\t\tlet trans3X (a,b,c): transition3X = (a, symbX b, c) in\r\n\t\t\tList.map trans3X (Set.toList s)\r\n\r\n\tlet internalize (fa: tx): t = {\r\n\t\talphabet = symbolsI fa.alphabet;\r\n\t\tstates = Set.make fa.states;\r\n\t\tinitialState = fa.initialState;\r\n\t\ttransitions = transitions3I fa.transitions;\r\n\t\tacceptStates = Set.make fa.acceptStates\r\n\t}\r\n\t\r\n\tlet externalize (fa: t): tx = {\r\n\t\talphabet = symbolsX fa.alphabet;\r\n\t\tstates = Set.toList fa.states;\r\n\t\tinitialState = fa.initialState;\r\n\t\ttransitions = transitions3X fa.transitions;\r\n\t\tacceptStates = Set.toList fa.acceptStates\r\n\t}\r\nend\r\n\r\nmodule FiniteAutomatonLearnOCaml =\r\nstruct\r\n\topen FiniteAutomatonBasics\r\n\topen FiniteAutomatonX\r\n\r\n\tlet moduleName =\r\n\t\t\"FiniteAutomaton\"\r\n\r\n\tlet xTypeName =\r\n\t\t\"finiteAutomaton\"\r\n\r\n\tlet transs3XD (l: transition3X list): string =\r\n\t\tlet t2d (a,b,c) =\r\n\t\t\tPrintf.sprintf \"(%s, %s, %s)\"\r\n\t\t\t(stateXD a)\r\n\t\t\t(symbXD b)\r\n\t\t\t(stateXD c)\r\n\t\tin listD t2d l\r\n\r\n\tlet solution (name: string) (rep: t): string =\r\n\t\tlet repx = externalize rep in\r\n\t\tPrintf.sprintf {zzz|\r\n\t\t%s{\r\n\t\t\talphabet = %s;\r\n\t\t\tstates = %s;\r\n\t\t\tinitialState = %s;\r\n\t\t\ttransitions = %s;\r\n\t\t\tacceptStates = %s\r\n\t\t}\r\n\t\t|zzz}\t(* please, do not change this line *)\r\n\t\t\t(FiniteEnumerationLearnOCaml.displayHeader name xTypeName)\r\n\t\t\t(symbolsXD repx.alphabet)\r\n\t\t\t(statesXD repx.states)\r\n\t\t\t(stateXD repx.initialState)\r\n\t\t\t(transs3XD repx.transitions)\r\n\t\t\t(statesXD repx.acceptStates)\r\n\r\n\r\n\tlet prelude : string =\r\n\t\tPrintf.sprintf {zzz|\r\n\t\ttype symbol = %s\r\n\t\ttype state = string\r\n\t\ttype finiteAutomaton = {\r\n\t\t\talphabet : symbol list;\r\n\t\t\tstates : state list;\r\n\t\t\tinitialState : state;\r\n\t\t\ttransitions : (state * symbol * state) list;\r\n\t\t\tacceptStates : state list\r\n\t\t}\r\n\t\t|zzz}\t(* please, do not change this line *)\r\n\t\t\tsymbolTypeName\r\n\r\n\tlet example : JSon.t =\r\n\t\tJSon.parse {|\r\n\t\t{\r\n\t\t\tkind : \"finite automaton\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"fa example\",\r\n\t\t\talphabet: [\"w\", \"z\"],\r\n\t\t\tstates : [\"START\", \"X\", \"Z\"],\r\n\t\t\tinitialState : \"START\",\r\n\t\t\ttransitions : [\r\n\t\t\t\t[\"START\", \"w\", \"X\"], [\"X\", \"z\", \"X\"]\r\n\t\t\t],\r\n\t\t\tacceptStates : [\"Z\"]\r\n\t\t}\r\n\t\t|}\t(* please, do not change this line *)\r\nend\r\n\r\nmodule FiniteAutomatonSupport =\r\nstruct\r\n\tinclude FiniteAutomatonBasics\r\n\tinclude FiniteAutomatonConversions\r\n\tinclude FiniteAutomatonBasicFunctions\r\n\tinclude FiniteAutomatonLearnOCaml\r\nend\r\n# 1 \"src/FiniteAutomaton.ml\"\r\n(*\r\n * FiniteAutomaton.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by João Gonçalves (jg)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * set/2022 (amd) - Full restructuration.\r\n * jul/2021 (amd) - Improved Learn-OCaml support and error handling.\r\n * jun/2021 (amd) - Added checks for epsilon ('~') in the #validate method.\r\n * may/2021 (amd) - Added support for an extern representation.\r\n * jan/2021 (amd) - Module in an independent file and some cleanup.\r\n * dec/2019 (jg) - Main functionalities.\r\n * jun/2019 (amd) - Initial skeleton, inside the big file \"OCamlFlat.ml\".\r\n *)\r\n\r\n(*\r\n * Description: Finite automata functionality.\r\n *\r\n * TODO: More cleanup.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule FiniteAutomatonAccept = (* AMD *)\r\nstruct\r\n\topen FiniteAutomatonSupport\r\n\r\n\tlet initialConfigs fa w : configurations =\r\n\t\tSet.make [(fa.initialState,w)]\r\n\r\n\tlet isAcceptingConfig fa (st,w) : bool =\r\n\t\tSet.belongs st fa.acceptStates && w = []\r\n\r\n\tlet nextConfigs fa (st,w) : configurations =\r\n\t\tmatch w with\r\n\t\t| [] ->\r\n\t\t\tlet empty = Set.filter (fun (st1,sy,_) -> st1 = st && sy = epsilon) fa.transitions in\r\n\t\t\t\tSet.map (fun (_,_,st2) -> (st2,[])) empty\r\n\t\t| x::xs -> \r\n\t\t\tlet nonEmpty = Set.filter (fun (st1,sy,_) -> st1 = st && sy = x) fa.transitions in\r\n\t\t\tlet empty = Set.filter (fun (st1,sy,_) -> st1 = st && sy = epsilon) fa.transitions in\r\n\t\t\tlet res1 = Set.map (fun (_,_,st2) -> (st2,xs)) nonEmpty in\r\n\t\t\tlet res2 = Set.map (fun (_,_,st2) -> (st2,w)) empty in\r\n\t\t\t\tSet.union res1 res2\r\n\r\n\tlet accept (fa: t) (w: word) : bool =\r\n\t\tignore (Model.checkWord fa.alphabet w);\r\n\t\tModel.accept fa w initialConfigs nextConfigs isAcceptingConfig\r\n\r\n\tlet acceptFull (fa: t) (w: word) : bool * path * trail =\r\n\t\tignore (Model.checkWord fa.alphabet w);\r\n\t\tModel.acceptFull fa w initialConfigs nextConfigs isAcceptingConfig\r\nend\r\n\r\nmodule FiniteAutomatonGenerate = (* AMD *)\r\nstruct\r\n\topen FiniteAutomatonSupport\r\n\topen FiniteAutomatonAccept\r\n\r\n\tlet nextConfigs2 fa _ (st,w) =\r\n\t\tlet selected = Set.filter (fun (st1,_,_) -> st1 = st) fa.transitions in\r\n\t\t\tSet.map (fun (_,sy,st2) -> (st2,if sy = epsilon then w else sy::w)) selected\r\n\r\n\tlet isAcceptingConfig2 fa (st,_) =\r\n\t\tSet.belongs st fa.acceptStates\r\n\r\n\tlet getWord (_,w) = List.rev w;;\r\n\r\n\tlet generate (fa: t) (len: int): words =\r\n\t\tModel.generate fa len initialConfigs nextConfigs2 isAcceptingConfig2 getWord\r\n\r\n\tlet generateDumb (fa: t) (len: int): words = \r\n\t\tModel.generateDumb fa fa.alphabet len initialConfigs nextConfigs isAcceptingConfig\r\nend\r\n\r\nmodule FiniteAutomatonPrivate =\r\nstruct\r\n\topen FiniteAutomatonSupport\r\n\r\n\t(*------Auxiliary functions---------*)\r\n\r\n\t(* get starting state, symbol, and/or end state of all transitions in set *)\r\n\tlet transitionGet1 trns = Set.map ( fun (a,_,_) -> a ) trns\r\n\tlet transitionGet2 trns = Set.map ( fun (_,b,_) -> b ) trns\r\n\tlet transitionGet3 trns = Set.map ( fun (_,_,c) -> c ) trns\r\n\tlet transitionGet23 trns = Set.map (fun (_,b,c) -> (b,c)) trns\r\n\r\n\t(* fuse all states into a new state *)\r\n\tlet fuseStates sts =\r\n\t\tlet l = List.map state2str sts in\r\n\t\t\tstate (String.concat \"_\" l)\r\n\r\n\t(* checks if set ts has at least one transition from state st through symbol sy *)\r\n\tlet hasTrans st sy ts = Set.exists (fun (x,y,_) -> x = st && y = sy) ts\r\n\r\n\t(* returns the set of state st and all its states reachable by an epsilon transition *)\r\n\tlet nextEpsilon1 st ts =\r\n\t\tlet trns = Set.filter (fun (a,b,c) -> st = a && b = epsilon) ts in\r\n\t\tlet nextStates = transitionGet3 trns in\r\n\t\t\tSet.add st nextStates\r\n\r\n\t(* returns the set of states sts and all states reachable from sts through epsilon transitions *)\r\n\tlet rec closeEmpty sts t =\r\n\t\tlet ns = Set.flatMap (fun st -> nextEpsilon1 st t) sts in\r\n\t\t\tif (Set.subset ns sts) then ns else closeEmpty (Set.union sts ns) t\r\n\r\n\t(* futuro\r\n\t\tlet rec closeEmpty sts t =\r\n\t\t\tSet.fixedPoint (Set.flatMap (fun st -> nextEpsilon1 st t)) sts\r\n\t*)\r\n\r\n\t(* returns states reachable from st through symbol sy *)\r\n\tlet nextStates st sy t =\r\n\t\tlet n = Set.filter (fun (a,b,c) -> st = a && sy = b) t in\r\n\t\t\ttransitionGet3 n\r\n\r\n\t(**\r\n\t* This function verifies if the automaton is valid.\r\n\t* An automaton is considered valid if its initial and acceptance states belong to the set of all its states\r\n\t* and if all its transitions have states and symbols belonging to the set of all its states and its alphabet respectively.\r\n\t*\r\n\t* Desc: If the automaton is invalid, the cause could derive from any combination of the following\r\n\t* three options: either the initial state, one of the acceptance states, or one of the transitions does not follow the\r\n\t* previously discussed predicate. This method will print to the console stating which combination of these options caused\r\n\t* the automaton to be invalid\r\n\t*)\r\n\tlet validate (name: string) (fa: t): unit =\r\n\t(* the alphabet must not contain \" \" *)\r\n\t\tlet validAlphabet = not (Set.belongs epsilon fa.alphabet) in\r\n\t(* does initial state belong to the set of all states *)\r\n\t\tlet validInitSt = Set.belongs fa.initialState fa.states in\r\n\t(* are all accepted states members of all states *)\r\n\t\tlet validAccSts = Set.subset fa.acceptStates fa.states in\r\n\t\tlet fromSt = transitionGet1 fa.transitions in\r\n\t\tlet sy = transitionGet2 fa.transitions in\r\n\t\tlet toSt = transitionGet3 fa.transitions in\r\n\t\tlet alpha = Set.add epsilon fa.alphabet in\r\n\t(* do all transitions have states belonging to all states and symbols belonging to the alphabet *)\r\n\t\tlet validTrns = (Set.subset fromSt fa.states)\r\n\t\t\t\t\t&& (Set.subset sy alpha) && (Set.subset toSt fa.states) in\r\n\t\t\tif not validAlphabet then\r\n\t\t\t\tError.error name \"The alphabet contains epsilon '~', and it should not\" ();\r\n\t\t\tif not validInitSt then\r\n\t\t\t\tError.error name \"The initial state does not belong to the set of all states\" ();\r\n\t\t\tif not validAccSts then\r\n\t\t\t\tError.error name \"Some accept states do not belong to the set of all states\" ();\r\n\t\t\tif not validTrns then\r\n\t\t\t\tError.error name \"Some transitions are invalid\" ()\r\n\r\n\t(**\r\n\t* This function verifies if the given word is accepted by the automaton\r\n\t* @param w:word -> word to be tested for acceptance\r\n\t* @returns bool -> true if w is accepted and false otherwise\r\n\t* Desc: Checks if the automaton accepts word w using configurations (that is, pairs formed by a state and\r\n\t* a remaining word) and a breadth-first approach as to deal with potential non-termination\r\n\t*)\r\n\tlet acceptBreadthFirst (fa: t) (w: word): bool = false\r\n\t(*\r\n\t\tlet rec acc cf t sta =\r\n\t\t\tmatch cf with\r\n\t\t\t\t[] -> false\r\n\t\t\t\t|(st,[])::ls ->\r\n\t\t\t\t\tlet accepts = (Set.inter (closeEmpty (Set.make [st]) t) sta) <> Set.empty in\r\n\t\t\t\t\t\taccepts || acc ls t sta\r\n\t\t\t\t|(st,x::xs)::ls ->\r\n\t\t\t\t\tlet n = nextStates st x t in\r\n\t\t\t\t\tlet cfn = Set.map (fun c -> (c,xs)) n in\r\n\t\t\t\t\tlet n2 = nextStates st epsilon t in\r\n\t\t\t\t\tlet cfn2 = Set.map (fun c -> (c,x::xs)) n2 in\r\n\t\t\t\t\t\tacc (Set.flatten (Set.make [ls;cfn;cfn2])) t sta in\r\n\t\tacc (Set.make [(fa.initialState,w)]) fa.transitions fa.acceptStates\r\n\t*)\r\n\r\n\t\r\n\r\n\t(**\r\n\t* This function verifies if the given word is accepted by the automaton\r\n\t* @param w:word -> word to be accepted\r\n\t* @returns bool -> true if w is accepted and false otherwise\r\n\t* Desc: Checks if the automaton accepts word w using functions over sets of states\r\n\t*)\r\n\tlet accept_disabled (fa: t) (w: word): bool =\r\n\t\tlet transition sts sy t =\r\n\t\t\tlet nsts = Set.flatMap (fun st -> nextStates st sy t) sts in\r\n\t\t\t\tSet.union nsts (closeEmpty nsts t) in\r\n\t\tlet rec acceptX sts w t =\r\n\t\t\tmatch w with\r\n\t\t\t\t[] -> (Set.inter sts fa.acceptStates) <> Set.empty\r\n\t\t\t\t|x::xs -> let nextSts = transition sts x t in\r\n\t\t\t\t\tnextSts <> Set.empty && acceptX nextSts xs t in\r\n\t\tlet i = closeEmpty (Set.make [fa.initialState]) fa.transitions in\r\n\t\t\tacceptX i w fa.transitions\r\n\r\n\r\n\tlet acceptWithTracing (fa: t) (w:word): unit =\r\n\t\tlet transition sts sy t =\r\n\t\t\tlet nsts = Set.flatMap (fun st -> nextStates st sy t) sts in\r\n\t\t\t\tSet.union nsts (closeEmpty nsts t) in\r\n\t\tlet rec acceptX sts w t =\r\n\t\t\tmatch w with\r\n\t\t\t\t[] -> [(w,sts)]\r\n\t\t\t\t|x::xs -> let nextSts = transition sts x t in\r\n\t\t\t\t\t\t\tlet res = acceptX nextSts xs t in\r\n\t\t\t\t\t\t\t\t(w,sts)::res in\r\n\t\tlet i = closeEmpty (Set.make [fa.initialState]) fa.transitions in\r\n\t\tlet res = acceptX i w fa.transitions in\r\n\t\tlet printRes w sts =\r\n\t\t\tUtil.print [\"('\"; word2str w; \"',[\"];\r\n\t\t\tSet.iter (fun st -> Util.print [state2str st; \";\"]) sts;\r\n\t\t\tUtil.print [\"])\"]\r\n\t\tin List.iter (fun (w,sts) -> printRes w sts; Util.print [\";\"]) res; Util.println []\r\n\r\n\t(**\r\n\t* This function generates all words of the given size which are accepted by the automaton\r\n\t* Precondition -> length >= 0\r\n\t* @param length:int -> size of all words to be generated\r\n\t* @returns words -> the set of all words with size length\r\n\t*)\r\n\tlet generate_disabled (fa: t) (length: int): words =\r\n\t\t(* adds symbol to the left of all words *)\r\n\t\tlet addSyToRWords symb ws = Set.map (fun l -> symb::l) ws in\r\n\t\tlet hasAcceptState sts accSts = Set.exists (fun st -> Set.belongs st accSts) sts in\r\n\t\tlet nxtNonEmptyTrns st ts = Set.filter (fun (a,b,_) -> a = st && b <> epsilon) ts in\r\n\t\tlet rec gen n state transitions accSts =\r\n\t\t\tlet clsEmpty = (closeEmpty (Set.make [state]) transitions) in\r\n\t\t\tif n = 0 then\r\n\t\t\t\tif hasAcceptState clsEmpty accSts then Set.make [[]] else Set.empty\r\n\t\t\telse\r\n\t\t\t\tlet trnsSet = Set.flatMap (fun st -> nxtNonEmptyTrns st transitions ) clsEmpty in\r\n\t\t\t\tlet rwords st1 l1 = gen (l1-1) st1 transitions accSts in\r\n\t\t\t\tlet genX sy st l = addSyToRWords sy (rwords st l) in\r\n\t\t\t\t\t\tSet.flatMap (fun (_,sy,st) -> genX sy st n) trnsSet\r\n\t\tin\r\n\t\t\tgen length fa.initialState fa.transitions fa.acceptStates\r\n\r\n\r\n\t(**\r\n\t* This function generates all words up to a given size which are accepted by the automaton\r\n\t* Precondition -> length >= 0\r\n\t* @param length:int -> maximum size of all words to be generated\r\n\t* @returns words -> the set of all words with size length or less\r\n\t*)\r\n\tlet generateUntil (fa: t) (length: int): words =\r\n\t\t(* adds symbol to the left of all words *)\r\n\t\tlet addSyToRWords symb ws = Set.map (fun l -> symb::l) ws in\r\n\t\tlet hasAcceptState sts accSts = Set.exists (fun st -> Set.belongs st accSts) sts in\r\n\t\tlet nxtNonEmptyTrns st ts = Set.filter (fun (a,b,_) -> a = st && b <> epsilon) ts in\r\n\t\tlet rec gen n state transitions accSts =\r\n\t\t\tlet clsEmpty = (closeEmpty (Set.make [state]) transitions) in\r\n\t\t\tif n = 0 then\r\n\t\t\t\tif hasAcceptState clsEmpty accSts then Set.make [[]] else Set.empty\r\n\t\t\telse\r\n\t\t\t\tlet trnsSet = Set.flatMap (fun st -> nxtNonEmptyTrns st transitions ) clsEmpty in\r\n\t\t\t\tlet genX sy st l = addSyToRWords sy (gen (l-1) st transitions accSts) in\r\n\t\t\t\tlet lenOneOrMore = Set.flatMap (fun (_,sy,st) -> genX sy st n) trnsSet in\r\n\t\t\t\tlet lenZero = if hasAcceptState clsEmpty accSts then Set.make [[]] else Set.empty in\r\n\t\t\t\t\tSet.union lenOneOrMore lenZero\r\n\t\tin\r\n\t\t\tgen length fa.initialState fa.transitions fa.acceptStates\r\n\r\n\r\n\t(**\r\n\t* This function generates all states that are reachable from the given state. A state is reachable from s if there\r\n\t* exists a word that starting on s will lead to that state\r\n\t* @param s:state -> the given state\r\n\t* @returns states -> the set of all states reachable from s.\r\n\t*)\r\n\tlet reachable (fa: t) (s:state): states =\r\n\t\tlet neighbourSts st t = transitionGet3 (Set.filter (fun (a,_,_) -> a = st) t) in\r\n\t\tlet nextStates sts t = Set.flatMap (fun st -> neighbourSts st t) sts in\r\n\t\tlet remain s t = Set.filter (fun (a,_,_) -> not (Set.belongs a s)) t in\r\n\t\tlet rec reach visited s t = if visited = s then Set.empty else Set.union s ( reach s (nextStates s t) (remain s t) ) in\r\n\t\t\treach Set.empty (Set.make [s]) fa.transitions\r\n\r\n\r\n\r\n\t(**\r\n\t* This function generates all productive states. A state is productive if there exists a word that will lead said state\r\n\t* to an acceptance state\r\n\t* @returns states -> the set of all productive states\r\n\t* Desc: For each state of the automaton, this method applies the reachable method and checks if any of the resulting\r\n\t* states is an acceptance state, and if it is then that state will belong to the resulting set of productive states\r\n\t*)\r\n\tlet productive (fa: t): states =\r\n\t\tlet reachsAccSt st = Set.exists (fun s -> Set.belongs s fa.acceptStates ) (reachable fa st) in\r\n\t\t\tSet.filter (fun st -> reachsAccSt st) fa.states\r\n\r\n\t(**\r\n\t* This function generates the set of all useful states\r\n\t* @returns states -> the set of all useful states\r\n\t*)\r\n\tlet getUsefulStates (fa: t): states =\r\n\t\tSet.inter (productive fa) (reachable fa fa.initialState)\r\n\r\n\t(**\r\n\t* This function generates the set of all non useful states\r\n\t* @returns states -> the set of all non useful states\r\n\t*)\r\n\tlet getUselessStates (fa: t): states =\r\n\t\tSet.diff fa.states (getUsefulStates fa)\r\n\r\n\t(**\r\n\t* This function creates the equivalent automaton where all states are useful\r\n\t* @returns FiniteAutomaton.model -> the new equivalent automaton where all states are useful\r\n\t* Desc: The new automaton is created by eliminating from the original automaton all its non useful states, all transitions\r\n\t* that have a non useful state, and all symbols of the alphabet that only appear in said transitions\r\n\t*)\r\n\tlet cleanUselessStates (fa: t): t =\r\n\t\tlet usfSts = getUsefulStates fa in\r\n\t\tlet usfTrs = Set.filter\r\n\t\t\t\t\t\t(fun (a,_,c) -> Set.belongs a usfSts && Set.belongs c usfSts)\r\n\t\t\t\t\t\tfa.transitions in\r\n\t\tlet alf = transitionGet2 usfTrs in\r\n\t\tlet usfAlf = Set.diff alf (Set.make [epsilon]) in\r\n\t\tlet newAccSts = Set.inter fa.acceptStates usfSts in\r\n\t\tlet usfSts = Set.add fa.initialState usfSts in\r\n\t\t\t{\r\n\t\t\t\talphabet = usfAlf;\r\n\t\t\t\tstates = usfSts;\r\n\t\t\t\tinitialState = fa.initialState;\r\n\t\t\t\ttransitions = usfTrs;\r\n\t\t\t\tacceptStates = newAccSts\r\n\t\t\t}\r\n\r\n\t(**\r\n\t* This function verifies if all the automaton's states are useful\r\n\t* @returns bool -> true if all states of the automaton are useful, false otherwise\r\n\t*)\r\n\tlet areAllStatesUseful (fa: t): bool =\r\n\t\tlet usfSts = getUsefulStates fa in\r\n\t\t\tSet.size fa.states = Set.size usfSts\r\n\r\n\t(**\r\n\t* This function converts the non-deterministic automaton into its deterministic equivalent\r\n\t*\r\n\t* @returns FiniteAutomaton.model -> the new deterministic automaton\r\n\t*\r\n\t* Desc: If the automaton to determinize is already deterministic,\r\n\t* the resulting automaton will be equal to the original\r\n\t*)\r\n\tlet toDeterministic (fa: t): t =\r\n\r\n\t\tlet move sts sy ts = Set.flatMap (fun st -> nextStates st sy ts ) sts in\r\n\r\n\t\t(* generates the set of states reachable from the given state set though the given symbol *)\r\n\t\tlet newR oneR sy ts =\r\n\t\t\tlet nxtSts = move oneR sy ts in\r\n\t\t\tlet clsempty = closeEmpty nxtSts ts in\r\n\t\t\tSet.union nxtSts clsempty in\r\n\r\n\t\t(* creates all transitions (given state set, a given symbol, states reachable from set through given symbol) *)\r\n\t\tlet rToTs r =\r\n\t\t\tlet nxtTrans = Set.map (fun sy -> (r,sy,newR r sy fa.transitions)) fa.alphabet in\r\n\t\t\t\tSet.filter (fun (_,_,z) -> not (z = Set.empty)) nxtTrans in\r\n\r\n\t\t(* applies previous function to all state sets until no new set is generated *)\r\n\t\tlet rec rsToTs stsD rD trnsD alph =\r\n\t\t\tlet nxtTs = Set.flatMap (fun stSet -> rToTs stSet ) rD in\r\n\t\t\tlet nxtRs = Set.map (fun (_,_,z) -> z) nxtTs in\r\n\t\t\tlet newRs = Set.filter (fun r -> not (Set.belongs r stsD)) nxtRs in\r\n\t\t\tif newRs = Set.empty then (Set.union trnsD nxtTs) else\r\n\t\t\t\trsToTs (Set.union newRs stsD) newRs (Set.union trnsD nxtTs) alph in\r\n\r\n\r\n\t\tlet r1 = closeEmpty (Set.make [fa.initialState]) fa.transitions in\r\n\r\n\t\t(* all transitions of the new deterministic automaton *)\r\n\t\tlet trnsD = rsToTs (Set.make [r1]) (Set.make [r1]) Set.empty fa.alphabet in\r\n\r\n\t\tlet tds = Set.map (fun (a,b,c) -> (fuseStates (Set.toList a), b, fuseStates (Set.toList c))) trnsD in\r\n\r\n\t\tlet newInitialState = fuseStates (Set.toList r1) in\r\n\r\n\t\tlet stSet1 = Set.map (fun (a,_,_) -> a) trnsD in\r\n\t\tlet stSet2 = Set.map (fun (_,_,c) -> c) trnsD in\r\n\t\tlet stSet = Set.union stSet1 stSet2 in\r\n\r\n\t\tlet isAccepState st = Set.belongs st fa.acceptStates in\r\n\t\tlet hasAnAccepSt set = Set.exists (fun st -> isAccepState st ) set in\r\n\t\tlet newAccStsSet = Set.filter (fun set -> hasAnAccepSt set) stSet in\r\n\r\n\t\tlet newAllSts = Set.map (fun set -> fuseStates (Set.toList set)) stSet in\r\n\t\tlet newAccSts = Set.map (fun set -> fuseStates (Set.toList set)) newAccStsSet in\r\n\t\t\t{\r\n\t\t\t\talphabet = fa.alphabet;\r\n\t\t\t\tstates = newAllSts;\r\n\t\t\t\tinitialState = newInitialState;\r\n\t\t\t\ttransitions = tds;\r\n\t\t\t\tacceptStates = newAccSts\r\n\t\t\t}\r\n\r\n\t(**\r\n\t* This function verifies if the automaton is deterministic\r\n\t* @returns bool -> true if automaton is deterministic, false otherwise\r\n\t* Desc: For each state s, this method checks if there exists 2 or more transitions with the same symbol from any\r\n\t* state belonging to closeempty of s, independently of the state which said transitions will lead to.\r\n\t* If there is no state for which this property is true, then the automaton is deterministic\r\n\t*)\r\n\tlet isDeterministic (fa: t): bool =\r\n\t\tlet trnsFromSt st ts = Set.filter (fun (st1,sy,_) -> st1 = st && sy <> epsilon) ts in\r\n\t\tlet isStDeter st ts =\r\n\t\t\tlet allSts = closeEmpty (Set.make [st]) ts in\r\n\t\t\tlet allTs = Set.flatMap (fun st -> trnsFromSt st ts) allSts in\r\n\t\t\tlet sys = transitionGet2 allTs in\r\n\t\t\t\tSet.size allTs = Set.size sys in\r\n\t\tlet hasNondeterSt = Set.exists (fun st -> not (isStDeter st fa.transitions) )\r\n\t\t\t\t\t\t\t\tfa.states in\r\n\t\t\tnot hasNondeterSt\r\n\r\n\r\n\t(* partition states by equivalence *)\r\n\tlet equivalencePartition (fa: t): states set =\r\n\t\tlet fa = toDeterministic fa in\r\n\t\tlet fa = cleanUselessStates fa in\r\n\t\tlet (inF, notF) = Set.partition (fun x -> Set.belongs x fa.acceptStates) fa.states in\r\n\t\tlet distI1 = Set.product inF notF in\r\n\r\n\t\tlet hasTransMulti sts sy ts = Set.partition (fun st -> hasTrans st sy ts) sts in\r\n\t\tlet distI2 = Set.flatMap (fun sy -> Util.distrib2 Set.product\r\n\t\t\t\t\t\t\t\t\t\t\t(hasTransMulti fa.states sy fa.transitions))\r\n\t\t\t\t\t\tfa.alphabet in\r\n\r\n\r\n\t\tlet distI = Set.union distI1 distI2 in\r\n\r\n\t\tlet stsXSts = Set.product fa.states fa.states in\r\n\r\n\t\t(* generates all pairs of states that can reach the pair (st1,st2) through a transition with symbol sy *)\r\n\t\tlet reachingSts st1 st2 sy p =\r\n\t\t\tlet t1 = Set.filter (fun (_,y,z) -> z = st1 && y = sy) fa.transitions in\r\n\t\t\tlet t2 = Set.filter (fun (_,y,z) -> z = st2 && y = sy) fa.transitions in\r\n\t\t\tlet s1 = transitionGet1 t1 in\r\n\t\t\tlet s2 = transitionGet1 t2 in\r\n\t\t\t\tSet.diff (Set.product s1 s2) p in\r\n\r\n\t\tlet findAR p q = Set.flatMap (fun (a,b) -> Set.flatMap (fun sy -> reachingSts a b sy p) fa.alphabet) q in\r\n\r\n\t\tlet distA = findAR distI distI in\r\n\r\n\t\tlet rec aped p q = if (q = Set.empty || (Set.union p q) = stsXSts) then Set.union p q\r\n\t\t\telse aped (Set.union p q) (findAR (Set.union p q) q ) in\r\n\r\n\t\tlet dist = aped distI distA in\r\n\r\n\r\n\t\t(* given for example states a b c d generates (a,a) (a,b) (a,c) (a,d) (b,b) (b,c) (b,d) (c,c) (c,d) (d,d) *)\r\n\t\tlet rec halfCombs sts =\r\n\t\t\tmatch sts with\r\n\t\t\t\t[] -> Set.empty\r\n\t\t\t\t|x::xs -> Set.union (Set.product (Set.make [x]) (Set.make sts)) (halfCombs xs) in\r\n\r\n\t\tlet halfTriang = halfCombs (Set.toList fa.states) in\r\n\r\n\t\t(* given set of equivalent states dicti, substitutes state st for its leftmost equivalent state according to dicti *)\r\n\t\tlet rec translate st dicti =\r\n\t\t\tmatch dicti with\r\n\t\t\t\t[] -> st\r\n\t\t\t\t|(eq1,eq2)::xs -> if eq2 = st then eq1 else translate st xs in\r\n\r\n\t\t(* the set of equivalent state pairs are those not present in the set of distinct state pairs *)\r\n\t\tlet equiv = Set.filter ( fun (a,b) -> not (Set.belongs (a,b) dist) &&\r\n\t\t\t\t\t\t\t\t\t\t\t\tnot (Set.belongs (b,a) dist) ) halfTriang in\r\n\r\n\t\tlet equivList = Set.toList equiv in\r\n\t\tlet hasAny st1 st2 sta stb = (translate st1 equivList) = sta || (translate st2 equivList) = sta\r\n\t\t\t\t\t\t\t\t\t|| (translate st1 equivList) = stb || (translate st2 equivList) = stb in\r\n\r\n\r\n\t\tlet rec agroup eq =\r\n\t\t\tmatch eq with\r\n\t\t\t\t| [] -> Set.empty\r\n\t\t\t\t| (a,b)::ls ->\r\n\t\t\t\t\tlet (part1,part2) = Set.partition (fun (x,y) -> hasAny x y a b) (Set.make eq) in\r\n\t\t\t\t\tlet gRemain = Set.flatMap (fun (c,d) -> Set.make [c;d]) part1 in\r\n\t\t\t\t\t\tSet.add (Set.union (Set.make [a;b]) gRemain) (agroup (Set.toList part2))\r\n\t\tin\r\n\r\n\t\tagroup equivList\r\n\r\n\r\n\r\n\t(**\r\n\t* This function minimizes the automaton\r\n\t* @returns FiniteAutomaton.model -> the new minimal equivalent automaton\r\n\t* Desc: The given automaton is minimized according to the process described in lecture a15.\r\n\t*)\r\n\tlet minimize (fa: t): t =\r\n\t\tlet fa = toDeterministic fa in\r\n\t\tlet fa = cleanUselessStates fa in\r\n\r\n\t\tlet (inF, notF) = Set.partition (fun x -> Set.belongs x fa.acceptStates) fa.states in\r\n\t\tlet distI1 = Set.product inF notF in\r\n\r\n\t\tlet hasTransMulti sts sy ts = Set.partition (fun st -> hasTrans st sy ts) sts in\r\n\t\tlet distI2 = Set.flatMap (fun sy -> Util.distrib2 Set.product\r\n\t\t\t\t\t\t\t\t\t\t\t(hasTransMulti fa.states sy fa.transitions))\r\n\t\t\t\t\t\tfa.alphabet in\r\n\r\n\r\n\t\tlet distI = Set.union distI1 distI2 in\r\n\r\n\t\tlet stsXSts = Set.product fa.states fa.states in\r\n\r\n\t\t(* generates all pairs of states that can reach the pair (st1,st2) through a transition with symbol sy *)\r\n\t\tlet reachingSts st1 st2 sy p =\r\n\t\t\tlet t1 = Set.filter (fun (_,y,z) -> z = st1 && y = sy) fa.transitions in\r\n\t\t\tlet t2 = Set.filter (fun (_,y,z) -> z = st2 && y = sy) fa.transitions in\r\n\t\t\tlet s1 = transitionGet1 t1 in\r\n\t\t\tlet s2 = transitionGet1 t2 in\r\n\t\t\t\tSet.diff (Set.product s1 s2) p in\r\n\r\n\t\tlet findAR p q = Set.flatMap (fun (a,b) -> Set.flatMap (fun sy -> reachingSts a b sy p) fa.alphabet) q in\r\n\r\n\t\tlet distA = findAR distI distI in\r\n\r\n\t\tlet rec aped p q = if (q = Set.empty || (Set.union p q) = stsXSts) then Set.union p q\r\n\t\t\telse aped (Set.union p q) (findAR (Set.union p q) q ) in\r\n\r\n\t\tlet dist = aped distI distA in\r\n\r\n\r\n\t\t(* given for example states a b c d generates (a,b) (a,c) (a,d) (b,c) (b,d) (c,d) *)\r\n\t\tlet rec halfCombs sts =\r\n\t\t\tmatch sts with\r\n\t\t\t\t[] -> Set.empty\r\n\t\t\t\t|x::xs -> Set.union (Set.product (Set.make [x]) (Set.make xs)) (halfCombs xs) in\r\n\t\tlet halfTriang = halfCombs (Set.toList fa.states) in\r\n\r\n\t\t(* given set of equivalent states dicti, substitutes state st for its leftmost equivalent state according to dicti *)\r\n\t\tlet rec translate st dicti =\r\n\t\t\tmatch dicti with\r\n\t\t\t\t[] -> st\r\n\t\t\t\t|(eq1,eq2)::xs -> if eq2 = st then eq1 else translate st xs in\r\n\r\n\t\t(* the set of equivalent state pairs are those not present in the set of distinct state pairs *)\r\n\t\tlet equiv = Set.filter ( fun (a,b) -> not (Set.belongs (a,b) dist) &&\r\n\t\t\t\t\t\t\t\t\t\t\t\tnot (Set.belongs (b,a) dist) ) halfTriang in\r\n\r\n\t\tlet equivList = Set.toList equiv in\r\n\r\n\t\tlet eq = Set.map (fun (a,b) -> b) equiv in\r\n\t\tlet newSts = Set.diff fa.states eq in\r\n\t\tlet newInitSt = translate fa.initialState equivList in\r\n\t\tlet newAccSts = Set.inter fa.acceptStates newSts in\r\n\t\tlet newTrans = Set.map (fun (x,y,z) -> (translate x equivList,y,translate z equivList) ) fa.transitions in\r\n\t\t\t{\r\n\t\t\t\talphabet = fa.alphabet;\r\n\t\t\t\tstates = newSts;\r\n\t\t\t\tinitialState = newInitSt;\r\n\t\t\t\ttransitions = newTrans;\r\n\t\t\t\tacceptStates = newAccSts\r\n\t\t\t}\r\n\r\n\t(**\r\n\t* This function verifies if the automaton is minimal\r\n\t* @returns boolean -> true if automaton is minimal, false otherwise\r\n\t* Desc: The given automaton is considered minimal if the result of minimizing it is an automaton with the same\r\n\t* number of states\r\n\t*)\r\n\tlet isMinimized (fa: t): bool =\r\n\t\tlet min = minimize fa in\r\n\t\t\tSet.size fa.states = Set.size min.states\r\nend\r\n\r\nmodule FiniteAutomaton =\r\nstruct\r\n\tinclude FiniteAutomatonSupport\r\n\topen FiniteAutomatonAccept\r\n\topen FiniteAutomatonGenerate\r\n\topen FiniteAutomatonPrivate\r\n\r\n\t(* Make *)\r\n\tlet make2 (arg: t Arg.alternatives): Entity.t * t = make2 arg validate\r\n\tlet make (arg: t Arg.alternatives): t = make arg validate\r\n\r\n\t(* Exercices support *)\r\n\tlet checkProperty (fa: t) (prop: string) =\r\n\t\tmatch prop with\r\n\t\t\t| \"deterministic\" -> isDeterministic fa\r\n\t\t\t| \"minimized\" -> isMinimized fa\r\n\t\t\t| \"finite automaton\" -> true\r\n\t\t\t| _ -> Model.checkProperty prop\r\n\tlet checkExercise ex fa = Model.checkExercise ex (accept fa) (checkProperty fa)\t\r\n\tlet checkExerciseFailures ex fa = Model.checkExerciseFailures ex (accept fa) (checkProperty fa)\r\n\r\n\t(* Ops *)\r\n\tlet stats = Model.stats\r\n\tlet accept = accept\r\n\tlet acceptFull = acceptFull\r\n\tlet generate = generate\t\r\n\tlet toDeterministic = toDeterministic\t\r\n\r\n\t(* Class *)\r\n\tclass model (arg: t Arg.alternatives) =\r\n\t\tobject(self) inherit Model.model (make2 arg) as super\t\r\n\t\t(* Representation *)\r\n\t\t\tmethod representation = representation\r\n\t\t(* Kind *)\r\n\t\t\tmethod isFiniteAutomaton : bool = true\r\n\t\t(* Show *)\t\t\t\r\n\t\t\tmethod toJSon: JSon.t = toJSon representation\r\n\t\t\tmethod toJSon2: JSon.t = toJSon2 id representation\r\n\t\t\tmethod show: unit = show representation\r\n\t\t\tmethod show2: unit = show2 id representation\r\n\t\t(* Ops *)\r\n\t\t\tmethod acceptBreadthFirst (w: word): bool = acceptBreadthFirst representation w\r\n\t\t\tmethod accept (w: word): bool = accept representation w\r\n\t\t\tmethod acceptFull (w: word) : bool * path * trail = acceptFull representation w\r\n\r\n\t\t\tmethod acceptWithTracing (w:word): unit = acceptWithTracing representation w\r\n\t\t\tmethod generate (length: int): words = generate representation length\r\n\t\t\tmethod generateUntil (length: int): words = generateUntil representation length\r\n\r\n\t\t\tmethod reachable (s:state): states = reachable representation s\r\n\t\t\tmethod productive: states = productive representation\r\n\t\t\tmethod getUsefulStates: states = getUsefulStates representation\r\n\t\t\tmethod getUselessStates: states = getUselessStates representation\r\n\t\t\tmethod cleanUselessStates: model =\r\n\t\t\t\tlet fa = cleanUselessStates representation in\r\n\t\t\t\t\tnew model (Arg.Representation fa)\r\n\t\t\tmethod areAllStatesUseful: bool = areAllStatesUseful representation\r\n\r\n\t\t\tmethod toDeterministic: model =\r\n\t\t\t\tlet fa = toDeterministic representation in\r\n\t\t\t\t\tnew model (Arg.Representation fa)\r\n\t\t\tmethod isDeterministic: bool = isDeterministic representation\r\n\r\n\t\t\tmethod equivalencePartition: states set = equivalencePartition representation\r\n\t\t\tmethod minimize: model =\r\n\t\t\t\tlet fa = minimize representation in\r\n\t\t\t\t\tnew model (Arg.Representation fa)\r\n\t\t\tmethod isMinimized: bool = isMinimized representation\r\n\t\t(* Exercices support *)\r\n\t\t\tmethod checkProperty (prop: string) = Util.println[\"WWW\"]; checkProperty representation prop\r\n\t\t\t\t\r\n\t\t(* Learn-OCaml support *)\r\n\t\t\tmethod moduleName = moduleName\r\n\t\t\tmethod xTypeName = xTypeName\r\n\t\t\tmethod xTypeDeclString : string = prelude\r\n\t\t\tmethod toDisplayString (name: string): string = solution name self#representation\r\n\t\t\tmethod example : JSon.t = example\r\n\t\tend\r\nend\r\n\r\nmodule FiniteAutomatonTop =\r\nstruct\r\n\topen FiniteAutomaton\r\n\topen FiniteAutomatonX\r\n\r\n\tlet faI fa = internalize fa\r\n\tlet faX fa = externalize fa\r\n\r\n\tlet fa_load file = faX (make (Arg.File file))\r\n\tlet fa_text text = faX (make (Arg.Text text))\r\n\tlet fa_json json = faX (make (Arg.JSon json))\r\n\tlet fa_predef name = fa_text (Examples.example name)\r\n\r\n\r\n\tlet confX (s, w) = (state2str s, word2str w)\r\n\tlet pathX (p: path) = pathX confX p\r\n\tlet trailX (t: trail) = trailX confX t\r\n\t\r\n\tlet stats () = RuntimeControl.stats ()\r\n\r\n\tlet fa_accept fa w = accept (faI fa) (wordI w)\r\n\r\n\tlet fa_path fa w =\r\n\t\tlet (r,p,t) = acceptFull (faI fa) (wordI w) in\r\n\t\t\tpathX p\r\n\r\n\tlet fa_trail fa w =\r\n\t\tlet (r,p,t) = acceptFull (faI fa) (wordI w) in\r\n\t\t\ttrailX t\r\n\r\n\tlet fa_generate fa len = wordsX (generate (faI fa) len)\r\n\r\nend\r\n\r\nopen FiniteAutomatonTop\r\n\r\n\r\n(*\r\n\r\n--------------------\r\nlet fa = fa_predef \"dfa_astar\";;\r\n\r\nfa_generate fa 8;;\r\n\r\nfa_accept fa \"aaaa\";;\r\nfa_accept fa \"aaaca\";;\r\n\r\nfa_path fa \"aaaa\";;\r\nfa_path fa \"aaaca\";;\r\n\r\nfa_trail fa \"aaaa\";;\r\n--------------------\r\n\r\n#print_depth 10000;;\r\n#print_length 10000;;\r\n\r\n\r\n\r\nlet fa_astar = {| {\r\n\t\tkind : \"finite automaton2\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"dfa_astar\",\r\n\t\talphabet: [\"a\"],\r\n\t\tstates : [\"START\", \"Z1\"],\r\n\t\tinitialState : \"START\",\r\n\t\ttransitions : [\r\n\t\t\t[\"START\", \"a\", \"START\"],\r\n\t\t\t[\"START\", \"~\", \"START\"],\t\t\t\r\n\t\t\t[\"START\", \"~\", \"Z\"],\t\t\t\r\n\t\t\t[\"Z\", \"a\", \"Z\"],\r\n\t\t\t[\"START\", \"a\", \"Z\"]\r\n\t\t],\r\n\t\tacceptStates : [\"START\", \"Z\"]\r\n\t\t} |}\r\n;;\r\nlet fa = fa_text fa_astar;;\r\n\r\n\r\nfa_accept fa \"aaa\";;\r\nfa_accept fa \"aab\";;\r\n\r\nfa_path fa \"aaa\";;\r\nfa_trail fa \"aaa\";;\r\n\r\n\r\nlet rec str n =\r\n\tif n = 0 then \"\"\r\n\telse \"a\" ^ str (n-1)\r\n;;\r\n\r\nlet res (r,p,t) = r;;\r\n\r\n\r\n\r\nlet n = 10;;\r\nlet big = str 20;;\r\nlet bign = (str 10) ^ \"b\" ^ (str 10);;\r\nlet big3 = str (2*n);;\r\nlet bign3 = (str n) ^ \"b\" ^ (str n);;\r\n\r\n\r\nlet z = 1500 ;;\r\nlet r = fa_accept fa ((str z));;\r\nstats ();;\r\nlet r = res (fa_acceptFull fa (str z));;\r\nstats ();;\r\n\r\n\r\n\r\n\r\n\r\nlet a = fa_accept fa bign;;\r\nstats ();;\r\nlet t = fa_acceptTrail fa  bign;;\r\nstats ();;\r\nlet p = fa_acceptPath fa  bign;;\r\nstats ();;\r\nlet (r,p,t) = fa_acceptFull fa  bign;;\r\nstats ();;\r\n\r\n*)\r\n\r\n# 1 \"src/RegularExpressionSupport.ml\"\r\n(*\r\n * RegularExpressionSupport.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * sep/2022 (amd) - New submodules RegularExpressionConversions and RegularExpressionLearnOCaml\r\n * jul/2021 (amd) - Now this module is client of the Scanner module and\r\n *                  the erros are registered using the Error module.\r\n * jan/2021 (amd) - Module in an independent file.\r\n * jun/2019 (amd) - Initial version, inside the big file \"OCamlFlatSupport.ml\".\r\n *)\r\n\r\n(*\r\n * Description: Support types and functions for REs including a parser for REs.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule RegularExpressionBasics =\r\nstruct\r\n\ttype t =\r\n\t\t| Plus of t * t\r\n\t\t| Seq of t * t\r\n\t\t| Star of t\r\n\t\t| Symb of symbol\r\n\t\t| Empty\r\n\t\t| Zero\r\n\r\n\ttype reTree =\r\n\t\t| Fail\r\n\t\t| Tree of word * t * reTree list\r\n\r\n\tlet kind = \"regular expression\"\r\n\r\n\tlet re_zero: t =\r\n\t\tZero\r\nend\r\n\r\nmodule type RegularExpressionSyntaxSig =\r\nsig\r\n\topen RegularExpressionBasics\r\n\t\r\n\tval parse : string -> t\r\n\tval toString : t -> string\r\n\tval show : t -> unit\r\nend\r\n\r\nmodule RegularExpressionSyntax : RegularExpressionSyntaxSig =\r\nstruct\r\n\topen Scanner\r\n\topen RegularExpressionBasics\r\n\r\n\t(*\tGrammar:\r\n\t\t\tE -> E + E | E E | E* | c | (E) | ()\r\n\r\n\t\tGrammar with priorities:\r\n\t\t\tE -> T | T + E\r\n\t\t\tT -> F | F T\r\n\t\t\tF -> A | A*\r\n\t\t\tA -> P | c\r\n\t\t\tP -> (E) | ()\r\n\t*)\r\n\tlet rec parseExp () =\r\n\t\tlet t = parseTerm () in\r\n\t\t\tmatch peek() with\r\n\t\t\t\t| '+' -> skip(); Plus (t, parseExp ())\r\n\t\t\t\t| _ -> t\r\n\r\n\tand parseTerm () =\r\n\t\tlet f = parseFactor () in\r\n\t\t\tmatch peek() with\r\n\t\t\t\t| '+' | ')' | ' ' -> f\r\n\t\t\t\t| _ -> Seq (f, parseTerm ())\r\n\r\n\tand parseFactor () =\r\n\t\tlet a = parseAtom () in\r\n\t\t\tmatch peek() with\r\n\t\t\t\t| '*' -> skip(); (Star a)\r\n\t\t\t\t| _ -> a\r\n\r\n\tand parseAtom () =\r\n\t\tmatch peek() with\r\n\t\t\t| '~' -> skip(); Empty\r\n\t\t\t| '!' -> skip(); Zero\r\n\t\t\t| '(' -> skip(); parseParentised ()\r\n\t\t\t| '+' | '*' -> invalid \"Invalid use of wildcard\\n\"\r\n\t\t\t| ' ' -> invalid \"Premature end of expression\\n\"\r\n\t\t\t| c -> skip(); (Symb (char2symb c))\r\n\r\n\tand parseParentised () =\r\n\t\tlet e = parseExp () in (\r\n\t\t\tmatch peek() with\r\n\t\t\t\t| ')' -> skip(); e\r\n\t\t\t\t| _ -> invalid \"Right-parenthesis expected\\n\"\r\n\t\t)\r\n\r\n\tlet parse s =\r\n\t\tScanner.start \"RegExpSyntax\" s;\r\n\t\ttry\r\n\t\t\tparseExp ()\r\n\t\twith Not_found ->\r\n\t\t\tZero\r\n\r\n\tlet rec toStringN n re =\r\n\t\tmatch re with\r\n\t\t\t| Plus(l, r) ->\r\n\t\t\t\t\t(if n > 0 then \"(\" else \"\") ^\r\n\t\t\t\t\ttoStringN 0 l ^ \"+\" ^ toStringN 0 r\r\n\t\t\t\t\t^ (if n > 0 then \")\" else \"\")\r\n\t\t\t| Seq(l, r) ->\r\n\t\t\t\t\t(if n > 1 then \"(\" else \"\") ^\r\n\t\t\t\t\ttoStringN 1 l ^ toStringN 1 r\r\n\t\t\t\t\t^ (if n > 1 then \")\" else \"\")\r\n\t\t\t| Star(r) ->\r\n\t\t\t\t\ttoStringN 2 r ^ \"*\"\r\n\t\t\t| Symb(c) -> symb2str c\r\n\t\t\t| Empty -> \"~\"\r\n\t\t\t| Zero -> \"!\"\r\n\r\n\tlet toString re =\r\n\t\ttoStringN 0 re\r\n\r\n\tlet show re =\r\n\t\tUtil.println [toString re]\r\nend\r\n\r\nmodule RegularExpressionConversions =\r\nstruct\r\n\topen RegularExpressionBasics\r\n\r\n\tlet fromJSon (j: JSon.t): t =\r\n\t\tif JSon.isNull j || not (JSon.hasField j \"kind\") then\r\n\t\t\tre_zero\r\n\t\telse\r\n\t\t\tlet re = JSon.fieldString j \"re\" in\r\n\t\t\t\tRegularExpressionSyntax.parse re\r\n\r\n\tlet toJSon0 (rep: t): JSon.t =\r\n\tJSon.makeAssoc [\r\n\t\t\t(\"re\", JSon.makeString (RegularExpressionSyntax.toString rep));\r\n\t\t]\r\n\r\n\tlet toJSon2 (id: Entity.t) (rep: t): JSon.t =\r\n\t\t JSon.append (Entity.toJSon id) (toJSon0 rep)\r\n\r\n\tlet toJSon (rep: t): JSon.t = \r\n\t\ttoJSon2 (Entity.dummyId kind) rep\r\nend\r\n\r\n\r\nmodule RegularExpressionBasicFunctions =\r\nstruct\r\n\topen RegularExpressionBasics\r\n\topen RegularExpressionConversions\r\n\t\r\n\tlet make2 (arg: t Arg.alternatives) validate: Entity.t * t =\r\n\t\tEntity.make2 arg fromJSon kind validate\r\n\r\n\tlet make (arg: t Arg.alternatives) validate: t =\r\n\t\tsnd (make2 arg validate)\r\n\r\n\tlet show (rep: t): unit =\r\n\t\tlet j = toJSon rep in\r\n\t\t\tJSon.show j\r\n\r\n\tlet show2 (id: Entity.t) (rep: t): unit =\r\n\t\tlet j = toJSon2 id rep in\r\n\t\t\tJSon.show j\r\nend\r\n\r\nmodule RegularExpressionX =\r\nstruct\r\n\topen RegularExpressionBasics\r\n\t\r\n\ttype tx = string\r\n\r\n\tlet internalize (re: tx): t =\r\n\t\tRegularExpressionSyntax.parse re\r\n\r\n\tlet externalize (re: t): tx =\r\n\t\tRegularExpressionSyntax.toString re\r\nend\r\n\r\nmodule RegularExpressionLearnOCaml =\r\nstruct\r\n\topen RegularExpressionBasics\r\n\topen RegularExpressionX\r\n\r\n\tlet moduleName =\r\n\t\t\"RegularExpression\"\r\n\r\n\tlet xTypeName =\r\n\t\t\"regularExpression\"\r\n\r\n\tlet solution (name: string) (rep: t): string =\r\n\t\tlet repx = externalize rep in\r\n\t\tPrintf.sprintf {zzz|\r\n\t\t%s\t%s\r\n\t\t|zzz}\t(* please, do not change this line *)\r\n\t\t\t(FiniteEnumerationLearnOCaml.displayHeader name xTypeName)\r\n\t\t\t(strD repx)\r\n\r\n\tlet prelude : string = {|\r\n\t\ttype regularExpression = string\r\n\t\t|}\t(* please, do not change this line *)\r\n\r\n\tlet example : JSon.t =\r\n\t\tJSon.parse {| {\r\n\t\t\tkind : \"regular expression\",\r\n\t\t\tdescription : \"this is a simple example\",\r\n\t\t\tname : \"re example\",\r\n\t\t\tre : \"w*+(w+yz)*\"\r\n\t\t}\r\n\t\t|}\t(* please, do not change this line *)\r\nend\r\n\r\nmodule RegularExpressionSupport =\r\nstruct\r\n\tinclude RegularExpressionBasics\r\n\tinclude RegularExpressionSyntax\r\n\tinclude RegularExpressionConversions\r\n\tinclude RegularExpressionBasicFunctions\r\n\tinclude RegularExpressionLearnOCaml\r\nend\r\n\r\nmodule RegularExpressionSyntaxTests : sig end =\r\nstruct\r\n\tlet active = false\r\n\r\n\tlet test0 () =\r\n\t\tlet re = RegularExpressionSyntax.parse \"ab+~*\" in\r\n\t\t\tRegularExpressionSyntax.show re\r\n\r\n\tlet test1 () =\r\n\t\tlet re = RegularExpressionSyntax.parse \"~((a+b)*(cd)*)*\" in\r\n\t\t\tRegularExpressionSyntax.show re\r\n\r\n\tlet runAll =\r\n\t\tif Util.testing active \"RegularExpressionSyntax\" then begin\r\n\t\t\ttest0 ();\r\n\t\t\ttest1 ()\r\n\t\tend\r\nend\r\n# 1 \"src/RegularExpression.ml\"\r\n(*\r\n * RegularExpression.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by João Gonçalves (jg)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * set/2022 (amd) - Full restructuration.\r\n * jul/2021 (amd) - Improved Learn-OCaml support and error handling.\r\n * may/2021 (amd) - Added support for an extern representation.\r\n * jan/2021 (amd) - Module in an independent file and some cleanup.\r\n * dec/2019 (jg) - Main functionalities.\r\n * jun/2019 (amd) - Initial skeleton, inside the big file \"OCamlFlat.ml\".\r\n *)\r\n\r\n(*\r\n * Description: Regular expressions functionality.\r\n *\r\n * TODO: More cleanup. Improve the regular expression simplifier.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule RegularExpressionPartialDerivative =\r\nstruct\r\n\topen RegularExpressionSupport\r\n\r\n\tlet rec hasEmpty (rep: t): bool =\r\n\t\tmatch rep with\r\n\t\t| Plus(l, r) -> hasEmpty l && hasEmpty r\r\n\t\t| Seq(l, r) -> hasEmpty l || hasEmpty r\r\n\t\t| Star _ | Empty -> true\r\n\t\t| _ -> false\r\n\r\n\tlet rightConcat (s: t set) (rep: t): t set =\r\n\t\tmatch rep with\r\n\t\t| Empty -> s\r\n\t\t| Zero -> Set.empty\r\n\t\t| _ -> Set.map (fun e -> Seq(e,rep)) s\r\n\r\n\tlet rec partialDerivative (rep: t) (a: symbol): t set =\r\n\t\tlet pd = partialDerivative in\r\n\t\tmatch rep with\r\n\t\t| Plus(l, r) -> Set.union (pd l a) (pd r a)\r\n\t\t| Seq(l, r) when hasEmpty l -> Set.union (rightConcat (pd l a) r) (pd r a)\r\n\t\t| Seq(l, r) -> rightConcat (pd l a) r\r\n\t\t| Star r -> rightConcat (pd r a) (Star r)\r\n\t\t| Symb c when c=a -> Set.make [Empty]\r\n\t\t| Symb c -> Set.empty\r\n\t\t| Empty -> Set.empty\r\n\t\t| Zero -> Set.empty\r\n\r\n\tlet partialDerivativeUno (rep: t) (a: symbol): t =\r\n\t\tlet s = partialDerivative rep a in\r\n\t\t\tSet.fold_right ((fun r s -> Plus(r,s))) s Zero\r\nend\r\n\r\nmodule RegularExpressionPrivate =\r\nstruct\r\n\topen RegularExpressionSupport\r\n\r\n\t(** aux *)\r\n\tlet seqConcat aset bset = Set.flatMap (fun s1 -> Set.map (fun s2 -> s1@s2) bset) aset\r\n\r\n\tlet validate (name: string) (rep: t): unit =\r\n\t\t(\r\n\r\n\t\t\t\t\t\t(*\r\n\t\t\t\tlet representation = RegExpSyntax.parse \"(((xx+ut)+(aaa+dss+ghf)+(xx+uu))ee)+bgc*+(jgg+bgcd)\" in\r\n\r\n\t\t\t\tlet rec lang rep =\r\n\t\t\t\t\tmatch rep with\r\n\t\t\t\t\t\t| RegExpSyntax.Plus(l, r) -> Util.print \"pls: \"; Util.print (RegExpSyntax.toString l); Util.print \", \";\r\n\t\t\t\t\t\tUtil.print (RegExpSyntax.toString r); Util.println \"\"; Set.union (lang l) (lang r)\r\n\t\t\t\t\t\t| RegExpSyntax.Seq(l, r) -> Util.print \"seq: \"; Util.print (RegExpSyntax.toString l); Util.print \", \";\r\n\t\t\t\t\t\tUtil.print (RegExpSyntax.toString r); Util.println \"\"; Set.union (lang l) (lang r)\r\n\t\t\t\t\t\t| RegExpSyntax.Star(r) -> Util.print \"str: \"; Util.print (RegExpSyntax.toString r); Util.println \"\"; (lang r)\r\n\t\t\t\t\t\t| RegExpSyntax.Symb(c) -> Set.make [c]\r\n\t\t\t\t\t\t| RegExpSyntax.Empty -> Set.empty\r\n\t\t\t\t\t\t| RegExpSyntax.Zero -> Set.empty\r\n\t\t\t\tin\r\n\t\t\t\tlet a = lang representation in\r\n\t\t\t\t()\r\n\t\t\t\t*)\r\n\t\t)\r\n\r\n\r\n\t(**\r\n\t* This method generates the alphabet of all symbols in the expression\r\n\t* @returns symbols -> the set of all symbols in the expression's alphabet\r\n\t*)\r\n\tlet rec alphabet rep: symbols =\r\n\tmatch rep with\r\n\t\t| Plus(l, r) -> Set.union (alphabet l) (alphabet r)\r\n\t\t| Seq(l, r) -> Set.union (alphabet l) (alphabet r)\r\n\t\t| Star(r) -> alphabet r\r\n\t\t| Symb(c) -> Set.make [c]\r\n\t\t| Empty -> Set.empty\r\n\t\t| Zero -> Set.empty\r\n\r\n\t(**\r\n\t* This method generates the language of the regular expression for when klenne is always zero\r\n\t* @returns words -> set of generated words\r\n\t*)\r\n\tlet rec quasiLanguage rep: words =\r\n\t\tmatch rep with\r\n\t\t| Plus(l, r) -> Set.union (quasiLanguage l) (quasiLanguage r)\r\n\t\t| Seq(l, r) -> seqConcat (quasiLanguage l) (quasiLanguage r)\r\n\t\t| Star(r) -> Set.make [[]]\r\n\t\t| Symb(c) -> Set.make [[c]]\r\n\t\t| Empty -> Set.empty\r\n\t\t| Zero -> Set.empty\r\n\r\n\t(** aux *)\r\n\tlet partition w =\r\n\t\tlet rec partX w pword =\r\n\t\t\tmatch w with\r\n\t\t\t\t[] -> Set.empty\r\n\t\t\t\t| x::xs -> let fwp = pword@[x] in\r\n\t\t\t\t\t\t\t\tSet.add (fwp, xs) (partX xs fwp) in\r\n\t\tSet.add ([],w) (partX w [])\r\n\r\n\t(**\r\n\t* This method tests if a given word is accepted by the regular expression\r\n\t* @param w:word -> word to be tested for acceptance\r\n\t* @returns bool -> true if w is accepted and false otherwise\r\n\t*)\r\n\tlet rec accept rep (w: word): bool =\r\n\t\tmatch rep with\r\n\t\t| Plus(l, r) -> (accept l w) || (accept r w)\r\n\t\t| Seq(l, r) ->\r\n\t\t\tlet wpl = partition w in\r\n\t\t\t\tSet.exists (fun (wp1,wp2) -> (accept l wp1) && (accept r wp2)) wpl\r\n\t\t| Star(re) ->\r\n\t\t\tw = []\r\n\t\t\t|| (let wpl = Set.remove ([],w) (partition w) in\r\n\t\t\t\t\tSet.exists (fun (wp1,wp2) -> (accept re wp1) && (accept (Star re) wp2)) wpl)\r\n\t\t| Symb(c) -> w = [c]\r\n\t\t| Empty -> w = []\r\n\t\t| Zero -> false\r\n\r\n\t(**\r\n\t* This method returns the derivation tree for the word acceptance\r\n\t* @param w:word -> word to be tested for acceptance\r\n\t* @returns reTree list -> list of derivation trees\r\n\t*)\r\n\tlet allTrees rep w : unit =\r\n\r\n\t\tlet rec acc rep w =\r\n\t\t\tmatch rep with\r\n\t\t\t| Plus(l, r) ->\r\n\t\t\t\tlet l1 = acc l w in\r\n\t\t\t\tlet r1 = acc r w in\r\n\t\t\t\t\tList.map (fun t -> Tree (w, rep, [t])) (l1 @ r1)\r\n\r\n\t\t\t| Seq(l, r) ->\r\n\t\t\t\tlet wps = partition w in\r\n\t\t\t\tlet wpl = Set.toList wps in\r\n\t\t\t\tList.flatten ( List.map (fun (wp1, wp2) ->\r\n\t\t\t\t\tlet tl = acc l wp1 in\r\n\t\t\t\t\tlet tr = acc r wp2 in\r\n\t\t\t\t\t\tList.flatten (List.map (fun x -> List.map\r\n\t\t\t\t\t\t\t(fun y -> Tree (w, rep, [x; y])) tr)tl)\r\n\t\t\t\t) wpl)\r\n\r\n\t\t\t| Star(re) ->\r\n\t\t\t\tif w = [] then\r\n\t\t\t\t\t[Tree ([epsilon], rep, [])]\r\n\t\t\t\telse\r\n\t\t\t\t\t(let wps = Set.remove ([],w) (partition w) in\r\n\t\t\t\t\tlet wpl = Set.toList wps in\r\n\t\t\t\t\tList.flatten (List.map (fun (wp1, wp2) ->\r\n\t\t\t\t\t\tlet tl = acc re wp1 in\r\n\t\t\t\t\t\tlet tr = acc (Star re) wp2 in\r\n\t\t\t\t\t\tList.flatten (List.map (fun x -> List.map\r\n\t\t\t\t\t\t\t(fun y -> Tree (w, rep, [x; y])) tr) tl)) wpl))\r\n\r\n\t\t\t| Symb(c) ->\r\n\t\t\t\tif w = [c] then\r\n\t\t\t\t\t[Tree (w, rep, [])]\r\n\t\t\t\telse\r\n\t\t\t\t\t[Tree (w, rep, [Fail])]\r\n\r\n\t\t\t| Empty ->\r\n\t\t\t\tif w = [] then\r\n\t\t\t\t\t[Tree ([epsilon], rep, [])]\r\n\t\t\t\telse\r\n\t\t\t\t\t[Tree (w, rep, [Fail])]\r\n\r\n\t\t\t| Zero -> [Tree (w, rep, [Fail])]\r\n\r\n\t\tin\r\n\r\n\t\tlet ac = acc rep w in\r\n\r\n\r\n\r\n\t\tlet rec isNotFail t =\r\n\t\t\tmatch t with\r\n\t\t\t\tFail -> false\r\n\t\t\t\t| Tree ([], re, []) -> true\r\n\t\t\t\t| Tree (w, re, []) -> true\r\n\t\t\t\t| Tree ([], re, x::xs) -> (isNotFail x) && (isNotFail (Tree ([], re, xs)))\r\n\t\t\t\t| Tree (w, re, x::xs) -> (isNotFail x) && (isNotFail (Tree (w, re, xs)))\r\n\t\tin\r\n\r\n\t\tlet ts = List.filter (fun t -> isNotFail t) ac in\r\n\r\n\r\n\t\tlet printTreeX w re n =\r\n\t\t\tlet s = String.make (3*n) ' ' in\r\n\t\t\tUtil.println [s; word2str w; \" -> \"; RegularExpressionSyntax.toString re]\r\n\t\tin\r\n\r\n\t\tlet rec printTree t n =\r\n\t\t\tmatch t with\r\n\t\t\t\tFail -> Util.println [\"Fail\"]\r\n\t\t\t\t| Tree ([], re, []) -> Util.println [\"TREH \"]\r\n\t\t\t\t| Tree (w, re, []) -> printTreeX w re n\r\n\t\t\t\t| Tree ([], re, x::xs) -> printTreeX [] re n; printTree x (n+1); List.iter (fun t -> printTree t (n+1)) xs\r\n\t\t\t\t| Tree (w, re, x::xs) -> printTreeX w re n; printTree x (n+1); List.iter (fun t -> printTree t (n+1)) xs\r\n\t\tin\r\n\r\n\t\t\tList.iter (fun t -> printTree t 0) ts\r\n\r\n\r\n\t(**\r\n\t* This method generates all words up to the given length that are generated by the regular expression\r\n\t* @param length:int -> maximum length of all generated words\r\n\t* @returns words -> set of generated words\r\n\t*)\r\n\tlet rec generate rep (len: int): words =\r\n\t\tmatch rep with\r\n\t\t| Plus(l, r) ->\r\n\t\t\t\tSet.union (generate l len) (generate r len)\r\n\t\t| Seq(l, r) ->\r\n\t\t\t\tlet left = generate l len in\r\n\t\t\t\tlet rigth w = generate r (len - (List.length w)) in\r\n\t\t\t\tlet conc w = Util.concatAll w (Set.toList (rigth w)) in\r\n\t\t\t\t\tSet.flatMap (fun lw -> Set.make (conc lw)) left\r\n\t\t| Star r ->\r\n\t\t\t\tlet exp = generate r len in\r\n\t\t\t\t\tSet.star exp len\r\n\r\n\t\t\t(* alternate version of star, leave 4 now\r\n\r\n\t\t\tlet rec starX ws sz =\r\n\t\t\t\tif sz <= 0 then Set.make [[]]\r\n\t\t\t\telse\r\n\t\t\t\t\tlet ws = Set.filter (fun x -> sz >= (List.length x)) ws in\r\n\t\t\t\t\tlet newLn w = sz - (List.length w) in\r\n\t\t\t\t\tlet tail w ws = Set.toList (starX ws (newLn w)) in\r\n\t\t\t\t\tlet conc w ws = Util.concatAll w (tail w ws) in\r\n\t\t\t\t\tlet track w ws = Set.add w (Set.make (conc w ws)) in\r\n\t\t\t\t\t\tSet.flatMap (fun w -> if w = [] then Set.make [[]] else track w ws) ws in\r\n\t\t\tlet exp = generate r len in\r\n\t\t\t\tSet.add [] (starX exp len)*)\r\n\r\n\t\t| Symb(c) -> if len > 0 then Set.make [[c]] else Set.empty\r\n\t\t| Empty -> Set.make [[]]\r\n\t\t| Zero -> Set.empty\r\n\r\n\r\n\t(**\r\n\t* This method simplifies the regular expression\r\n\t*\r\n\t* @returns RegularExpression.model -> the new simplified, equivalent expression\r\n\t*)\r\n\tlet simplify (rep: t): t =\r\n\r\n\t  (* various base case simplification rules to apply to the given expressions *)\r\n\t  let simpX re =\r\n\t\tmatch re with\r\n\t\t\t(* plus *)\r\n\t\t\t(* a* + empty -> a*  *)\r\n\t\t\t| Plus(Star(l), Empty) -> Star(l)\r\n\t\t\t| Plus(Empty, Star(r)) -> Star(r)\r\n\t\t\t(* a + zero = a  *)\r\n\t\t\t| Plus(Zero, r) -> r\r\n\t\t\t| Plus(l, Zero) -> l\r\n\t\t\t(* ~ + aa* = a*  *)\r\n\t\t\t| Plus(Empty, Seq(l, Star(r))) when l = r -> Star(r)\r\n\t\t\t| Plus(Empty, Seq(Star(l), r)) when l = r -> Star(l)\r\n\t\t\t| Plus(Seq(l, Star(r)), Empty) when l = r -> Star(r)\r\n\t\t\t| Plus(Seq(Star(l), r), Empty) when l = r -> Star(l)\r\n\t\t\t(* a* + a + empty = a* ????? *)\r\n\t\t\t| Plus(Star(l), Plus(Empty, r)) when l = r -> Star(l)\r\n\t\t\t| Plus(Star(l), Plus(r, Empty)) when l = r -> Star(l)\r\n\t\t\t| Plus(Plus(Empty, l), Star(r)) when l = r -> Star(r)\r\n\t\t\t| Plus(Plus(l, Empty), Star(r)) when l = r -> Star(r)\r\n\t\t\t(* a* + a = a* *)\r\n\t\t\t| Plus(Star(l), r) when l = r -> Star(l)\r\n\t\t\t| Plus(l, Star(r)) when l = r -> Star(r)\r\n\t\t\t(* a + a = a  *)\r\n\t\t\t| Plus(l, r) when l = r -> l\r\n\t\t\t(* seq *)\r\n\t\t\t| Seq(Empty, Empty) -> Empty\r\n\t\t\t| Seq(Zero, Zero) -> Zero\r\n\t\t\t| Seq(Empty, r) -> r\r\n\t\t\t| Seq(l, Empty) -> l\r\n\t\t\t| Seq(Zero, r) -> Zero\r\n\t\t\t| Seq(l, Zero) -> Zero\r\n\t\t\t(* (~+a)a* = a* *)\r\n\t\t\t| Seq(Plus(Empty, l),Star(r)) when l = r -> Star(r)\r\n\t\t\t| Seq(Plus(l, Empty),Star(r)) when l = r -> Star(r)\r\n\t\t\t| Seq(Star(l),Plus(Empty, r)) when l = r -> Star(l)\r\n\t\t\t| Seq(Star(l),Plus(r, Empty)) when l = r -> Star(l)\r\n\t\t\t| Seq(Star(l),Star(r)) when l = r -> Star(l)\r\n\t\t\t(* star a** = a* *)\r\n\t\t\t| Star(Star(r)) -> Star(r)\r\n\t\t\t(* star (~+a)* = a* *)\r\n\t\t\t| Star(Plus(Empty, r)) -> Star(r)\r\n\t\t\t| Star(Plus(r, Empty)) -> Star(r)\r\n\t\t\t(* star (~)* = ~ *)\r\n\t\t\t| Star(Empty) -> Empty\r\n\t\t\t(* star (0)* = ~ *)\r\n\t\t\t| Star(Zero) -> Empty\r\n\t\t\t(* other *)\r\n\t\t\t| _ -> re\r\n\t\tin\r\n\r\n\t\t(* applies various base case simplifications to the various sub-expressions of regular expression re *)\r\n\t\tlet rec simplify re =\r\n\r\n\t\t\tmatch re with\r\n\t\t\t\t| Plus(l,r) -> simpX (Plus(simplify l, simplify r))\r\n\t\t\t\t| Seq(l,r) -> simpX (Seq(simplify l, simplify r))\r\n\t\t\t\t| Star(re) -> simpX (Star(simplify re))\r\n\t\t\t\t| Symb(c) -> Symb c\r\n\t\t\t\t| Empty -> Empty\r\n\t\t\t\t| Zero -> Zero\r\n\t\tin\r\n\r\n\t\t\tsimplify rep\r\n\r\n\r\n\t\t\t(*CODIGO JP*)\r\n\r\n\ttype configuration =\r\n\t\tt * word\r\n\ttype configurations =\r\n\t\tconfiguration set\r\n\ttype path =\r\n\t\tconfiguration list\r\n\ttype trail =\r\n\t\tconfigurations list\r\n\r\n\tlet initialConfigs (rep: t) (w: word): configurations =\r\n\t\tSet.make [(rep, w)]\r\n\r\n\tlet nextConfigs (rep: t) (re, w) =\r\n\t\tmatch w with\r\n\t\t| [] -> Set.empty\r\n\t\t| x :: xs ->\r\n\t\t\tlet der = RegularExpressionPartialDerivative.partialDerivativeUno re x in\r\n\t\t\t\tif der = Zero then Set.empty\r\n\t\t\t\telse Set.make [(der, xs)]\r\n\r\n\tlet nextConfigs2 (rep: t) (re, w) : configurations =\r\n\t\tmatch w with\r\n\t\t\t| [] -> Set.empty\r\n\t\t\t| x :: xs ->\r\n\t\t\t\tlet der = RegularExpressionPartialDerivative.partialDerivative re x in\r\n\t\t\t\t\tSet.map (fun re -> (re,xs)) der \r\n\r\n\r\n\tlet isAcceptingConfig (rep: t) (re,w) : bool =\r\n\t\tRegularExpressionPartialDerivative.hasEmpty re && w = []\r\n\r\n\tlet accept (res: t) (w: word) : bool =\r\n\t\tModel.accept res w initialConfigs nextConfigs2 isAcceptingConfig\r\n\t\r\n\tlet acceptFull (res: t) (w: word) : bool * path * trail =\r\n\t\tModel.acceptFull res w initialConfigs nextConfigs2 isAcceptingConfig\r\n\r\n\t\tlet nextConfigs3 (_: t) (len: int) (re, w) : configurations = \r\n\t\t\tshow re;\r\n\t\t\tUtil.show (word2str w);\r\n\t\t\t\tSet.flatMap (fun sym ->\r\n\t\t\t\t\tUtil.show (symb2str sym);\r\n\t\t\t\t\tlet der = RegularExpressionPartialDerivative.partialDerivative re sym in\r\n\t\t\t\t\t\tSet.map (fun re -> (re, sym::w)) der \r\n\t\t\t\t\t) (alphabet re)\r\n\r\n\t\tlet isAcceptingConfig2 (rep: t) (re,w) =\r\n\t\t\tRegularExpressionPartialDerivative.hasEmpty re\r\n\r\n\t\tlet getWord (_, w) = List.rev w;;\r\n\r\n\t\tlet generate (rep: t) (len: int): words =\r\n\t\t\tModel.generate rep len initialConfigs nextConfigs3 isAcceptingConfig2 getWord\r\n\t\t\t\t\t\r\nend\r\n\r\nmodule RegularExpression =\r\nstruct\r\n\tinclude RegularExpressionSupport\r\n\topen RegularExpressionPartialDerivative\r\n\topen RegularExpressionPrivate\r\n\t\r\n\t(* Make *)\r\n\tlet make2 (arg: t Arg.alternatives): Entity.t * t = make2 arg validate\r\n\tlet make (arg: t Arg.alternatives): t = make arg validate\r\n\tlet show = show\r\n\r\n\t(* Exercices support *)\r\n\tlet checkProperty (re: t) (prop: string) =\r\n\t\tmatch prop with\r\n\t\t| \"regular expression\" -> true\r\n\t\t| _ -> Model.checkProperty prop\r\n\tlet checkExercise ex re = Model.checkExercise ex (accept re) (checkProperty re)\t\r\n\tlet checkExerciseFailures ex re = Model.checkExerciseFailures ex (accept re) (checkProperty re)\t\r\n\r\n\t(* Ops *)\r\n\tlet stats = Model.stats\r\n\tlet accept = accept\r\n\tlet generate = generate\r\n\tlet simplify = simplify\r\n\tlet partialDerivative = partialDerivative\r\n\tlet partialDerivativeUno = partialDerivativeUno\r\n\t\r\n\t(* Class *)\r\n\tclass model (arg: t Arg.alternatives) =\r\n\t\tobject(self) inherit Model.model (make2 arg) as super\r\n\t\t(* Representation *)\r\n\t\t\tmethod representation = representation\r\n\t\t(* Kind *)\r\n\t\t\tmethod isRegulartExpression : bool = true\r\n\t\t(* Show *)\t\t\t\r\n\t\t\tmethod toJSon: JSon.t = toJSon representation\r\n\t\t\tmethod toJSon2: JSon.t = toJSon2 id representation\r\n\t\t\tmethod show: unit = show representation\r\n\t\t\tmethod show2: unit = show2 id representation\r\n\t\t(* Ops *)\t\t\t\t\r\n\t\t\tmethod accept w = accept representation w\r\n\t\t\tmethod acceptFull (w: word) : bool * path * trail = acceptFull representation w\r\n\t\t\tmethod allTrees w = allTrees representation w\r\n\t\t\tmethod generate n = generate representation n\r\n\t\t\tmethod alphabet = alphabet representation\r\n\t\t\tmethod quasiLanguage = quasiLanguage representation\r\n\t\t\tmethod simplify = new model (Arg.Representation (simplify representation))\r\n\r\n\t\t\tmethod partialDerivative sy =\r\n\t\t\t\tlet s = partialDerivative representation sy in\r\n\t\t\t\t\tSet.map (fun rep -> new model (Arg.Representation rep)) s\r\n\r\n\t\t(* Exercices support *)\r\n\t\t\tmethod checkProperty (prop: string) = checkProperty representation prop\r\n\r\n\t\t(* Learn-OCaml support *)\r\n\t\t\tmethod moduleName = moduleName\r\n\t\t\tmethod xTypeName = xTypeName\r\n\t\t\tmethod xTypeDeclString : string = prelude\r\n\t\t\tmethod toDisplayString (name: string): string = solution name self#representation\r\n\t\t\tmethod example : JSon.t = example\r\n\t\tend\r\nend\r\n\r\nmodule RegularExpressionTop =\r\nstruct\r\n\topen RegularExpression\r\n(*\r\n\tlet reF file = make (Arg.File file)\r\n\tlet reT text = make (Arg.Text text)\r\n\tlet reI x = internalize x\r\n\tlet reX re = externalize (simplify re)\r\n\r\n\tlet re_load file = externalize (reF file)\r\n\tlet re_predef name = externalize (reT (Examples.example name))\r\n\tlet re_text text = externalize (reI text)\r\n\r\n\tlet re_accept re w = accept (reI re) (wordI w)\r\n\tlet re_pd re sy = reX (partialDerivativeUno (reI re) (symbI sy))\r\n*)\r\nend\r\n\r\nopen RegularExpressionTop\r\n\r\n(*\r\n\tlet re_build (text: string): RegularExpressionBasics.tx =\r\n\t\tlet re = new RegularExpression.model (Arg.Text text) in\r\n\t\t\tre#representationx\r\n\r\n\tlet re_predef (name: string): RegularExpressionBasics.tx =\r\n\t\tre_build (Examples.example name)\r\n\r\n\tlet re_convertTo (re: RegularExpressionBasics.t) : RegularExpressionBasics.tx =\r\n\t\tRegularExpression.toString re\r\n\r\n\tlet re_convertFrom (re: RegularExpressionBasics.tx): RegularExpressionBasics.t = RegularExpression.parse re\r\n\r\n\tlet re_accept (re: RegularExpressionBasics.tx) (w: string): bool =\r\n\t\tlet re = re_convertFrom re in\r\n\t\tlet a = new RegularExpression.model (Arg.Representation re) in\r\n\t\tlet w = str2word w in\r\n\t\t\ta#accept w\r\n*)\r\n# 1 \"src/TransducerSupport.ml\"\r\n(*\r\n * TransducerSupport.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * jul/2025 (amd) - New file.\r\n *)\r\n\r\n(*\r\n * Description: Supporting types and functions for Finite-state transducers.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule TransducerBasics =\r\nstruct\r\n\ttype transition4 = state * symbol * symbol * state\r\n\ttype transitions4 = transition4 set\r\n\ttype t = {\r\n\t\tinAlphabet : symbols;\r\n\t\toutAlphabet : symbols;\r\n\t\tstates : states;\r\n\t\tinitialState : state;\r\n\t\ttransitions : transitions4;\r\n\t\tacceptStates : states\r\n\t}\r\n\r\n\ttype configuration = state * word * word\r\n\ttype configurations = configuration set\r\n\ttype path = configuration list\r\n\ttype trail = configurations list\r\n\r\n\tlet kind = \"transducer\"\r\n\r\n\tlet fst_zero: t = {\r\n\t\tinAlphabet = Set.empty;\r\n\t\toutAlphabet = Set.empty;\r\n\t\tstates = Set.make [draftState];\r\n\t\tinitialState = draftState;\r\n\t\ttransitions = Set.empty;\r\n\t\tacceptStates = Set.empty\r\n\t}\r\nend\r\n\r\nmodule TransducerConversions =\r\nstruct\r\n\topen TransducerBasics\r\n\r\n\tlet fromJSon (j: JSon.t): t =\r\n\t\tif JSon.isNull j || not (JSon.hasField j \"kind\") then\r\n\t\t\tfst_zero\r\n\t\telse {\r\n\t\t\tinAlphabet = JSon.fieldSymbolSet j \"inAlphabet\";\r\n\t\t\toutAlphabet = JSon.fieldSymbolSet j \"outAlphabet\";\r\n\t\t\tstates = JSon.fieldStateSet j \"states\";\r\n\t\t\tinitialState = JSon.fieldState j \"initialState\";\r\n\t\t\ttransitions = JSon.fieldQuadsSet j \"transitions\";\r\n\t\t\tacceptStates = JSon.fieldStateSet j \"acceptStates\"\r\n\t\t}\r\n\r\n\tlet toJSon0 (rep: t): JSon.t =\r\n\t\tJSon.makeAssoc [\r\n\t\t\t(\"inAlphabet\", JSon.makeSymbolSet rep.inAlphabet);\r\n\t\t\t(\"outAlphabet\", JSon.makeSymbolSet rep.outAlphabet);\r\n\t\t\t(\"states\", JSon.makeStateSet rep.states);\r\n\t\t\t(\"initialState\", JSon.makeState rep.initialState);\r\n\t\t\t(\"transitions\", JSon.makeQuadsSet rep.transitions);\r\n\t\t\t(\"acceptStates\", JSon.makeStateSet rep.acceptStates)\r\n\t\t]\r\n\t\r\n\tlet toJSon2 (id: Entity.t) (rep: t): JSon.t =\r\n\t\t JSon.append (Entity.toJSon id) (toJSon0 rep)\r\n\t\r\n\tlet toJSon (rep: t): JSon.t =\r\n\t\t toJSon2 (Entity.dummyId kind) rep\r\nend\r\n\r\nmodule TransducerBasicFunctions =\r\nstruct\r\n\topen TransducerBasics\r\n\topen TransducerConversions\r\n\r\n\tlet make2 (arg: t Arg.alternatives) validate: Entity.t * t =\r\n\t\tEntity.make2 arg fromJSon kind validate\r\n\r\n\tlet make (arg: t Arg.alternatives) validate: t =\r\n\t\tsnd (make2 arg validate)\r\n\r\n\tlet show (rep: t): unit =\r\n\t\tlet j = toJSon rep in\r\n\t\t\tJSon.show j\r\n\r\n\tlet show2 (id: Entity.t) (rep: t): unit =\r\n\t\tlet j = toJSon2 id rep in\r\n\t\t\tJSon.show j\r\nend\r\n\r\nmodule TransducerX =\r\nstruct\r\n\topen TransducerBasics\r\n\r\n\ttype transition4X = state * symbolX * symbolX * state\r\n\ttype tx = {\r\n\t\tinAlphabet : symbolX list;\r\n\t\toutAlphabet : symbolX list;\r\n\t\tstates : state list;\r\n\t\tinitialState : state;\r\n\t\ttransitions : transition4X list;\r\n\t\tacceptStates : state list\r\n\t}\r\n\r\n\tlet transitions4I (l: transition4X list): transitions4 =\r\n\t\tlet trans4I (a,b,c,d): transition4 = (a, symbI b, symbI c, d) in\r\n\t\t\tSet.make (List.map trans4I l)\r\n\t\t\t\r\n\tlet transitions4X (s: transitions4): transition4X list =\r\n\t\tlet trans4X (a,b,c,d): transition4X = (a, symbX b, symbX c, d) in\r\n\t\t\tList.map trans4X (Set.toList s)\r\n\r\n\tlet internalize (fst: tx): t = {\r\n\t\tinAlphabet = symbolsI fst.inAlphabet;\r\n\t\toutAlphabet = symbolsI fst.outAlphabet;\r\n\t\tstates = Set.make fst.states;\r\n\t\tinitialState = fst.initialState;\r\n\t\ttransitions = transitions4I fst.transitions;\r\n\t\tacceptStates = Set.make fst.acceptStates\r\n\t}\r\n\t\r\n\tlet externalize (fst: t): tx = {\r\n\t\tinAlphabet = symbolsX fst.inAlphabet;\r\n\t\toutAlphabet = symbolsX fst.outAlphabet;\r\n\t\tstates = Set.toList fst.states;\r\n\t\tinitialState = fst.initialState;\r\n\t\ttransitions = transitions4X fst.transitions;\r\n\t\tacceptStates = Set.toList fst.acceptStates\r\n\t}\r\nend\r\n\r\nmodule TransducerLearnOCaml =\r\nstruct\r\n\topen TransducerBasics\r\n\topen TransducerX\r\n\r\n\tlet moduleName =\r\n\t\t\"Transducer\"\r\n\r\n\tlet xTypeName =\r\n\t\t\"finiteAutomaton\"\r\n\r\n\tlet transs4XD (l: transition4X list): string =\r\n\t\tlet t2d (a,b,c,d) =\r\n\t\t\tPrintf.sprintf \"(%s, %s, %s, %s)\"\r\n\t\t\t(stateXD a)\r\n\t\t\t(symbXD b)\r\n\t\t\t(symbXD c)\r\n\t\t\t(stateXD d)\r\n\t\tin listD t2d l\r\n\r\n\tlet solution (name: string) (rep: t): string =\r\n\t\tlet repx = externalize rep in\r\n\t\tPrintf.sprintf {zzz|\r\n\t\t%s{\r\n\t\t\tinAlphabet = %s;\r\n\t\t\toutAlphabet = %s;\r\n\t\t\tstates = %s;\r\n\t\t\tinitialState = %s;\r\n\t\t\ttransitions = %s;\r\n\t\t\tacceptStates = %s\r\n\t\t}\r\n\t\t|zzz}\t(* please, do not change this line *)\r\n\t\t\t(FiniteEnumerationLearnOCaml.displayHeader name xTypeName)\r\n\t\t\t(symbolsXD repx.inAlphabet)\r\n\t\t\t(symbolsXD repx.outAlphabet)\r\n\t\t\t(statesXD repx.states)\r\n\t\t\t(stateXD repx.initialState)\r\n\t\t\t(transs4XD repx.transitions)\r\n\t\t\t(statesXD repx.acceptStates)\r\n\r\n\r\n\tlet prelude : string =\r\n\t\tPrintf.sprintf {zzz|\r\n\t\ttype symbol = %s\r\n\t\ttype state = string\r\n\t\ttype finiteAutomaton = {\r\n\t\t\talphabet : symbol list;\r\n\t\t\tstates : state list;\r\n\t\t\tinitialState : state;\r\n\t\t\ttransitions : (state * symbol * state) list;\r\n\t\t\tacceptStates : state list\r\n\t\t}\r\n\t\t|zzz}\t(* please, do not change this line *)\r\n\t\t\tsymbolTypeName\r\n\r\n\tlet example : JSon.t =\r\n\t\tJSon.parse {|\r\n\t\t{\r\n\t\t\tkind : \"transducer\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"fst example\",\r\n\t\t\talphabet: [\"w\", \"z\"],\r\n\t\t\tstates : [\"START\", \"X\", \"Z\"],\r\n\t\t\tinitialState : \"START\",\r\n\t\t\ttransitions : [\r\n\t\t\t\t[\"START\", \"w\", \"w\", \"X\"], [\"X\", \"z\", \"z\", \"X\"]\r\n\t\t\t],\r\n\t\t\tacceptStates : [\"Z\"]\r\n\t\t}\r\n\t\t|}\t(* please, do not change this line *)\r\nend\r\n\r\nmodule TransducerSupport =\r\nstruct\r\n\tinclude TransducerBasics\r\n\tinclude TransducerConversions\r\n\tinclude TransducerBasicFunctions\r\n\tinclude TransducerLearnOCaml\r\nend\r\n# 1 \"src/Transducer.ml\"\r\n(*\r\n * Transducer.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by João Santos (js)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * jul/2025 (amd) - Initial skeleton.\r\n *)\r\n\r\n(*\r\n * Description: Finite-state transducer functionality.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule TransducerAccept =\r\nstruct\r\n\topen TransducerSupport\r\n\r\n\tlet accept (fst: t) (w: word): bool =\r\n\t\tfalse\r\n\r\n\tlet acceptFull (fa: t) (w: word) : bool * path * trail =\r\n\t\t(false, [], [])\r\nend\r\n\r\nmodule TransducerGenerate =\r\nstruct\r\n\topen TransducerSupport\r\n\topen TransducerAccept\r\n\r\n\tlet generate (fa: t) (len: int): words =\r\n\t\tSet.empty\r\n\r\n\tlet generateDumb (fa: t) (len: int): words =\r\n\t\tSet.empty\r\nend\r\n\r\nmodule TransducerPrivate =\r\nstruct\r\n\topen TransducerSupport\r\n\r\n\tlet validate (name: string) (fst: t): unit =\r\n\t\t()\t\r\n\t\r\n\tlet asFiniteAutomaton (fst:t): FiniteAutomaton.t =\r\n\t\tFiniteAutomaton.fa_zero\r\n\r\n\tlet cleanUselessStates (fst: t): t =\r\n\t\tfst\r\n\r\n\tlet isClean (fst: t): bool =\r\n\t\tfalse\r\n\r\n\tlet isDeterministic (fst: t): bool =\r\n\t\tfalse\r\n\r\n\tlet isComplete (fst: t): bool =\r\n\t\tfalse\r\n\r\n\tlet isMooreMachine (fst: t): bool =\r\n\t\tfalse\r\n\r\n\tlet isMeelyMachine (fst: t): bool =\r\n\t\tfalse\r\nend\r\n\r\nmodule Transducer =\r\nstruct\r\n\tinclude TransducerSupport\r\n\topen TransducerAccept\r\n\topen TransducerGenerate\r\n\topen TransducerPrivate\r\n\r\n\t(* Make *)\r\n\tlet make2 (arg: t Arg.alternatives): Entity.t * t = make2 arg validate\r\n\tlet make (arg: t Arg.alternatives): t = make arg validate\r\n\r\n\t(* Exercices support *)\r\n\tlet checkProperty (fst: t) (prop: string) =\r\n\t\tmatch prop with\r\n\t\t\t| \"deterministic\" -> isDeterministic fst\r\n\t\t\t| \"complete\" -> isComplete fst\r\n\t\t\t| \"moore\" -> isMooreMachine fst\r\n\t\t\t| \"meely\" -> isMeelyMachine fst\r\n\t\t\t| \"transducer\" -> true\r\n\t\t\t| \"finite-state transducer\" -> true\r\n\t\t\t| _ -> Model.checkProperty prop\r\n\tlet checkExercise ex fst = Model.checkExercise ex (accept fst) (checkProperty fst)\t\r\n\tlet checkExerciseFailures ex fst = Model.checkExerciseFailures ex (accept fst) (checkProperty fst)\r\n\r\n\t(* Ops *)\r\n\tlet stats = Model.stats\r\n\tlet accept = accept\r\n\tlet acceptFull = acceptFull\r\n\tlet generate = generate\t\r\n\r\n\t(* Class *)\r\n\tclass model (arg: t Arg.alternatives) =\r\n\t\tobject(self) inherit Model.model (make2 arg) as super\t\r\n\t\t(* Representation *)\r\n\t\t\tmethod representation = representation\r\n\t\t(* Kind *)\r\n\t\t\tmethod isTransducer : bool = true\r\n\t\t(* Show *)\t\t\t\r\n\t\t\tmethod toJSon: JSon.t = toJSon representation\r\n\t\t\tmethod toJSon2: JSon.t = toJSon2 id representation\r\n\t\t\tmethod show: unit = show representation\r\n\t\t\tmethod show2: unit = show2 id representation\r\n\t\t(* Ops *)\r\n\t\t\tmethod accept (w: word): bool = accept representation w\r\n\t\t\tmethod acceptFull (w: word) : bool * path * trail = acceptFull representation w\r\n\t\t\tmethod generate (length: int): words = generate representation length\r\n\t\t(* Exercices support *)\r\n\t\t\tmethod checkProperty (prop: string) = Util.println[\"WWW\"]; checkProperty representation prop\t\r\n\t\t(* Learn-OCaml support *)\r\n\t\t\tmethod moduleName = moduleName\r\n\t\t\tmethod xTypeName = xTypeName\r\n\t\t\tmethod xTypeDeclString : string = prelude\r\n\t\t\tmethod toDisplayString (name: string): string = solution name self#representation\r\n\t\t\tmethod example : JSon.t = example\r\n\t\tend\r\nend\r\n# 1 \"src/GrammarSupport.ml\"\r\n(*\r\n * GrammarSupport.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * jul/2024 (amd) - New file.\r\n *)\r\n\r\n(*\r\n * Description: Support types and functions for Formal Grammars,\r\n                including a parser.\r\n *)\r\n \r\nopen BasicTypes\r\n\r\nmodule GrammarBasics =\r\nstruct\r\n\ttype rule = { head : word; body : word }\r\n\ttype rules = rule set\r\n\r\n\ttype t = {\r\n\t\talphabet : symbols;\r\n\t\tvariables : variables;\r\n\t\tinitial : variable;\r\n\t\trules : rules\r\n\t}\r\n\t\r\n\ttype configuration =\r\n\t\tsymbol list * word\r\n\ttype configurations =\r\n\t\tconfiguration set\r\n\r\n\ttype path =\r\n\t\tconfiguration Path.path\r\n\ttype trail =\r\n\t\tconfiguration Trail.trail\r\n\r\n\ttype grTree =\r\n\t\t  Leaf of symbol\r\n\t\t| Root of symbol * grTree list\r\n\r\n\tlet kind = \"grammar\"\r\n\r\n\tlet gr_zero: t = {\r\n\t\talphabet = Set.empty;\r\n\t\tvariables = Set.make [draftVar];\r\n\t\tinitial = draftVar;\r\n\t\trules = Set.empty;\r\n\t}\r\nend\r\n\r\nmodule type GrammarSyntaxSig =\r\nsig\r\n\topen GrammarBasics\r\n\r\n\tval parse : string set -> rules\r\n\tval parseLine : string -> rules\r\n\tval toStringList : rules -> string list\r\n\tval (-->) : string -> string -> rule\r\n\tval rule2str : rule -> string\r\n\tval show : rules -> unit\r\nend\r\n\r\nmodule GrammarSyntax: GrammarSyntaxSig =\r\nstruct\r\n\topen Scanner\r\n\topen GrammarBasics\r\n\r\n\tlet isWhite c =\r\n\t\tList.mem c [' '; '\\t']\r\n\r\n\tlet parseString delim =\r\n\t\tskip();\t(* skip quotation mark *)\r\n\t\tlet tk = getUntil delim in\r\n\t\t\tmatch peek () with\r\n\t\t\t\t| x when x = delim -> skip(); (\"<\" ^ tk ^ \">\")\r\n\t\t\t\t| _ -> expecting0 (\"closing '\" ^ (Char.escaped delim) ^ \"'\")\r\n\t\t\t\r\n\tlet rec parseHead () : word =\r\n\t\tmatch peek() with\r\n\t\t\t| ' ' -> invalid \"Premature end of expression\\n\"\r\n\t\t\t| '-' -> []\r\n\t\t\t| '<' -> let symb = str2symb (parseString '>')\r\n\t\t\t\t\t\tin symb::parseHead ()\r\n\t\t\t| c -> skip();\r\n\t\t\t\t\tlet symb = char2symb c in\r\n\t\t\t\t\t\tsymb::parseHead ()\r\n\t\t\t\r\n\tlet parseNeck (): unit =\r\n\t\tmatch peek() with\r\n\t\t\t| ' ' -> invalid \"Premature end of expression\\n\"\r\n\t\t\t| '-' -> skip();\r\n\t\t\t\t\tif peek() = '>' then skip()\r\n\t\t\t\t\telse invalid \"Bad neck\\n\"\r\n\t\t\t| _ -> invalid \"Bad neck\\n\"\r\n\r\n\tlet rec parseBody (): word list =\r\n\t\tmatch peek() with\r\n\t\t\t| ' ' -> [[]]\r\n\t\t\t| '|' -> skip(); []::parseBody ()\r\n\t\t\t| '<' -> let symb = str2symb (parseString '>') in\r\n\t\t\t\t\t\t(match parseBody () with\r\n\t\t\t\t\t\t\t| [] -> invalid \"never happens 1\"\r\n\t\t\t\t\t\t\t| x::xs -> (symb::x)::xs)\t\t\r\n\t\t\t| c -> skip();\r\n\t\t\t\t\tmatch parseBody () with\r\n\t\t\t\t\t\t| [] -> invalid \"never happens 2\"\r\n\t\t\t\t\t\t| x::xs -> ((char2symb c)::x)::xs\r\n\t\r\n\tlet parseLine line: rules =\r\n\t\tif String.trim line = \"\" then\r\n\t\t\tSet.empty\r\n\t\telse (\r\n\t\t\tScanner.start \"GrammarSyntax\" line;\r\n\t\t\ttry\r\n\t\t\t\tlet finish l = if l = [] then [epsilon] else l in\r\n\t\t\t\tlet h = parseHead () in\r\n\t\t\t\tlet _ = parseNeck () in\r\n\t\t\t\tlet bs = Set.make (parseBody ()) in\r\n\t\t\t\t\tSet.map (fun b -> {head=finish h; body=finish b}) bs\r\n\t\t\twith Not_found ->\r\n\t\t\t\tSet.empty\r\n\t\t)\r\n\r\n\tlet parse rs: rules =\r\n\t\tSet.flatMap parseLine rs\r\n\t\r\n\tlet rule2str {head=h; body=b} =\r\n\t\t\t(word2str h) ^ \" -> \" ^ (word2str b)\r\n\r\n\tlet toString rs: string =\r\n\t\tlet rl = Set.toList rs in\r\n\t\tString.concat \"\\n\" (List.map rule2str rl)\r\n\r\n\tlet toStringList rs: string list =\r\n\t\tlet rl = Set.toList rs in\r\n\t\t\tList.map rule2str rl\r\n\t\r\n\tlet (-->) h b : rule =\r\n\t\t{ head = str2word h; body = str2word b } ;;\r\n\r\n\tlet show rs =\r\n\t\tUtil.println [toString rs]\r\nend\r\n\r\nmodule GrammarConversions =\r\nstruct\r\n\topen GrammarBasics\r\n\topen GrammarSyntax\r\n\r\n\tlet fromJSon (j: JSon.t): t =\r\n\t\tif JSon.isNull j || not (JSon.hasField j \"kind\") then\r\n\t\t\tgr_zero\r\n\t\telse {\r\n\t\t\talphabet = JSon.fieldSymbolSet j \"alphabet\";\r\n\t\t\tvariables = JSon.fieldSymbolSet j \"variables\";\r\n\t\t\tinitial = JSon.fieldSymbol j \"initial\";\r\n\t\t\trules = GrammarSyntax.parse (JSon.fieldStringSet j \"rules\");\r\n\t\t}\r\n\r\n\tlet toJSon0 (rep: t): JSon.t =\r\n\t\tJSon.makeAssoc [\r\n\t\t\t(\"alphabet\", JSon.makeSymbolSet rep.alphabet);\r\n\t\t\t(\"variables\", JSon.makeSymbolSet rep.variables);\r\n\t\t\t(\"initial\", JSon.makeSymbol rep.initial);\r\n\t\t\t(\"rules\", JSon.makeStringSet (Set.map rule2str rep.rules))\r\n\t\t]\r\n\t\r\n\tlet toJSon2 (id: Entity.t) (rep: t): JSon.t =\r\n\t\t JSon.append (Entity.toJSon id) (toJSon0 rep)\r\n\r\n\t\r\n\tlet toJSon (rep: t): JSon.t =\r\n\t\t toJSon2 (Entity.dummyId kind) rep\r\n\r\nend\r\n\r\nmodule GrammarBasicFunctions =\r\nstruct\r\n\topen GrammarBasics\r\n\topen GrammarConversions\r\n\r\n\tlet make2 (arg: t Arg.alternatives) validate: Entity.t * t =\r\n\t\tEntity.make2 arg fromJSon kind validate\r\n\r\n\tlet make (arg: t Arg.alternatives) validate: t =\r\n\t\tsnd (make2 arg validate)\r\n\r\n\tlet show (rep: t): unit =\r\n\t\tlet j = toJSon rep in\r\n\t\t\tJSon.show j\r\n\r\n\tlet show2 (id: Entity.t) (rep: t): unit =\r\n\t\tlet j = toJSon2 id rep in\r\n\t\t\tJSon.show j\r\nend\r\n\r\nmodule GrammarBasicsX =\r\nstruct\r\n\topen GrammarBasics\r\n\r\n\ttype tx = {\r\n\t\talphabet : symbolX list;\r\n\t\tvariables : variableX list;\r\n\t\tinitial : variableX;\r\n\t\trules : string list\r\n\t}\r\n\r\n\tlet internalize (grammar: tx): t = {\r\n\t\talphabet = symbolsI grammar.alphabet;\r\n\t\tvariables = symbolsI grammar.variables;\r\n\t\tinitial = symbI grammar.initial;\r\n\t\trules = GrammarSyntax.parse (Set.make grammar.rules)\r\n\t}\r\n\r\n\tlet externalize (grammar: t): tx = {\r\n\t\talphabet = symbolsX grammar.alphabet;\r\n\t\tvariables = symbolsX grammar.variables;\r\n\t\tinitial = symbX grammar.initial;\r\n\t\trules = GrammarSyntax.toStringList grammar.rules\r\n\t}\r\nend\r\n\r\nmodule GrammarLearnOCaml =\r\nstruct\r\n\topen GrammarBasics\r\n\topen GrammarBasicsX\r\n\r\n\tlet moduleName =\r\n\t\t\"Grammar\"\r\n\r\n\tlet xTypeName =\r\n\t\t\"contextFreeGrammar\"\r\n\r\n\tlet solution (name: string) (rep: t): string =\r\n\t\tlet repx = externalize rep in\r\n\t\tPrintf.sprintf {zzz|\r\n\t\t%s{\r\n\t\t\talphabet = %s;\r\n\t\t\tvariables = %s;\r\n\t\t\tinitial = %s;\r\n\t\t\trules = %s\r\n\t\t}\r\n\t\t|zzz}\t(* please, do not change this line *)\r\n\t\t\t(FiniteEnumerationLearnOCaml.displayHeader name xTypeName)\r\n\t\t\t(symbolsXD repx.alphabet)\r\n\t\t\t(symbolsXD repx.variables)\r\n\t\t\t(symbXD repx.initial)\r\n\t\t\t(stringsD repx.rules)\r\n\r\n\tlet prelude : string =\r\n\t\tPrintf.sprintf {zzz|\r\n\t\t\ttype symbol = %s\r\n\t\t\ttype variable = %s\r\n\t\t\ttype rule = string\r\n\t\t\ttype contextFreeGrammar = {\r\n\t\t\t\talphabet : symbol list;\r\n\t\t\t\tvariables : variable list;\r\n\t\t\t\tinitial : variable;\r\n\t\t\t\trules : rule list\r\n\t\t\t}\r\n\t\t|zzz}\t(* please, do not change this line *)\r\n\t\t\t\tsymbolTypeName symbolTypeName\r\n\r\n\t\tlet example : JSon.t =\r\n\t\t\tJSon.parse {| {\r\n\t\t\t\tkind : \"context free grammar\",\r\n\t\t\t\tdescription : \"this is an example\",\r\n\t\t\t\tname : \"grammar_simple\",\r\n\t\t\t\talphabet : [\"0\", \"1\"],\r\n\t\t\t\tvariables : [\"S\", \"X\"],\r\n\t\t\t\tinitial : \"S\",\r\n\t\t\t\trules : [ \"S -> 1S0 | X\", \"X -> 0X1 | ~\" ]\r\n\t\t\t}\r\n\t\t\t|}\t(* please, do not change this line *)\r\nend\r\n\r\nmodule GrammarSupport =\r\nstruct\r\n\tinclude GrammarBasics\r\n\tinclude GrammarSyntax\r\n\tinclude GrammarConversions\r\n\tinclude GrammarBasicFunctions\r\n\tinclude GrammarLearnOCaml\r\nend\r\n\r\nmodule GrammarSyntaxTests : sig end =\r\nstruct\r\n\tlet active = false\r\n\r\n\tlet test0 () =\r\n\t\tlet grammar = Set.make [ \"aSb -> a~~Tb | ~~ |\"; \"T -> aSb\"; \"->\" ] in\r\n\t\tlet rules = GrammarSyntax.parse grammar in\r\n\t\t\tGrammarSyntax.show rules\r\n\r\n\tlet test1 () =\r\n\t\tlet grammar = Set.make [\"a<variable>b -> a<variable>b | ~\"] in\r\n\t\tlet rules = GrammarSyntax.parse grammar in\r\n\t\t\tGrammarSyntax.show rules\r\n\r\n\tlet runAll =\r\n\t\tif Util.testing active \"GrammarSyntax\" then begin\r\n\t\t\tUtil.header \"test0\";\r\n\t\t\ttest0 ();\r\n\t\t\tUtil.header \"test1\";\r\n\t\t\ttest1 ();\r\n\t\t\tUtil.header \"\"\r\n\t\tend\r\nend\r\n# 1 \"src/Grammar.ml\"\r\n(*\r\n * Grammar.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Pedro Carlos (p.carlos)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * jul/2024 (amd) - New file.\r\n *)\r\n\r\n(*\r\n * Description: General grammar functionality.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\n\r\n\r\nmodule GrammarPrivate =\r\nstruct\r\n\topen GrammarSupport\r\n\r\n\tlet validate (name: string) (gram: t): unit =\r\n\t\t(* Util.show (symb2str gram.initial);\r\n\t\tSet.iter (fun v -> Util.show (symb2str v)) gram.variables;\r\n\t\tif Set.size gram.variables = 0 then\r\n\t\t\tUtil.show \"No variables\"\r\n\t\telse\r\n\t\t\tUtil.show \"Variables\"; *)\r\n\t\t(* The alphabet must not contain epsilon ('~') *)\r\n\t\tlet isValidAlphabet = not (Set.belongs epsilon gram.alphabet) in\r\n\t\t(* The variables must not contain epsilon ('~') *)\r\n\t\tlet isValidVariables = not (Set.belongs epsilon gram.variables) in\r\n\t\t(* The alphabet and the variables must not intersect *)\r\n\t\tlet isIntersectionValid = (Set.inter gram.variables gram.alphabet) = Set.empty in\r\n\t\t(* The initial symbol must be a variable *)\r\n\t\tlet isInitialValid = Set.belongs gram.initial gram.variables in\r\n\r\n\t\t(* heads should not be empty, and must be a subset of valid symbols (alphabet + variables) *)\r\n\t\tlet areRuleHeadsValid =\r\n\t\t\tlet allHeadSymbols = Set.flatMap (fun r -> Set.make r.head) gram.rules in (* set of all heads in rules, heads *)\r\n\t\t\tlet allValidSymbs = Set.union gram.alphabet gram.variables in\r\n\t\t\tSet.subset allHeadSymbols allValidSymbs && \t\t(* heads must be a subset of valid symbols (alphabet + variables) *)\r\n\t\t\tSet.for_all (fun r -> r.head <> []) gram.rules (* heads should not be empty*)\r\n\t\tin\r\n\r\n\t\t(* bodies must be a subset of valid symbols (alphabet + variables + epsilon) *)\r\n\t\tlet areRuleBodiesValid =\r\n\t\t\tlet allBodySymbols = Set.flatMap (fun r -> Set.make r.body) gram.rules in (* set of all bodies in rules, bodies *)\r\n\t\t\t(* Set.iter (fun s -> Printf.printf \"%s\\n\" (symb2str s)) allBodySymbols; *)\r\n\t\t\tlet allValidSymbs = Set.add epsilon (Set.union gram.alphabet gram.variables) in\r\n\t\t\tSet.subset allBodySymbols allValidSymbs (* bodies must be a subset of valid symbols (alphabet + variables + epsilon) *)\r\n\t\tin\r\n\r\n\r\n\t\tif not isValidAlphabet then\r\n\t\t\tError.error name\r\n\t\t\t\t\"The alphabet contains epsilon '~', and it should not\" ();\r\n\t\tif not isValidVariables then\r\n\t\t\tError.error name\r\n\t\t\t\t\"The variables contain epsilon '~', and it should not\" ();\r\n\t\tif not isIntersectionValid then\r\n\t\t\tError.error name\r\n\t\t\t\t\"The intersection between the alphabet and the variables is not empty\" ();\r\n\t\tif not isInitialValid then\r\n\t\t\tError.error (symb2str gram.initial)\r\n\t\t\t\t\"The initial symbol is not a declared variable\" ();\r\n\t\tif not areRuleHeadsValid then\r\n\t\t\tError.error name\r\n\t\t\t\t\"Some rule heads contain invalid symbols or are empty\" ();\r\n\t\tif not areRuleBodiesValid then\r\n\t\t\tError.error name\r\n\t\t\t\t\"Some rule bodies contain invalid symbols\" ()\r\n\r\n\r\n\tlet isUnrestrictedGrammar (gram: t): bool =\r\n\t\ttrue \r\n\t\t(* Unrestricted grammars have no restrictions on the form of their production rules. *)\r\n\t\t(* The restrictions are unsured by validate *)\r\n\r\n\tlet hasEpsilonRules (gram: t)=\r\n\t\tlet isEpsilonRule r =\r\n\t\t\tif r.body = [epsilon] then (\r\n\t\t\t\tif r.head = [gram.initial] then ( (* Special case: S → ε *)\r\n\t\t\t\t\t(* Ensure S doesn't appear on the body of any rule *)\r\n\t\t\t\t\tList.for_all (fun r' -> not (List.mem gram.initial r'.body)) (Set.toList gram.rules)\r\n\t\t\t\t)\r\n\t\t\t\telse false\r\n\t\t\t)\r\n\t\t\telse true (* Not an epsilon rule, so it's valid *)\r\n\t\tin\r\n\t\tList.for_all isEpsilonRule (Set.toList gram.rules)\r\n\r\n\tlet lengthMonotonicCheck (gram: t): bool =\r\n\t\tList.for_all (fun r ->\r\n\t\t\t(* Check if the rule's head is the initial symbol and the body is epsilon *)\r\n\t\t\t\t(* if r.head = [gram.initial] && r.body = [epsilon] then\r\n\t\t\t\t\tfalse\r\n\t\t\t\telse   /// this applys for essentially noncontracting grammars *)\r\n\t\t\t\tList.length r.body >= List.length r.head\r\n\t\t) (Set.toList gram.rules)\r\n\t\t\r\n\t(* A grammar is monotonic if the length of the body of each rule is greater or equal to the length of the head. *)\r\n\tlet isMonotonicGrammar (gram: t): bool =\r\n\t\thasEpsilonRules gram &&\r\n\t\tlengthMonotonicCheck gram\r\n\r\n\r\n\tlet isNoncontractingGrammar = isMonotonicGrammar\r\n\r\n\t(* A grammar is monotonic strict if the length of the body of each rule is strictly greater than the length of the head. *)\r\n\tlet isMonotonicStrictGrammar (gram: t): bool =\r\n\t\tlengthMonotonicCheck gram\r\n\r\n\r\n\t(* A grammar is context-sensitive if it is monotonic and if each rule in P is either of the form S → ε where ε is the empty string, or of the form αAβ → αγβ *)\r\n\tlet isContextSensitiveGrammar (gram: t): bool =\r\n\t\t(* Check if epsilon rule is valid: S → ε is allowed only if S is the start symbol and S does not appear in any rule's body *)\r\n\t\tlet isContextRule (rule: rule) = (*check if rule are of the from αAβ → αγβ*)\r\n\t\t\tlet rec findContextsHelper head body match_found =\r\n\t\t\t\tmatch head, body with\r\n\t\t\t\t| [], _ -> match_found  (* Return true if a match was found *)\r\n\t\t\t\t| _, [] -> false  (* No match found *)\r\n\t\t\t\t| h::ht, b::bt ->\r\n\t\t\t\tif h = b then\r\n\t\t\t\t\tfindContextsHelper ht bt true  (* Continue matching and set match_found to true *)\r\n\t\t\t\telse\r\n\t\t\t\t\tSet.belongs h gram.variables &&  (* Check if h belongs to variables *)\r\n\t\t\t\t\tList.length body >= List.length head &&  (* Ensure rule is monotonic *)\r\n\t\t\t\t\tfindContextsHelper ht bt match_found  (* Continue matching with the same match_found status *)\r\n\t\t  \tin\r\n\t\t  \tlet findContexts head body =\r\n\t\t\t\tfindContextsHelper head body false  (* Start with match_found set to false *)\r\n\t\t  \tin\r\n\t\t  findContexts rule.head rule.body\r\n\t\tin\r\n\t\t(* Helper function to check if the head of the rule is a single nonterminal *)\r\n\t\tlet isSingleNonterminal (rule: rule) =\r\n\t\t\tmatch rule.head with\r\n\t\t\t| [h] -> Set.belongs h gram.variables || h = epsilon\r\n\t\t\t| _ -> false\r\n\t\tin\r\n\t\tList.for_all (fun rule -> isSingleNonterminal rule || isContextRule rule) (Set.toList gram.rules)\r\n\r\n\r\n\r\n\t(*In a context-free grammar, each production rule is of the form A → α with A a single nonterminal symbol, and α a string of terminals and/or nonterminals  *)\r\n\t(*i.e the head of each rule is a single variable. *)\r\n\tlet isContextFreeGrammar (gram: t): bool = (*verify if the head has exactly one symbol (length 1) and that this symbol belongs to the set of variables *)\r\n\t\tList.for_all (fun r -> List.length r.head = 1 && Set.belongs (List.hd r.head) gram.variables) (Set.toList gram.rules)\r\n\r\n\t(*in a left linear grammar all rules are of the form A → αw where α is either empty or a single nonterminal and w is a string of terminals *)\r\n\tlet isLeftLinearGrammar (gram: t): bool =\r\n\t\tisContextFreeGrammar gram &&\r\n\t\tList.for_all (fun r ->\r\n\t\t\tmatch r.body with\r\n\t\t\t| [] ->\r\n\t\t\t\t\ttrue\r\n\t\t\t| [var] ->\r\n\t\t\t\t\tlet belongs_to_vars = Set.belongs var gram.variables in\r\n\t\t\t\t\tlet belongs_to_alphabet = Set.belongs var gram.alphabet in\r\n\t\t\t\t\tbelongs_to_vars || belongs_to_alphabet || var = epsilon\r\n\t\t\t| var :: rest ->\r\n\t\t\t\t\tlet var_belongs = Set.belongs var gram.variables in\r\n\t\t\t\t\tlet rest_belongs = List.for_all (fun s -> Set.belongs s gram.alphabet) rest in\r\n\t\t\t\t\tvar_belongs && rest_belongs\r\n\t\t) (Set.toList gram.rules)\r\n\r\n\tlet isRightLinearGrammar (gram: t): bool =\r\n\t\tisContextFreeGrammar gram &&\r\n\t\tList.for_all (fun r ->\r\n\t\t\tmatch List.rev r.body with\r\n\t\t\t| [] ->\r\n\t\t\t\t\ttrue\r\n\t\t\t| [var] ->\r\n\t\t\t\t\tlet belongs_to_vars = Set.belongs var gram.variables in\r\n\t\t\t\t\tlet belongs_to_alphabet = Set.belongs var gram.alphabet in\r\n\t\t\t\t\tbelongs_to_vars || belongs_to_alphabet || var = epsilon (*Allow epsilon ?? *)\r\n\t\t\t| var :: rest ->\r\n\t\t\t\t\tlet var_belongs = Set.belongs var gram.variables in\r\n\t\t\t\t\tlet rest_belongs = List.for_all (fun s -> Set.belongs s gram.alphabet) rest in\r\n\t\t\t\t\tvar_belongs && rest_belongs\r\n\t\t) (Set.toList gram.rules)\r\n\r\n\t(*linear grammar is a context-free grammar that has at most one nonterminal in the right-hand side of each of its productions. *)\r\n\tlet isLinearGrammar (gram: t): bool =\r\n\t\tisContextFreeGrammar gram &&\r\n\t\t(List.for_all (fun r ->\r\n\t\t\tlet var_count = List.fold_left (fun count symb ->\r\n\t\t\t\tif Set.belongs symb gram.variables then count + 1 else count)\r\n\t\t\t\t0\r\n\t\t\t\tr.body\r\n\t\t\t\tin var_count <= 1 (* Only one variable allowed on the right-hand side *)\r\n\t\t) (Set.toList gram.rules))\r\n\r\n\r\n\r\n\tlet rechableSymbs (gram: t) set =\r\n\t\tSet.fold_right (fun r acc ->\r\n\t\t\tif List.exists (fun symb -> Set.belongs symb set) r.head then\r\n\t\t\t\tSet.union (Set.make r.body) acc\r\n\t\t\telse\r\n\t\t\t\tacc\r\n\t\t) gram.rules set\r\n\r\n\r\n\tlet rechableSymbsCFG (gram: t) set =\r\n\t\tSet.fold_right (fun r acc ->\r\n\t\t\tif List.for_all (fun symb -> Set.belongs symb set) r.head then\r\n\t\t\t\tSet.union (Set.make r.body) acc\r\n\t\t\telse\r\n\t\t\t\tacc\r\n\t\t) gram.rules set\r\n\r\n\tlet rec reachSymbs (gram :t) symbSet =\r\n\t\tlet reach = rechableSymbs gram symbSet in\r\n\t\tif Set.subset reach symbSet then\r\n\t\t\treach\r\n\t\telse\r\n\t\t\treachSymbs gram reach\r\n\r\n\tlet allRulesAccessible (gram: t): bool =\r\n\t\t(* let accessSymbols = reachSymbs gram (Set.make [gram.initial]) in *)\r\n\t\tlet accessSymbols = \r\n\t\t\tif isContextFreeGrammar gram then\r\n\t\t\t\tSet.acumFixedPoint (rechableSymbsCFG gram) (Set.make [gram.initial])\r\n\t\t\telse\r\n\t\t\t\tSet.acumFixedPoint (rechableSymbs gram) (Set.make [gram.initial])\r\n\t\tin\r\n\t\t(* let accessSymbols = Set.acumFixedPoint (rechableSymbs gram) (Set.make [gram.initial]) in *)\r\n\t\tlet allVars = gram.variables in\r\n\t\tSet.equals (Set.inter accessSymbols allVars) allVars\r\n\r\n\tlet terminalSymbs (gram: t) set =\r\n\t\tSet.fold_right (fun r acc ->\r\n\t\t\tif Set.exists (fun elem -> Set.belongs elem set) (Set.make r.body) then\r\n\t\t\t\t\tSet.union (Set.make r.head) acc\r\n\t\t\telse\r\n\t\t\t\t\tacc\r\n\t\t) gram.rules set\r\n\r\n\tlet terminalSymbsCFG (gram: t) set =\r\n\t\tSet.fold_right (fun r acc ->\r\n\t\t\tif List.for_all (fun symb -> Set.belongs symb set) r.body then\r\n\t\t\t\tSet.union (Set.make r.head) acc\r\n\t\t\telse\r\n\t\t\t\tacc\r\n\t\t) gram.rules set\r\n\r\n\tlet rec productiveSymbs (gram :t) symbSet =\r\n\t\tlet prod = terminalSymbs gram symbSet in\r\n\t\tif Set.subset prod symbSet then\r\n\t\t\tprod\r\n\t\telse\r\n\t\t\tproductiveSymbs gram prod\r\n\r\n\r\n\r\n\r\n\r\n\r\n\tlet allRulesProductive (gram: t): bool =\r\n\t\t(* let prodVars = productiveSymbs gram (Set.add epsilon gram.alphabet) in  *)\r\n\t\tlet prodVars =\r\n\t\t\tif isContextFreeGrammar gram then\r\n\t\t\t\tSet.acumFixedPoint (terminalSymbsCFG gram) (Set.add epsilon gram.alphabet)\r\n\t\t\telse\r\n\t\t\t\tSet.acumFixedPoint (terminalSymbs gram) (Set.add epsilon gram.alphabet)\r\n\t\tin\r\n\t\tlet allVars = Set.add epsilon (Set.union gram.variables gram.alphabet) in\r\n\r\n\t\tSet.equals prodVars allVars\r\n\r\n\t(* Checks if the grammar is clean (all symbols are productive and accessible) *)\r\n\tlet isClean (gram: t): bool =\r\n\t\tallRulesAccessible gram && allRulesProductive gram\r\n\r\n\r\n\t(* Cleans the grammar by removing unproductive symbols and rules *)\r\n\tlet cleanUnproductive (gram: t) =\r\n\t\tlet allVars = gram.variables in\r\n\t\tlet prodSymbols =\r\n\t\t\tif isContextFreeGrammar gram then\r\n\t\t\t\tSet.acumFixedPoint (terminalSymbsCFG gram) (Set.add epsilon gram.alphabet)\r\n\t\t\telse\r\n\t\t\t\tSet.acumFixedPoint (terminalSymbs gram) (Set.add epsilon gram.alphabet)\r\n\t\tin\r\n\t\tlet prodVars = Set.inter prodSymbols gram.variables in\r\n\r\n\t\tif Set.equals prodVars allVars then\r\n\t\t\tgram\r\n\t\telse\r\n\t\t\tlet filteredRules = Set.filter (fun rule ->\r\n\t\t\t\tList.for_all (fun var -> (Set.belongs var prodSymbols || var = epsilon)) rule.body\r\n\t\t\t) gram.rules in\r\n\r\n\t\t\t(*In the context of unproductive rules we can i have a rule like A -> AA and A -> ~ , in this case rule A -> AA should be removed*)\r\n\t\t\t(*First get the heads of the rules that derive epsilon*)\r\n\t\t\tlet epsilonRuleHeads = Set.flat_map (fun r -> Set.make r.head) (Set.filter (fun r -> r.body = [epsilon]) filteredRules) in\r\n\t\t\t(*get the rules that have as head and body the head of epsilonRules*)\r\n\t\t\tlet unprodictiveEpsilonRules =\r\n\t\t\t\t\tSet.filter\r\n\t\t\t\t\t\t\t(fun r ->\r\n\t\t\t\t\t\t\t\t\tList.for_all (fun s ->\r\n\t\t\t\t\t\t\t\t\t\tSet.belongs s epsilonRuleHeads\r\n\t\t\t\t\t\t\t\t\t) r.head\r\n\t\t\t\t\t\t\t\t&&\r\n\t\t\t\t\t\t\t\t\tList.for_all (fun s ->\r\n\t\t\t\t\t\t\t\t\t\t\tSet.belongs s epsilonRuleHeads\r\n\t\t\t\t\t\t\t\t\t) r.body\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\tfilteredRules\r\n\t\t\tin\r\n\t\t\tlet newFilteredRules = Set.diff filteredRules unprodictiveEpsilonRules in\r\n\t\t\t{ gram with\r\n\t\t\tvariables = Set.inter allVars prodVars;\r\n\t\t\trules = newFilteredRules\r\n\t\t\t}\r\n\r\n\t(* Cleans the grammar by removing inaccessible symbols and rules *)\r\n\tlet cleanInaccessible (gram: t) =\r\n\t\tlet allVars = gram.variables in\r\n\t\tlet accessSymbols = \r\n\t\t\tif isContextFreeGrammar gram then\r\n\t\t\t\tSet.acumFixedPoint (rechableSymbsCFG gram) (Set.make [gram.initial])\r\n\t\t\telse\r\n\t\t\t\tSet.acumFixedPoint (rechableSymbs gram) (Set.make [gram.initial])\r\n\t\tin\r\n\t\t(* let accessSymbols = Set.acumFixedPoint (rechableSymbs gram) (Set.make [gram.initial]) in *)\r\n\t\tlet accessibleVars = Set.inter accessSymbols allVars in\r\n\t\tif Set.equals accessibleVars allVars then\r\n\t\t\tgram\r\n\t\telse\r\n\t\t\tlet filteredRules = Set.filter (fun rule ->\r\n\t\t\t\tList.for_all (fun var -> Set.belongs var accessSymbols) rule.head\r\n\t\t\t\t(* &&\r\n\t\t\t\tList.for_all (fun var -> Set.belongs var accessSymbols) rule.body *)\r\n\t\t\t) gram.rules in\r\n\t\t\tlet filteredAlphabet = Set.inter gram.alphabet accessSymbols in\r\n\t\t\t{ gram with\r\n\t\t\talphabet = filteredAlphabet;\r\n\t\t\tvariables = accessibleVars;\r\n\t\t\trules = filteredRules\r\n\t\t\t}\r\n\r\n\t(* Cleans the grammar by removing unproductive and then inaccessible symbols and rules *)\r\n\tlet clean (gram: t) =\r\n\t\tlet cleanUnproductiveGram = cleanUnproductive gram in\r\n\t\t(* print_endline \"show cleanUnproductiveGram:\";\r\n\t\tshow cleanUnproductiveGram;   *)\r\n\t\t(* print_endline \"show cleanInacessibleGram:\"; *)\r\n\t\t(* let cleanInaccessibleGram = cleanInaccessible gram in *)\r\n\t\t(* show cleanInaccessibleGram;   *)\r\n\t\tcleanInaccessible cleanUnproductiveGram\r\n\r\n\r\n\t\r\n\r\n\tlet rec starts_with sub lst =\r\n\t\tmatch sub, lst with\r\n\t\t| [], _ -> true\r\n\t\t| _, [] -> false\r\n\t\t| shd::stail, lhd::ltail -> shd = lhd && starts_with stail ltail\r\n\r\n\tlet rec removeN n lst =\r\n\t\tmatch n, lst with\r\n\t\t| 0, _ -> lst\r\n\t\t| _, [] -> []\r\n\t\t| n, _::tail -> removeN (n - 1) tail\r\n\r\n\r\n\tlet rec replace_subsequence original subseq replacement subseq_lenght = (*passing lenght to improve performance since List.lenght is O(n) *)\r\n\t\tmatch original with\r\n\t\t| [] -> []\r\n\t\t| _ when starts_with subseq original -> replacement @ (removeN subseq_lenght original) (*Returns on first occurence replacement*)\r\n\t\t| x::xs -> x :: (replace_subsequence xs subseq replacement subseq_lenght)\r\n\r\n\tlet rec replace_subsequence_all original subseq replacement subseq_length =\r\n\t\tmatch original with\r\n\t\t| [] -> []\r\n\t\t| _ when starts_with subseq original ->\r\n\t\t\treplacement @ (replace_subsequence_all (removeN subseq_length original) subseq replacement subseq_length)\r\n\t\t| x::xs -> x :: (replace_subsequence_all xs subseq replacement subseq_length)\r\n\r\n\r\n\tlet rechableSymbsCFG (gram: t) set =\r\n\t\tSet.fold_right (fun r acc ->\r\n\t\t\tif List.for_all (fun symb -> Set.belongs symb set) r.head then\r\n\t\t\t\tSet.union (Set.make r.body) acc\r\n\t\t\telse\r\n\t\t\t\tacc\r\n\t\t) gram.rules set\r\n\r\n\tlet hasEpsilonRules (gram: t)=\r\n\t\tlet isEpsilonRule r =\r\n\t\t\tif r.body = [epsilon] then\r\n\t\t\t\ttrue\r\n\t\t\telse false\r\n\t\tin\r\n\t\tList.exists isEpsilonRule (Set.toList gram.rules)\r\n\r\n\tlet generatesEmpty (gram: t)=\r\n\t\t(* Collect all that are direct derivations from start symbol *)\r\n\t\tlet accessSymbols = Set.acumFixedPoint (rechableSymbsCFG gram) (Set.make [gram.initial]) in\r\n\t\tlet accessVars = Set.inter accessSymbols gram.variables in\r\n\t\tlet filteredRules = Set.filter (fun rule ->\r\n\t\t\tList.for_all (fun var -> Set.belongs var accessVars) rule.head\r\n\t\t) gram.rules in\r\n\t\r\n\t\tList.exists (fun rule -> rule.body = [epsilon]) (Set.toList filteredRules)\r\n\r\n\tlet removeEpsilonRules (gram: t) : t =\r\n\t\t(* Step 1: Identify Nullable Variables *)\r\n\t\tlet rec nullableVars nullable =\r\n\t\t\tlet newNullable = Set.fold_right (fun rule acc ->\r\n\t\t\t\tif List.for_all (fun symb -> Set.belongs symb nullable) rule.body then\r\n\t\t\t\t\tSet.union (Set.make rule.head) acc\r\n\t\t\t\telse\r\n\t\t\t\t\tacc\r\n\t\t\t) gram.rules nullable\r\n\t\t\tin\r\n\t\t\tif Set.equals newNullable nullable then\r\n\t\t\t\tnullable\r\n\t\t\telse\r\n\t\t\t\tnullableVars newNullable\r\n\t\tin\r\n\t\tlet nullable = nullableVars (Set.filter (fun r -> r.body = [epsilon]) gram.rules |> Set.flatMap (fun r -> Set.make r.head)) in\r\n\r\n\t\t(* Step 2: Adjust Productions *)\r\n\t\tlet newRules = Set.flatMap (fun rule ->\r\n\t\t\tlet rec generateCombinations body =\r\n\t\t\t\tmatch body with\r\n\t\t\t\t| [] -> [[]]\r\n\t\t\t\t| hd :: tl ->\r\n\t\t\t\t\tlet tlCombinations = generateCombinations tl in\r\n\t\t\t\t\tif Set.belongs hd nullable then\r\n\t\t\t\t\t\tList.map (fun comb -> hd :: comb) tlCombinations @ tlCombinations\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tList.map (fun comb -> hd :: comb) tlCombinations\r\n\t\t\tin\r\n\t\t\tlet newBodies = generateCombinations rule.body in\r\n\t\t\tSet.make (List.map (fun body -> { head = rule.head; body }) newBodies)\r\n\t\t) gram.rules\r\n\t\t|> Set.filter (fun r -> r.body <> [] && r.body <> [epsilon] && r.head <> r.body) (* Step 3: Remove Epsilon Rules *)\r\n\t\tin\r\n\r\n\t\t{ gram with rules = newRules }\r\n\r\nend\r\n\r\nmodule GrammarAccept = (* Pedro + Artur *)\r\nstruct\r\n\topen GrammarSupport\r\n\topen GrammarPrivate\r\n\t(* open ContextFreeGrammarBasic *)\r\n\r\n\r\n\tlet initialConfig (gram: t) (w: word) : configurations =\r\n\t\tSet.make [([gram.initial], w)]\r\n\r\n\tlet rec containsSubSequence subSequence list =\r\n\t\tmatch subSequence, list with\r\n\t\t| [], _ -> true\r\n\t\t| _, [] -> false\r\n\t\t| sShd::sStail, lhd::ltail ->\r\n\t\t\tif sShd = lhd then containsSubSequence sStail ltail\r\n\t\t\telse containsSubSequence subSequence ltail\r\n\r\n\r\n\tlet showInFile (msg: string) : unit =\r\n\t\tlet oc = open_out_gen [Open_creat; Open_text; Open_append] 0o640 \"file.txt\" in\r\n\t\toutput_string oc (msg ^ \"\\n\");\r\n\t\tclose_out oc\r\n\r\n\r\n\r\n\tlet expand2 (gram: t) (sf,w) : configurations =\r\n\t\tlet rules = Set.filter (fun r -> containsSubSequence r.head sf) gram.rules in\r\n\t\t(* Generate one configuration for each matching rule *)\r\n\t\tSet.flatMap (fun rule ->\r\n\t\t\t\t(* For each rule, generate just one new configuration by replacing the first and only the first occurence of its head with its body *)\r\n\t\t\t\tlet rec combinations sf rule =\r\n\t\t\t\t\t\tmatch sf with\r\n\t\t\t\t\t\t| [] -> []\r\n\t\t\t\t\t\t| x::xs ->\r\n\t\t\t\t\t\t\t\tif rule.body = [epsilon] then\r\n\t\t\t\t\t\t\t\t\t\t(replace_subsequence sf rule.head [] (List.length rule.head)) :: (List.map (fun c -> x :: c) (combinations xs rule))\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t(replace_subsequence sf rule.head rule.body (List.length rule.head)) :: (List.map (fun c -> x :: c) (combinations xs rule))\r\n\t\t\t\tin\r\n\t\t\t\tlet newSfs = combinations sf rule in\r\n\t\t\t\tSet.make (List.map (fun newSf -> (newSf, w)) newSfs)\r\n\t\t) rules\r\n\r\n\tlet nextConfigs2 (gram: t) (sf, w) : configurations =\r\n\t\t(* showInFile(\"Starting nextConfigs for: \" ^ word2str sf); *)\r\n\t\tlet configs = expand2 gram (sf, w) in\r\n\t\tif isMonotonicGrammar gram then\r\n\t\t\tlet filtered = Set.filter (fun (sf', _) -> List.length sf' <= List.length w) configs in\r\n\t\t\t(* Set.iter(fun (sf', w) -> showInFile(\"[\" ^ word2str sf' ^ \",\" ^ word2str w ^ \"]\")) filtered; *)\r\n\t\t\tfiltered\r\n\t\telse\r\n\t\t\tconfigs\r\n\r\n\tlet nextConfigs2Full (gram: t) (sf, w) : configurations =\r\n\t\t(* showInFile(\"Starting nextConfigs for: \" ^ word2str sf); *)\r\n\t\tlet configs = expand2 gram (sf, w) in\r\n\t\tconfigs\r\n\r\n\tlet rec partOneX fs h =\r\n\t\tmatch fs, h with\r\n\t\t| [], [] -> (true, [])\r\n\t\t| [], _ -> (false, [])\r\n\t\t| x::xs, [] -> (true, fs)\r\n\t\t| x::xs, y::ys ->\r\n\t\t\tif x = y then\r\n\t\t\t\tpartOneX xs ys\r\n\t\t\telse\r\n\t\t\t\t(false, [])\r\n\r\n\tlet partOne fs h =\r\n\t\tlet (a,b) = partOneX fs h in\r\n\t\t\t(a,h,b)\r\n\r\n\tlet part fs heads =\r\n\t\tlet tryMatch = List.map (partOne fs) heads in\r\n\t\tlet reallyMatch = List.filter (fun (a, b, c) -> a) tryMatch in\r\n\t\t\tList.map (fun (a,b,c) -> (b,c)) reallyMatch\r\n\r\n\tlet rec processHRest heads rules w (h, rest) =\r\n\t\tlet xRules = Set.filter (fun r -> r.head = h) rules in\r\n\t\tlet xBodies = Set.map (fun r -> if r.body = [epsilon] then [] else r.body) xRules in (*special case foe epsilon rule*)\r\n\t\tlet ySet = expand heads rules rest w in\r\n\t\tSet.flatMap (fun (fs1, w) -> Set.map (fun fs2 -> (fs2@fs1, w)) xBodies) ySet\r\n\tand expand heads rules fs w =\r\n\t\tmatch fs with\r\n\t\t| [] -> Set.make [([],w)]\r\n\t\t| x :: xs ->\r\n\t\t\tlet alternativesX = Set.make (part fs heads) in\r\n\t\t\tlet useX = Set.flatMap (processHRest heads rules w) alternativesX in\r\n\t\t\tlet ignoreX = expand heads rules xs w in\r\n\t\t\tlet restoreX = Set.map (fun (fs, w) -> (x::fs, w)) ignoreX in\r\n\t\t\tSet.union useX restoreX\r\n\r\n\r\n\tlet nextConfigs (gram: t) (sf, w) : configurations =\r\n\t\t(* showInFile(\"Starting nextConfigs for: \" ^ word2str sf); *)\r\n\t\tlet rules = gram.rules in\r\n\t\tlet heads = Set.toList (Set.map (fun r -> r.head) rules) in\r\n\t\tlet configs = expand heads rules sf w in\r\n\t\t(* Set.iter(fun (sf', w) -> showInFile(\"[\" ^ word2str sf' ^ \",\" ^ word2str w ^ \"]\")) configs;  *)\r\n\t\tif isMonotonicGrammar gram then\r\n\t\t\tlet filtered = Set.filter (fun (sf', _) -> List.length sf' <= List.length w) configs in\r\n\t\t\t(* Set.iter(fun (sf', w) -> showInFile(\"[\" ^ word2str sf' ^ \",\" ^ word2str w ^ \"]\")) filtered; *)\r\n\t\t\tfiltered\r\n\t\telse\r\n\t\t\t(* Set.iter(fun (sf', w) -> showInFile(\"[\" ^ word2str sf' ^ \",\" ^ word2str w ^ \"]\")) configs; *)\r\n\t\t\tconfigs\r\n\t\t\t(* configs *)\r\n\r\n\r\n\r\n\tlet isAcceptingConfig (gram: t) (genW, w) : bool =\r\n\t\t(* Printf.printf \"genW: %s , w: %s\\n\" (word2str genW) (word2str w);  *)\r\n\t\tgenW = w\r\n\r\n\tlet simplifyGrammar (gram: t) : t =\r\n\t\tgram\r\n\t\t|> (fun g -> if not (isClean g) then clean g else g)\r\n\t\t|> (fun g ->\r\n\t\t\tif isContextFreeGrammar g && hasEpsilonRules g\r\n\t\t\tthen removeEpsilonRules g\r\n\t\t\telse g)\r\n\r\n\tlet accept (gram: t) (w: word) : bool =\r\n\t\tlet processed_gram = simplifyGrammar gram in\r\n\t\tif (generatesEmpty gram) && (w = [] || w = [epsilon]) then\r\n\t\t\ttrue\r\n\t\telse\r\n\t\t\tModel.accept processed_gram w initialConfig nextConfigs isAcceptingConfig\r\n\r\n\tlet accept2 (gram: t) (w: word) : bool =\r\n\t\tlet processed_gram = simplifyGrammar gram in\r\n\t\tif (generatesEmpty gram) && (w = [] || w = [epsilon]) then\r\n\t\t\ttrue\r\n\t\telse\r\n\t\t\tModel.accept processed_gram w initialConfig nextConfigs2 isAcceptingConfig\r\n\r\n\tlet acceptFull (gram: t) (w: word) : bool * path * trail =\r\n\t\tif (generatesEmpty gram) && (w = [] || w = [epsilon]) then\r\n\t\t\t(true, [], [])\r\n\t\telse\r\n\t\t\tModel.acceptFull gram w initialConfig nextConfigs2 isAcceptingConfig\r\n\r\n\tlet split_at n lst =\r\n\t\tlet rec aux i acc = function\r\n\t\t\t| [] -> (List.rev acc, [])\r\n\t\t\t| h :: t as l -> if i = 0 then (List.rev acc, l) else aux (i - 1) (h :: acc) t\r\n\t\tin\r\n\t\taux n [] lst\r\n\r\n\r\n\tlet string_of_symbol_list symbols =\r\n\t  \"[\" ^ (String.concat \"; \" (List.map symb2str symbols)) ^ \"]\"\r\n\r\n\tlet count_subsequence_occurrences subseq lst =\r\n\t\tlet rec aux count lst =\r\n\t\t\tmatch lst with\r\n\t\t\t| [] -> count\r\n\t\t\t| _ when starts_with subseq lst -> aux (count + 1) (List.tl lst)\r\n\t\t\t| _ :: tl -> aux count tl\r\n\t\tin\r\n\taux 0 lst\r\n\r\n\tlet replace_subsequence_with_index original subseq replacement subseq_length =\r\n\t\t\tlet rec aux original subseq replacement subseq_length index =\r\n\t\t\t\t\tmatch original with\r\n\t\t\t\t\t| [] -> ([], None)\r\n\t\t\t\t\t| _ when starts_with subseq original ->\r\n\t\t\t\t\t\t\t\t\t(replacement @ (removeN subseq_length original), Some index)\r\n\t\t\t\t\t| x::xs ->\r\n\t\t\t\t\t\t\t\t\tlet (replaced, found_index) = aux xs subseq replacement subseq_length (index + 1) in\r\n\t\t\t\t\t\t\t\t\t(x :: replaced, match found_index with Some _ -> found_index | None -> Some index)\r\n\t\t\tin\r\n\t\t\taux original subseq replacement subseq_length 0\r\n\r\n\r\n\tlet find_applied_rules (gram: t) (path: path) =\r\n\t\tlet rec aux i acc =\r\n\t\t\tif i < List.length path - 1 then\r\n\t\t\t\tlet current = fst (List.nth path i) in\r\n\t\t\t\tlet next = fst (List.nth path (i + 1)) in\r\n\t\t\t\tlet rules = Set.filter (fun r -> containsSubSequence r.head current) gram.rules in\r\n\t\t\t\tlet index_rule = ref 0 in\r\n\t\t\t\tlet applicable_rule =\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t\tSome (Set.find (fun rule ->\r\n\t\t\t\t\t\t\tlet rec combinations current rule curr_i =\r\n\t\t\t\t\t\t\t\tmatch current with\r\n\t\t\t\t\t\t\t\t| [] -> []\r\n\t\t\t\t\t\t\t\t| x::xs ->\r\n\t\t\t\t\t\t\t\t\tlet (replaced, index) =\r\n\t\t\t\t\t\t\t\t\t\tif rule.body = [epsilon] then\r\n\t\t\t\t\t\t\t\t\t\t\treplace_subsequence_with_index current rule.head [] (List.length rule.head)\r\n\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t\treplace_subsequence_with_index current rule.head rule.body (List.length rule.head)\r\n\t\t\t\t\t\t\t\t\tin\r\n\t\t\t\t\t\t\t\t\tmatch index with\r\n\t\t\t\t\t\t\t\t\t| Some idx ->\r\n\t\t\t\t\t\t\t\t\t\tif replaced <> current then\r\n\t\t\t\t\t\t\t\t\t\t\t(replaced, Some (idx + curr_i)) :: (List.map (fun (c, i) -> (x :: c, i)) (combinations xs rule (curr_i + 1)))\r\n\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t\tList.map (fun (c, i) -> (x :: c, i)) (combinations xs rule (curr_i + 1))\r\n\t\t\t\t\t\t\t\t\t| None -> combinations xs rule (curr_i + 1)\r\n\t\t\t\t\t\t\tin\r\n\t\t\t\t\t\t\tlet replaced = combinations current rule 0 in\r\n\t\t\t\t\t\t\t(* List.iter (fun (w, i) -> Printf.printf \"Current %s, Replaced: %s, Index: %d\\n\" (word2str current) (word2str w) (match i with Some idx -> idx | None -> -1)) replaced;\r\n\t\t\t\t\t\t\tprint_endline \"----------------\"; *)\r\n\t\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t\t\tlet found = List.find (fun r -> (fst r) = next) replaced in\r\n\t\t\t\t\t\t\t\tmatch snd found with\r\n\t\t\t\t\t\t\t\t| Some idx -> index_rule := idx; true\r\n\t\t\t\t\t\t\t\t| _ -> false\r\n\t\t\t\t\t\t\twith Not_found -> false\r\n\t\t\t\t\t\t) rules)\r\n\t\t\t\t\twith Not_found -> None\r\n\t\t\t\tin\r\n\t\t\t\taux (i + 1) (((current, i), (applicable_rule, !index_rule)) :: acc)\r\n\t\t\telse\r\n\t\t\t\tacc\r\n\t\tin\r\n\t\tlet result = aux 0 [((fst (List.nth path (List.length path - 1)), List.length path - 1), (Some {head = []; body = []}, -1))] in\r\n\t\tList.sort (fun ((_, level1), _) ((_, level2), _) -> compare level1 level2) result\r\n\r\nend\r\n\r\nmodule GrammarGenerate =\r\nstruct\r\n\topen GrammarSupport\r\n\topen GrammarAccept\r\n\topen GrammarPrivate\r\n\r\n\r\n\tlet expandGenerate (gram: t) (len: int) (sf,w) : configurations =\r\n\t\tlet rules = gram.rules in\r\n\t\tlet heads = Set.toList (Set.map (fun r -> r.head) rules) in\r\n\t\tlet configs = expand heads rules sf w in\r\n\t\tif isMonotonicGrammar gram then\r\n\t\t\tlet filtered = Set.filter (fun (sf', _) -> List.length sf' <= len) configs in\r\n\t\t\tfiltered\r\n\t\telse\r\n\t\t\tconfigs\r\n\r\n\tlet nextConfigsGenerate (gram: t) (len: int) (sf, w) : configurations =\r\n\t\tlet res = expandGenerate gram len (sf, w) in\r\n\t\t\tres\r\n\r\n\r\n\tlet isAcceptingConfigGenerate (gram: t) (sf, w) : bool =\r\n\t\tList.for_all(fun sym -> Set.belongs sym gram.alphabet) sf\r\n\r\n\tlet isTerminalSymbol (symbol: symbol) : bool =\r\n\t\tlet str = symb2str symbol in\r\n\t\tnot (\"A\" <= str && str <= \"Z\") && not (String.get str 0 = '<' && String.get str (String.length str - 1) = '>')\r\n\r\n\tlet getWord (sf, _) = List.filter (fun symb -> isTerminalSymbol symb) sf\r\n\r\n\tlet generate (gram: t) (len: int) : words =\r\n\t\tlet processed_gram =\r\n\t\t\tgram\r\n\t\t\t|> (fun g -> if not (isClean g) then clean g else g)\r\n\t\t\t|> (fun g ->\r\n\t\t\t\tif isContextFreeGrammar g && hasEpsilonRules g\r\n\t\t\t\tthen removeEpsilonRules g\r\n\t\t\t\telse g)\r\n\t\tin\r\n\t\t(* show processed_gram; *)\r\n\t\tif (generatesEmpty gram) then\r\n\t\t\tSet.add (str2word \"\") (Model.generate processed_gram len initialConfig nextConfigsGenerate isAcceptingConfigGenerate getWord)\r\n\t\telse\r\n\t\t\tModel.generate processed_gram len initialConfig nextConfigsGenerate isAcceptingConfigGenerate getWord\r\n\r\nend\r\n\r\nmodule GrammarConversion = (* Pedro + Artur *)\r\nstruct\r\n\topen GrammarSupport\r\n\topen GrammarPrivate\r\n\topen GrammarGenerate\r\n\r\n\tlet generateNewVariable variables=\r\n\t\tlet start = 65 in (* ASCII value for 'A' *)\r\n\t\tlet rec auxGenerateNewVariable i =\r\n\t\t\tif i > 90 then (* ASCII value for 'Z' No more capital letters available for new nonterminals*)\r\n\t\t\t\tSymbol.str2symb (IdGenerator.genVar \"A\")\r\n\t\t\telse\r\n\t\t\t\tlet newVar = Char.uppercase_ascii (char_of_int i) in\r\n\t\t\t\tif Set.belongs (Symbol.str2symb (Char.escaped newVar)) variables then\r\n\t\t\t\t\tauxGenerateNewVariable (i + 1)\r\n\t\t\t\telse\r\n\t\t\t\t\tSymbol.str2symb (Char.escaped newVar)\r\n\t\tin\r\n\t\tauxGenerateNewVariable start\r\n\r\n\r\n\r\n\r\n\r\n\t(*HOW to Kuroda normal form:\r\n\tEnsure the grammar is context-sensitive\r\n\tRemove useless symbols:\r\n\t\tEnsure all nonterminals can derive a terminal string and can be reached from the start symbol. Use the clean.\r\n\tConvert long productions to binary form:\r\n\t\tBreak down rules with more than two nonterminals or terminals (e.g.,  A -> X_1 X_2 X_3 ) into binary forms, using intermediate nonterminals:\r\n\t\tA -> X_1 A_1, A_1 -> X_2 X_3\r\n\tHandle terminal symbols:\r\n\t\tIf a terminal appears with a nonterminal (e.g.,  A -> aB ), introduce a new nonterminal for the terminal:\r\n\t\tA -> T_a B, T_a -> a\r\n\t*)\r\n\t\t(* Helper function to count variables in a list of symbols *)\r\n\t\tlet countVariables symbols variables =\r\n\t\t\tList.fold_left (fun count symb -> if Set.belongs symb variables then count + 1 else count) 0 symbols\r\n\r\n\t\t(* Helper function to find consecutive non-terminals in a list of symbols *)\r\n\t\tlet rec findConsecutiveNonTerminals variables body =\r\n\t\t\tmatch body with\r\n\t\t\t| [] | [_] -> None\r\n\t\t\t| x :: y :: xs ->\r\n\t\t\t\tif Set.belongs x variables && Set.belongs y variables then\r\n\t\t\t\t\tSome [x; y]\r\n\t\t\t\telse\r\n\t\t\t\t\tfindConsecutiveNonTerminals variables (y :: xs)\r\n\r\n\t\t(* Helper function to find a sequence of a variable and an alphabet symbol *)\r\n\t\tlet rec findSequence variables alphabet body =\r\n\t\t\tmatch body with\r\n\t\t\t| [] | [_] -> None\r\n\t\t\t| x :: y :: xs ->\r\n\t\t\t\tif (Set.belongs x variables && Set.belongs y alphabet) || (Set.belongs x alphabet && Set.belongs y variables) then\r\n\t\t\t\t\tSome [x; y]\r\n\t\t\t\telse\r\n\t\t\t\t\tfindSequence variables alphabet (y :: xs)\r\n\r\n\t\t(* Helper function to find an alphabet symbol in a sequence *)\r\n\t\tlet rec findAlphabetSymbol alphabet sequence =\r\n\t\t\tmatch sequence with\r\n\t\t\t| [] -> str2symb \"a\" (* not reached *)\r\n\t\t\t| x :: xs ->\r\n\t\t\t\tif Set.belongs x alphabet then\r\n\t\t\t\t\tx\r\n\t\t\t\telse\r\n\t\t\t\t\tfindAlphabetSymbol alphabet xs\r\n\r\n\t\t(* Step 1: Introduce variables for terminals (T_a -> a) using Hashtbl *)\r\n\t\tlet introduceTerminalVariables (gram: t) : t =\r\n\t\t\t(* Create a mutable hash table to map terminal symbols to new variables *)\r\n\t\t\t(* Initial size can be estimated, e.g., size of alphabet *)\r\n\t\t\tlet term_map : (symbol, symbol) Hashtbl.t = Hashtbl.create (Set.size gram.alphabet) in\r\n\t\t\tlet current_vars = ref gram.variables in\r\n\t\t\tlet new_terminal_rules = ref Set.empty in (* Stores T_a -> a rules *)\r\n\t\t\tlet original_rules = gram.rules in (* Keep a copy of original rules *)\r\n\r\n\t\t\t(* First pass: Populate the hash map and create new variable symbols/rules *)\r\n\t\t\tSet.iter (fun terminal ->\r\n\t\t\t\tif terminal <> epsilon then (* Epsilon is not in the alphabet *)\r\n\t\t\t\t\t(* Generate a new variable for this terminal *)\r\n\t\t\t\t\tlet new_var_symb = generateNewVariable !current_vars in\r\n\t\t\t\t\tcurrent_vars := Set.add new_var_symb !current_vars;\r\n\t\t\t\t\t(* Add mapping to hash table: terminal -> new_var_symb *)\r\n\t\t\t\t\tHashtbl.replace term_map terminal new_var_symb;\r\n\t\t\t\t\t(* Create the rule: new_var_symb -> terminal *)\r\n\t\t\t\t\tnew_terminal_rules := Set.add { head = [new_var_symb]; body = [terminal] } !new_terminal_rules\r\n\t\t\t) gram.alphabet;\r\n\r\n\t\t\t(* Second pass: Iterate through original rules and replace terminals *)\r\n\t\t\tlet final_other_rules = ref Set.empty in (* Stores modified original rules *)\r\n\t\t\tSet.iter (fun rule ->\r\n\t\t\t\tlet replace_terminal symb =\r\n\t\t\t\t\tmatch Hashtbl.find_opt term_map symb with (* Lookup in hash table *)\r\n\t\t\t\t\t| Some new_var -> new_var (* Found mapping, replace *)\r\n\t\t\t\t\t| None -> symb (* Not a terminal needing replacement, keep as is *)\r\n\t\t\t\tin\r\n\t\t\t\tlet new_head = List.map replace_terminal rule.head in\r\n\t\t\t\tlet new_body = List.map replace_terminal rule.body in\r\n\t\t\t\tfinal_other_rules := Set.add { head = new_head; body = new_body } !final_other_rules\r\n\t\t\t) original_rules;\r\n\r\n\t\t\t(* Combine the new (T_a -> a) rules and the modified original rules *)\r\n\t\t\tlet final_rules = Set.union !new_terminal_rules !final_other_rules in\r\n\r\n\t\t\t(* Return the updated grammar *)\r\n\t\t\t{ gram with variables = !current_vars; rules = final_rules }\r\n\t\t\t(* We don't need to return the hash table itself if it's not used later *)\r\n\r\n\t\t(* Main transformation function *)\r\n\t\tlet rec transformGrammar gram =\r\n\t\t\t(* Step 1: Prioritize checking for heads longer than 2 symbols *)\r\n\t\t\tmatch Set.find_opt (fun r -> List.length r.head > 2) gram.rules with\r\n\t\t\t| Some rule_with_long_head ->\r\n\t\t\t\t\t(* Found a rule with head length > 2. Fix this first. *)\r\n\t\t\t\t\t(* Example: H1 H2 H3... -> Body  becomes  NewVar -> H1 H2,  NewVar H3... -> Body *)\r\n\t\t\t\t\tlet newVariable = generateNewVariable gram.variables in\r\n\t\t\t\t\tlet updated_vars = Set.add newVariable gram.variables in\r\n\t\t\t\t\tlet remaining_rules = Set.remove rule_with_long_head gram.rules in\r\n\t\t\r\n\t\t\t\t\t(match rule_with_long_head.head with\r\n\t\t\t\t\t | h1 :: h2 :: rest_head -> (* Must have at least 3 elements due to length check *)\r\n\t\t\t\t\t\t\t let newRuleHead = { head = [newVariable]; body = [h1; h2] } in\r\n\t\t\t\t\t\t\t let modifiedRule = { head = newVariable :: rest_head; body = rule_with_long_head.body } in\r\n\t\t\t\t\t\t\t let updated_rules = Set.add newRuleHead (Set.add modifiedRule remaining_rules) in\r\n\t\t\t\t\t\t\t let updated_gram = { gram with variables = updated_vars; rules = updated_rules } in\r\n\t\t\t\t\t\t\t transformGrammar updated_gram (* Recurse: continue transforming *)\r\n\t\t\t\t\t | _ ->\r\n\t\t\t\t\t\t\t (* This case should technically not be reached if List.length > 2 *)\r\n\t\t\t\t\t\t\t Error.error \"transformGrammar\" \"Internal inconsistency checking head length\" ();\r\n\t\t\t\t\t\t\t gram (* Return original gram on unexpected error *)\r\n\t\t\t\t\t)\r\n\t\t\r\n\t\t\t| None ->\r\n\t\t\t\t\t(* No heads longer than 2 found. Now check for bodies longer than 2 symbols. *)\r\n\t\t\t\t\t(* This part adapts the KNF requirement: Head -> B1 B2 B3... becomes Head -> B1 NewVar, NewVar -> B2 B3... *)\r\n\t\t\t\t\tmatch Set.find_opt (fun r -> List.length r.body > 2) gram.rules with\r\n\t\t\t\t\t| Some rule_with_long_body ->\r\n\t\t\t\t\t\t\t(* Found a rule with body length > 2. *)\r\n\t\t\t\t\t\t\tlet newVariable = generateNewVariable gram.variables in\r\n\t\t\t\t\t\t\tlet updated_vars = Set.add newVariable gram.variables in\r\n\t\t\t\t\t\t\tlet remaining_rules = Set.remove rule_with_long_body gram.rules in\r\n\t\t\r\n\t\t\t\t\t\t\t(match rule_with_long_body.body with\r\n\t\t\t\t\t\t\t | b1 :: rest_body_all when List.length rest_body_all >= 2 -> (* Body needs at least 3 elements *)\r\n\t\t\t\t\t\t\t\t\t let newRuleBody = { head = [newVariable]; body = rest_body_all } in\r\n\t\t\t\t\t\t\t\t\t let modifiedRule = { head = rule_with_long_body.head; body = [b1; newVariable] } in\r\n\t\t\t\t\t\t\t\t\t let updated_rules = Set.add newRuleBody (Set.add modifiedRule remaining_rules) in\r\n\t\t\t\t\t\t\t\t\t let updated_gram = { gram with variables = updated_vars; rules = updated_rules } in\r\n\t\t\t\t\t\t\t\t\t transformGrammar updated_gram (* Recurse: continue transforming *)\r\n\t\t\t\t\t\t\t | _ ->\r\n\t\t\t\t\t\t\t\t\t (* This case should not be reached if List.length > 2 *)\r\n\t\t\t\t\t\t\t\t\t Error.error \"transformGrammar\" \"Internal inconsistency checking body length\" ();\r\n\t\t\t\t\t\t\t\t\t gram (* Return original gram on unexpected error *)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t| None ->\r\n\t\t\t\t\t\t\t(* No heads > 2 and no bodies > 2. Transformation is complete. *)\r\n\t\t\t\t\t\t\tgram\r\n\t\t(* let rec transformGrammar gram =\r\n\r\n\t\t\tlet longProductionsBody = Set.filter (fun r -> countVariables r.body gram.variables > 2) gram.rules in\r\n\t\t\t\r\n\t\t\tif Set.isEmpty longProductionsBody then\r\n\t\t\t\tgram\r\n\t\t\telse\r\n\t\t\t\tlet gram =\r\n\t\t\t\t\tif not (Set.isEmpty longProductionsBody) then\r\n\t\t\t\t\t\tlet longProduction = Set.hd longProductionsBody in\r\n\t\t\t\t\t\tlet newVariable = generateNewVariable gram.variables in\r\n\t\t\t\t\t\tlet consecutiveNonTerminals = findConsecutiveNonTerminals gram.variables longProduction.body in\r\n\t\t\t\t\t\tlet newRules =\r\n\t\t\t\t\t\t\tList.map (fun rule ->\r\n\t\t\t\t\t\t\t\tmatch consecutiveNonTerminals with\r\n\t\t\t\t\t\t\t\t| Some cn ->\r\n\t\t\t\t\t\t\t\t\tlet new_body = replace_subsequence rule.body cn [newVariable] 2 in\r\n\t\t\t\t\t\t\t\t\t{ rule with body = new_body }\r\n\t\t\t\t\t\t\t\t| None -> rule\r\n\t\t\t\t\t\t\t) (Set.toList gram.rules)\r\n\t\t\t\t\t\tin\r\n\t\t\t\t\t\tlet newRules = Set.add {head = [newVariable]; body = Option.get consecutiveNonTerminals} (Set.make newRules) in\r\n\t\t\t\t\t\t{gram with rules = newRules; variables = Set.add newVariable gram.variables}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tgram\r\n\t\t\t\tin\r\n\r\n\t\t\r\n\t\t\t\ttransformGrammar gram *)\r\n\r\n\r\n\r\n\t\t \r\n\tlet kurodaNormalForm (gram: t) : t =\r\n\t\t(* show gram;\r\n\t\tshow (replaceTerminalSymbols gram); *)\r\n\t\tgram\r\n\t\t\t|> clean\r\n\t\t\t|> introduceTerminalVariables\r\n\t\t\t|> transformGrammar\r\n\t\t\r\n\r\n\t\t(* gram\r\n\t\t|> clean \r\n\t\t|> transformGrammar *)\r\n\r\n\r\n\t(*\r\n\tNOTE:\r\n\tConversely, every noncontracting grammar that does not generate the empty string\r\n\tcan be converted to Kuroda normal form.\r\n\r\n\tA straightforward technique attributed to György Révész\r\n\ttransforms a grammar in Kuroda normal form to a\r\n\tcontext-sensitive grammar: AB → CD is replaced\r\n\tby four context-sensitive rules AB → AZ, AZ → WZ, WZ → WD and WD → CD. *)\r\n\r\n\tlet makeContextRules (gram: t) : t =\r\n\t\tlet rec processRules rulesToCheck gramAux =\r\n\t\t\tmatch rulesToCheck with\r\n\t\t\t| [] -> gramAux\r\n\t\t\t| rule :: rest ->\r\n\t\t\t\t\tif List.length rule.head = 2 && List.length rule.body = 2 then\r\n\t\t\t\t\t\t\tmatch rule.head, rule.body with\r\n\t\t\t\t\t\t\t| [a; b], [c; d] ->\r\n\t\t\t\t\t\t\t\tif a <> c && b <> d then\r\n\t\t\t\t\t\t\t\t\tlet z = generateNewVariable gramAux.variables in\r\n\t\t\t\t\t\t\t\t\tlet w = generateNewVariable (Set.union gramAux.variables (Set.make [z])) in\r\n\t\t\t\t\t\t\t\t\tlet new_variables = Set.add z (Set.add w gramAux.variables) in\r\n\r\n\t\t\t\t\t\t\t\t\tlet new_rules = Set.add {head = [a; b]; body = [a; z]} gramAux.rules in\r\n\t\t\t\t\t\t\t\t\tlet new_rules = Set.add {head = [a; z]; body = [w; z]} new_rules in\r\n\t\t\t\t\t\t\t\t\tlet new_rules = Set.add {head = [w; z]; body = [w; d]} new_rules in\r\n\t\t\t\t\t\t\t\t\tlet new_rules = Set.add {head = [w; d]; body = [c; d]} new_rules in\r\n\t\t\t\t\t\t\t\t\tprocessRules rest {gramAux with rules = (Set.remove rule new_rules); variables = new_variables}\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\tprocessRules rest gramAux\r\n\t\t\t\t\t\t\t| _ -> failwith  \"No supposed to happen, matching error\"\r\n\t\t\t\t\telse processRules rest gramAux\r\n\r\n\t\tin\r\n\t\tprocessRules (Set.toList gram.rules) gram\r\n\r\n\tlet nonContractingToCSG (gram: t) : t =\r\n\t\t\tif isContextSensitiveGrammar gram then\r\n\t\t\t\t\tgram\r\n\t\t\telse\r\n\t\t\t\t\tif isNoncontractingGrammar gram then\r\n\t\t\t\t\t\tlet kuroda_gram = kurodaNormalForm gram in\r\n\t\t\t\t\t\t(* print_endline \"Kuroda Grammar:\";\r\n\t\t\t\t\t\tshow kuroda_gram; *)\r\n\t\t\t\t\t\t(* let new_gram = makeContextRules kuroda_gram in *)\r\n\t\t\t\t\t\t(* print_endline \"New Grammar:\"; *)\r\n\t\t\t\t\t\tmakeContextRules kuroda_gram\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t\tfailwith \"Grammar is not noncontracting\"\r\n\r\n\t(*HOW TO DO Grammar to Penttonen normal form:\r\n\tPerform the Kuroda Normal Form Conversion\r\n\tRemove unit productions:\r\n\t\tEliminate any unit productions of the form  A -> B , where both  A  and  B  are nonterminals.*)\r\n\tlet rec removeUnitProductions (gram: t) : t =\r\n\t\t(* Identify unit productions *)\r\n\t\tlet unitProductions = Set.filter (fun r -> List.length r.head = 1\r\n\t\t\t\t&& List.length r.body = 1\r\n\t\t\t\t&& Set.belongs (List.hd r.body) gram.variables\r\n\t\t\t\t&& Set.belongs (List.hd r.head) gram.variables)\r\n\t\tgram.rules in\r\n\r\n\t\tif Set.isEmpty unitProductions then\r\n\t\t\t\tgram\r\n\t\telse\r\n\t\t(* Select a unit production *)\r\n\t\tlet unitProduction = Set.hd unitProductions in\r\n\t\tlet symbolToReplace = List.hd unitProduction.head in\r\n\t\tlet replacementSymbol = List.hd unitProduction.body in\r\n\t\tlet replace_symbol lst =\r\n\t\t\t\tList.map (fun x -> if x = symbolToReplace then replacementSymbol else x) lst\r\n\t\tin\r\n\t\t(* Replace occurrences of unitProduction.head with unitProduction.body in other rules *)\r\n\t\tlet newRules =\r\n\t\t\tList.filter (fun rule -> rule.head <> rule.body) (\r\n\t\t\t\tList.map (fun rule ->\r\n\t\t\t\t\tlet new_head = replace_symbol rule.head in\r\n\t\t\t\t\tlet new_body = replace_symbol rule.body in\r\n\t\t\t\t\t{ head = new_head; body = new_body }\r\n\t\t\t\t) (Set.toList gram.rules)\r\n\t\t\t)\r\n\t\tin\r\n\t\tlet newVariables = Set.remove symbolToReplace gram.variables in\r\n\t\tlet newInitial = if gram.initial = symbolToReplace then replacementSymbol else gram.initial in\r\n\t\tremoveUnitProductions {gram with rules = (Set.make newRules); variables = newVariables; initial = newInitial}\r\n\r\n\tlet penttonenNormalForm (gram: t) : t =\r\n\t\tgram\r\n\t\t|> kurodaNormalForm\r\n\t\t|> makeContextRules\r\n\t\t|> removeUnitProductions\r\n\r\n\r\n\r\nend\r\n\r\n\r\n\r\n\r\nmodule Grammar =\r\nstruct\r\n    include GrammarSupport\r\n    open GrammarPrivate\r\n\r\n    (* Make *)\r\n    let make2 (arg: t Arg.alternatives): Entity.t * t = make2 arg validate\r\n    let make (arg: t Arg.alternatives): t = make arg validate\r\n\r\n    let isUnrestrictedGrammar = isUnrestrictedGrammar\r\n    let isContextFreeGrammar = isContextFreeGrammar\r\n    let isLinearGrammar = isLinearGrammar\r\n    let isRightLinearGrammar = isRightLinearGrammar\r\n    let isLeftLinearGrammar = isLeftLinearGrammar\r\n    let isContextSensitiveGrammar = isContextSensitiveGrammar\r\n    let isMonotonicGrammar = isMonotonicGrammar\r\n\t\tlet isMonotonicStrictGrammar = isMonotonicStrictGrammar\r\n    let isNoncontractingGrammar = isNoncontractingGrammar\r\n\t\tlet removeEpsilonRules = removeEpsilonRules\r\n\t\tlet hasEpsilonRules = hasEpsilonRules\r\n\r\n\r\n\t\t(*Conversions*)\r\n\t\tlet kurodaNormalForm = GrammarConversion.kurodaNormalForm\r\n\t\tlet penttonenNormalForm = GrammarConversion.penttonenNormalForm\r\n\t\tlet nonContractingToCSG = GrammarConversion.nonContractingToCSG\r\n\t\t(* Clean *)\r\n\t\tlet allRulesAccessible = allRulesAccessible\r\n\t\tlet allRulesProductive = allRulesProductive\r\n\t\tlet isClean = isClean\r\n\t\tlet clean = clean\r\n\r\n\t\t(* Acceptance *)\r\n\t\tlet accept = GrammarAccept.accept\r\n\t\tlet accept2 = GrammarAccept.accept2\r\n\t\tlet acceptFull = GrammarAccept.acceptFull\r\n\t\tlet find_applied_rules = GrammarAccept.find_applied_rules\r\n\r\n\t\t(* Generate *)\r\n\t\tlet generate = GrammarGenerate.generate\r\n\r\n    (* Exercices support *)\r\n    let checkProperty (gram: t) (prop: string) =\r\n        match prop with\r\n        | \"grammar\" -> true\r\n\t\t\t\t| \"unrestricted grammar\" -> true\r\n\t\t\t\t| \"monotonic grammar\" -> isMonotonicGrammar gram\r\n\t\t\t\t| \"monotonic grammar strict\" -> isMonotonicStrictGrammar gram\r\n\t\t\t\t| \"context free grammar\" -> isContextFreeGrammar gram\r\n\t\t\t\t| \"context sensitive grammar\" -> isContextSensitiveGrammar gram\r\n\t\t\t\t| \"context sensitive grammar strict\" -> isContextSensitiveGrammar gram && not (isContextFreeGrammar gram)\r\n\t\t\t\t| \"noncontracting grammar\" -> isNoncontractingGrammar gram\r\n\t\t\t\t| \"linear grammar\" -> isLinearGrammar gram\r\n\t\t\t\t| \"right linear grammar\" -> isRightLinearGrammar gram\r\n\t\t\t\t| \"left linear grammar\" -> isLeftLinearGrammar gram\r\n        | _ -> Model.checkProperty prop\r\n    let checkExercise ex gram = Model.checkExercise ex (accept gram) (checkProperty gram)\r\n    let checkExerciseFailures ex gram = Model.checkExerciseFailures ex (accept gram) (checkProperty gram)\r\n\r\n\r\n\r\n\r\n    class model (arg: t Arg.alternatives) =\r\n        object(self) inherit Model.model (make2 arg) as super\r\n            val mutable simplified = false\r\n        (* Representation *)\r\n            method representation = representation\r\n        (* Kind *)\r\n\t\t\t\t\t\tmethod isGrammar : bool = true\r\n\r\n        (* Show *)\r\n            method toJSon: JSon.t = toJSon representation\r\n            method toJSon2: JSon.t = toJSon2 id representation\r\n            method show: unit = show representation\r\n            method show2: unit = show2 id representation\r\n\r\n            method accept (testWord:word) : bool = GrammarAccept.accept representation testWord\r\n            method generate (length:int) : words = GrammarGenerate.generate representation length\r\n\r\n        (* Exercices support *)\r\n            method checkProperty (prop: string) = checkProperty representation prop\r\n\r\n        (* Learn-OCaml support *)\r\n            method moduleName = moduleName\r\n            method xTypeName = xTypeName\r\n            method xTypeDeclString : string = prelude\r\n            method toDisplayString (name: string): string = solution name self#representation\r\n            method example : JSon.t = example\r\n        end\r\n\r\nend\r\n\r\n\r\nmodule GrammarTop =\r\nstruct\r\n\topen Grammar\r\n\topen GrammarBasicsX\r\n\r\n\ttype configurationX = string * string\r\n\ttype configurationsX = configurationX list\r\n\r\n\tlet confX ((s,w): configuration): configurationX =\r\n\t\t(wordX s, wordX w)\r\n\tlet confsX (c: configurations): configurationsX =\r\n\t\tList.map confX (Set.toList c)\r\n\r\n\tlet pathX (p: path) = pathX confX p\r\n\tlet trailX (t: trail) = trailX confX t\r\n\r\n\tlet gI = internalize\r\n\tlet gX = externalize\r\n\r\n\tlet g_load file = gX (make (Arg.File file))\r\n\tlet g_text text = gX (make (Arg.Text text))\r\n\tlet g_json json = gX (make (Arg.JSon json))\r\n\tlet g_predef name = g_text (Examples.example name)\r\n\r\n\tlet g_init gx w =\r\n\t\tlet is = GrammarAccept.initialConfig (gI gx) (wordI w) in\r\n\t\t\tconfsX is\r\n\r\n\tlet stats () = RuntimeControl.stats ()\r\n\r\n\tlet g_accept gx w = accept (gI gx) (wordI w)\r\n\r\n\tlet g_path gx w =\r\n\t\tlet (r,p,t) = acceptFull (gI gx) (wordI w) in\r\n\t\t\tpathX p\r\n\r\n\tlet g_trail gx w =\r\n\t\tlet (r,p,t) = acceptFull (gI gx) (wordI w) in\r\n\t\t\ttrailX t\r\n\r\n\tlet g_generate gx len = wordsX (generate (gI gx) len)\r\nend\r\n\r\nopen GrammarTop\r\n\r\n\r\n(*\r\n\r\n--------------------\r\n\r\n#print_depth 10000;;\r\n#print_length 10000;;\r\n\r\nlet ab = {| {\r\n\t\tkind : \"grammar\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"ab\",\r\n\t\talphabet : [\"a\", \"b\"],\r\n\t\tvariables : [\"S\", \"A\", \"B\"],\r\n\t\tinitial : \"S\",\r\n\t\trules : [\t\"S -> AB\",\r\n\t\t\t\t\t\"A -> aA | ~\",\r\n\t\t\t\t\t\"B -> b\" ]\r\n\t\t} |};;\r\n\r\nlet g = g_text ab;;\r\nlet w = \"ab\";;\r\ng_init g w;;\r\ng_accept g \"ab\";;\r\ng_path g \"ab\";;\r\ng_trail g \"ab\";;\r\ng_generate g 4;;\r\n--------------------\r\n\r\n*)\r\n# 1 \"src/GrammarTests.ml\"\r\n(*\r\n * GrammarUnrestrictedTests.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Pedro Carlos (p.carlos)\r\n *)\r\n\r\n\r\nmodule GrammarTests : sig end =\r\nstruct\r\n\r\n\r\n\tlet active = false\r\n\r\n\topen Grammar\r\n\topen BasicTypes\r\n\r\n\t(* Sample grammars *)\r\n\r\n\tlet unGrammar = {| {\r\n    kind: \"grammar\",\r\n    description: \"Unrestricted grammar example\",\r\n    name: \"g_unrestricted\",\r\n    alphabet: [\"a\", \"b\", \"c\"],\r\n    variables: [\"S\", \"A\", \"B\"],\r\n    initial: \"S\",\r\n    rules: [\r\n        \"S -> aSBc\",\r\n\t\t\t\t\"S -> ~\",\r\n        \"cB -> Bc\",\r\n        \"bB -> bb\"\r\n    ]\r\n} |}\r\n\r\nlet replaced = {|{\r\n        kind : \"grammar\",\r\n        description : \"_\",\r\n        name : \"_\",\r\n        alphabet : [\"a\", \"b\"],\r\n        variables : [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"S\", \"G\", \"H\"],\r\n        initial : \"S\",\r\n        rules : [\"A -> AA\", \"A -> BD\", \"A -> CS\",\r\n\t\t\t\t\"B -> AB\", \"B -> BE\", \"B -> CG\",\r\n\t\t\t\t \"C -> AC\", \"C -> BF\", \"C -> CH\",\r\n\t\t\t\t  \"D -> DA\", \"D -> ED\", \"D -> FS\",\r\n\t\t\t\t\t \"E -> DB\", \"E -> EE\", \"E -> FG\",\r\n\t\t\t\t\t  \"F -> DC\", \"F -> EF\", \"F -> FH\",\r\n\t\t\t\t\t\t \"S -> SA\", \"S -> GD\", \"S -> HS\",\r\n\t\t\t\t\t\t  \"G -> SB\", \"G -> GE\", \"G -> HG\",\r\n\t\t\t\t\t\t\t \"H -> SC\", \"H -> GF\", \"H -> HH\",\r\n\t\t\t\t\t\t\t \"G -> aGb\", \"G -> aHb\", \"H -> ~\", \"E -> ~\", \"A -> ~\"]\r\n}|}\r\n\r\nlet unGrammar2 = {| {\r\n\tkind: \"grammar\",\r\n\tdescription: \"Unrestricted grammar example\",\r\n\tname: \"g_unrestricted\",\r\n\talphabet: [\"1\", \"2\", \"c\", \"3\", \"+\", \"d\"],\r\n\tvariables: [\"S\", \"A\"],\r\n\tinitial: \"S\",\r\n\trules: [\r\n\t\t\t\"S -> +AAAA+\",\r\n\t\t\t\"AA -> 1\",\r\n\t\t\t\"AA -> 2\",\r\n\t\t\t\"1AA -> 3\",\r\n\t\t\t\"A1A -> c\",\r\n\t\t\t\"A2A -> d\"\t]\r\n} |}\r\n \r\n\r\nlet testAB = {| {\r\n\tkind: \"grammar\",\r\n\tdescription: \"Unrestricted grammar example\",\r\n\tname: \"g_unrestricted\",\r\n\talphabet: [\"a\", \"b\"],\r\n\tvariables: [\"S\", \"A\", \"B\"],\r\n\tinitial: \"S\",\r\n\trules: [\r\n\t\t\t\"S -> SAB | ~\",\r\n\t\t\t\"A -> a\",\r\n\t\t\t\"B -> b\"\t]\r\n} |}\r\n\r\n\r\nlet cfg = {| \t\t{\r\n\tkind : \"grammar\",\r\n\tdescription : \"this is an example\",\r\n\tname : \"cfg_simple\",\r\n\talphabet : [\"0\", \"1\"],\r\n\tvariables : [\"S\", \"P\"],\r\n\tinitial : \"S\",\r\n\trules : [\r\n\t\"S -> 1S0\",\r\n\t\"S -> P\",\r\n\t\"P -> 0P1\", \"P -> ~\" ]\r\n}|}\r\n\r\nlet cfg_bounded = {| {\r\n\tkind : \"grammar\",\r\n\tdescription : \"CFG: Language of balanced square bracket parentheses\",\r\n\tname : \"cfg_balanced\",\r\n\talphabet : [\"[\", \"]\", \"a\"],\r\n\tvariables : [\"S\", \"A\"],\r\n\tinitial : \"S\",\r\n\trules : [ \"S -> [S] | A\", \"A -> a\" ]\r\n} |}\r\n\r\nlet csg = {| {\r\n\tkind: \"grammar\",\r\n\tdescription: \"a^nb^nc^n\",\r\n\tname: \"custom_csg\",\r\n\talphabet: [\"a\", \"b\", \"c\"],\r\n\tvariables: [\"S\", \"B\", \"C\", \"Z\", \"W\"],\r\n\tinitial: \"S\",\r\n\trules: [\r\n\t\"S -> aBC\",\r\n\t\"S -> aSBC\",\r\n\t\"CB -> CZ\",\r\n\t\"CZ -> WZ\",\r\n\t\"WZ -> WC\",\r\n\t\"WC -> BC\",\r\n\t\"aB -> ab\",\r\n\t\"bB -> bb\",\r\n\t\"bC -> bc\",\r\n\t\"cC -> cc\"]\r\n} |}\r\n\r\nlet non_contracting = {| {\r\n\tkind: \"grammar\",\r\n\tdescription: \"a^nb^nc^n\",\r\n\tname: \"custom_non_contracting\",\r\n\talphabet: [\"a\", \"b\", \"c\"],\r\n\tvariables: [\"S\", \"B\"],\r\n\tinitial: \"S\",\r\n\trules: [\r\n\t\"S -> abc\",\r\n\t\"S -> aSBc\",\r\n\t\"cB -> Bc\",\r\n\t\"bB -> bb\"]\r\n} |}\r\n\r\nlet gram_example = {| {\r\n\tkind: \"grammar\",\r\n\tdescription: \"a^nb^nc^n\",\r\n\tname: \"custom_non_contracting\",\r\n\talphabet: [\"[\", \"]\", \"a\"],\r\n\tvariables: [\"S\", \"A\"],\r\n\tinitial: \"S\",\r\n\trules: [\r\n\t\"S -> [ S ] | A\",\r\n\t\"A -> a\"]\r\n\t} |}\r\n\r\n\r\n\tlet gram_example2 = {| {\r\n\t\tkind: \"grammar\",\r\n\t\tdescription: \"a^nb^nc^n\",\r\n\t\tname: \"custom_non_contracting\",\r\n\t\talphabet: [ \"b\", \"a\"],\r\n\t\tvariables: [\"S\", \"A\", \"B\"],\r\n\t\tinitial: \"S\",\r\n\t\trules: [\r\n\t\t\t\"S\t-> aAB\",\r\n\t\t\t\"aA\t-> aB\",\r\n\t\t\t\"B\t-> b | aB\"\r\n\t\t\t]\r\n\t\t} |}\r\n\r\n\tlet gram_example3 = {| {\r\n\t\tkind: \"grammar\",\r\n\t\tdescription: \"a^nb^nc^n\",\r\n\t\tname: \"custom_non_contracting\",\r\n\t\talphabet: [ \"b\", \"a\"],\r\n\t\tvariables: [\"S\", \"A\", \"B\"],\r\n\t\tinitial: \"S\",\r\n\t\trules: [\r\n\t\t\t\"S\t-> AB\",\r\n\t\t\t\"A\t-> a\",\r\n\t\t\t\"B\t-> b\"\r\n\t\t\t]\r\n\t\t} |}\r\n\r\n\tlet lg = {| \t\t{\r\n\t\tkind : \"grammar\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"linear_grammar\",\r\n\t\talphabet : [\"a\", \"b\"],\r\n\t\tvariables : [\"S\"],\r\n\t\tinitial : \"S\",\r\n\t\trules : [\t\"S -> aSb | ~\" ]\r\n\t}|}\r\n\r\n\tlet rlgrammar = {| {\r\n\t\tkind: \"grammar\",\r\n\t\tdescription: \"Right-linear grammar example\",\r\n\t\tname: \"g_right_linear\",\r\n\t\talphabet: [\"0\", \"1\"],\r\n\t\tvariables: [\"S\", \"B\"],\r\n\t\tinitial: \"S\",\r\n\t\trules: [\r\n\t\t\t\t\"S -> 00B | 11S\",\r\n\t\t\t\t\"B -> 0B | 1B | 0 | 1 | ~\"\r\n\t\t]\r\n\t}|}\r\n\r\n\tlet llgrammar = {| {\r\n\t\tkind: \"grammar\",\r\n\t\tdescription: \"Left-linear grammar example\",\r\n\t\tname: \"g_left_linear\",\r\n\t\talphabet: [\"0\", \"1\"],\r\n\t\tvariables: [\"S\", \"B\"],\r\n\t\tinitial: \"S\",\r\n\t\trules: [\r\n\t\t\t\t\"S -> B00 | S11\",\r\n\t\t\t\t\"B -> B0 | B1 | 0 | 1\"\r\n\t\t]\r\n\t}|}\r\n\r\n\tlet cfg_balanced = {| {\r\n\t\tkind : \"grammar\",\r\n\t\tdescription : \"\",\r\n\t\tname : \"remove epsilon example\",\r\n\t\talphabet: [\"a\", \"b\", \"c\"],\r\n\t\tvariables: [\"S\", \"B\", \"A\", \"C\"],\r\n\t\tinitial: \"S\",\r\n\t\trules: [\r\n\t\t\t\"S -> AbB | C\",\r\n\t\t\t\"B -> AA | AC\",\r\n\t\t\t\"C -> b | c\",\r\n\t\t\t\"A -> a | ~\"\r\n\t\t]\r\n\t} |}\r\n\r\n\tlet g_unproductive = {| {\r\n\t\tkind: \"grammar\",\r\n\t\tdescription: \"Unproductive grammar\",\r\n\t\tname: \"g_unproductive\",\r\n\t\talphabet: [\"a\", \"b\"],\r\n\t\tvariables: [\"S\", \"A\", \"B\", \"C\"],\r\n\t\tinitial: \"S\",\r\n\t\trules: [\r\n\t\t\t\"S -> aA\",\r\n\t\t\t\"A -> B\",\r\n\t\t\t\"B -> BB\",\r\n\t\t\t\"C -> a\"\r\n\t\t]\r\n\t}|}\r\n\r\n\tlet g_inaccessible = {| {\r\n\t\tkind: \"grammar\",\r\n\t\tdescription: \"Inaccessible grammar\",\r\n\t\tname: \"g_inaccessible\",\r\n\t\talphabet: [\"t\", \"b\", \"u\"],\r\n\t\tvariables: [\"S\", \"B\", \"A\", \"Z\", \"C\"],\r\n\t\tinitial: \"S\",\r\n\t\trules: [\r\n\t\t\t\"S -> AB\",\r\n\t\t\t\"BAu -> BCZ\",\r\n\t\t\t\"A -> t\",\r\n\t\t\t\"B -> b\",\r\n\t\t\t\"Z -> u\"\r\n\r\n\t\t]\r\n\t}|}\r\n\r\n\tlet cleang = {| {\r\n\t\tkind : \"grammar\",\r\n\t\tdescription : \"Clean example from https://www.tutorialspoint.com/automata_theory/removal_of_useless_symbols_in_cfg.htm\",\r\n\t\tname : \"Clean1\",\r\n\t\talphabet : [\"a\", \"b\"],\r\n\t\tvariables : [\"S\", \"A\", \"B\", \"C\", \"D\"],\r\n\t\tinitial : \"S\",\r\n\t\trules : [\"S -> aA | BC\", \"A -> b | bB\", \"B -> aB | ~\", \"C -> aC | D\", \"D -> bD\"]\r\n\t} |}\r\n\r\n\t(* Result of clean should be: *)\r\n\t(*  S → aA\r\n\t\t\tA → b|bB\r\n\t\t\tB → aB|ε *)\r\n\r\n\r\n\t\t(* Rule with body length > 2 *)\r\n\t\t(* \"S -> ABC\", *)\r\n\r\n\t\t(* Rule with head length > 2 AND body length > 2 *)\r\n\t\t(* \"ABC -> DEF\", *)\r\n\r\n\t\t(* Rule already in AB -> CD form (after terminal replacement) *)\r\n\t\t(* \"DE -> FG\", *)\r\n\r\n\t\t(* Simple terminal rules *)\r\n\t\t(* \"F -> b\",\r\n\t\t\"A -> a\",\r\n\t\t\"E -> b\",\r\n*)\r\n\t\t(* Rule with terminal in body *)\r\n\t\t(* \"G -> cG\", *)\r\n\r\n\t\t(* Rule already in A -> BC form *)\r\n\t\t(* \"B -> AC\", *)\r\n\r\n\t\t(* Unit rule A -> B *)\r\n\t\t(* \"C -> S\" *)\r\n\t\tlet knf_test_grammar = {| {\r\n\t\t\tkind : \"grammar\",\r\n\t\t\tdescription : \"Test grammar for Kuroda Normal Form conversion (long heads/bodies, terminals)\",\r\n\t\t\tname : \"knf_test\",\r\n\t\t\talphabet : [\"a\", \"b\", \"c\"],\r\n\t\t\tvariables : [\"S\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"],\r\n\t\t\tinitial : \"S\",\r\n\t\t\trules : [\r\n\t\t\t\t\"S -> ABC\",\r\n\t\t\t\t\"ABC -> DEF\",\r\n\t\t\t\t\"DE -> FG\",\r\n\t\t\t\t\"F -> b\",\r\n\t\t\t\t\"A -> a\",\r\n\t\t\t\t\"E -> b\",\r\n\t\t\t\t\"G -> cG\",\r\n\t\t\t\t\"B -> AC\",\r\n\t\t\t\t\"C -> S\"\r\n\t\t\t]\r\n\t} |}\r\n\r\n\tlet make_grammar json = Grammar.make (Arg.Text json)\r\n\tlet word = str2word\r\n\tlet assert_accepts grammar words = List.iter (fun w -> assert (Grammar.accept grammar (word w))) words\r\n\tlet assert_rejects grammar words = List.iter (fun w -> assert (not (Grammar.accept grammar (word w)))) words\r\n\r\n\tmodule ClassificationTests = struct\r\n    let test_grammar_types () =\r\n      print_endline \"Testing grammar classification\";\r\n      \r\n      let cfg = make_grammar cfg in\r\n      let csg = make_grammar csg in\r\n\t\t\tlet unrestricted = make_grammar unGrammar in\r\n      let unrestricted2 = make_grammar unGrammar2 in\r\n\r\n\t\t\t(* print_endline \"Testing isUnrestrictedGrammar\"; *)\r\n\t\t\tassert (Grammar.isUnrestrictedGrammar unrestricted);\r\n\t\t\tassert (Grammar.isUnrestrictedGrammar unrestricted2);\r\n\t\t\tassert (Grammar.isUnrestrictedGrammar cfg);\r\n\t\t\tassert (Grammar.isUnrestrictedGrammar csg);\r\n\t\t\tprint_endline \"Passed isUnrestrictedGrammar\";\r\n\r\n\t\t\t(* print_endline \"Testing isContextSensitiveGrammar\"; *)\r\n\t\t\tassert (Grammar.isContextSensitiveGrammar csg);\r\n\t\t\tassert (Grammar.isContextSensitiveGrammar cfg);\r\n\t\t\tassert (not (Grammar.isContextSensitiveGrammar unrestricted));\r\n\t\t\tprint_endline \"Passed isContextSensitiveGrammar\";\r\n\r\n\t\t\t(* print_endline \"Testing isContextFreeGrammar\"; *)\r\n\t\t\tassert (Grammar.isContextFreeGrammar cfg);\r\n\t\t\tassert (not (Grammar.isContextFreeGrammar csg));\r\n\t\t\tassert (not (Grammar.isContextFreeGrammar unrestricted));\r\n\t\t\tprint_endline \"Passed isContextFreeGrammar\";\r\n\r\n\t\t\t(* print_endline \"Testing isLinearGrammar\"; *)\r\n\t\t\tlet linear = make_grammar lg in\r\n\t\t\tassert (Grammar.isLinearGrammar linear);\r\n\t\t\tassert (not (Grammar.isLinearGrammar csg));\r\n\t\t\tprint_endline \"Passed isLinearGrammar\";\r\n\r\n\t\t\t(* print_endline \"Testing isRightLinearGrammar\"; *)\r\n\t\t\tlet rlgrammar = make_grammar rlgrammar in\r\n\t\t\tassert (Grammar.isRightLinearGrammar rlgrammar);\r\n\t\t\tassert (not (Grammar.isRightLinearGrammar csg));\r\n\t\t\tprint_endline \"Passed isRightLinearGrammar\";\r\n\r\n\t\t\t(* print_endline \"Testing isLeftLinearGrammar\"; *)\r\n\t\t\tlet llgrammar = make_grammar llgrammar in\r\n\t\t\tassert (Grammar.isLeftLinearGrammar llgrammar);\r\n\t\t\tassert (not (Grammar.isLeftLinearGrammar csg));\r\n\t\t\tprint_endline \"Passed isLeftLinearGrammar\";\r\n\r\n\t\t\t(* print_endline \"Testing isMonotonicGrammar\"; *)\r\n\t\t\tlet non_contracting = make_grammar non_contracting in\r\n\t\t\tassert (Grammar.isMonotonicGrammar non_contracting);\r\n\t\t\tassert (Grammar.isMonotonicGrammar csg);\r\n\t\t\tassert (not (Grammar.isMonotonicGrammar unrestricted2));\r\n\t\t\tprint_endline \"Passed isMonotonicGrammar\"\r\n  end\r\n\r\n\tmodule ProductionTests = struct\r\n    let test_acceptance () =\r\n      print_endline \"Testing acceptance\";\r\n      \r\n      let csg = make_grammar csg in\r\n\t\t\tlet non_contracting = make_grammar non_contracting in\r\n      assert_accepts csg [\"abc\"; \"aabbcc\"; \"aaabbbccc\"];\r\n      assert_rejects csg [\"ab\"; \"aabcc\"];\r\n\t\t\tassert_accepts non_contracting [\"abc\"; \"aabbcc\"; \"aaabbbccc\"];\r\n\t\t\tassert_rejects non_contracting [\"ab\"; \"aabcc\"];\r\n\r\n      let cfg = make_grammar cfg in\r\n      assert_accepts cfg [\"10\"; \"110100\"];\r\n      assert_rejects cfg [\"001\"; \"101\"];\r\n\r\n      let unrestricted = make_grammar unGrammar2 in\r\n      assert_accepts unrestricted [\"+12+\"; \"+3+\"; \"+c+\"; \"+21+\"; \"+d+\"; \"+11+\"; \"+22+\"];\r\n\r\n\t\t\tprint_endline \"Passed acceptance\"\r\n      \r\n    let test_generation () =\r\n      print_endline \"Testing generation\";\r\n      let csg = make_grammar csg in\r\n\t\t\tlet len = 9 in\r\n\t\t\tlet expected_words = Set.make (List.map word [\"abc\"; \"aabbcc\"; \"aaabbbccc\"]) in\r\n\t\t\tlet actual_words = Grammar.generate csg len in\r\n\t\t\tassert (Set.equals expected_words actual_words);\r\n\r\n\t\t\tlet testNew = make_grammar unGrammar2 in\r\n\t\t\tlet len = 4 in\r\n\t\t\tlet expected_words = Set.make (List.map word [\"+12+\"; \"+3+\"; \"+c+\";\"+21+\";\"+d+\";\"+11+\";\"+22+\" ]) in\r\n\t\t\tlet actual_words = Grammar.generate testNew len in\r\n\t\t\tassert (Set.equals expected_words actual_words);\r\n\r\n\t\t\tlet g_cfg = make_grammar cfg in\r\n\t\t\tlet len = 6 in\r\n\t\t\tlet expected_words = Set.make (List.map word [\"\"; \"01\"; \"10\";\"0011\"; \"1010\"; \"1100\";\"000111\";\"100110\"; \"110100\"; \"111000\" ]) in\r\n\t\t\tlet actual_words = Grammar.generate g_cfg len in\r\n\t\t\tassert (Set.equals expected_words actual_words);\r\n\t\t\tprint_endline \"Passed generation\"\r\n\r\n\r\n  end\r\n\r\n\tmodule ConversionTests = struct\r\n\t\tlet test_kuroda_normalization () =\r\n\t\t\tprint_endline \"Testing Kuroda normalization\";\r\n\t\t\tlet csg = make_grammar csg in\r\n\t\t\tlet kuroda = Grammar.kurodaNormalForm csg in\r\n\t\t\tassert (Grammar.isContextSensitiveGrammar kuroda);\r\n\t\t\t(* assert_accepts kuroda [\"abc\"; \"aabbcc\"]; *)\r\n\t\t\tprint_endline \"Passed Kuroda normalization\"\r\n\t\t\t(* Grammar.show kuroda; *)\r\n\r\n\t\tlet test_kuroda_full () =\r\n\t\t\tprint_endline \"Testing Kuroda full\";\r\n\t\t\tlet csg = make_grammar knf_test_grammar in\r\n\t\t\tlet kuroda = Grammar.kurodaNormalForm csg in\r\n\t\t\t(* assert (Grammar.isContextSensitiveGrammar kuroda); *)\r\n\t\t\t(* assert_accepts kuroda [\"abc\"; \"aabbcc\"]; *)\r\n\t\t\tGrammar.show kuroda;\r\n\t\t\tprint_endline \"Passed Kuroda full\"\r\n\t\t\t(* Grammar.show kuroda; *)\r\n\r\n\t\tlet test_penttonen_normalization () =\r\n\t\t\tprint_endline \"Testing Penttonen normalization\";\r\n\t\t\tlet example_grammar = make_grammar gram_example in\r\n\t\t\tlet penttonen = Grammar.penttonenNormalForm example_grammar in\r\n\t\t\tassert (Grammar.isContextFreeGrammar penttonen);\r\n\t\t\tassert_accepts penttonen [\"[a]\"; \"[[a]]\"];\r\n\t\t\tprint_endline \"Passed Penttonen normalization\"\r\n\t\t\t(* Grammar.show penttonen; *)\r\n\r\n\t\tlet test_nonContrating_to_CSG () =\r\n\t\t\tprint_endline \"Testing nonContrating to CSG\";\r\n\t\t\tlet g_non_contracting = make_grammar non_contracting in\r\n\t\t\tlet csg = Grammar.nonContractingToCSG g_non_contracting in\r\n\t\t\t(* Grammar.show csg; *)\r\n\t\t\tassert (Grammar.isContextSensitiveGrammar csg);\r\n\t\t\tassert_accepts csg [\"abc\"; \"aabbcc\"];\r\n\t\t\tprint_endline \"Passed nonContrating to CSG\"\r\n\r\n\tend\r\n\r\n\tmodule PerformanceTests = struct\r\n\t\tlet testAcceptImplementations () =\r\n\t\t\tprint_endline \"Running testAcceptImplementations\";\r\n\t\t\t(* let g_nc = make_grammar non_contracting in *)\r\n\t\t\tlet g_csg = make_grammar csg in\r\n\t\t\t(* let g_cfg = make_grammar cfg in *)\r\n\t\r\n\t\t\tlet input_strings = ref [] in\r\n\t\t\tlet accept_times = ref [] in\r\n\t\t\tlet accept2_times = ref [] in\r\n\t\r\n\t\t\tlet test_word g w =\r\n\t\t\t\tinput_strings := w :: !input_strings;\r\n\t\t\t\tlet (_, duration1) = Util.benchmark (fun () -> Grammar.accept g (word w)) in\r\n\t\t\t\taccept_times := duration1 :: !accept_times;\r\n\t\t\t\tlet (_, duration2) = Util.benchmark (fun () -> Grammar.accept2 g (word w)) in\r\n\t\t\t\taccept2_times := duration2 :: !accept2_times\r\n\t\t\tin \r\n\t\t\t(* test_word g_cfg \"111000\";\r\n\t\t\ttest_word g_cfg \"110100\";\r\n\t\t\ttest_word g_cfg \"100110\";\r\n\t\t\ttest_word g_cfg \"000111\"; *)\r\n\t\r\n\t\t\t(* test_word g_nc \"aaaaaaaaaabbbbbbbbbbccccccccccc\";  *)\r\n\t\t\t(* let (accept, duration1) = Util.benchmark (fun () -> Grammar.accept g_nc (word \"aabbcc\")) in\r\n\t\t\tlet (accept2, duration2) = Util.benchmark (fun () -> Grammar.accept2 g_nc (word \"aabbcc\")) in\r\n\t\t\tprint_endline (string_of_float duration1);\r\n\t\t\tprint_endline (string_of_bool accept); *)\r\n\t\t\ttest_word g_csg \"aabbcc\"; \r\n\t\t\t(* test_word g_csg \"aabbcc\"; *)\r\n\t\r\n\t\t\t(* test_word g_nc \"aaaabbbbcccc\";\r\n\t\t\ttest_word g_csg \"aaaabbbbcccc\";\r\n\t\r\n\t\t\ttest_word g_nc \"aaaaabbbbbccccc\";\r\n\t\t\ttest_word g_csg \"aaaaabbbbbccccc\";  *)\r\n\t\t\t(* test_word g_nc \"aaaaaabbbbbbcccccc\";*)\r\n\t\t\t(* test_word g_csg \"aaaaaabbbbbbcccccc\";  NOT ENOUGH MEMORY IF TIME IS UNLIMITED*)\r\n\t\r\n\t\t\tlet channel = open_out \"acceptTest.txt\" in\r\n\t\t\tPrintf.fprintf channel \"input_strings = [%s]\\n\" (String.concat \", \" (List.rev (List.map (fun s -> \"\\\"\" ^ s ^ \"\\\"\") !input_strings)));\r\n\t\t\tPrintf.fprintf channel \"accept_times = [%s]\\n\" (String.concat \", \" (List.rev (List.map (Printf.sprintf \"%.6f\") !accept_times)));\r\n\t\t\tPrintf.fprintf channel \"accept2_times = [%s]\\n\" (String.concat \", \" (List.rev (List.map (Printf.sprintf \"%.6f\") !accept2_times)));\r\n\t\t\tclose_out channel;\r\n\t\r\n\t\t\tprint_endline \"Ended testAcceptImplementations\"\r\n\tend\r\n\r\n\r\n\t\tmodule CleanupTests = struct\r\n\t\t\tlet test_cleaning () =\r\n\t\t\t\tprint_endline \"Testing grammar cleaning\";\r\n\t\t\t\tlet g_inaccessible = make_grammar g_inaccessible in\r\n\t\t\t\tlet g_unproductive = make_grammar g_unproductive in\r\n\t\t\t\tlet g_cleang = make_grammar cleang in\r\n\t\t\t\tlet csg = make_grammar csg in\r\n\t\t\t\tassert (not (Grammar.isClean g_inaccessible));\r\n\t\t\t\tassert (not (Grammar.isClean g_unproductive));\r\n\t\t\t\t(* Grammar.show g_cleang; *)\r\n\t\t\t\t\r\n\t\t\t\tassert (not (Grammar.isClean g_cleang));\r\n\t\t\t\tassert ((Grammar.isClean csg));\r\n\r\n\t\t\t\tlet cleaned_inaccessible = Grammar.clean g_inaccessible in\r\n\t\t\t\tassert (Grammar.isClean cleaned_inaccessible);\r\n\r\n\t\t\t\tlet cleaned_unproductive = Grammar.clean g_unproductive in\r\n\t\t\t\tassert (Grammar.isClean cleaned_unproductive);\r\n\r\n\t\t\t\tlet cleaned_cleang = Grammar.clean g_cleang in\r\n\t\t\t\tassert (Grammar.isClean cleaned_cleang)\r\n\t\t\t\t(* Grammar.show cleaned_cleang; *)\r\n\t\t\t\t(* ;\r\n\t\t\t\tGrammar.show cleaned_cleang; *)\r\n\r\n\t\tend\r\n\r\n\r\n\t\tmodule UtilityTests = struct\r\n\t\t\tlet testRemoveEpislon () =\r\n\t\t\t\tprint_endline \"Testing remove epsilon\";\r\n\t\t\t\t\r\n\t\t\t\tlet g = make_grammar cfg_balanced in\r\n\t\t\t\tassert (Grammar.isContextFreeGrammar g);\r\n\t\t\t\tassert (Grammar.hasEpsilonRules g);\r\n\t\t\t\tlet g = Grammar.removeEpsilonRules g in\r\n\t\t\t\t(*Result should be:\r\n\t\t\t\t\tS → AbB | Ab | bB | b | C\r\n\t\t\t\t\tB → AA | A | AC | C\r\n\t\t\t\t\tC → b | c\r\n\t\t\t\t\tA → a\r\n\t\t\t\twebgraphy: https://en.wikipedia.org/wiki/Chomsky_normal_form\r\n\t\t\t\t*)\r\n\t\t\t\tGrammar.show g;\r\n\r\n\t\t\t\tprint_endline \"Passed testRemoveEpislon\"\r\n\r\n\t\t\tlet\ttest_find_applied_rules () =\r\n\t\t\t\tprint_endline \"Running test_find_applied_rules\";\r\n\t\t\t\tlet g_non_contracting = make_grammar gram_example3 in\r\n\t\t\t\tlet word = \"ab\" in\r\n\t\t\t\tlet (accepted, path, trail) = Grammar.acceptFull g_non_contracting (str2word word) in\r\n\r\n\t\t\t\tprint_endline (\"Path: \" ^\r\n\t\t\t\t\t\t(String.concat \" -> \" (\r\n\t\t\t\t\t\t\t\tList.map (fun (syms, _) ->\r\n\t\t\t\t\t\t\t\t\t\tString.concat \"\" (List.map symb2str syms)\r\n\t\t\t\t\t\t\t\t) path\r\n\t\t\t\t\t\t))\r\n\t\t\t\t);\r\n\r\n\t\t\t\tprint_endline (\"Trail: \" ^\r\n\t\t\t\t\t\t(String.concat \", \" (\r\n\t\t\t\t\t\t\t\tList.map (fun config_set ->\r\n\t\t\t\t\t\t\t\t\t\t\"{\" ^\r\n\t\t\t\t\t\t\t\t\t\t\t\t(String.concat \"; \" (\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tSet.toList config_set\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t|> List.map (fun (syms, _) -> String.concat \"\" (List.map symb2str syms))\r\n\t\t\t\t\t\t\t\t\t\t\t\t)) ^\r\n\t\t\t\t\t\t\t\t\t\t\"}\"\r\n\t\t\t\t\t\t\t\t) trail\r\n\t\t\t\t\t\t))\r\n\t\t\t\t);\r\n\t\t\t\tlet rule_map = find_applied_rules g_non_contracting path in\r\n\t\t\t\tList.iter (fun ((key, int), (rule_opt, index)) ->  \r\n\t\t\t\t\t\tmatch rule_opt with\r\n\t\t\t\t\t\t| Some rule ->\r\n\t\t\t\t\t\t\t\tPrintf.printf \"%s %d: (\" (word2str key) int;\r\n\t\t\t\t\t\t\t\tPrintf.printf \"%s, %d \" (rule2str rule) index;\r\n\t\t\t\t\t\t\t\tPrintf.printf \")\\n\"\r\n\t\t\t\t\t\t| None -> ()\r\n\t\t\t\t) rule_map;\r\n\r\n\t\t\t\tprint_endline \"Passed test_find_applied_rules\"\r\n\t\tend\r\n\r\n\r\n\tlet runAll =\r\n\t\tif Util.testing active \"Grammar\" then begin\r\n      ClassificationTests.test_grammar_types ();\r\n\r\n\t\t\tUtil.sep ();\r\n      ProductionTests.test_acceptance ();\r\n      ProductionTests.test_generation ();\r\n\r\n\t\t\tUtil.sep ();\r\n      PerformanceTests.testAcceptImplementations ();\r\n\r\n\t\t\tUtil.sep ();\r\n      ConversionTests.test_kuroda_normalization ();\r\n\t\t\tConversionTests.test_kuroda_full ();\r\n      ConversionTests.test_penttonen_normalization ();\r\n\t\t\tConversionTests.test_nonContrating_to_CSG ();\r\n\r\n\t\t\tUtil.sep ();\r\n\t\t\tCleanupTests.test_cleaning ();\r\n\r\n\t\t\tUtil.sep ();\r\n\t\t\tUtilityTests.testRemoveEpislon ();\r\n\t\t\tUtilityTests.test_find_applied_rules ();\r\n\r\n\t\tend\r\nend\r\n\r\n# 1 \"src/ContextFreeGrammarSupport.ml\"\r\n(*\r\n * ContextFreeGrammarSupport.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * sep/2022 (amd) - New submodules CFGConversions and CFGLearnOCaml\r\n * jul/2021 (amd) - Now this module is client of the Scanner module and\r\n *                  the erros are registered using the Error module.\r\n * jan/2021 (amd) - Module moved to an independent file.\r\n * dec/2019 (amd) - Initial version, inside the big file \"OCamlFlatSupport.ml\".\r\n *)\r\n\r\n(*\r\n * Description: Support types and functions for CFGs including a parser for CFGs.\r\n *)\r\n \r\nopen BasicTypes\r\n\r\nmodule ContextFreeGrammarBasics =\r\nstruct\r\n\ttype rule = { head : symbol; body : word }\r\n\ttype rules = rule set\r\n\r\n\ttype t = {\r\n\t\talphabet : symbols;\r\n\t\tvariables : variables;\r\n\t\tinitial : variable;\r\n\t\trules : rules\r\n\t}\r\n\t\r\n\ttype configuration =\r\n\t\tsymbol list * word\r\n\ttype configurations =\r\n\t\tconfiguration set\r\n\r\n\ttype path =\r\n\t\tconfiguration Path.path\r\n\ttype trail =\r\n\t\tconfiguration Trail.trail\r\n\r\n\ttype cfgTree =\r\n\t\t  Leaf of symbol\r\n\t\t| Root of symbol * cfgTree list\r\n\r\n\tlet kind = \"context free grammar\"\r\n\r\n\tlet cfg_zero: t = {\r\n\t\talphabet = Set.empty;\r\n\t\tvariables = Set.make [draftVar];\r\n\t\tinitial = draftVar;\r\n\t\trules = Set.empty;\r\n\t}\r\nend\r\n\r\nmodule type ContextFreeGrammarSyntaxSig =\r\nsig\r\n\topen ContextFreeGrammarBasics\r\n\r\n\tval parse : string set -> rules\r\n\tval parseLine : string -> rules\r\n\tval toStringList : rules -> string list\r\n\tval (-->) : symbol -> string -> rule\r\n\tval rule2str : rule -> string\r\n\tval showRules : rules -> unit\r\nend\r\n\r\n(* REVER e comparar com o parser do CFG AMD *)\r\nmodule ContextFreeGrammarSyntax: ContextFreeGrammarSyntaxSig =\r\nstruct\r\n\topen Scanner\r\n\topen ContextFreeGrammarBasics\r\n\r\n\tlet isWhite c =\r\n\t\tList.mem c [' '; '\\t']\r\n\r\n\tlet parseString delim : string =\r\n\t\tskip();\t(* skip quotation mark *)\r\n\t\tlet tk = getUntil delim in\r\n\t\t\tmatch peek () with\r\n\t\t\t\t| x when x = delim -> skip(); (\"<\" ^ tk ^ \">\")\r\n\t\t\t\t| _ -> expecting0 (\"closing '\" ^ (Char.escaped delim) ^ \"'\")\r\n\t\r\n\tlet parseHead () : symbol =\r\n\t\tmatch peek() with\r\n\t\t\t| ' ' -> invalid \"Premature end of expression\\n\"\r\n\t\t\t| '<' -> str2symb (parseString '>')\r\n\t\t\t| c -> skip() ; char2symb c\r\n\t\t\t\r\n\tlet parseNeck (): unit =\r\n\t\tmatch peek() with\r\n\t\t\t| ' ' -> invalid \"Premature end of expression\\n\"\r\n\t\t\t| '-' -> skip();\r\n\t\t\t\t\tif peek() = '>' then skip()\r\n\t\t\t\t\telse invalid \"Bad neck\\n\"\r\n\t\t\t| _ -> invalid \"Bad neck\\n\"\r\n\r\n\tlet rec parseBody (): word list =\r\n\t\tmatch peek() with\r\n\t\t\t| ' ' -> [[]]\r\n\t\t\t| '|' -> skip(); []::parseBody ()\r\n\t\t\t| '~' -> skip(); parseBody ()\r\n\t\t\t| '<' ->\r\n\t\t\t\t(let symb = str2symb (parseString '>') in\r\n\t\t\t\t\tmatch parseBody () with\r\n\t\t\t\t\t\t| [] -> invalid \"never happens\"\r\n\t\t\t\t\t\t| x::xs -> (symb::x)::xs)\t\t\r\n\t\t\t| c -> skip();\r\n\t\t\t\t\tmatch parseBody () with\r\n\t\t\t\t\t\t| [] -> invalid \"never happens\"\r\n\t\t\t\t\t\t| x::xs -> ((char2symb c)::x)::xs\r\n\r\n\tlet parseFinish (): unit =\r\n\t\tmatch peek() with\r\n\t\t| ' ' -> ()\r\n\t\t| _ -> \trubbish \"at the end of rule\"\r\n\r\n\tlet parseLine line: rules =\r\n\t\tif String.trim line = \"\" then\r\n\t\t\tSet.empty\r\n\t\telse (\r\n\t\t\tScanner.start \"ContextFreeGrammarSyntax\" line;\r\n\t\t\ttry\r\n\t\t\t\tlet finish l = if l = [] then [epsilon] else l in\r\n\t\t\t\tlet h = parseHead () in\r\n\t\t\t\tlet _ = parseNeck () in\r\n\t\t\t\tlet bs = Set.make (parseBody ()) in\r\n\t\t\t\t(* let _ = parseFinish () in CONSIDERAR! *)\t\t\t\t\r\n\t\t\t\t\tSet.map (fun b -> {head=h; body=finish b}) bs\r\n\t\t\twith Not_found ->\r\n\t\t\t\tSet.empty\r\n\t\t)\r\n\r\n\tlet parse rs: rules =\r\n\t\tSet.flatMap parseLine rs\r\n\t\r\n\tlet rule2str {head=h; body=b}: string =\r\n\t\tlet b = if b = [] then [epsilon] else b in\r\n\t\t\t(symb2str h) ^ \" -> \" ^ (word2str b)\r\n\r\n\tlet toString rs: string =\r\n\t\tlet rl = Set.toList rs in\r\n\t\tString.concat \"\\n\" (List.map rule2str rl)\r\n\r\n\tlet toStringList rs: string list =\r\n\t\tlet rl = Set.toList rs in\r\n\t\t\tList.map rule2str rl\r\n\t\r\n\tlet (-->) h b : rule =\r\n\t\t{ head = h; body = str2word b } ;;\r\n\r\n\tlet showRules rs =\r\n\t\tUtil.println [toString rs]\r\nend\r\n\r\nmodule ContextFreeGrammarConversions =\r\nstruct\r\n\topen ContextFreeGrammarBasics\r\n\topen ContextFreeGrammarSyntax\r\n\r\n\tlet fromJSon (j: JSon.t): t =\r\n\t\tif JSon.isNull j || not (JSon.hasField j \"kind\") then\r\n\t\t\tcfg_zero\r\n\t\telse {\r\n\t\t\talphabet = JSon.fieldSymbolSet j \"alphabet\";\r\n\t\t\tvariables = JSon.fieldSymbolSet j \"variables\";\r\n\t\t\tinitial = JSon.fieldSymbol j \"initial\";\r\n\t\t\trules = ContextFreeGrammarSyntax.parse (JSon.fieldStringSet j \"rules\");\r\n\t\t}\r\n\r\n\tlet toJSon0 (rep: t): JSon.t =\r\n\t\tJSon.makeAssoc [\r\n\t\t\t(\"alphabet\", JSon.makeSymbolSet rep.alphabet);\r\n\t\t\t(\"variables\", JSon.makeSymbolSet rep.variables);\r\n\t\t\t(\"initial\", JSon.makeSymbol rep.initial);\r\n\t\t\t(\"rules\", JSon.makeStringSet (Set.map rule2str rep.rules))\r\n\t\t]\r\n\t\r\n\tlet toJSon2 (id: Entity.t) (rep: t): JSon.t =\r\n\t\t JSon.append (Entity.toJSon id) (toJSon0 rep)\r\n\r\n\tlet toJSon (rep: t): JSon.t =\r\n\t\t toJSon2 (Entity.dummyId kind) rep\r\nend\r\n\r\nmodule ContextFreeGrammarBasicFunctions =\r\nstruct\r\n\topen ContextFreeGrammarBasics\r\n\topen ContextFreeGrammarConversions\r\n\r\n\tlet make2 (arg: t Arg.alternatives) validate: Entity.t * t =\r\n\t\tEntity.make2 arg fromJSon kind validate\r\n\r\n\tlet make (arg: t Arg.alternatives) validate: t =\r\n\t\tsnd (make2 arg validate)\r\n\r\n\tlet show (rep: t): unit =\r\n\t\tlet j = toJSon rep in\r\n\t\t\tJSon.show j\r\n\r\n\tlet show2 (id: Entity.t) (rep: t): unit =\r\n\t\tlet j = toJSon2 id rep in\r\n\t\t\tJSon.show j\r\nend\r\n\r\nmodule ContextFreeGrammarBasicsX =\r\nstruct\r\n\topen ContextFreeGrammarBasics\r\n\r\n\ttype tx = {\r\n\t\talphabet : symbolX list;\r\n\t\tvariables : variableX list;\r\n\t\tinitial : variableX;\r\n\t\trules : string list\r\n\t}\r\n\r\n\tlet internalize (cfg: tx): t = {\r\n\t\talphabet = symbolsI cfg.alphabet;\r\n\t\tvariables = symbolsI cfg.variables;\r\n\t\tinitial = symbI cfg.initial;\r\n\t\trules = ContextFreeGrammarSyntax.parse (Set.make cfg.rules)\r\n\t}\r\n\r\n\tlet externalize (cfg: t): tx = {\r\n\t\talphabet = symbolsX cfg.alphabet;\r\n\t\tvariables = symbolsX cfg.variables;\r\n\t\tinitial = symbX cfg.initial;\r\n\t\trules = ContextFreeGrammarSyntax.toStringList cfg.rules\r\n\t}\r\nend\r\n\r\nmodule ContextFreeGrammarLearnOCaml =\r\nstruct\r\n\topen ContextFreeGrammarBasics\r\n\topen ContextFreeGrammarBasicsX\r\n\r\n\tlet moduleName =\r\n\t\t\"ContextFreeGrammar\"\r\n\r\n\tlet xTypeName =\r\n\t\t\"contextFreeGrammar\"\r\n\r\n\tlet solution (name: string) (rep: t): string =\r\n\t\tlet repx = externalize rep in\r\n\t\tPrintf.sprintf {zzz|\r\n\t\t%s{\r\n\t\t\talphabet = %s;\r\n\t\t\tvariables = %s;\r\n\t\t\tinitial = %s;\r\n\t\t\trules = %s\r\n\t\t}\r\n\t\t|zzz}\t(* please, do not change this line *)\r\n\t\t\t(FiniteEnumerationLearnOCaml.displayHeader name xTypeName)\r\n\t\t\t(symbolsXD repx.alphabet)\r\n\t\t\t(symbolsXD repx.variables)\r\n\t\t\t(symbXD repx.initial)\r\n\t\t\t(stringsD repx.rules)\r\n\r\n\tlet prelude : string =\r\n\t\tPrintf.sprintf {zzz|\r\n\t\t\ttype symbol = %s\r\n\t\t\ttype variable = %s\r\n\t\t\ttype rule = string\r\n\t\t\ttype contextFreeGrammar = {\r\n\t\t\t\talphabet : symbol list;\r\n\t\t\t\tvariables : variable list;\r\n\t\t\t\tinitial : variable;\r\n\t\t\t\trules : rule list\r\n\t\t\t}\r\n\t\t|zzz}\t(* please, do not change this line *)\r\n\t\t\t\tsymbolTypeName symbolTypeName\r\n\r\n\t\tlet example : JSon.t =\r\n\t\t\tJSon.parse {| {\r\n\t\t\t\tkind : \"context free grammar\",\r\n\t\t\t\tdescription : \"this is an example\",\r\n\t\t\t\tname : \"cfg_simple\",\r\n\t\t\t\talphabet : [\"0\", \"1\"],\r\n\t\t\t\tvariables : [\"S\", \"X\"],\r\n\t\t\t\tinitial : \"S\",\r\n\t\t\t\trules : [ \"S -> 1S0 | X\", \"X -> 0X1 | ~\" ]\r\n\t\t\t}\r\n\t\t\t|}\t(* please, do not change this line *)\r\nend\r\n\r\nmodule ContextFreeGrammarSupport =\r\nstruct\r\n\tinclude ContextFreeGrammarBasics\r\n\tinclude ContextFreeGrammarSyntax\r\n\tinclude ContextFreeGrammarConversions\r\n\tinclude ContextFreeGrammarBasicFunctions\r\n\tinclude ContextFreeGrammarLearnOCaml\r\nend\r\n\r\nmodule ContextFreeGrammarSyntaxTests : sig end =\r\nstruct\r\n\tlet active = false\r\n\r\n\tlet test0 () =\r\n\t\tlet cfg = Set.make [ \"S -> aTb | ~\"; \"T -> aSb\" ] in\r\n\t\tlet rules = ContextFreeGrammarSyntax.parse cfg in\r\n\t\t\tContextFreeGrammarSyntax.showRules rules\r\n\r\n\tlet test1 () =\r\n\t\tlet cfg = Set.make [\"S -> aSb | ~\"] in\r\n\t\tlet rules = ContextFreeGrammarSyntax.parse cfg in\r\n\t\t\tContextFreeGrammarSyntax.showRules rules\r\n\r\n\tlet runAll =\r\n\t\tif Util.testing active \"ContextFreeGrammarSyntax\" then begin\r\n\t\t\tUtil.header \"test0\";\r\n\t\t\ttest0 ();\r\n\t\t\tUtil.header \"test1\";\r\n\t\t\ttest1 ();\r\n\t\t\tUtil.header \"\"\r\n\t\tend\r\nend\r\n# 1 \"src/ContextFreeGrammarChomsky.ml\"\r\n(*\r\n * ChomskyNormalForm.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Guilherme Fernandes (gf)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * sep/2022 (amd) - Adapted the Guilherme code to the context of OCamlFLAT\r\n * jul/2022 (gf) - New module (original code inside the \"contributions\" dir)\r\n *)\r\n\r\n(*\r\n * Description: Conversion of CFG to Chomsky Normal Form\r\n *)\r\n \r\nopen BasicTypes\r\n\r\nmodule type ChomskyNormalFormSig =\r\nsig\r\n\topen ContextFreeGrammarBasics\r\n\r\n\tval chomsky : t -> t\t\r\n\tval cykAccept : t -> word -> bool\t\r\n\tval accept : t -> word -> bool\t\r\nend\r\n\r\nmodule ChomskyNormalForm : ChomskyNormalFormSig =\r\nstruct\r\n\topen ContextFreeGrammarBasics\r\n\t\r\n\t(*Remove rule rule from grammar cfg\r\n\t  and return a new grammar*)\r\n\tlet removeRule (rule : rule) (cfg : t) : t = \r\n\t  let newRules = Set.filter (fun x -> x <> rule) cfg.rules in \r\n\t  {alphabet = cfg.alphabet;\r\n\t  variables = cfg.variables;\r\n\t  initial = cfg.initial;\r\n\t  rules = newRules\r\n\t  }\r\n\t;;\r\n\r\n\t(*Generate a random char*)\r\n\tlet randVar (forbiddenSymbols : symbols) : symbol =\r\n\t\tlet var = ref (Char.uppercase_ascii (Char.chr (97 + (Random.int 26)))) in\r\n\t\twhile Set.belongs (char2symb !var) forbiddenSymbols do \r\n\t\t\tvar := Char.uppercase_ascii (Char.chr (97 + (Random.int 26))) \r\n\t\tdone;\r\n\t\tchar2symb !var\r\n\t;;\r\n\r\n\t(* return the symbols used in grammar cfg *)\r\n\tlet usedSymbols (cfg : t) : symbols = \r\n\t\tSet.union cfg.variables cfg.alphabet\r\n\t;;\r\n\r\n\t(* return the direct derivations of the \r\n\t   variable var in grammar cfg*)\r\n\tlet directDeriv (var : symbol) (cfg : t) : rules =\r\n\t\tSet.filter ( fun x -> x.head = var) cfg.rules\r\n\t;;\r\n\r\n\t(* return the number of direct derivations\r\n\t of the variable var in grammar cfg*)\r\n\tlet numberOfProdVar (var : symbol) (cfg : t) : int = \r\n\t\tSet.size (directDeriv var cfg)\r\n\t;;\r\n\r\n\r\n\t(*returns the rule with a body equal to bdy and,\r\n\t  if it does not exist, generates a new one with the body bdy*)\r\n\t  (* in rulesWithSameBdy it is necessary to check\r\n\t\tif numberOfProdVar x.head is equal to 1\r\n\t\tbecause if not, we may be changing\r\n\t\tthe grammar ex: S -> a\r\n\t\tS -> b\r\n\t\tif we look for bdy 'a' we will find the S\r\n\t\tbut we will also add production b\r\n\t\tthe grammar\r\n\t\t *)   \r\n\tlet getRule (bdy : word) (cfg : t) : rule = \r\n\t\tlet rulesWithSameBdy =\r\n\t\t\t\tSet.filter ( fun x -> x.body = bdy && numberOfProdVar x.head cfg = 1) cfg.rules in\r\n\t\t\tif Set.size rulesWithSameBdy > 0 then \r\n\t\t\t\tSet.hd rulesWithSameBdy\r\n\t\t\telse\r\n\t\t\t\t{head = randVar (usedSymbols cfg); body = bdy}\r\n\t;;\r\n\r\n\r\n\t(*checks if there is a rule in grammar cfg that \r\n\t  contains the initial variable on the right-hand side*)\r\n\tlet containsSInRHS (cfg : t) : bool = \r\n\t\tSet.exists (fun x -> List.mem cfg.initial x.body) cfg.rules\r\n\t;;\r\n\r\n\t(* adds a new rule to grammar cfg and sSymb indicates if \r\n\t  variable in the left-hand side is the initial variable*)\r\n\tlet addRule (rule : rule) (cfg : t) (sSymb : bool): t = \r\n\t  {alphabet = cfg.alphabet;\r\n\t  variables = Set.union (Set.make [rule.head]) cfg.variables;\r\n\t  initial = if sSymb then rule.head else cfg.initial;\r\n\t  rules = Set.cons rule cfg.rules\r\n\t  }\r\n\t;;\r\n\r\n\t(*START*)\r\n\t(*Eliminate the start symbol from right-hand side *)\r\n\tlet delSFromRHS (cfg : t) : t = \r\n\t  if containsSInRHS cfg then \r\n\t\tlet newS = randVar (usedSymbols cfg) in\r\n\t\taddRule {head = newS; body = [cfg.initial]} cfg true\r\n\t  else cfg\r\n\t;;\r\n\r\n\t(*------------------------------------------------------------------------------------------------*)\r\n\r\n\t(*checks if symbol var is a cfg grammar variable*)\r\n\tlet isVariable (var : symbol) (cfg : t) : bool = \r\n\t  Set.belongs var cfg.variables\r\n\t;;\r\n\r\n\t(*checks if symbol symbol is a terminal symbol*)\r\n\tlet isTerminalSymbol (symbol : symbol) (cfg : t) : bool = \r\n\t  Set.belongs symbol cfg.alphabet\r\n\t;;\r\n\t(*checks if var produces the word in grammar cfg\r\n\t  and seen are the rules already parsed*)\r\n\tlet rec prodWord (var : symbol) (word : word) (cfg : t) (seen : rules): bool = \r\n\t  let direct = directDeriv var cfg in \r\n\t  let words = Set.map (fun x -> x.body) direct in \r\n\t\t\tSet.belongs word words \r\n\t\t|| Set.exists (fun x -> not (Set.belongs x seen) \r\n\t\t\t&& List.for_all (fun y -> prodWord y word cfg (Set.cons x seen)) x.body) direct\r\n\t;; \r\n\r\n\t(*checks if var produces the word in grammar cfg*)\r\n\tlet varProdWord (var : symbol) (word : word) (cfg : t) : bool = \r\n\t  prodWord var word cfg Set.empty\r\n\t;;\r\n\r\n\t(*checks if var produces the empty word in grammar cfg*)\r\n\tlet prodEpsilon (var : symbol) (cfg : t) : bool =\r\n\t  varProdWord var [] cfg \r\n\t;;\r\n\r\n\t(*generates all possible words by applying the epsilon\r\n\t  transformation, if the variable we are analyzing derives epsilon*)\r\n\tlet rec epsilonProdsCombs (word : word) (cfg : t) : words = \r\n\t  match word with\r\n\t  | [] -> Set.make [[]]\r\n\t  | hd::tl -> let a = epsilonProdsCombs tl cfg in\r\n\t\t\t\t  if prodEpsilon hd cfg then \r\n\t\t\t\t\tlet b = Set.map ( fun x -> hd::x) a in\r\n\t\t\t\t\tif numberOfProdVar hd cfg > 1 then\r\n\t\t\t\t\t  Set.union a b\r\n\t\t\t\t\telse a\r\n\t\t\t\t  else\r\n\t\t\t\t\tSet.map (fun x -> hd::x) a\r\n\t;;\r\n\r\n\r\n\t(*test*)\r\n\tlet rec print rules =\r\n\t  match rules with\r\n\t  | [] -> Format.printf \"\\n\"\r\n\t  | hd::tl ->\r\n\t\t\tFormat.printf \"{head = %s; body = \" (symb2str hd.head); \r\n\t\t\tList.iter (fun x -> Format.printf \"%s\" (symb2str x)) hd.body;\r\n\t\t\tFormat.printf \"}\\n\";\r\n\t\t\tFormat.print_flush ();\r\n\t\t\tprint tl\r\n\t;;\r\n\r\n\t(*for each element x in bodies \r\n\t  add a rule with head leftSide and body x*)\r\n\tlet rec addNewRules (leftSide : symbol) (bodies : words) (cfg : t) : t =\r\n\t\tSet.match_ bodies\r\n\t\t\t(fun () -> cfg)\r\n\t\t\t(fun hd tl ->\r\n\t\t\t\tlet nCfg = addNewRules leftSide tl cfg in\r\n\t\t\t\t  if hd <> [leftSide] then\r\n\t\t\t\t\taddRule {head = leftSide; body = hd} nCfg false\r\n\t\t\t\t  else nCfg)\r\n\t  ;;\r\n\r\n\t(*verifies if symb is the cfg grammar start symbol *)\r\n\tlet isStartSymbol (symb : symbol) (cfg : t) : bool = \r\n\t  symb = cfg.initial\r\n\t;;\r\n\r\n\t(*Eliminate ε-rules of cfgRules\r\n\t  and returns a new grammar without ε-rules *)\r\n\t  let rec delEpsilonRules (cfgRules: rules) (cfg : t) : t =\r\n\t\tSet.match_ cfgRules\r\n\t\t\t(fun () -> cfg)\r\n\t\t\t(fun hd tl ->\r\n\t\t\t\tlet nCfg = delEpsilonRules tl cfg in\r\n\t\t\t\t  let epsilonProd = epsilonProdsCombs hd.body cfg in \r\n\t\t\t\t  let cfgWithRules = addNewRules hd.head epsilonProd nCfg in\r\n\t\t\t\t  if isStartSymbol hd.head cfgWithRules then \r\n\t\t\t\t\tcfgWithRules \r\n\t\t\t\t  else \r\n\t\t\t\t\tremoveRule {head = hd.head; body = []} cfgWithRules)\r\n\t;;\r\n\r\n\r\n\r\n\r\n\t(*DEL*)\r\n\t(*Eliminate ε-rules of cfg grammar*)\r\n\tlet cleanEpsilonRules (cfg : t) : t = \r\n\t  delEpsilonRules cfg.rules cfg \r\n\t;;\r\n\r\n\r\n\r\n\r\n\r\n\t(*------------------------------------------------------------------------------------------------*)\r\n\r\n\t(*checks if rule derivates only one variable*)\r\n\tlet isAnUnitProduction (rule : rule) (cfg : t) : bool = \r\n\t  List.length rule.body = 1 && isVariable (List.hd rule.body) cfg\r\n\t;;\r\n\r\n\tlet rec addRules (rules : rules ) (cfg : t) : t =\r\n\t\tSet.match_ rules\r\n\t\t\t(fun () -> cfg)\r\n\t\t\t(fun hd tl -> addRules tl (addRule hd cfg false))\r\n\r\n\t(*UNIT*)\r\n\t(*let unitFor1 (seen : rules) (rule : rule) (cfg : t) : rules * cfg = \r\n\t  let nCfg = removeRule rule cfg in\r\n\t  let direct = directDeriv (List.hd rule.body) nCfg in \r\n\t  let words = List.map (fun x -> x.body) direct in\r\n\t  let nW = List.filter( fun x -> not(List.mem {head = rule.head; body = x} seen)) words in\r\n\t  let analyzed = List.map( fun x-> {head = rule.head; body = x})nW in\r\n\t  (analyzed, addNewRules rule.head nW nCfg)\r\n\t;;\r\n\r\n\t(* Eliminate unit rules and seen\r\n\t  are the rules already parsed*)\r\n\tlet rec processUnitProduction (seen : rules) (cfgRules: rules) (cfg : t) : t = \r\n\t  match cfgRules with\r\n\t  | [] -> cfg\r\n\t  | hd::tl -> if isAnUnitProduction hd cfg then\r\n\t\t\t\t\tlet (a, b) = unitFor1 seen hd cfg in\r\n\t\t\t\t\tprocessUnitProduction (seen@a) b.rules b\r\n\t\t\t\t  else \r\n\t\t\t\t\tprocessUnitProduction seen tl cfg\r\n\t;;*)\r\n\tlet unitFor1 (seen : rules) (rule : rule) (cfg : t) : rules  = \r\n\t  let direct = directDeriv (List.hd rule.body) cfg in \r\n\t  let words = Set.map (fun x -> x.body) direct in\r\n\t  let nW = Set.filter ( fun x -> not (Set.belongs {head = rule.head; body = x} seen)) words in\r\n\t  Set.map ( fun x-> {head = rule.head; body = x}) nW \r\n\t;;\r\n\r\n\t(* Eliminate unit rules and seen\r\n\t  are the rules already parsed*)\r\n\tlet rec processUnitProduction (seen : rules) (cfgRules: rules) (cfg : t) : t = \r\n\t\tSet.match_ cfgRules\r\n\t\t\t(fun () -> cfg)\r\n\t\t\t(fun hd tl ->\r\n\t\t\t\tlet nCfg = processUnitProduction seen tl cfg in\r\n\t\t\t\t  if isAnUnitProduction hd nCfg then\r\n\t\t\t\t\tlet sdnCfg = removeRule hd nCfg in\r\n\t\t\t\t\tlet rules = unitFor1 seen hd sdnCfg in\r\n\t\t\t\t\tprocessUnitProduction (Set.union rules seen) rules (addRules rules sdnCfg)\r\n\t\t\t\t  else \r\n\t\t\t\t\tnCfg)\r\n\t;;\r\n\r\n\t(*UNIT*)  \r\n\t(*Eliminate unit rules from cfg grammar*)\r\n\tlet delUnitProductions (cfgRules: rules) (cfg : t) : t = \r\n\t  processUnitProduction Set.empty cfgRules cfg;;\r\n\r\n\t(*------------------------------------------------------------------------------------------------*)\r\n\r\n\t(*checks if the right-hand side of the \r\n\t  rule has one isolated terminal symbol*)\r\n\tlet isNonSolitaryTerminalsRule (rule : rule) (cfg : t) : bool = \r\n\t  let terminals = List.filter ( fun x -> isTerminalSymbol x cfg) rule.body in\r\n\t\t\tList.length terminals > 1 \r\n\t\t||  (List.length terminals > 0 && List.length rule.body > 1)\r\n\t;;\r\n\r\n\t(*removes the non solitary terminal symbols from word and\r\n\t  add a new rule to cfg grammar for each one\r\n\t  and returns a ( new word * new grammar)*)\r\n\tlet rec addRulesFromNonSolitary (bdy : word) (cfg : t) : word * t = \r\n\t  match bdy with\r\n\t  | [] -> (bdy, cfg)\r\n\t  | hd::tl -> let (a, b) = addRulesFromNonSolitary tl cfg in\r\n\t\t\t\t  if isTerminalSymbol hd b then\r\n\t\t\t\t\tlet rule = getRule [hd] b in\r\n\t\t\t\t\tlet nCfg = addRule rule b false in\r\n\t\t\t\t\t(rule.head::a, nCfg)\r\n\t\t\t\t  else\r\n\t\t\t\t\t(hd::a, b)\r\n\t;;\r\n\r\n\t(*TERM*)\r\n\t(*Eliminate rules with nonsolitary terminals*)\r\n\t(*let rec delRulesNonSolitaryTerminals (cfgRules: rules) (cfg : t) : t = (*trocar nome*)\r\n\t  match cfgRules with\r\n\t  | [] -> cfg\r\n\t  | hd::tl -> if isNonSolitaryTerminalsRule hd cfg then \r\n\t\t\t\t\tlet (a, b) = cleanNonSolitary hd.body cfg in\r\n\t\t\t\t\tlet nCfg = addRule {head = hd.head; body = a} b false in\r\n\t\t\t\t\tdelRulesNonSolitaryTerminals tl (removeRule hd nCfg)\r\n\t\t\t\t  else\r\n\t\t\t\t\tdelRulesNonSolitaryTerminals tl cfg\r\n\r\n\t;;*)\r\n\r\n\r\n\tlet rec processRulesWithNonSolitaryTerminals (cfgRules: rules) (cfg : t) : t = \r\n\t\tSet.match_ cfgRules\r\n\t\t\t(fun () -> cfg)\r\n\t\t\t(fun hd tl ->\r\n\t\t\t\tlet nCfg = processRulesWithNonSolitaryTerminals tl cfg in\r\n\t\t\t\t  if isNonSolitaryTerminalsRule hd nCfg then \r\n\t\t\t\t\tlet (a, b) = addRulesFromNonSolitary hd.body nCfg in\r\n\t\t\t\t\taddRule {head = hd.head; body = a} (removeRule hd b) false \r\n\t\t\t\t  else\r\n\t\t\t\t\tnCfg)\r\n\t;;\r\n\r\n\r\n\t(*------------------------------------------------------------------------------------------------*)\r\n\t(* checks if the rule has more than 2 \r\n\t  non terminal symbols in right-hand side*)\r\n\tlet hasMoreThan2NonTerminalsInRHS (rule : rule) (cfg : t) : bool = \r\n\t\tlet nonTerminalsInRHS = List.filter ( fun x -> isVariable x cfg) rule.body in\r\n\t\tList.length nonTerminalsInRHS > 2\r\n\t;;\r\n\r\n\t(* split the word when it finds the first variable*)\r\n\tlet rec splitBodyByVariables (body:word) (cfg : t) : word * word = \r\n\t\tmatch body with\r\n\t\t| [] -> ([], [])\r\n\t\t| hd::tl -> let (a, b) = splitBodyByVariables tl cfg in\r\n\t\t\t\t\t\t\t\tif isVariable hd cfg then \r\n\t\t\t\t\t\t\t\t\t([hd], tl)\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t(hd::a, b)\r\n\t;;\r\n\r\n\t(*let binFor1 (rule : rule) (cfg : t) : t = \r\n\t  let cfgWithoutHd = removeRule rule cfg in \r\n\t  let (a, b) = splitBodyByVariables rule.body cfgWithoutHd in\r\n\t  let var = randVar (usedSymbols cfgWithoutHd) in \r\n\t  let nCfg = addRule {head = rule.head; body = a@[var]} cfgWithoutHd false in\r\n\t  addRule {head = var; body = b} nCfg false\r\n\t;;*)\r\n\r\n\r\n\tlet binFor1 (rule : rule) (cfg : t) : rules = \r\n\t  let (a, b) = splitBodyByVariables rule.body cfg in\r\n\t  let var = randVar (usedSymbols cfg) in \r\n\t\tSet.make [{head = rule.head; body = a@[var]}; {head = var; body = b}]\r\n\t;;\r\n\r\n\tlet rec processRHSwithMoreThan2NonTerminals (cfgRules: rules) (cfg : t) : t = \r\n\t\tSet.match_ cfgRules\r\n\t\t\t(fun () -> cfg)\r\n\t\t\t(fun hd tl ->\r\n\t\t\t\tlet nCfg = processRHSwithMoreThan2NonTerminals tl cfg in\r\n\t\t\t\t  if hasMoreThan2NonTerminalsInRHS hd nCfg then \r\n\t\t\t\t\tlet cfgWithoutHd = removeRule hd nCfg in \r\n\t\t\t\t\tlet rules = binFor1 hd cfgWithoutHd in\r\n\t\t\t\t\tlet sdCfg = addRules rules cfgWithoutHd in\r\n\t\t\t\t\tprocessRHSwithMoreThan2NonTerminals rules sdCfg\r\n\t\t\t\t  else\r\n\t\t\t\t\tnCfg)\r\n\t;;\r\n\r\n\t(*BIN*)\r\n\t(*Eliminate right-hand sides with more than 2 nonterminals*)\r\n\t(*let rec processRHSwithMoreThan2NonTerminals (cfgRules: rules) (cfg : t) : t = \r\n\t  match cfgRules with\r\n\t  | [] -> cfg\r\n\t  | hd::tl -> if hasMoreThan2NonTerminalsInRHS hd cfg then \r\n\t\t\t\t\tlet sdCfg = binFor1 hd cfg in\r\n\t\t\t\t\tprocessRHSwithMoreThan2NonTerminals sdCfg.rules sdCfg\r\n\t\t\t\t  else\r\n\t\t\t\t\tprocessRHSwithMoreThan2NonTerminals tl cfg\r\n\t;;*)\r\n\r\n\t(*let rec delRHSwithMoreThan2NonTerminals (cfgRules: rules) (cfg : t) : t = \r\n\t  match cfgRules with\r\n\t  | [] -> cfg\r\n\t  | hd::tl -> let nCfg = delRHSwithMoreThan2NonTerminals tl cfg in \r\n\t\t\t\t  if hasMoreThan2NonTerminalsInRHS hd nCfg then \r\n\t\t\t\t\tbinFor1 hd nCfg   // It doesn't work because we need to\r\n\t\t\t\t\t\t\t\t\t  // analyze the new rules added in binFor1\r\n\t\t\t\t  else\r\n\t\t\t\t\tnCfg\r\n\r\n\t\t\t\t\r\n\t;;*)\r\n\r\n\r\n\r\n\t(*------------------------------------------------------------------------------------------------*)\r\n\t(*Convert cfg grammar to Chomsky normal form*)\r\n\tlet chomsky (cfg: t) : t =\r\n\t  let start = delSFromRHS cfg in\r\n\t  let term = processRulesWithNonSolitaryTerminals start.rules start in\r\n\t  let bin = processRHSwithMoreThan2NonTerminals term.rules term in \r\n\t  let del = cleanEpsilonRules bin in\r\n\t  let unit = delUnitProductions del.rules del in\r\n\t  unit \r\n\t;;\r\n\r\n\t(* IMPERATIVE code - https://www.geeksforgeeks.org/cocke-younger-kasami-cyk-algorithm/ *)\r\n\t(* pre: rule is in chomsky form *)\r\n\tlet prodVars (rule : rule) : bool =\r\n\t\tList.length rule.body = 2\r\n\r\n\tlet cykAccept (cfg: t) (w: word) =\r\n\t  if w = [] then\r\n\t\tprodEpsilon cfg.initial cfg\r\n\t  else\r\n\t\tlet n = List.length w in\r\n\t\tlet matrix = Array.make_matrix n n (Set.empty) in\r\n\t\tfor j = 0 to (n-1) do\r\n\t\t  let vars = Set.filter(fun x -> List.length x.body = 1 && List.nth x.body 0 = List.nth w j) cfg.rules in\r\n\t\t  let lhs = Set.map ( fun x -> x.head) vars in\r\n\t\t  matrix.(j).(j) <- Set.union matrix.(j).(j) lhs;\r\n\t\t  for i = j downto 0 do \r\n\t\t\tfor k = i to (j-1) do\r\n\t\t\t  let vars = Set.filter(fun x -> prodVars x && Set.belongs (List.nth x.body 0) matrix.(i).(k)\r\n\t\t\t\t\t\t\t\t\t\t\t  && Set.belongs (List.nth x.body 1) matrix.(k+1).(j)) cfg.rules in\r\n\t\t\t  let lhs = Set.map ( fun x -> x.head) vars in\r\n\t\t\t  matrix.(i).(j) <- Set.union matrix.(i).(j) lhs\r\n\t\t\tdone\r\n\t\t  done\r\n\t\tdone; \r\n\t\tSet.belongs cfg.initial matrix.(0).(n-1)\r\n\r\n\tlet accept (cfg: t) (w: word) =\r\n\t\tcykAccept (chomsky cfg) w\r\n\r\nend\r\n# 1 \"src/ContextFreeGrammarBasic.ml\"\r\n(*\r\n * ContextFreeGrammarBasic.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by João Gonçalves (jg)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * jul/2021 (amd) - Improved Learn-OCaml support and error handling.\r\n * jun/2021 (amd) - Added checks for '~' in the #validate method.\r\n * may/2021 (amd) - Added support for an extern representation.\r\n * jan/2021 (amd) - Module in an independent file and some cleanup.\r\n * feb/2020 (jg) - Main functionalities.\r\n * dec/2019 (amd) - Initial skeleton, inside the big file \"OCamlFlat.ml\".\r\n *)\r\n\r\n(*\r\n * Description: Context-free grammar functionality.\r\n *\r\n * TODO: More cleanup.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule ContextFreeGrammarPrivate =\r\nstruct\r\n\topen ContextFreeGrammarSupport\r\n\r\n\t(*------Auxiliary functions---------*)\r\n\r\n\t(* given a head, returns the set of all its bodies according to the cfg's rules *)\r\n\tlet bodiesOfHead h rl =\r\n\t\tlet rls = Set.filter (fun r -> r.head = h) rl in\r\n\t\t\tSet.map (fun r -> r.body) rls\r\n\r\n\r\n\t(* given 2 sets of words, to each word of the left set, appends each word of the right set *)\r\n\tlet concatWords lws rws =\r\n\t\tif lws = Set.empty then rws\r\n\t\telse if rws = Set.empty then lws\r\n\t\telse\r\n\t\t\tlet pairs = Set.product lws rws in\r\n\t\t\t\tSet.map (fun (x,y) -> x@y) pairs\r\n\r\n\t(* tests if the number of symbols in the given word exceeds the given lenght *)\r\n\tlet exceedsMaxLen w l alph =\r\n\t\tlet cleanWord = List.filter (fun c -> Set.belongs c alph) w in\r\n\t\t\t(List.length cleanWord) > l\r\n\r\n\r\n\r\n\tlet subX h rws rl =\r\n\t\tlet bs = bodiesOfHead h rl in\r\n\t\t\tconcatWords bs rws\r\n\r\n\r\n\t(* applies the cfg's rules to the given word *)\r\n\tlet rec subVar w vs rs =\r\n\t\tmatch w with\r\n\t\t\t| [] -> Set.make [[]]\r\n\t\t\t| x::xs -> if (Set.belongs x vs) then subX x (subVar xs vs rs) rs\r\n\t\t\t\telse concatWords (Set.make [[x]]) (subVar xs vs rs)\r\n\r\n\r\n\t(* removes the empty symbol from all non-empty words *)\r\n\tlet removeEpsi w = List.filter (fun c -> c <> epsilon) w\r\n\r\n\r\n\t(* filters out all words that have variables and cleans any unnecessary epsilon *)\r\n\tlet cleanNonWords ws vs =\r\n\t\tlet hasVar w = List.exists (fun c -> Set.belongs c vs) w in\r\n\t\tlet ws = Set.filter (fun w -> not (hasVar w)) ws in\r\n\t\t\tSet.map (fun w -> removeEpsi w) ws\r\n\r\n  let removeEpsilonFromWord w =\r\n    List.filter (fun c -> c <> epsilon) w\r\n\r\n  let removeDollarFromWord w =\r\n    List.filter (fun c -> c <> dollar) w\r\n\r\n  let rec doWordGenerateEmptyX w seen (rep:t) =\r\n    let doGenerateEmpty x =\r\n      if List.mem x seen\r\n      then false\r\n      else(\r\n\t\t    let bodies = bodiesOfHead x rep.rules in\r\n\t\t    Set.exists (fun b -> doWordGenerateEmptyX b (x::seen) rep) bodies \r\n\t\t  )\r\n\t\tin      \r\n      List.for_all doGenerateEmpty w\r\n\r\n  let doWordGenerateEmpty w (rep:t) =\r\n    doWordGenerateEmptyX (removeDollarFromWord w) [] rep\r\n\r\n  let rec firstX testWord seen simple (rep:t) =\r\n    match testWord with\r\n\t\t  | [] -> Set.empty\r\n\t\t\t| [x] when Set.belongs x rep.variables -> \r\n\t\t\t\t\tlet bodies = bodiesOfHead x rep.rules in\r\n\t\t\t\t\tif Set.belongs x seen \r\n\t\t\t\t\t  then Set.empty\r\n\t\t\t\t\t  else let result = Set.flatMap ( fun b ->\r\n\t\t\t\t\t          let result = firstX b (Set.add x seen) simple rep in\r\n                    let empty = if b = []\r\n                                then Set.make [epsilon]\r\n                                else Set.empty in\r\n\t\t\t\t\t          Set.union empty result\r\n\t\t\t\t\t        ) bodies\r\n\t\t\t\t\t        in\r\n                  if Set.exists (fun b -> doWordGenerateEmpty b rep) bodies \r\n                    then Set.union result (Set.make [epsilon])\r\n                    else Set.make (removeEpsilonFromWord (Set.toList result))\r\n\t\t\t| x::xs when Set.belongs x rep.alphabet -> \r\n\t\t\t\t\tSet.make [x]\r\n\t\t\t| x::xs -> Set.union \r\n\t\t  \t\t\t\t\t\t(firstX [x] seen simple rep) \r\n\t\t\t\t\t\t\t\t\t(if doWordGenerateEmpty [x] rep then firstX xs seen simple rep else Set.empty)  \r\n\r\n  let first2 (testWord:word) simple (rep:t) =\r\n    firstX testWord Set.empty simple rep\r\n\r\n  let first (testWord:word) simple (rep:t) =\r\n    let first = first2 testWord simple rep in\r\n    if simple then Set.filter (fun c -> c <> epsilon) first else first\r\n\r\n\tlet getFollowRules (testSymbol:symbol) (rep:t) =\r\n\t  Set.filter (fun r -> Set.belongs testSymbol (Set.make r.body) ) rep.rules\r\n\r\n  let rec getFollowInfo2 testSymbol h b =\r\n    match b with\r\n      | [] -> []\r\n      | x::xs when x = testSymbol -> (h, xs) :: getFollowInfo2 testSymbol h xs\r\n      | x::xs -> getFollowInfo2 testSymbol h xs\r\n\r\n  (* given a variable X, returns the pairs (Y,w2) *)\r\n  let getFollowInfo testSymbol rep =\r\n    let rules = Set.toList (getFollowRules testSymbol rep) in\r\n    List.flatten (List.map (fun r -> getFollowInfo2 testSymbol r.head r.body) rules )\r\n\r\n    \r\n  let rec followX (testSymbol:symbol) seen simple (rep:t) =\r\n    let pairs = Set.make (getFollowInfo testSymbol rep) in\r\n    let dollar = if testSymbol = rep.initial\r\n                  then Set.make [dollar]\r\n                  else Set.empty\r\n    in\r\n    let set = Set.flatMap (fun (y,w) -> \r\n          Set.union \r\n            (Set.filter (fun s -> s <> epsilon) (first w simple rep))\r\n            (if (not (Set.belongs y seen) && doWordGenerateEmpty w rep) \r\n              then followX y (Set.add testSymbol seen) simple rep\r\n              else Set.empty\r\n            )\r\n    ) pairs \r\n    in\r\n    Set.union set dollar\r\n    \r\n  let follow2 testSymbol simple rep =\r\n    followX testSymbol (Set.make []) simple rep\r\n  \r\n  let follow testSymbol simple rep =\r\n    let follow = follow2 testSymbol simple rep in\r\n    if simple then Set.filter (fun c -> c <> dollar) follow else follow\r\n\r\n\r\n  let lookahead rule simple (rep:t) =\r\n    let x = rule.head in\r\n    let w = rule.body in\r\n      Set.filter (\r\n        fun c -> c <> epsilon \r\n      ) (Set.union (first2 w simple rep) (if doWordGenerateEmpty w rep then follow2 x simple rep else Set.empty))\r\n\r\n\t(* Make *)\r\n\tlet validate (name: string) (rep: t): unit =\r\n\t\t(* the alphabet must not contain epsilon ('~') *)\r\n\t\tlet isValidAlphabet = not (Set.belongs epsilon rep.alphabet) in\r\n\t\t(* the variables must not contain epsilon ('~') *)\r\n\t\tlet isValidVariables = not (Set.belongs epsilon rep.variables) in\r\n\t\tlet isIntersectionValid = (Set.inter rep.variables rep.alphabet) = Set.empty in\r\n\t\tlet isInitialValid = Set.belongs rep.initial rep.variables in\r\n\r\n\t\tlet areRuleHeadsValid =\r\n\t\t\tlet hs = Set.map (fun r -> r.head) rep.rules in\r\n\t\t\t\tSet.subset hs rep.variables\r\n\t\tin\r\n\t\tlet areRuleBodiesValid =\r\n\t\t\tlet allBodySymbols = Set.flatMap (fun r -> Set.make r.body) rep.rules in\r\n\t\t\tlet allValidSymbs = Set.add epsilon (Set.union rep.alphabet rep.variables) in\r\n\t\t\t\tSet.subset allBodySymbols allValidSymbs\r\n\t\tin\r\n\t\tif not isValidAlphabet then\r\n\t\t\tError.error name\r\n\t\t\t\t\"The alphabet contains epsilon '~', and it should not\" ();\r\n\t\tif not isValidVariables then\r\n\t\t\tError.error name\r\n\t\t\t\t\"The variables contain epsilon '~', and it should not\" ();\r\n\t\tif not isIntersectionValid then\r\n\t\t\tError.error name\r\n\t\t\t\t\"The intersection between the alphabet and the variables is not empty\" ();\r\n\t\tif not isInitialValid then\r\n\t\t\tError.error (symb2str rep.initial)\r\n\t\t\t\t\"The initial symbol is not a declared variable\" ();\r\n\t\tif not areRuleHeadsValid then\r\n\t\t\tError.error name\r\n\t\t\t\t\"Some rule heads are not declared variables\" ();\r\n\t\tif not areRuleBodiesValid then\r\n\t\t\tError.error name\r\n\t\t\t\t\"Some rule bodies are not declared symbols\" ()\r\n\t\t\t\t\r\n\tlet accept (fe: t) (w: word): bool =\r\n\t\tfalse (* TODO *)\r\n\r\n\tlet generate (fe: t) (length: int): words =\r\n\t\tSet.empty (* TODO *)\r\n\r\n(* ----------------------------------------------------------------------------*)\r\n\r\n\t(*CODIGO JP*)\r\n\r\n\t(*checks if symbol var is a cfg grammar variable*)\r\n\tlet isVariable (var : symbol) (cfg : t) : bool = \r\n\t\tSet.belongs var cfg.variables\r\n\t;;\r\n\t\r\n\t\t(*checks if symbol symbol is a terminal symbol*)\t\t\r\n\tlet isTerminalSymbol (symbol : symbol) (cfg : t) : bool = \r\n\t\tSet.belongs symbol cfg.alphabet\r\n\t;;\r\n\r\n\tlet isTerminalSymbol2 (symbol: symbol) : bool =\r\n\t\tlet str = symb2str symbol in\r\n\t\tnot ((\"A\" <= str && str <= \"Z\") || String.get str 0 = '<' && String.get str (String.length str - 1) = '>')   \r\n\r\n\tlet hasEmpty body =\r\n\t\tbody = [epsilon]\r\n\r\n\tlet rec expandsEmpty sym cfg =\r\n\t\tlet xRules = Set.filter(fun r -> r.head = sym) cfg.rules in\r\n\t\tlet xBodies = Set.map (fun r -> r.body) (Set.filter (fun r -> List.length r.body == 1) xRules) in\r\n\t\tSet.for_all(fun b -> hasEmpty b || List.for_all (fun sy -> expandsEmpty sy cfg && isVariable sy cfg) b) xBodies\r\n\t\t\t\t\r\n\tlet rec calcSymExpansions cfg sym seen =\r\n\t\tlet xRules = Set.filter(fun r -> r.head == sym) cfg.rules in\r\n\t\tlet xBodies = Set.toList (Set.map (fun r -> r.body) xRules) in\r\n\t\tlet rec minBody bodies min seen =\r\n\t\t\tmatch bodies with\r\n\t\t\t| [] -> (min, seen)\r\n\t\t\t| ba :: bb -> \r\n\t\t\t\tlet terminalLength = List.length (List.filter (fun sy -> isTerminalSymbol sy cfg) ba) in\r\n\t\t\t\tlet nonTerms = List.filter (fun sy -> isVariable sy cfg && sy != sym) ba in\r\n\t\t\t\tlet sameSymLength = List.length (List.filter (fun sy -> sy == sym) ba) in\r\n\t\t\t\tlet rec expandNonTerms terms seen =\r\n\t\t\t\t\tmatch terms with\r\n\t\t\t\t\t| [] -> (0, seen)\r\n\t\t\t\t\t| sa :: sb ->\r\n\t\t\t\t\t\tif (Set.exists(fun (sy, value) -> sy == sa) seen)\r\n\t\t\t\t\t\t\tthen\r\n\t\t\t\t\t\tlet (_, kValue) = Set.find(fun (sy, value) -> sy == sa) seen in\r\n\t\t\t\t\t\t\tlet (value, newSeen) = expandNonTerms sb seen in\r\n\t\t\t\t\t\t\t(kValue + value, newSeen)\r\n\t\t\t\t\t\telse (\r\n\t\t\t\t\t\t\tlet (_, saValue, newSymSeen) = calcSymExpansions cfg sa seen in\r\n\t\t\t\t\t\t\tlet newSymSeen2 = Set.add (sa, saValue) newSymSeen in\r\n\t\t\t\t\t\t\tlet (ntValue, newNonTermSeen) = expandNonTerms sb newSymSeen2 in\r\n\t\t\t\t\t\t\tlet unionSeen = Set.unionUnsafe newSymSeen2 newNonTermSeen in\r\n\t\t\t\t\t\t\t(saValue + ntValue, unionSeen)\r\n\t\t\t\t\t\t)\t\t\t\t\t\r\n\t\t\t\tin\r\n\t\t\t\tlet (value, newSeen) = expandNonTerms nonTerms seen in\r\n\t\t\t\tif (sameSymLength != 0) then\r\n\t\t\t\t\tlet (minVal, newSeen) = minBody bb min seen in\r\n\t\t\t\t\tif (minVal < min) then\r\n\t\t\t\t\t\tlet bodyLength = terminalLength + value + (sameSymLength * minVal) in\r\n\t\t\t\t\t\tif (bodyLength < min) then\r\n\t\t\t\t\t\t\tlet (minVal2, newSeen) = minBody bb bodyLength seen in\r\n\t\t\t\t\t\t\t\t(minVal2, newSeen)\r\n\t\t\t\t\t\telse (\r\n\t\t\t\t\t\t\tlet (minVal, newSeen) = minBody bb min seen in\r\n\t\t\t\t\t\t\t\t(minVal, newSeen)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\telse (\r\n\t\t\t\t\t\tlet (minVal2, newSeen) = minBody bb min seen in\r\n\t\t\t\t\t\t(minVal2, newSeen)\r\n\t\t\t\t\t)\r\n\t\t\t\telse(\r\n\t\t\t\t\tlet bodyLength = terminalLength + value in\r\n\t\t\t\t\tif (bodyLength < min) then\r\n\t\t\t\t\t\tlet (minVal, newSeen) = minBody bb bodyLength seen in\r\n\t\t\t\t\t\t\t(minVal, newSeen)\r\n\t\t\t\t\telse (\r\n\t\t\t\t\t\tlet (minVal, newSeen) = minBody bb min seen in\r\n\t\t\t\t\t\t\t(minVal, newSeen)\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\t\t\r\n\t\t\tin\r\n\t\t\tlet (minValue, newSeen) = minBody xBodies (Int.max_int) seen in\r\n\t\t\t(sym, minValue, newSeen)\r\n\r\n\r\n\tlet calcExpans cfg =\r\n\t\tlet vars = Set.toList (cfg.variables) in\r\n\t\tlet seen = Set.make ([]) in\r\n\t\tlet rec buildPairs vars seen =\r\n\t\t\tmatch vars with\r\n\t\t\t| [] -> []\r\n\t\t\t| va :: vb -> \r\n\t\t\t\tif not (Set.exists(fun (sy, value) -> sy == va) seen)\r\n\t\t\t\t\tthen\r\n\t\t\t\t\t\tlet (_, minValue, newSeen) = calcSymExpansions cfg va seen in\r\n\t\t\t\t\t\tlet newSeen2 = Set.add (va, minValue) newSeen in \r\n\t\t\t\t\t\t(va, minValue) :: buildPairs vb newSeen2\r\n\t\t\t\telse (\r\n\t\t\t\t\tlet pair = Set.find(fun (sy, value) -> sy == va) seen in\r\n\t\t\t\t\tpair :: buildPairs vb seen\r\n\t\t\t\t\t)\r\n\t\tin\r\n\t\tbuildPairs vars seen\r\n\t\r\n\tlet verifyLength2 cfg sf body len pairs =\r\n\t\tlet terminalLengthSf = List.length (List.filter(fun sy -> isTerminalSymbol sy cfg) sf) in\r\n\t\tlet terminalLengthBody = List.length (List.filter(fun sy -> isTerminalSymbol sy cfg) body) in\r\n\t\tlet rec sumMinExpansions syms =\r\n\t\t\tmatch syms with\r\n\t\t\t| [] -> 0\r\n\t\t\t| sa :: sb ->\r\n\t\t\t\tlet (_, value) = List.find(fun (sy, value) -> sy == sa) pairs in\r\n\t\t\t\tvalue + sumMinExpansions sb\r\n\t\tin\r\n\t\tlet sfVars = List.filter(fun sy -> isVariable sy cfg) sf in \r\n\t\tlet bodyVars = List.filter(fun sy -> isVariable sy cfg) body in\r\n\t\tterminalLengthSf + terminalLengthBody + (sumMinExpansions sfVars) + (sumMinExpansions bodyVars) - 1 <= len\r\n\t\r\n\r\n\tlet verifyLength cfg sf body len =\r\n\t\tlet lengthSf = List.length (sf) in\r\n\t\tlet lengthBody = List.length (body) in\r\n\t\tlet sfVars = List.length (List.filter(fun sy -> isVariable sy cfg && expandsEmpty sy cfg) sf) in \r\n\t\tlet bodyVars = List.length (List.filter(fun sy -> isVariable sy cfg && expandsEmpty sy cfg) body) in\r\n\t\tlengthSf + lengthBody - sfVars - bodyVars - 1 <= len\r\n\r\n\r\n\t\t(*\r\n\t\t\t4\r\n\t\t\t2 -> 5\r\n\t\t\t2 -> 4\t \r\n\t\t*)\r\n\r\n\tlet initialConfig (cfg: t) (w: word) : configurations =\r\n\t\tSet.make [([cfg.initial], w)]\r\n\r\n\r\n\tlet rec expand (cfg: t) (sf,w) : configurations =\r\n\t\tmatch sf with\r\n\t\t\t| [] -> Set.make [([],w)]\r\n\t\t\t| x::xs ->\r\n\t\t\t\tlet ySet = expand cfg (xs, w) in\r\n\t\t\t\t\tif isTerminalSymbol x cfg then\r\n\t\t\t\t\t\tSet.map (fun (fs, w) -> (x::fs, w)) ySet\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tlet xRules = Set.filter(fun r -> r.head = x) cfg.rules in\r\n\t\t\t\t\t\tlet xBodies = Set.map (fun r -> r.body) xRules in\r\n\t\t\t\t\t\tlet res = Set.flatMap (fun (fs1, w) -> Set.map (fun fs2 -> (fs2@fs1, w)) xBodies) ySet in\r\n\t\t\t\t\t\tres\r\n\r\n\tlet rec expandGenerate (cfg: t) (len: int) (sf,w) : configurations =\r\n\t\tmatch sf with\r\n\t\t\t| [] -> Set.make [([],[])]\r\n\t\t\t| x::xs ->\r\n\t\t\t\tlet ySet = expandGenerate cfg len (xs, w) in\r\n\t\t\t\t\tif isTerminalSymbol x cfg then\r\n\t\t\t\t\t\tSet.map (fun (fs, w) -> (x :: fs, w)) ySet\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tlet xRules = Set.filter(fun r -> r.head = x) cfg.rules in\r\n\t\t\t\t\t\tlet xBodies = Set.map (fun r -> r.body) (Set.filter(fun r -> hasEmpty r.body || verifyLength cfg sf r.body len) xRules) in\r\n\t\t\t\t\t\tlet res = Set.flatMap (fun (fs1, w) -> Set.map (fun fs2 -> (fs2@fs1, w)) xBodies) ySet in\r\n\t\t\t\t\t\tres\r\n\t\t\t\t\r\n\t\t(* 0P1, 0P1*)\r\n\t\t(* *)\r\n\r\n\r\n\tlet nextConfigs (cfg: t) (sf, w) : configurations =\r\n\t\tUtil.show(\"Starting nextConfigs for: \"^word2str sf);\r\n\t\tlet res = expand cfg (sf,w) in\r\n\t\t\tSet.iter(fun (sf, w) -> Util.show(\"[\" ^ word2str sf ^ \",\" ^ word2str w ^ \"]\")) res;\r\n\t\t\tres\r\n\r\n\tlet nextConfigs2 (cfg: t) (len: int) (sf, w) : configurations =\r\n\t\tUtil.show(\"Starting nextConfigs for: \"^word2str sf);\r\n\t\tlet res = expandGenerate cfg len (sf,w) in\r\n\t\t\tSet.iter(fun (sf, w) -> Util.show(\"[\" ^ word2str sf ^ \",\" ^ word2str w ^ \"]\")) res;\r\n\t\t\tres\r\n\r\n\t\t\r\n\r\n\tlet isAcceptingConfig (cfg: t) (rl, w) : bool =\r\n\t\trl = w\r\n\r\n\t\r\n\tlet accept (cfg: t) (w: word) : bool =\r\n\t\t\tModel.accept cfg w initialConfig nextConfigs isAcceptingConfig\r\n\t\t\r\n\tlet acceptFull (cfg: t) (w: word) : bool * path * trail =\r\n\t\t\tModel.acceptFull cfg w initialConfig nextConfigs isAcceptingConfig\r\n\t\r\n\tlet isAcceptingConfig2 (cfg: t) (sf, w) : bool =\r\n\t\tList.for_all(fun sym -> isTerminalSymbol sym cfg) sf\r\n\r\n(* Pedro Carlos*)\r\n(* VER! o que faz?  gram->cfg\r\n      teste desta função -> ver gram_example4!!! *)\r\n\tlet find_applied_rules (gram: t) (path: path) : (word * rule list * int list) list =\r\n\t\t(* For each configuration in the path, identify applicable rules *)\r\n\t\tlet rec starts_with sub main =\r\n\t\t\tmatch sub, main with\r\n\t\t\t| [], _ -> true (* An empty list is a prefix of any list *)\r\n\t\t\t| _, [] -> false (* 'main' list ended before 'sub' list did *)\r\n\t\t\t| h_sub :: t_sub, h_main :: t_main ->\r\n\t\t\t\t\tif h_sub = h_main then\r\n\t\t\t\t\t\tstarts_with t_sub t_main (* Heads match, check the tails *)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tfalse (* Heads don't match *)\r\n\t\tin\r\n\t\t(* Main function: Checks if 'sub' is a contiguous sublist of 'main' *)\r\n\t\tlet rec is_sublist sub main =\r\n\t\t\tmatch sub with\r\n\t\t\t| [] -> true (* An empty list is always a sublist *)\r\n\t\t\t| _ -> (* 'sub' is not empty *)\r\n\t\t\t\t\tmatch main with\r\n\t\t\t\t\t| [] -> false (* 'main' is empty, non-empty 'sub' cannot be a sublist *)\r\n\t\t\t\t\t| _ :: t_main ->\r\n\t\t\t\t\t\t\tif starts_with sub main then\r\n\t\t\t\t\t\t\t\ttrue (* Found 'sub' starting at the current position *)\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tis_sublist sub t_main (* Try starting from the next element of 'main' *)\r\n\t\tin\t\r\n\t\tList.mapi (fun i config ->\r\n\t\t\tif i < (List.length path) - 1 then begin\r\n\t\t\t\tlet (sf, w) = config in\r\n\t\t\t\tlet (sf_next, w_next) = List.nth path (i + 1) in\r\n\t\t\t\t\r\n\t\t\t\t(* Find variables in the sentential form and their positions *)\r\n\t\t\t\tlet var_positions = ref [] in\r\n\t\t\t\tList.iteri (fun i sym ->\r\n\t\t\t\t\tif Set.belongs sym gram.variables then\r\n\t\t\t\t\t\tvar_positions := (i, sym) :: !var_positions\r\n\t\t\t\t) sf;\r\n\t\t\t\tlet var_positions = List.rev !var_positions in\r\n\t\t\t\t\r\n\t\t\t\t(* For each variable, find all applicable rules *)\r\n\t\t\t\tlet all_rules = ref [] in\r\n\t\t\t\tlet all_positions = ref [] in\r\n\t\t\t\t\r\n\t\t\t\tList.iter (fun (i, var) ->\r\n\t\t\t\t\tlet var_rules = Set.filter (fun r -> r.head = var) gram.rules in\r\n\t\t\t\t\tprint_endline (\"Variable: \" ^ symb2str var);\r\n\t\t\t\t\tSet.iter (fun rule ->\r\n\t\t\t\t\t\tif is_sublist rule.body sf_next then begin\r\n\t\t\t\t\t\t\tall_rules := rule :: !all_rules;\r\n\t\t\t\t\t\t\tall_positions := i :: !all_positions\r\n\t\t\t\t\t\tend\r\n\t\t\t\t\t) var_rules\r\n\t\t\t\t) var_positions;\r\n\t\t\t\t\r\n\t\t\t\t(* Return the configuration along with applicable rules and their positions *)\r\n\t\t\t\t(* let variables_only = List.filter (fun sym -> Set.belongs sym gram.variables) sf in *)\r\n\t\t\t\t(sf, List.rev !all_rules, List.rev !all_positions)\r\n\t\t\tend else begin\r\n\t\t\t\t([], [], [])\r\n\t\t\tend\r\n\t\t) path\r\n\t\r\n\r\n\tlet getWord (sf, _) = List.filter (fun symb -> isTerminalSymbol2 symb) sf\r\n\r\n\tlet generate (cfg: t) (len: int) : words =\r\n\t\t\r\n\t\tModel.generate cfg len initialConfig nextConfigs2 isAcceptingConfig2 getWord\r\n\r\n\r\n(* ----------------------------------------------------------------------------*)\r\n\r\n\r\n\r\nend\r\n\r\nmodule ContextFreeGrammarBasic =\r\nstruct\r\n\tinclude ContextFreeGrammarSupport\r\n\topen ContextFreeGrammarPrivate\r\n\r\n\t(* Make *)\r\n\tlet make2 (arg: t Arg.alternatives): Entity.t * t = make2 arg validate\r\n\tlet make (arg: t Arg.alternatives): t = make arg validate\r\n\r\n\t(* Exercices support *)\r\n\tlet checkProperty (re: t) (prop: string) =\r\n\t\tmatch prop with\r\n\t\t| \"regular\" -> false (* TODO self#isRegular *)\r\n\t\t| \"context free grammar\" -> true\r\n\t\t| _ -> Model.checkProperty prop\r\n\tlet checkExercise ex re = Model.checkExercise ex (accept re) (checkProperty re)\t\r\n\tlet checkExerciseFailures ex re = Model.checkExerciseFailures ex (accept re) (checkProperty re)\t\r\n\r\n\t(* Ops *)\r\n\tlet lookahead = lookahead\r\n\tlet follow = follow\r\n\tlet first = first\r\n\tlet accept = accept\r\n\tlet generate = generate\t\r\n\r\n\tclass model (arg: t Arg.alternatives) =\r\n\t\tobject(self) inherit Model.model (make2 arg) as super\r\n\t\t\tval mutable simplified = false\r\n\t\t(* Representation *)\r\n\t\t\tmethod representation = representation\r\n\t\t(* Kind *)\r\n\t\t\tmethod isContextGrammar : bool = true\r\n\t\t\tmethod isContextFreeGrammar : bool = true\r\n\t\t(* Show *)\t\t\t\r\n\t\t\tmethod toJSon: JSon.t = toJSon representation\r\n\t\t\tmethod toJSon2: JSon.t = toJSon2 id representation\r\n\t\t\tmethod show: unit = show representation\r\n\t\t\tmethod show2: unit = show2 id representation\r\n\t\t(* Ops *)\r\n\t\t\t(* This method checks if the grammar is regular\r\n\t\t\t*\r\n\t\t\t* @returns bool -> true if regular, false otherwise\r\n\t\t\t*)\r\n\t\t\tmethod isRegular : bool =\r\n\r\n\t\t\t\tlet vs = representation.variables in\r\n\t\t\t\tlet alp = representation.alphabet in\r\n\r\n\t\t\t\tlet bs = Set.map (fun r -> r.body) representation.rules in\r\n\r\n\t\t\t\tlet isRightLinear bs =\r\n\t\t\t\t\tlet isRightLinearX b =\r\n\t\t\t\t\t\tmatch b with\r\n\t\t\t\t\t\t\t| [a] -> (Set.belongs a alp) || a = epsilon\r\n\t\t\t\t\t\t\t| [a; v] -> (Set.belongs a alp) && (Set.belongs v vs)\r\n\t\t\t\t\t\t\t| _ -> false\r\n\t\t\t\t\tin\r\n\t\t\t\t\t\tSet.for_all (fun b -> isRightLinearX b) bs\r\n\t\t\t\tin\r\n\r\n\t\t\t\tlet isLeftLinear bs =\r\n\t\t\t\t\tlet isLeftLinearX b =\r\n\t\t\t\t\t\tmatch b with\r\n\t\t\t\t\t\t\t| [a] -> (Set.belongs a alp) || a = epsilon\r\n\t\t\t\t\t\t\t| [v; a] -> (Set.belongs v vs) && (Set.belongs a alp)\r\n\t\t\t\t\t\t\t| _ -> false\r\n\t\t\t\t\tin\r\n\t\t\t\t\t\tSet.for_all (fun b -> isLeftLinearX b) bs\r\n\t\t\t\tin\r\n\t\t\t\t\tisRightLinear bs || isLeftLinear bs\r\n\r\n\r\n      method first testWord = first testWord simplified self#representation\r\n      method follow testSymbol = follow testSymbol simplified self#representation\r\n      method lookahead rule = lookahead rule simplified self#representation\r\n\r\n\t\t\t(* This method checks if the given word is accepted by the grammar\r\n\t\t\t*\r\n\t\t\t* @param testWord -> word to be tested\r\n\t\t\t*\r\n\t\t\t* @returns bool -> true if it accepts the word, false otherwise\r\n\t\t\t*)\r\n\r\n\r\n\t\t\tmethod accept (testWord:word) : bool =\r\n\t\t\t\tChomskyNormalForm.accept (self#representation) testWord\r\n\r\n\t\t\tmethod acceptFull (w: word) : bool * path * trail = acceptFull representation w\r\n\r\n\t\t\t(* PEDRO CARLOS *)\r\n\t\t\tmethod find_applied_rules (path: path) : (word * rule list * int list) list =\r\n\t\t\t\tfind_applied_rules representation path\r\n\r\n\t\t\tmethod private acceptXXX (testWord:word) : bool =\r\n\r\n\t\t\t\t(* any word with a symbol not from the cfg alphabet will not be accepted\r\n\t\t\t\tif not (Set.subset (Set.make testWord) representation.alphabet) then false else\r\n\t\t\t\t*)\r\n\r\n\t\t\t\tlet vs = representation.variables in\r\n\r\n\r\n\t\t\t\t(* for word wa, get subword to the left of its first variable *)\r\n\t\t\t\tlet rec getPrefix wa =\r\n\t\t\t\t\tmatch wa with\r\n\t\t\t\t\t\t| [] -> []\r\n\t\t\t\t\t\t| x::xs -> if Set.belongs x vs then [] else x::(getPrefix xs)\r\n\t\t\t\tin\r\n\r\n\t\t\t\t(* for word wa, get subword to the rigth of its last variable *)\r\n\t\t\t\tlet getSuffix wa =\r\n\t\t\t\t\tlet rec getSuffixX wa sfx =\r\n\t\t\t\t\t\tmatch wa with\r\n\t\t\t\t\t\t\t| [] -> sfx\r\n\t\t\t\t\t\t\t| x::xs -> let auxSfx = sfx@[x] in\r\n\t\t\t\t\t\t\t\t\t\tif Set.belongs x vs then getSuffixX xs []\r\n\t\t\t\t\t\t\t\t\t\t\telse getSuffixX xs auxSfx\r\n\t\t\t\t\tin\r\n\t\t\t\t\t\tgetSuffixX wa []\r\n\t\t\t\tin\r\n\r\n\t\t\t\tlet rec firstNElements w n =\r\n\t\t\t\t\tmatch w with\r\n\t\t\t\t\t\t| [] -> []\r\n\t\t\t\t\t\t| x::xs -> if n > 0 then x::(firstNElements xs (n-1)) else []\r\n\t\t\t\tin\r\n\r\n\t\t\t\tlet rec lastNElements w n =\r\n\t\t\t\t\tmatch w with\r\n\t\t\t\t\t\t| [] -> []\r\n\t\t\t\t\t\t| x::xs -> if n < (List.length w) then lastNElements xs n else w\r\n\t\t\t\tin\r\n\r\n\t\t\t\t(* a word can be discarded if its prefix does not match the leftmostmost part of word w *)\r\n\t\t\t\tlet keepByPrefix genW testW =\r\n\t\t\t\t\tlet pgw = getPrefix genW in\r\n\t\t\t\t\tlet ptw = firstNElements testW (List.length pgw) in\r\n\t\t\t\t\t\tpgw = [] || pgw = ptw\r\n\t\t\t\tin\r\n\r\n\r\n\t\t\t\t(* a word can be discarded if its suffix does not match the rightmost part of word w *)\r\n\t\t\t\tlet keepBySufix genW testW =\r\n\t\t\t\t\tlet sgw = getSuffix genW in\r\n\t\t\t\t\tlet stw = lastNElements testW (List.length sgw) in\r\n\t\t\t\t\t\tsgw = [] || sgw = stw\r\n\t\t\t\tin\r\n\r\n\t\t\t\t(* the word inst discarded only if it cant be discarded by neither its prefix nor its suffix *)\r\n\t\t\t\tlet toKeep w tw = (w = [] && tw = []) || (keepByPrefix w tw && keepBySufix w tw) in\r\n\r\n\r\n\t\t\t\tlet alph = representation.alphabet in\r\n\t\t\t\tlet vs = representation.variables in\r\n\t\t\t\tlet rs = representation.rules in\r\n\t\t\t\tlet l = List.length testWord in\r\n\r\n\t\t\t\tlet nextGeneration ws =\r\n\t\t\t\t\tlet subsWs = Set.flatMap (fun w -> subVar w vs rs) ws in\r\n\t\t\t\t\tlet rws = Set.filter (fun w -> not (exceedsMaxLen w l alph)) subsWs in\r\n\t\t\t\t\tlet rws = Set.map (fun w -> removeEpsi w) rws in\r\n\t\t\t\t\t\tSet.filter (fun w -> toKeep w testWord ) rws\r\n\r\n\t\t\t\tin\r\n\r\n\t\t\t\tlet start = Set.make [[representation.initial]] in\r\n\r\n\t\t\t\tlet res = Set.historicalFixedPoint nextGeneration start in\r\n\t\t\t\t\tSet.exists (fun x -> x = testWord ) res\r\n\r\n\r\n\r\n\r\n\t\t\tmethod acceptWithTracing (testWord:word) =\r\n\r\n\r\n\r\n\t\t\t\tlet vs = representation.variables in\r\n\r\n\r\n\t\t\t\t(* for word wa, get subword to the left of its first variable *)\r\n\t\t\t\tlet rec getPrefix wa =\r\n\t\t\t\t\tmatch wa with\r\n\t\t\t\t\t\t| [] -> []\r\n\t\t\t\t\t\t| x::xs -> if Set.belongs x vs then [] else x::(getPrefix xs)\r\n\t\t\t\tin\r\n\r\n\t\t\t\t(* for word wa, get subword to the rigth of its last variable *)\r\n\t\t\t\tlet getSuffix wa =\r\n\t\t\t\t\tlet rec getSuffixX wa sfx =\r\n\t\t\t\t\t\tmatch wa with\r\n\t\t\t\t\t\t\t| [] -> sfx\r\n\t\t\t\t\t\t\t| x::xs -> let auxSfx = sfx@[x] in\r\n\t\t\t\t\t\t\t\t\t\tif Set.belongs x vs then getSuffixX xs []\r\n\t\t\t\t\t\t\t\t\t\t\telse getSuffixX xs auxSfx\r\n\t\t\t\t\tin\r\n\t\t\t\t\t\tgetSuffixX wa []\r\n\t\t\t\tin\r\n\r\n\t\t\t\tlet rec firstNElements w n =\r\n\t\t\t\t\tmatch w with\r\n\t\t\t\t\t\t| [] -> []\r\n\t\t\t\t\t\t| x::xs -> if n > 0 then x::(firstNElements xs (n-1)) else []\r\n\t\t\t\tin\r\n\r\n\t\t\t\tlet rec lastNElements w n =\r\n\t\t\t\t\tmatch w with\r\n\t\t\t\t\t\t| [] -> []\r\n\t\t\t\t\t\t| x::xs -> if n < (List.length w) then lastNElements xs n else w\r\n\t\t\t\tin\r\n\r\n\t\t\t\t(* a word can be discarded if its prefix does not match the leftmostmost part of word w *)\r\n\t\t\t\tlet keepByPrefix genW testW =\r\n\t\t\t\t\tlet pgw = getPrefix genW in\r\n\t\t\t\t\tlet ptw = firstNElements testW (List.length pgw) in\r\n\t\t\t\t\t\tpgw = [] || pgw = ptw\r\n\t\t\t\tin\r\n\r\n\r\n\t\t\t\t(* a word can be discarded if its suffix does not match the rightmost part of word w *)\r\n\t\t\t\tlet keepBySufix genW testW =\r\n\t\t\t\t\tlet sgw = getSuffix genW in\r\n\t\t\t\t\tlet stw = lastNElements testW (List.length sgw) in\r\n\t\t\t\t\t\tsgw = [] || sgw = stw\r\n\t\t\t\tin\r\n\r\n\t\t\t\t(* the word inst discarded only if it cant be discarded by neither its prefix nor its suffix *)\r\n\t\t\t\tlet toKeep w tw = (w = [] && tw = []) || (keepByPrefix w tw && keepBySufix w tw) in\r\n\r\n\r\n\t\t\t\tlet alph = representation.alphabet in\r\n\t\t\t\tlet vs = representation.variables in\r\n\t\t\t\tlet rs = representation.rules in\r\n\t\t\t\tlet l = List.length testWord in\r\n\r\n\t\t\t\tlet nextGeneration ws =\r\n\t\t\t\t\tlet subsWs = Set.flatMap (fun w -> subVar w vs rs) ws in\r\n\t\t\t\t\tlet rws = Set.filter (fun w -> not (exceedsMaxLen w l alph)) subsWs in\r\n\t\t\t\t\tlet rws = Set.map (fun w -> removeEpsi w) rws in\r\n\t\t\t\t\t\tSet.filter (fun w -> toKeep w testWord ) rws\r\n\r\n\t\t\t\tin\r\n\r\n\t\t\t\tlet start = Set.make [[representation.initial]] in\r\n\r\n\t\t\t\tlet res = Set.historicalFixedPointTracing nextGeneration start in\r\n\r\n\r\n\t\t\t\tlet trimRes l =\r\n\t\t\t\t\tmatch l with\r\n\t\t\t\t\t| [] -> []\r\n\t\t\t\t\t| x::xs -> if Set.belongs testWord x then xs\r\n\t\t\t\t\t\t\t\telse l\r\n\t\t\t\tin\r\n\r\n\t\t\t\tlet res2 = List.rev (trimRes (List.rev res)) in\r\n\r\n\r\n\t\t\t\tlet printWset ws =\r\n\t\t\t\t\tUtil.print [\"[\"];\r\n\t\t\t\t\tSet.iter (fun w -> Util.print [word2str w; \";\"]) ws;\r\n\t\t\t\t\tUtil.println [\"]\"];\r\n\t\t\t\tin\r\n\r\n\t\t\t\t\tList.iter (fun ws -> printWset ws) res2\r\n\r\n\r\n\r\n\r\n\t\t\t(* This method generates all words up the the given lenght that belong to the grammars language\r\n\t\t\t*\r\n\t\t\t* @ param lenght -> the max lenght of generated words\r\n\t\t\t*\r\n\t\t\t* @returns words -> the set of generated words\r\n\t\t\t*)\r\n\t\t\tmethod generate (length:int) : words =\r\n\r\n\t\t\t\tlet alph = representation.alphabet in\r\n\t\t\t\tlet vs = representation.variables in\r\n\t\t\t\tlet rs = representation.rules in\r\n\r\n\r\n\t\t\t\tlet nextGeneration ws =\r\n\t\t\t\t\tlet subsWs = Set.flatMap (fun w -> subVar w vs rs) ws in\r\n\t\t\t\t\t\tSet.filter (fun w -> not (exceedsMaxLen w length alph)) subsWs\r\n\t\t\t\tin\r\n\r\n\t\t\t\tlet start = Set.make [[representation.initial]] in\r\n\r\n\t\t\t\tlet res = Set.historicalFixedPoint nextGeneration start in\r\n\r\n\t\t\t\t\tcleanNonWords res vs\r\n\r\n\t\t(* Exercices support *)\r\n\t\t\tmethod checkProperty (prop: string) = checkProperty representation prop\r\n\r\n\t\t(* Learn-OCaml support *)\r\n\t\t\tmethod moduleName = moduleName\r\n\t\t\tmethod xTypeName = xTypeName\r\n\t\t\tmethod xTypeDeclString : string = prelude\r\n\t\t\tmethod toDisplayString (name: string): string = solution name self#representation\r\n\t\t\tmethod example : JSon.t = example\r\n\t\tend\r\nend\r\n\r\nmodule ContextFreeGrammarTop =\r\nstruct\r\n\topen ContextFreeGrammarBasic\r\n\topen ContextFreeGrammarBasicsX\r\n\r\n\tlet cfgI cfg = internalize cfg\r\n\tlet cfgX cfg = externalize cfg\r\n\t\r\n\tlet cfg_load file = cfgX (make (Arg.File file))\r\n\tlet cfg_text text = cfgX (make (Arg.Text text))\r\n\tlet cfg_json json = cfgX (make (Arg.JSon json))\r\n\tlet cfg_predef name = cfg_text (Examples.example name)\r\n\r\n(*\tlet confX (s, w) = (state2str s, word2str w)\r\n\tlet pathX (p: path) = pathX confX p\r\n\tlet trailX (t: trail) = trailX confX t *)\r\n\t\r\n\tlet stats () = RuntimeControl.stats ()\r\n\r\n\tlet cfg_accept cfg w = accept (cfgI cfg) (wordI w)\r\n\r\n(*\r\n\tlet cfg_path cfg w =\r\n\t\tlet (r,p,t) = acceptFull (cfgI cfg) (wordI w) in\r\n\t\t\tpathX p\r\n\r\n\tlet cfg_trail cfg w =\r\n\t\tlet (r,p,t) = acceptFull (cfgI cfg) (wordI w) in\r\n\t\t\ttrailX t\r\n\t\t*)\r\n\r\n\tlet cfg_generate cfg len = wordsX (generate (cfgI cfg) len)\r\nend\r\n\r\nopen ContextFreeGrammarTop\r\n\r\n     (* Adds a sufix to a variable name name *)\r\n     let addSufixCFG (v: symbol)(sufix: string): symbol =\r\n       str2symb((symb2str v)^\"_\"^sufix)\r\n\r\n\r\n(* addSufix a que? *)\r\n    let addSufixList  body sufix =\r\n        List.map(fun s -> addSufixCFG  s sufix) body\r\n\r\n       (* Renames all the variables in one gramatic adding a sufix *)\t\r\n     let renameVariablesCFG (cfg: ContextFreeGrammarBasic.t) (sufix: string): ContextFreeGrammarBasic.t =\r\n       let open ContextFreeGrammarBasic in \r\n       {alphabet = cfg.alphabet;\r\n       variables =\tSet.map (fun v -> addSufixCFG v sufix) cfg.variables;\r\n       initial = addSufixCFG cfg.initial sufix;\r\n       rules = Set.map (fun {head= h;body = b} -> {head=(addSufixCFG h sufix);body= addSufixList b sufix}) cfg.rules\r\n       }\r\n\r\n\r\n(*\r\n\r\n--------------------\r\n\r\nlet cfg_balanced = {| {\r\n\t\tkind : \"context free grammar\",\r\n\t\tdescription : \"CFG: Language of balanced square bracket parentheses\",\r\n\t\tname : \"cfg_balanced\",\r\n\t\talphabet : [\"[\", \"]\"],\r\n\t\tvariables : [\"<Start>\"],\r\n\t\tinitial : \"<Start>\",\r\n\t\trules : [ \"<Start> -> [<Start>] | <Start><Start> | ~\"]\r\n\t} |};;\r\n\r\nlet cfg = cfg_text cfg_balanced;;\r\n\r\nlet cfg2 = cfgX cfg;;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlet cfg2 = renameVariablesCFG (cfgI cfg) \"ola\";;\r\n\r\n\r\n\r\n\r\n\r\nlet cfg = cfg_predef \"cfg_simple\";;\r\n\r\nlet cfg2 = renameVariablesCFG (cfgI cfg) \"ola\";;\r\n\r\n\r\n\r\nlet cfg2 = cfgX (renameVariablesCFG (cfgI cfg) \"ola\");;\r\n\r\nfa_generate fa 8;;\r\n\r\nfa_accept fa \"aaaa\";;\r\nfa_accept fa \"aaaca\";;\r\n\r\nfa_path fa \"aaaa\";;\r\nfa_path fa \"aaaca\";;\r\n\r\nfa_trail fa \"aaaa\";;\r\n--------------------\r\n\r\n#print_depth 10000;;\r\n#print_length 10000;;\r\n\r\n\r\n\r\n\r\n--------------------\r\nlet fa = fa_predef \"dfa_astar\";;\r\n\r\nfa_generate fa 8;;\r\n\r\nfa_accept fa \"aaaa\";;\r\nfa_accept fa \"aaaca\";;\r\n\r\nfa_path fa \"aaaa\";;\r\nfa_path fa \"aaaca\";;\r\n\r\nfa_trail fa \"aaaa\";;\r\n--------------------\r\n\r\n#print_depth 10000;;\r\n#print_length 10000;;\r\n\r\n\r\n\r\nlet fa_astar = {| {\r\n\t\tkind : \"finite automaton2\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"dfa_astar\",\r\n\t\talphabet: [\"a\"],\r\n\t\tstates : [\"START\", \"Z1\"],\r\n\t\tinitialState : \"START\",\r\n\t\ttransitions : [\r\n\t\t\t[\"START\", \"a\", \"START\"],\r\n\t\t\t[\"START\", \"~\", \"START\"],\t\t\t\r\n\t\t\t[\"START\", \"~\", \"Z\"],\t\t\t\r\n\t\t\t[\"Z\", \"a\", \"Z\"],\r\n\t\t\t[\"START\", \"a\", \"Z\"]\r\n\t\t],\r\n\t\tacceptStates : [\"START\", \"Z\"]\r\n\t\t} |}\r\n;;\r\nlet fa = fa_text fa_astar;;\r\n\r\nlet fa_astar = {| {\r\n\t\tkind : \"finite automaton2\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"dfa_astar\",\r\n\t\talphabet: [\"a\"],\r\n\t\tstates : [\"START\", \"Z1\"],\r\n\t\tinitialState : \"START\",\r\n\t\ttransitions : [\r\n\t\t\t[\"START\", \"a\", \"START\"],\r\n\t\t\t[\"START\", \"~\", \"START\"],\t\t\t\r\n\t\t\t[\"START\", \"~\", \"Z\"],\t\t\t\r\n\t\t\t[\"Z\", \"a\", \"Z\"],\r\n\t\t\t[\"START\", \"a\", \"Z\"]\r\n\t\t],\r\n\t\tacceptStates : [\"START\", \"Z\"]\r\n\t\t} |}\r\n;;\r\nlet fa = fa_text fa_astar;;\r\n\r\n*)\r\n\r\n# 3 \"src/ContextFreeGrammarRDParser.ml\"\r\nopen BasicTypes\r\nopen ContextFreeGrammarBasic\r\n\r\nmodule RDParser =\r\nstruct\r\n\r\n  (* given a head, returns the set of all its bodies according to the cfg's rules *)\r\n\tlet bodiesOfHead h rl =\r\n\t  let open ContextFreeGrammarBasic in\r\n\t\tlet rls = Set.filter (fun r -> r.head = h) rl in\r\n\t\t\tSet.map (fun r -> r.body) rls\r\n\r\n  let rec tabCreator tabLevel =\r\n    if tabLevel > 0 then \"\\t\"^ tabCreator (tabLevel - 1) else \"\"\r\n\r\n  class virtual parser =\r\n    object(self)\r\n\r\n    val arrayVar = \"word\"\r\n    val currentCharVar = \"currentChar\"\r\n    val currentIndexVar = \"wordIndex\"\r\n      \r\n    val getCharFun = \"getChar\"\r\n    val parseErrorFun = \"parseError\"\r\n    val matchCharFun = \"matchChar\"\r\n\r\n    val virtual equality : string\r\n    val virtual orOp : string\r\n    val virtual functionArgsOpen : string\r\n    val virtual functionArgsClose : string\r\n    val virtual ifOpen : string \r\n    val virtual ifClose : string\r\n    val virtual ifElseGuardOpen : string\r\n    val virtual ifElseGuardClose : string\r\n    val virtual expressionTermination : string\r\n    val virtual return : string\r\n\r\n    (* Method that will print includes/imports needed for the parser *)\r\n    method virtual setupIncludes : string\r\n    \r\n    \r\n    (* Method used to setup the variables for the parser. *)\r\n  \t(* Use values arrayVar, currentCharVar and currentIndexVar *)\r\n  \t(* to get correct variable names. *)\r\n    method virtual setupVariables : string\r\n    \r\n    \r\n    (* Method that prints the getCharFunction. *)\r\n    (* This function consumes a symbol while parsing. *)\r\n    method virtual getCharFunction : string\r\n    \r\n    \r\n    (* Method that prints the match function. *)\r\n    (* This function verifies if symbols match. *)\r\n    (* Consumes the symbol if there is a match. *)\r\n    (* Otherwise, calls error function. *)\r\n    method virtual matchFunction : string\r\n    \r\n    \r\n    (* Method that prints the error function. *)\r\n    (* This function exists the program when called symbols match. *)\r\n    method virtual errorFunction : string\r\n    \r\n\r\n    method printFunctions vars rep =\r\n      if vars = Set.empty then \"\"\r\n      else let (x,xs) = Set.cut vars in\r\n        self#symbolFunction x rep ^\r\n        (self#printFunctions xs rep)\r\n \r\n    (* Method that prints the programs main function. *)\r\n    method virtual mainFunction : symbol -> string\r\n    \r\n\r\n    method virtual createFun : string -> string -> string\r\n\r\n\r\n    (*TODO Move to lower level*)\r\n    method createFunCalls funs (rep: t) =\r\n      match funs with\r\n      | [] -> []\r\n      | x::xs when Set.belongs x rep.alphabet -> [matchCharFun ^ functionArgsOpen ^ \"\\'\" ^ symb2str x ^ \"\\'\" ^ functionArgsClose ^ expressionTermination] @ self#createFunCalls xs rep\r\n      | x::xs when Set.belongs x rep.variables -> [symb2str x ^ functionArgsOpen ^ functionArgsClose ^ expressionTermination] @ self#createFunCalls xs rep\r\n      | x::xs -> []\r\n\r\n    (*TODO Move to lower level*)\r\n    method createIfConds conditions =\r\n      let p = String.make 1 '\\'' in\r\n      match conditions with\r\n      | [] -> \"\"\r\n      | [x] -> currentCharVar ^ equality ^ p ^ symb2str x ^ p\r\n      | x::xs -> currentCharVar ^ equality ^ p ^ symb2str x ^ p ^ \" \" ^ orOp ^ \" \" ^ self#createIfConds xs\r\n      \r\n    (*TODO Move to lower level*)\r\n    method createIf ifList tabLevel = \r\n      let rec createIf2 first ifList tabLevel =\r\n        let rec createExpr exprList tabLevel =\r\n          match exprList with \r\n          | [] -> \"\"\r\n          | x::xs -> (tabCreator tabLevel) ^ x ^ \"\\n\" ^ createExpr xs tabLevel\r\n        in\r\n        let tab = (tabCreator tabLevel) in\r\n        match ifList with\r\n        | [] -> \"\"\r\n        | [(c,e)] -> tab ^ \"else\" ^ ifElseGuardOpen ^ \"\\n\" ^ (createExpr e (tabLevel+1)) ^ tab ^ ifElseGuardClose\r\n        | (c,e)::xs -> tab ^ (if first then \"if\" else \"else if\") ^ ifOpen ^ c ^ ifClose ^ ifElseGuardOpen ^ \"\\n\" ^ \r\n                       (createExpr e (tabLevel+1)) ^\r\n                       tab ^ (ifElseGuardClose) ^ \"\\n\" ^ createIf2 false xs tabLevel\r\n      in\r\n      createIf2 true ifList tabLevel\r\n\r\n  \r\n    method symbolFunction s (rep: t) =\r\n      let open ContextFreeGrammarBasic in\r\n      let getNextTerminals rule = \r\n(*        Printf.printf \"\\tGetting lookahead for rules\";*)\r\n(*        List.iter (fun r -> Printf.printf \" %s \" r) (CFGSyntax.toStringList (Set.make [rule]));*)\r\n(*        Printf.printf \"\\n\";*)\r\n(*        Set.iter (fun r -> Printf.printf \"\\tGot result %s\\n\" (symb2str r)) (ContextFreeGrammarBasic.lookahead rule false rep);*)\r\n        ContextFreeGrammarBasic.lookahead rule false rep\r\n      in\r\n\r\n      let rules = Set.filter (fun {head;body} -> head = s) rep.rules in\r\n      let funCalls = (List.map (fun {head;body} -> self#createFunCalls body rep) (Set.toList rules)) in\r\n      let lookaheads = Set.map (getNextTerminals) rules in\r\n      let mergedMap = List.map2 (fun a b -> (self#createIfConds (Set.toList a),b)) (Set.toList lookaheads) funCalls in\r\n(*      Printf.printf \"Current Var: %s\\n\" (symb2str s);*)\r\n(*      List.iter (fun (a,b) -> Printf.printf \"\\t%s\" a;*)\r\n(*                              Printf.printf \"\\n\";*)\r\n(*                              List.iter (fun c -> Printf.printf \"\\t\\t%s\\n\" c) b*)\r\n(*      ) mergedMap;*)\r\n      let mergedMap = mergedMap @ [(\"\",[(parseErrorFun ^ functionArgsOpen ^ functionArgsClose ^  expressionTermination)])] in\r\n      self#createFun (symb2str s) (self#createIf mergedMap 1)\r\n\r\n\r\n    method virtual build : t -> string\r\n\r\n  end\r\nend\r\n\r\n\r\nmodule RDParserWithDeclarations =\r\nstruct\r\n\r\n  class virtual parser =\r\n    object(self) inherit RDParser.parser as super\r\n    \r\n  end\r\n\r\nend\r\n\r\n\r\nmodule RDParserWithoutDeclarations =\r\nstruct\r\n\r\n  class virtual parser =\r\n    object(self) inherit RDParser.parser as super\r\n    \r\n      method build (rep: t) =\r\n        self#setupIncludes ^\r\n        self#setupVariables ^\r\n        self#getCharFunction ^\r\n        self#errorFunction ^\r\n        self#matchFunction ^\r\n        (self#printFunctions rep.variables rep) ^\r\n        (self#mainFunction rep.initial)\r\n    \r\n  end\r\nend\r\n\r\n\r\nmodule RDParserNeedFunDeclaration =\r\nstruct\r\n\r\n  class virtual parser =\r\n    object(self) inherit RDParserWithDeclarations.parser as super\r\n    \r\n      (* Method that prints function declarations *)\r\n      method functionDeclarations vars =\r\n        let rec printDecl vars =\r\n          if vars = Set.empty then \"\"\r\n          else let (x,xs) = Set.cut vars in\r\n            Printf.sprintf {|void %s();|} (symb2str x) ^ \"\\n\" ^ printDecl xs\r\n          in\r\n      printDecl vars ^ \"\\n\"\r\n    \r\n      method build (rep: t) =\r\n        Util.stripHead (self#setupIncludes ^\r\n        self#setupVariables ^\r\n        self#functionDeclarations rep.variables ^\r\n        self#getCharFunction ^\r\n        self#errorFunction ^\r\n        self#matchFunction ^\r\n        (self#printFunctions rep.variables rep) ^\r\n        (self#mainFunction rep.initial))\r\n    \r\n  end\r\n\r\nend\r\n\r\n\r\nmodule RDParserNeedRecursiveFunDeclaration =\r\nstruct\r\n\r\n  class virtual parser =\r\n    object(self) inherit RDParserWithDeclarations.parser as super\r\n    \r\n      method printFunctions vars rep =\r\n        let first = true in\r\n        let rec printFunctionsX vars rep first =\r\n          if vars = Set.empty then \"\"\r\n          else let (x,xs) = Set.cut vars in\r\n            (if first then \"let rec \" else \"and \") ^\r\n            self#symbolFunction x rep ^\r\n            (printFunctionsX xs rep false)\r\n        in\r\n        printFunctionsX vars rep first\r\n    \r\n      method build (rep: t) =\r\n        Util.stripHead (self#setupIncludes ^\r\n        self#setupVariables ^\r\n        self#getCharFunction ^\r\n        self#errorFunction ^\r\n        self#matchFunction ^\r\n        (self#printFunctions rep.variables rep) ^\r\n        (self#mainFunction rep.initial))\r\n    \r\n  end\r\n\r\nend\r\n\r\n\r\nmodule RDParserC =\r\nstruct\r\n\r\n  class parser =\r\n    object(self) inherit RDParserNeedFunDeclaration.parser as super\r\n\r\n    val equality = \"==\"\r\n    val orOp = \"||\"\r\n    val functionArgsOpen = \"(\"\r\n    val functionArgsClose = \")\"\r\n    val ifOpen = \"(\"\r\n    val ifClose = \")\"\r\n    val ifElseGuardOpen = \"{\"\r\n    val ifElseGuardClose = \"}\"\r\n    val expressionTermination = \";\"\r\n    val return = \"return\"\r\n\r\n\r\n    method setupIncludes =\r\n  \t  Printf.sprintf {|\r\n\t\t #include <stdio.h>\r\n\t\t #include <stdlib.h>\r\n\t\t #include <string.h>\r\n      |}\r\n    \r\n    \r\n    method setupVariables =\r\n      Printf.sprintf {|\r\n\t\tchar* %s;\r\n\t\tchar %s;\r\n\t\tint %s;\r\n\t\t|} arrayVar currentCharVar currentIndexVar\r\n    \r\n    \r\n    method getCharFunction =\r\n      Printf.sprintf {|\r\n\t\tchar %s(){\r\n\t\t\treturn %s[%s++];\r\n\t\t}\r\n      |} (getCharFun) (arrayVar) (currentIndexVar)\r\n    \r\n    \r\n    method matchFunction =\r\n      Printf.sprintf {|\r\n\t\tvoid %s(char t) {\r\n\t\t\tif(%s == t) {\r\n\t\t\t\t%s = %s();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t%s();\r\n\t\t\t}\r\n\t\t}\r\n      |} (matchCharFun) (currentCharVar) (currentCharVar) (getCharFun) (parseErrorFun)\r\n    \r\n    \r\n    method errorFunction = \r\n      Printf.sprintf {|\r\n\t\tvoid %s() {\r\n\t\t\tprintf(\"Error parsing! %s = %%c\\n\", %s);\r\n\t\t\texit(1);\r\n\t\t}\r\n      |} (parseErrorFun) (currentCharVar) (currentCharVar)\r\n    \r\n      \r\n    method mainFunction initialVar = \r\n      Printf.sprintf {|\r\n\t\tint main(int argc, char* argv[]){\r\n\t\t  char termChar = '$'; \r\n\t\t  char* tmp = strcat( argv[1], &termChar);\r\n\t\t\t%s = tmp;\r\n\t\t\t%s = %s();\r\n\t\t\t%s();\r\n\t\t\tif(%s == '$'){\r\n\t\t\t\tprintf(\"Parsing OK!\\n\");\r\n\t\t\t} else {\r\n\t\t\t\t%s();\r\n\t\t\t}\r\n\t\t\treturn 0;\r\n\t\t}\r\n    |} (arrayVar) (currentCharVar) (getCharFun) (symb2str initialVar) (currentCharVar) (parseErrorFun)\r\n    \r\n\r\n    method createFun name contents =\r\n      Printf.sprintf {|\r\n        void %s() {\r\n        %s\r\n        }\r\n      |} name contents\r\n\r\n  end\r\nend\r\n\r\n\r\nmodule RDParserOCaml =\r\nstruct\r\n\r\n\tlet tabCreator = RDParser.tabCreator\r\n\r\n  class parser =\r\n    object(self) inherit RDParserNeedRecursiveFunDeclaration.parser as super\r\n\r\n    val equality = \"=\"\r\n    val orOp = \"||\"\r\n    val functionArgsOpen = \"(\"\r\n    val functionArgsClose = \")\"\r\n    val ifOpen = \"(\"\r\n    val ifClose = \")\"\r\n    val ifElseGuardOpen = \"(\"\r\n    val ifElseGuardClose = \")\"\r\n    val expressionTermination = \";\"\r\n    val return = \"()\"\r\n    \r\n    method setupIncludes = \"\"\r\n\r\n\r\n    method setupVariables = \r\n      Printf.sprintf {|\r\n        let %s = ref [||]\r\n        let %s = ref 'l'\r\n        let %s = ref 0\r\n      |} arrayVar currentCharVar currentIndexVar\r\n      \r\n    \r\n    method getCharFunction = \r\n      Printf.sprintf {|\r\n        let %s() =\r\n          if ( !%s < (Array.length !%s) - 1 )\r\n          then %s := !%s + 1;\r\n          %s := !%s.(!%s)\r\n              |} (getCharFun)\r\n                (currentIndexVar) (arrayVar)\r\n                (currentIndexVar) (currentIndexVar)\r\n                currentCharVar (arrayVar) (currentIndexVar)\r\n        \r\n        \r\n    method createFunCalls funs (rep: t) =\r\n      match funs with\r\n      | [] -> []\r\n      | x::xs when Set.belongs x rep.alphabet -> [matchCharFun ^ functionArgsOpen ^ \"\\'\" ^ (symb2str x) ^ \"\\'\" ^ functionArgsClose ^ expressionTermination] @ self#createFunCalls xs rep\r\n      | x::xs when Set.belongs x rep.variables -> [String.lowercase_ascii (symb2str x) ^ functionArgsOpen ^ functionArgsClose ^ expressionTermination] @ self#createFunCalls xs rep\r\n      | x::xs -> []\r\n\r\n\r\n    method matchFunction = \r\n      Printf.sprintf {|\r\n\t\tlet %s t =\r\n\t\t\tif (!%s = t)\r\n\t\t\tthen (%s())\r\n\t\t\telse (%s())\r\n      |} matchCharFun currentCharVar getCharFun parseErrorFun\r\n\r\n      \r\n    method errorFunction = \r\n      Printf.sprintf {|\r\n\t\tlet %s() =\r\n\t\t\tPrintf.printf \"Error parsing! %s = %%c\\n\" !%s;\r\n\t\t\texit 1\r\n      |} parseErrorFun currentCharVar currentCharVar\r\n\r\n\r\n    method createIfConds conditions =\r\n      let p = String.make 1 '\\'' in\r\n      match conditions with\r\n      | [] -> \"\"\r\n      | [x] -> \"!\" ^ currentCharVar ^ equality ^ p ^ symb2str x ^ p\r\n      | x::xs -> \"!\" ^ currentCharVar ^ equality ^ p ^ symb2str x ^ p ^ \" \" ^ orOp ^ \" \" ^ self#createIfConds xs\r\n      \r\n\r\n    method createIf ifList tabLevel = \r\n      let rec createIf2 first ifList tabLevel =\r\n        let rec createExpr exprList tabLevel =\r\n          match exprList with \r\n          | [] -> \"\"\r\n          | x::xs -> (tabCreator tabLevel) ^ x ^ \"\\n\" ^ createExpr xs tabLevel\r\n        in\r\n        let tab = (tabCreator tabLevel) in\r\n        match ifList with\r\n        | [] -> \"\"\r\n        | [(c,e)] -> tab ^ \"else\" ^ ifElseGuardOpen ^ \"\\n\" ^ (createExpr e (tabLevel+1)) ^ tab ^ ifElseGuardClose\r\n        | (c,e)::xs -> tab ^ (if first then \"if\" else \"else if\") ^ ifOpen ^ c ^ ifClose ^ \" then \" ^ ifElseGuardOpen ^ \"\\n\" ^ \r\n                       (createExpr e (tabLevel+1)) ^\r\n                       tab ^ (ifElseGuardClose) ^ \"\\n\" ^ createIf2 false xs tabLevel\r\n      in\r\n      createIf2 true ifList tabLevel\r\n    \r\n    \r\n    method mainFunction i = \r\n      Printf.sprintf {|\r\n\t\tlet explode s = List.init (String.length s) (String.get s)\r\n\r\n\t\tlet main () =\r\n\t\t\t%s := Array.of_list (explode Sys.argv.(1));\r\n\t\t\t%s := Array.append (!%s) ([|'$'|]);\r\n\t\t\t%s := !%s.(0);\r\n\t\t\t%s();\r\n\t\t\tif !%s = '$'\r\n\t\t\tthen Printf.printf \"Parsing OK!\"\r\n\t\t\telse %s();\r\n\t\t\texit 0\r\n\r\n\t\tlet _ = main()\r\n\t  |} arrayVar arrayVar arrayVar\r\n                  currentCharVar arrayVar\r\n                  (String.lowercase_ascii (symb2str i))\r\n                  currentCharVar\r\n                  parseErrorFun\r\n\r\n    method createFun name contents =\r\n      (* Does not need let, inherited class deals with it *)\r\n      Printf.sprintf {|\r\n\t\t%s () =\r\n\t\t\t%s\r\n      |} (String.lowercase_ascii name) contents\r\n\r\n  end\r\nend\r\n\r\nmodule RDParserJava =\r\nstruct\r\n\r\n  class parser =\r\n    object(self) inherit RDParserWithoutDeclarations.parser as super\r\n\r\n    val equality = \"==\"\r\n    val orOp = \"||\"\r\n    val functionArgsOpen = \"(\"\r\n    val functionArgsClose = \")\"\r\n    val ifOpen = \"(\"\r\n    val ifClose = \")\"\r\n    val ifElseGuardOpen = \"{\"\r\n    val ifElseGuardClose = \"}\"\r\n    val expressionTermination = \";\"\r\n    val return = \"return\"\r\n\r\n    method setupIncludes = \"\"\r\n    \r\n    method setupVariables =\r\n  \t  Printf.sprintf {|\r\n\t\tstatic char[] %s;\r\n\t\tstatic char %s;\r\n\t\tstatic int %s;\r\n      |} arrayVar currentCharVar currentIndexVar\r\n \r\n\r\n    method getCharFunction =\r\n      Printf.sprintf {|\r\n\t\tstatic char %s() {\r\n\t\t\treturn %s[%s++];\r\n\t\t}\r\n      |} (getCharFun) (arrayVar) (currentIndexVar)\r\n    \r\n    method matchFunction =\r\n      Printf.sprintf {|\r\n\t\tstatic void %s(char t) {\r\n\t\t\tif(%s == t)\r\n\t\t\t\t%s = %s();\r\n\t\t\telse %s();\r\n\t\t}\r\n      |} (matchCharFun) (currentCharVar) (currentCharVar) (getCharFun) (parseErrorFun)\r\n    \r\n    \r\n    method errorFunction = \r\n      Printf.sprintf {|\r\n\t\tstatic void %s() {\r\n\t\t\tSystem.out.println(\"Error parsing! %s = \" + %s);\r\n\t\t\tSystem.exit(1);\r\n\t\t}\r\n      |} (parseErrorFun) (currentCharVar) (currentCharVar)\r\n\r\n\r\n    method mainFunction initialVar = \r\n      Printf.sprintf {|\r\n\t\tpublic static void main(String[] args) {\r\n\t\t\t%s = 0;\r\n\t\t\t%s = (args[0].toString()+'$').toCharArray(); //Add terminal symbol\r\n\t\t\t%s = %s();\r\n\t\t\t%s();\r\n\t\t\tif(%s == '$')\r\n\t\t\t\tSystem.out.println(\"Parsing OK!\");\r\n\t\t\telse %s();\r\n\t\t}\r\n    |} currentIndexVar arrayVar (currentCharVar) (getCharFun) (symb2str initialVar) (currentCharVar) (parseErrorFun)\r\n\r\n\r\n    method createFun name contents =\r\n      Printf.sprintf {|\r\n\t\tstatic void %s () {\r\n\t\t\t%s\r\n\t\t}\r\n      |} name contents\r\n\r\n\tmethod build (rep: t) =\r\n\t\t\"public class Main {\" ^\r\n\t\t\tsuper#build rep ^\r\n\t\t\"}\"\r\n\r\n  end\r\nend\r\n\r\n\r\n# 3 \"src/ContextFreeGrammarLL1.ml\"\r\nopen BasicTypes\r\nopen ContextFreeGrammarBasic  \r\n\r\nmodule ContextFreeGrammarLL1 =\r\nstruct\r\n  open RDParserC\r\n  open RDParserOCaml\r\n  open RDParserJava\r\n   \r\n  type syntaxTable = { term : symbol option; var : symbol option; rBody : word option }\r\n  type acceptTable = { input : string; stack: string; production: string }\r\n  type recognized = { recog : string; left : string }\r\n\ttype acceptStep = {\r\n    syntaxTable : syntaxTable;\r\n    acceptedString: string;\r\n    acceptTable : acceptTable;\r\n    recognized : recognized;\r\n    accepted: bool option;\r\n    nodes: cfgTree list\r\n  }\r\n  \r\n  let bodiesOfHead = RDParser.bodiesOfHead\r\n  \r\n  let leftRecursionRemovalTransform = \"Remove left recursion\"\r\n  let leftFactoringTransform = \"Left factoring\"\r\n  let cleanProductiveTransform = \"Clean unproductive symbols\"\r\n  let cleanAccessibleTransform = \"Clean inaccessible symbols\"\r\n  let unitRemovalTransform = \"Unit productions removal\"\r\n  let epsilonRemovalTransform = \"Epsilon productions removal\"\r\n  let ll1Transform = \"LL1 transformation\"\r\n  \r\n  type transformation = { tType : string; grammar : ContextFreeGrammarBasic.model }\r\n  \r\n  let newStep ?(term = None) ?(var = None) ?(rBody = None)\r\n              ?(acceptedString = \"\") \r\n              ?(input = \"\") ?(stack = \"\") ?(production = \"\") \r\n              ?(recog = \"\") ?(left = \"\") \r\n              ?(accepted = None) ?(nodes = []) simple =\r\n    (* let dollar = String.make 1 dollar in\r\n    let input = if simple then input else input ^ dollar in\r\n    let stack = if simple then stack else stack ^ dollar in *)\r\n    {\r\n      syntaxTable = {term; var; rBody};\r\n      acceptedString = acceptedString;\r\n      acceptTable = {input; stack; production};\r\n      recognized = {recog; left};\r\n      accepted = accepted;\r\n      nodes = nodes\r\n    }\r\n    \r\n  \r\n  (*type rule = CFGSyntax.rule*)\r\n  \r\n\r\n  let rec doWordGenerateEmptyX w seen (rep:t) =\r\n    let doGenerateEmpty x =\r\n      if List.mem x seen\r\n      then false\r\n      else(\r\n\t\t    let bodies = bodiesOfHead x rep.rules in\r\n\t\t    Set.exists (fun b -> doWordGenerateEmptyX b (x::seen) rep) bodies \r\n\t\t  )\r\n\t\tin      \r\n      List.for_all doGenerateEmpty w\r\n\r\n  let removeEpsilonFromWord w =\r\n    List.filter (fun c -> c <> epsilon) w\r\n\r\n  let removeDollarFromWord w =\r\n    List.filter (fun c -> c <> dollar) w\r\n\r\n  let doWordGenerateEmpty w (rep:t) =\r\n    doWordGenerateEmptyX (removeDollarFromWord w) [] rep\r\n    \r\n  let printRepresentation (rep:t) =\r\n    Printf.printf \"Alphabet = \"; Util.printAlphabet rep.alphabet;\r\n    Printf.printf \"Variables = \"; Util.printAlphabet rep.variables;\r\n    Printf.printf \"Initial = %s\\n\" (symb2str rep.initial);\r\n    Printf.printf \"Rules {\\n\"; Set.iter (fun {head=h; body=b} -> Printf.printf \"\\t%s -> %s\\n\" (symb2str h) (word2str b)) rep.rules;\r\n    Printf.printf \"}\\n\\n\"\r\n\r\n  let rec print_tuples = (*TEST*)\r\n    function\r\n    | [] -> ()\r\n    | (a, b) :: rest ->\r\n      Printf.printf \"%c -> \" a;\r\n      Util.printAlphabet b;\r\n      print_tuples rest\r\n      \r\n  let rec print_list = (*TEST*)\r\n    function\r\n    | [] -> Printf.printf \"\";\r\n    | x::xs ->\r\n      Printf.printf \"%c\" x;\r\n      print_list xs  \r\n  \r\n  (*Given a variable, returns all rules with variable as head*)\r\n  let sameHeadRules (testSymbol:symbol) (rep:t) =\r\n\t  Set.toList (Set.filter (fun r -> testSymbol = r.head) rep.rules)\r\n\r\n  let rec pairs l =\r\n    match l with\r\n      | [] -> []\r\n      | x::xs -> List.map (fun v -> (x,v)) xs :: pairs xs\r\n\r\n  (*Given a word and variable, returns the word behind the variable*)\r\n  let rec behindSymbol (word:word) (var:variable) = \r\n    match word with\r\n    | [] -> []\r\n    | x::xs -> if x <> var then x::behindSymbol xs var else []\r\n\r\n\r\n  let rec leftRecursionTest initial (seen: variables) (rep:t) =\r\n    if Set.belongs initial rep.alphabet then false else (*rule starting with a terminal symbol can't be left recursive*)\r\n      let ruleBodies = Set.toList (bodiesOfHead initial rep.rules) in (* example: rulesBodies = [['B';'a']; ['b']*)\r\n(*        Printf.printf \"initial = %c\\n\" initial;*)\r\n      let leftRecursionTest2 head body seen (rep:t) =\r\n        let wordBehind = behindSymbol body head in\r\n        let behindGenerateEmpty = doWordGenerateEmpty wordBehind rep in\r\n        let body = if behindGenerateEmpty \r\n                     then List.filter (fun x -> not (List.mem x wordBehind)) body \r\n                     else body\r\n        in\r\n        \r\n        match body with\r\n        | [] -> false\r\n        | x::xs when x = head || Set.belongs x seen -> true\r\n        | x::xs -> leftRecursionTest x (Set.cons x seen) rep in\r\n        \r\n      List.exists (fun x -> x = true) (List.map (fun x -> leftRecursionTest2 initial x seen rep) ruleBodies)\r\n\r\n      \r\n  let isLeftRecursive (rep:t) = \r\n    Set.exists (fun x -> x = true) (Set.map (fun v -> leftRecursionTest v Set.empty rep) rep.variables)\r\n\r\n  let isLL1Deterministic simple (rep:t) =\r\n    let variables = rep.variables in\r\n    let pairsSet = Set.map (fun v -> Set.make (List.flatten (pairs (sameHeadRules v rep)))) variables in\r\n    let lookaheadInterSet = Set.flatMap (fun v -> Set.map (fun (p1,p2) -> Set.inter (lookahead p1 simple rep) (lookahead p2 simple rep)) v) pairsSet in\r\n      Set.for_all (fun x -> Set.size x = 0) lookaheadInterSet\r\n\r\n  let isLL1 simple (rep:t) = \r\n    isLL1Deterministic simple rep\r\n  \r\n  (*given a production X->a, does lookahead(X->a), b, and returns pair ((X,b),a)*)\r\n  let lookahead2Tuple rule simple (rep:t) =\r\n    let lookahead = lookahead rule simple rep in \r\n      Set.map (fun l -> ((rule.head, l), rule.body)) lookahead\r\n  \r\n  let createParsingTable simple (rep:t) = \r\n    let lookaheadSet = Set.flatMap (fun r -> lookahead2Tuple r simple rep) rep.rules in\r\n      lookaheadSet\r\n  \r\n  let hasParsingTableConflict simple (rep:t) =\r\n    let parsingTable = createParsingTable simple rep in\r\n    let repeatsTbl = Hashtbl.create (Set.size parsingTable) in\r\n    let getRepeatNum c repeatsTbl =\r\n      let repeat = Hashtbl.find_opt repeatsTbl c in\r\n      match repeat with\r\n      | None -> Hashtbl.add repeatsTbl c 1; false\r\n      | Some a -> true\r\n    in\r\n    let boolResults = Set.map (fun ( (v,t), _ ) -> getRepeatNum (v,t) repeatsTbl ) parsingTable in\r\n    Set.exists (fun r -> r) boolResults\r\n    \r\n  \r\n  (*accept*)\r\n  \r\n(*  let printParsingInfo entry stack sub isSub =*)\r\n(*    Printf.printf \"\\t\"; print_list entry;*)\r\n(*    Printf.printf \"\\t\"; print_list stack;*)\r\n(*    if isSub*)\r\n(*      then (Printf.printf \"\\t%c->\" (List.nth stack 0); print_list sub;)*)\r\n(*      else Printf.printf \"\\t\";*)\r\n(*    Printf.printf \"\\n\"*)\r\n(*  *)\r\n(*  (*given the entry, stack and parsingTable, rewrites the leftmost*)*)\r\n(*  (*variable on the stack with its respective parsingTable rule*)*)\r\n(*  let ruleRewrite (entry:word) (stack:word) parsingTable =*)\r\n(*    let entryChar = List.nth entry 0 in*)\r\n(*    let stackChar = List.nth stack 0 in*)\r\n(*    let parsingTableList = Set.toList parsingTable in*)\r\n(*    let substitution = List.assoc (stackChar, entryChar) parsingTableList in*)\r\n(*      match stack with*)\r\n(*      | [] -> []*)\r\n(*      | x::xs ->*)\r\n(*                printParsingInfo entry stack substitution true;*)\r\n(*                substitution@xs*)\r\n(*  *)\r\n(*  let rec acceptX entry stack parsingTable (rep:t) =*)\r\n(*    match entry with*)\r\n(*    | [] -> if doWordGenerateEmpty stack rep then true else false*)\r\n(*    | x::xs -> match stack with*)\r\n(*                | [] -> false*)\r\n(*                | x2::xs2 -> if Set.belongs x2 rep.variables*)\r\n(*                             then*)\r\n(*                                let newStack = ruleRewrite entry stack parsingTable in*)\r\n(*                                acceptX entry newStack parsingTable rep*)\r\n(*                             else if x=x2 *)\r\n(*                                  then (printParsingInfo entry stack [] false;*)\r\n(*                                       acceptX xs xs2 parsingTable rep )*)\r\n(*                                  else false*)\r\n(*  *)\r\n(*  let acceptZ word rep = *)\r\n(*    Printf.printf \"\\t\"; Printf.printf \"Entry: \";*)\r\n(*    Printf.printf \"\\t\"; Printf.printf \"Stack: \";*)\r\n(*    Printf.printf \"\\t\"; Printf.printf \"Rule: \\n\";*)\r\n(*    let parsingTable = createParsingTable rep in*)\r\n(*      try (acceptX word [rep.initial] parsingTable rep) *)\r\n(*        with Not_found -> Printf.printf \"\\t\\t\\tApplicable rule not found!\\n\"; false*)\r\n\r\n  let word2tree w (rep:t) =\r\n    let rec word2tree2 w =\r\n    match w with\r\n    | [] -> []\r\n    | x::xs -> (if Set.belongs x rep.alphabet\r\n                then Leaf x\r\n                else Root(x,[]))\r\n                :: word2tree2 xs\r\n    in\r\n    \r\n    if List.length w = 0\r\n    then [Leaf epsilon]\r\n    else word2tree2 w\r\n\r\n  let rec acceptX entry stack parsingTable (currPerm:symbol list) simple (rep:t) =\r\n    match entry with\r\n    | [] -> [] (*Not supposed to happen*)\r\n    | x::xs when x = dollar ->\r\n          (match stack with\r\n          | [] -> [] (*Not supposed to happen*)\r\n          | x::xs -> if doWordGenerateEmpty [x] rep\r\n                      then\r\n                        (\r\n                          if x = dollar\r\n                          then [newStep ~acceptedString:(word2str currPerm)\r\n                               ~input:(word2str entry)\r\n                               ~stack:(word2str stack)\r\n                               ~recog:(word2str (currPerm))\r\n                               ~accepted:(Some true)\r\n                                simple]\r\n                          else (newStep ~var:(Some (List.hd stack))\r\n                              ~term:(Some dollar)\r\n                              ~rBody:(Some [])\r\n                              ~acceptedString:(word2str currPerm)\r\n                              ~input:(word2str entry)\r\n                              ~stack:(word2str stack) \r\n                              ~production:(symb2str (List.hd stack) ^ \" -> \" ^ \"\") \r\n                              ~recog:(word2str currPerm)\r\n                              ~nodes:(word2tree [] rep)\r\n                              simple) :: acceptX entry xs parsingTable currPerm simple rep\r\n                        )\r\n                      else [newStep ~var:(Some (List.hd stack))\r\n                      ~term:(Some dollar)\r\n                      ~rBody:(Some [])\r\n                      ~acceptedString:(word2str currPerm) \r\n                      ~input:(word2str entry)\r\n                      ~stack:(word2str stack)\r\n                      ~recog:(word2str currPerm) ~left:(word2str (removeDollarFromWord stack))\r\n                      ~accepted:(Some false)\r\n                      simple]\r\n             )\r\n    | x::xs -> match stack with\r\n                | [] -> [] (*Not supposed to happen*)\r\n                | [epsilon] -> [newStep ~acceptedString:(word2str currPerm)\r\n                                ~input:(word2str entry)\r\n                                ~stack:(word2str stack)\r\n                                ~recog:(word2str currPerm) ~left:(word2str (removeDollarFromWord stack))\r\n                                ~accepted:(Some false)\r\n                                simple]\r\n                | x2::xs2 -> if Set.belongs x2 rep.variables\r\n                             then\r\n                                let entryChar = List.nth entry 0 in\r\n                                let stackChar = List.nth stack 0 in\r\n                                let parsingTableList = Set.toList parsingTable in\r\n                                let substitution = List.assoc_opt (stackChar, entryChar) parsingTableList in\r\n                                match substitution with\r\n                                  | None -> [newStep ~term:(Some entryChar) ~var:(Some stackChar)\r\n                                                     ~acceptedString:(word2str currPerm)\r\n                                                     ~input:(word2str entry) ~stack:(word2str stack)\r\n                                                     ~recog:(word2str currPerm) ~left:(word2str (removeDollarFromWord stack))\r\n                                                     ~accepted:(Some false)\r\n                                                     simple]\r\n                                  | Some s -> let newStack = \r\n                                                match stack with\r\n                                                | [] -> []\r\n                                                | x::xs -> s@xs \r\n                                              in\r\n                                              (newStep ~term:(Some entryChar) ~var:(Some stackChar) ~rBody:(Some s)\r\n                                                       ~acceptedString:(word2str currPerm)\r\n                                                       ~input:(word2str entry) ~stack:(word2str stack) ~production:(symb2str (List.nth stack 0) ^ \" -> \" ^ word2str s)\r\n                                                       ~recog:(word2str currPerm) ~left:(word2str (removeDollarFromWord stack))\r\n                                                       ~nodes:(word2tree s rep)\r\n                                                       simple) :: acceptX entry newStack parsingTable currPerm simple rep\r\n                              else if x=x2 \r\n                                  then\r\n                                    let newCurrPerm = currPerm @ [x] in\r\n                                    (newStep ~acceptedString:(word2str newCurrPerm)\r\n                                             ~input:(word2str entry) ~stack:(word2str stack)\r\n                                             ~recog:(word2str newCurrPerm) ~left:(word2str (List.tl (removeDollarFromWord stack)))\r\n                                             simple) :: acceptX xs xs2 parsingTable newCurrPerm simple rep \r\n                                  else [newStep ~acceptedString:(word2str currPerm)\r\n                                                ~input:(word2str entry) ~stack:(word2str stack) \r\n                                                ~recog:(word2str currPerm) ~left:(word2str (removeDollarFromWord stack))\r\n                                                ~accepted:(Some false)\r\n                                                simple]\r\n  \r\n  let acceptZ word simple (rep:t) = \r\n    let word = word @ [dollar] in\r\n    let initial = [rep.initial] @ [dollar] in\r\n    let parsingTable = createParsingTable simple rep in\r\n      (newStep ~input:(word2str word) ~stack:(word2str initial) ~nodes:[Root(rep.initial,[])] simple)\r\n      ::acceptX word initial parsingTable [] simple rep\r\n\r\n  let rec acumFixedPoint (f: 'a set -> 'a set) (x: 'a set): 'a set =\r\n    let next = Set.union x (f x) in\r\n      if x = next then x\r\n      else acumFixedPoint f next\r\n  \r\n  (*productive symbols*)\r\n  \r\n  (*given a rule and a set of productive variables, verifies if given*)\r\n  (*rule is productive*)\r\n  let isRuleProductive r prodVars (rep:t) =\r\n(*    Printf.printf \"\\t\\t\\tisRuleProductive - Prod = %s   prodVars = %s\\n\" (word2str r) (word2str (Set.toList prodVars));*)\r\n    List.for_all (fun c -> Set.belongs c rep.alphabet || Set.belongs c prodVars) r\r\n      \r\n  (*given a variable and a set of productive variables, verifies if given *)\r\n  (*variable is productive*)\r\n  let isSymbolProductive h prodVars (rep:t) =\r\n    let rules = bodiesOfHead h rep.rules in\r\n      Set.exists (fun r -> \r\n(*                          Printf.printf \"\\t\\tProduction = %c -> %s\\n\" h (word2str r);*)\r\n                          isRuleProductive r prodVars rep\r\n                  ) rules\r\n      \r\n        \r\n  let productiveSymbolsFP (rep:t) varP =\r\n    Set.filter (fun v -> (*Printf.printf \"\\tVar %c\\n\" v;*) isSymbolProductive v varP rep) (Set.diff rep.variables varP)\r\n  \r\n  (*show the productive symbols of the current grammar*)\r\n  let productiveSymbols (rep:t) =\r\n    acumFixedPoint (productiveSymbolsFP rep) Set.empty\r\n  \r\n  (*show the simplified grammar with only productive symbols*)\r\n  (*TODO Confirm correct new model*)\r\n  let productiveGrammarRewrite (rep:t) =\r\n    let prodSyms = productiveSymbols rep in\r\n(*    Printf.printf \"Productive Symbols:\\n\";*)\r\n(*    Set.iter (fun s -> Printf.printf \"\\t%c\\n\" s) prodSyms;*)\r\n(*    Printf.printf \"\\n\";*)\r\n    let unprodSyms = Set.diff rep.variables prodSyms in\r\n(*    Printf.printf \"Unproductive Symbols:\\n\";*)\r\n(*    Set.iter (fun s -> Printf.printf \"\\t%c\\n\" s) unprodSyms;*)\r\n(*    Printf.printf \"\\n\";*)\r\n    let newRules = Set.filter (fun r -> Set.belongs r.head prodSyms && List.for_all (fun c -> not (Set.belongs c unprodSyms)) r.body) rep.rules in\r\n(*    Printf.printf \"New productions:\\n\";*)\r\n(*    Set.iter (fun {head=h;body=b} -> Printf.printf \"\\t%c -> %s\\n\" h (word2str b)) newRules;*)\r\n      new ContextFreeGrammarBasic.model (Arg.Representation {\r\n\t\t\t\t\t\t\t\talphabet = rep.alphabet; (*TODO Get productive alphabet*)\r\n\t\t\t\t\t\t\t\tvariables = prodSyms;\r\n\t\t\t\t\t\t\t\tinitial = rep.initial;\r\n\t\t\t\t\t\t\t\trules = newRules\r\n\t\t\t\t\t\t} )\r\n\r\n  \r\n  (*accessible symbols*)\r\n  \r\n  (*given a rule and a set of accessible symbols, adds all symbols from the*)\r\n  (*rule to the set*)\r\n  let ruleAccessibleSymbols r aSymbols =\r\n    Set.flatten (Set.make (List.map (fun s -> Set.cons s aSymbols) r))\r\n\r\n  let rulesAccessibleSymbols h aSymbols (rep:t) =\r\n    let rules = bodiesOfHead h rep.rules in\r\n      Set.flatMap (fun r -> ruleAccessibleSymbols r aSymbols) rules\r\n  \r\n  let accessibleSymbolsX (rep:t) aSymbols =\r\n    let vars = Set.filter (fun v -> Set.belongs v rep.variables) aSymbols in (*Remove terminals*)\r\n      Set.flatMap (fun v -> rulesAccessibleSymbols v aSymbols rep) vars\r\n  \r\n  (*show the accessible symbols of the current grammar*)\r\n  let accessibleSymbols (rep:t) = \r\n    Util.fixedPoint (accessibleSymbolsX rep) (Set.make [rep.initial])\r\n  \r\n  (*TODO Confirm correct new model*)\r\n  let accessibleGrammarRewrite (rep:t) =\r\n    let accessSymbs = accessibleSymbols rep in\r\n    let accessTerms = Set.filter (fun s -> Set.belongs s rep.alphabet) accessSymbs in\r\n    let accessVars = Set.filter (fun s -> Set.belongs s rep.variables) accessSymbs in\r\n    let rules = Set.filter (fun r -> Set.belongs r.head accessVars) rep.rules in\r\n      new ContextFreeGrammarBasic.model (Arg.Representation {\r\n\t\t\t\t\t\t\t\talphabet = accessTerms;\r\n\t\t\t\t\t\t\t\tvariables = accessVars;\r\n\t\t\t\t\t\t\t\tinitial = rep.initial;\r\n\t\t\t\t\t\t\t\trules = rules\r\n\t\t\t\t\t\t} )\r\n\r\n  let clean (rep:t) =\r\n    let prodRewrite = {tType = cleanProductiveTransform; grammar = productiveGrammarRewrite rep} in\r\n    let accessRewrite = {tType = cleanAccessibleTransform; grammar = accessibleGrammarRewrite prodRewrite.grammar#representation} in\r\n    [prodRewrite; accessRewrite]\r\n(*    accessibleGrammarRewrite (productiveGrammarRewrite rep)#representation*)\r\n\r\n  let isCFGFullyProductive (rep:t) =\r\n    Set.equals (productiveSymbols rep) (rep.variables)\r\n\r\n  let isCFGFullyAccessible (rep:t) =\r\n    Set.equals (accessibleSymbols rep) (Set.union rep.variables rep.alphabet)\r\n    \r\n  let isClean (rep:t) =\r\n    isCFGFullyProductive rep && isCFGFullyAccessible rep\r\n  \r\n  let getNewVar vs =\r\n    let chars = Set.make ['A'; 'B'; 'C'; 'D'; 'E'; 'F'; 'G'; 'H'; 'I'; 'J'; 'K'; 'L'; 'M'; 'N'; 'O'; 'P'; 'Q'; 'R'; 'S'; 'T'; 'U'; 'V'; 'W'; 'X'; 'Y'; 'Z'] in\r\n    let symbs = Set.map char2symb chars in\r\n    let acceptableVars = Set.diff symbs vs in\r\n      Set.nth acceptableVars 0\r\n\r\n\r\n  let rec leftCorner2 symbol seen (rep: t) =\r\n    match symbol with\r\n    | [] -> Set.empty\r\n    | x::xs ->\r\n      if Set.belongs x seen \r\n      then Set.make [x]\r\n      else \r\n        if Set.belongs x rep.alphabet\r\n        then Set.make [x]\r\n        else Set.union \r\n              (Set.make [x])\r\n              (Set.flatMap (fun b -> (leftCorner2 b (Set.cons x seen) rep)) (bodiesOfHead x rep.rules))\r\n\r\n  let leftCorner symbol rep =\r\n    leftCorner2 [symbol] Set.empty rep\r\n\r\n    \r\n  (*left recursion removal*)\r\n\r\n  let sortLeftCorner l =\r\n    let sortFun e1 e2 =\r\n      let (_, e1) = e1 in\r\n      let (_, e2) = e2 in\r\n      if List.length e1 > List.length e2 then -1\r\n      else (if List.length e1 < List.length e2 then 1 else 0)\r\n    in\r\n    List.sort sortFun l\r\n\r\n  let addToMap map varL =\r\n    let rec addToMap2 map varL value =\r\n      match varL with\r\n      | [] -> ()\r\n      | x::xs -> (*Printf.printf \"Adding var %c with value %d\\n\" x value;*)\r\n                  Hashtbl.add map x value; addToMap2 map xs (value+1)\r\n    in\r\n    addToMap2 map varL 0\r\n\r\n(* TODO Util.printWord does not exist anymore *)\r\n(*  let rec print_rules r =*)\r\n(*    match r with*)\r\n(*    | [] -> Printf.printf \"\\n\"*)\r\n(*    | x::xs -> Printf.printf \" - %c ->\" x.head; Util.printWord x.body; print_rules xs*)\r\n\r\n\r\n  let removeDirectLeftRecursion (rep:t) = \r\n    let hasRuleDirectLeftRecursion r =\r\n      match r.body with\r\n      | [] -> false\r\n      | x::xs when x = r.head -> true\r\n      | x::xs -> false\r\n    in\r\n    \r\n    let recursiveRuleRewrite r nV =\r\n      let body =\r\n        match r.body with\r\n        | [] -> [epsilon] (*Not reacheable*)\r\n        | x::xs -> xs@[nV]\r\n      in\r\n      { head = nV; body = body }\r\n    in\r\n      \r\n    let nRecursiveRuleRewrite r nV =\r\n      let body = r.body@[nV] in\r\n        { head = r.head; body = body }\r\n    in\r\n    \r\n    let rec removeDLRFromVar v drs ndrs nV =\r\n      if v = Set.empty then Set.empty\r\n      else let (x,xs) = Set.cut v in\r\n(*        Printf.printf \"\\tRemoving direct left recursion from variable %c\\n\" x;*)\r\n        let recursiveRs = Set.filter (fun r -> r.head = x) drs in\r\n        let nRecursiveRs = Set.filter (fun r -> r.head = x) ndrs in\r\n        let newVar = getNewVar nV in\r\n(*        Printf.printf \"\\tNew variable is %c\\n\" newVar;*)\r\n        let recRulesRewriteTmp = Set.map (fun r -> recursiveRuleRewrite r newVar) recursiveRs in\r\n        let recRulesRewrite = Set.cons ( {head = newVar; body = []} ) recRulesRewriteTmp in\r\n        let nRecRulesRewrite = Set.map (fun r -> nRecursiveRuleRewrite r newVar) nRecursiveRs in\r\n        let newRules = Set.union recRulesRewrite nRecRulesRewrite in\r\n(*        print_rules (Set.toList newRules);*)\r\n          Set.union newRules (removeDLRFromVar xs drs ndrs (Set.cons newVar nV))\r\n    in\r\n    \r\n    let leftRecursiveRules = Set.filter (fun r -> hasRuleDirectLeftRecursion r) rep.rules in\r\n(*        print_rules (Set.toList leftRecursiveRules);*)\r\n    let leftRecursiveVars = Set.map (fun r -> r.head) leftRecursiveRules in\r\n    let nonLeftRecursiveRules = Set.diff rep.rules leftRecursiveRules in\r\n(*        print_rules (Set.toList nonLeftRecursiveRules);*)\r\n    let nonLeftRecursiveRulesClean = Set.filter (fun {head = h; body = _} -> not (Set.belongs h leftRecursiveVars)) nonLeftRecursiveRules in\r\n    let newRules = Set.union nonLeftRecursiveRulesClean (removeDLRFromVar leftRecursiveVars leftRecursiveRules nonLeftRecursiveRules rep.variables) in\r\n(*      print_rules (Set.toList newRules);*)\r\n    let newVars = Set.union rep.variables (Set.map (fun r -> r.head) newRules) in\r\n      new ContextFreeGrammarBasic.model (Arg.Representation {\r\n\t\t    alphabet = rep.alphabet;\r\n\t\t    variables = newVars;\r\n\t\t\t  initial = rep.initial;\r\n\t\t\t  rules = newRules\r\n\t\t  } )\r\n\r\n\r\n  let rec removeIndirectLeftRecursion map varL (rep:t) = \r\n    match varL with\r\n    | [] -> new ContextFreeGrammarBasic.model (Arg.Representation {\r\n\t\t          alphabet = rep.alphabet;\r\n\t\t          variables = rep.variables;\r\n\t\t\t        initial = rep.initial;\r\n\t\t\t        rules = rep.rules\r\n\t\t        } )\r\n    | var::xs -> \r\n      let perVarIndirectRemoval map var (rep:t) =\r\n        let perVarProdIndirectRemoval prodHead iVal prodBody rhsValues (rep:t) =\r\n          let results = Set.flatMap (\r\n            fun (jVal, rhsBody) ->\r\n              match jVal with\r\n              | None -> Set.make [{head = prodHead; body = rhsBody}]\r\n              | Some jVal -> \r\n                if iVal > jVal\r\n                then (\r\n                  let rhsVar = (List.hd rhsBody) in\r\n                  let rhsVarBodies = bodiesOfHead rhsVar rep.rules in\r\n                  let replaceRules = Set.flatMap (fun rhsBody ->\r\n                    if List.length prodBody >= 1\r\n                    then (\r\n                      if List.hd prodBody = rhsVar\r\n                      then Set.make [{head = prodHead; body = rhsBody@(if List.length prodBody >= 1 then List.tl prodBody else prodBody)}]\r\n                      else Set.make []\r\n                    )\r\n                    else Set.make [] \r\n                  ) rhsVarBodies \r\n                  in\r\n                  replaceRules\r\n                )\r\n                else  Set.make [{head = prodHead; body = rhsBody}]\r\n          ) rhsValues in\r\n          results\r\n        in\r\n        let iVal = Hashtbl.find_opt map var in\r\n        match iVal with\r\n        | None -> Set.filter (fun {head=h;body=_} -> h=var) rep.rules\r\n        | Some iVal -> (\r\n          let varRules = bodiesOfHead var rep.rules in\r\n          let rhsValues = Set.map (\r\n            fun b -> \r\n              if List.length b >= 1 \r\n              then (Hashtbl.find_opt map (List.hd b), b)\r\n              else (None, b)\r\n          ) varRules\r\n          in\r\n          Set.flatMap (fun b ->\r\n            let r = perVarProdIndirectRemoval var iVal b rhsValues rep in\r\n            r\r\n          ) varRules)\r\n      in\r\n      let newProds = Set.flatMap (fun v -> perVarIndirectRemoval map v rep) rep.variables in\r\n      let newGrammar = new ContextFreeGrammarBasic.model (Arg.Representation {\r\n         alphabet = rep.alphabet;\r\n         variables = rep.variables;\r\n         initial = rep.initial;\r\n         rules = newProds\r\n       } ) in\r\n      let newGrammar = removeDirectLeftRecursion newGrammar#representation in\r\n      removeIndirectLeftRecursion map xs newGrammar#representation\r\n\r\n\r\n  let removeLeftRecursion (rep:t) =\r\n    let map = Hashtbl.create (Set.size rep.variables) in\r\n    let leftCornerTest = List.map (fun v -> (v, (Set.toList (leftCorner v rep))) ) (Set.toList rep.variables) in\r\n    let sortedLeftCornerTest = sortLeftCorner leftCornerTest in\r\n    addToMap map (List.map (fun (v,_) -> v) sortedLeftCornerTest);\r\n    let sortedVars = List.map (fun (s,_) -> s) sortedLeftCornerTest in\r\n    let result = removeIndirectLeftRecursion map sortedVars rep in\r\n      {tType = leftRecursionRemovalTransform; grammar = result}\r\n      \r\n  (*left factoring*)\r\n  \r\n  let rec lcp l1 l2 =\r\n    match l1 with\r\n    | [] -> []\r\n    | x1::xs1 -> match l2 with\r\n                | [] -> []\r\n                | x2::xs2 -> if x1=x2 then [x1]@(lcp xs1 xs2) else []\r\n  \r\n  let perVarLCP v rs =\r\n    let rules = Set.filter (fun r -> r.head = v) rs in\r\n    let combos = List.flatten (pairs (Set.toList rules)) in\r\n    let lcpList = List.map ( fun (r1,r2) -> lcp r1.body r2.body) combos in\r\n    let lcpList = List.filter (fun l -> l <> []) lcpList in\r\n      Set.toList (Set.make lcpList) (*Remove repeats*)\r\n  \r\n  let rec sameRuleFactoring nV p rb =\r\n    match p with\r\n    | [] -> [nV]\r\n    | x::xs -> match rb with\r\n              | [] -> []\r\n              | x2::xs2 -> [x2]@sameRuleFactoring nV xs xs2\r\n      \r\n  let rec newRuleFactoring rb p =\r\n    match rb with\r\n    | [] -> []\r\n    | x::xs -> match p with\r\n              | [] -> [x]@newRuleFactoring xs p\r\n              | x2::xs2 -> []@newRuleFactoring xs xs2\r\n      \r\n  let rec ruleHasPrefix r p rb =\r\n    match p with\r\n    | [] ->true\r\n    | x::xs -> match rb with\r\n              |[] -> false\r\n              |x2::xs2 -> if x = x2 then ruleHasPrefix r xs xs2 else false\r\n     \r\n  let rec getSmallestLCP l currSmallest =\r\n    match l with\r\n    | [] -> currSmallest\r\n    | x::xs -> if (x <> [] && List.length x < List.length currSmallest)\r\n               then getSmallestLCP xs x\r\n               else getSmallestLCP xs currSmallest\r\n      \r\n  let rec getBiggestList ll currBiggest =\r\n    match ll with\r\n    | [] -> currBiggest\r\n    | x::xs -> let length = List.length x in\r\n                if length > currBiggest\r\n                then getBiggestList xs length\r\n                else getBiggestList xs currBiggest\r\n      \r\n  let rec createLargeList size =\r\n    match size with\r\n    | 0 -> []\r\n    | _ -> [symb \"a\"] @ createLargeList (size-1)\r\n      \r\n  let rec perVarFactoring pair allVars (rep:t) = (* pair = ('A', ['a']) *)\r\n    if pair = Set.empty then Set.empty\r\n    else let (x,xs) = Set.cut pair in\r\n      let var = fst x in\r\n      let prefix = snd x in\r\n(*     Printf.printf \"prefix = \"; print_list prefix; Printf.printf \"\\n\";*)\r\n      let varRules = Set.filter (fun r -> r.head = var) rep.rules in\r\n      let prefixedRules = Set.filter (fun r -> ruleHasPrefix r prefix r.body) varRules in\r\n(*     Printf.printf \"prefixedRules = \"; Util.println (CFGSyntax.toStringList prefixedRules);*)\r\n      let nonPrefixedRules = Set.filter (fun r -> not (ruleHasPrefix r prefix r.body)) varRules in\r\n(*     Printf.printf \"nonPrefixedRules = \"; Util.println (CFGSyntax.toStringList nonPrefixedRules);*)\r\n      let newVar = getNewVar allVars in\r\n(*     Printf.printf \"newVar = %c\\n\" newVar;*)\r\n      let newSameHeadRulesSet = Set.map (fun r -> { head = var; body = sameRuleFactoring newVar prefix r.body } ) prefixedRules in\r\n      let newHeadRulesSet = Set.map (fun r -> { head = newVar; body = newRuleFactoring r.body prefix } ) prefixedRules in\r\n      let rules = Set.union nonPrefixedRules (Set.union newSameHeadRulesSet newHeadRulesSet) in\r\n(*     print_rules (Set.toList rules);*)\r\n        Set.union rules (perVarFactoring xs (Set.cons newVar allVars) rep)\r\n  \r\n  let getPerVarLCPResult (rep:t) = \r\n    let perVarLCPResult = Set.map (fun v -> (v, perVarLCP v rep.rules)) rep.variables in\r\n    let perVarLCPResult = Set.filter (fun (_,l) -> l <> []) perVarLCPResult in\r\n      Set.map ( fun (v,l) -> (v, getSmallestLCP l (createLargeList ((getBiggestList l 0)+1))) ) perVarLCPResult\r\n\r\n  let isLeftFactoring (rep:t) =\r\n    Set.map (fun (v,l) -> v) (getPerVarLCPResult rep) <> Set.empty\r\n\r\n  let rec leftFactoring (rep:t) =\r\n    let perVarLCPResult = getPerVarLCPResult rep in\r\n(*    Printf.printf \"perVarLCPResult = \"; Set.iter (fun (v,l) -> Printf.printf \"%c, \" v; print_list l) perVarLCPResult; Printf.printf \"\\n\";*)\r\n    let variablesToFactorize = Set.map (fun (v,l) -> v) perVarLCPResult in\r\n(*    Printf.printf \"Variables to factorize = \"; print_list (Set.toList variablesToFactorize); Printf.printf \"\\n\";*)\r\n    let unchangedVariables = Set.diff rep.variables variablesToFactorize in\r\n(*    Printf.printf \"Unchanged variables = \"; print_list (Set.toList unchangedVariables); Printf.printf \"\\n\";*)\r\n    let unchangedRules = Set.filter (fun {head = h; body = _} -> Set.belongs h unchangedVariables) rep.rules in\r\n    let newRules = perVarFactoring perVarLCPResult rep.variables rep in\r\n    let newVars = Set.map (fun ({head=v;body=_}) -> v ) newRules in\r\n    let newGrammar = new ContextFreeGrammarBasic.model (Arg.Representation {\r\n\t      alphabet = rep.alphabet;\r\n\t      variables = Set.union rep.variables newVars;\r\n\t      initial = rep.initial;\r\n\t      rules = Set.union newRules unchangedRules\r\n\t    } ) in\r\n    if isLeftFactoring newGrammar#representation \r\n    then leftFactoring newGrammar#representation \r\n    else {tType = leftFactoringTransform; grammar = newGrammar}\r\n\r\n  let hasEmptyProductions (rep:t) =\r\n    let nullableVars = Set.filter (fun v -> doWordGenerateEmpty [v] rep) rep.variables in\r\n    Set.size nullableVars <> 0\r\n\r\n  let removeEmptyProductions2 (rep:t) = \r\n    let rec combi vars body =\r\n      match body with\r\n      | [] -> Set.make [[]]\r\n      | x::xs -> let res = combi vars xs in\r\n                  (*Printf.printf \"Current body symbol is %c\\n\" x;\r\n                  Printf.printf \"res = \\n\";\r\n                  Set.iter (fun l -> Printf.printf \"\\t%s\\n\" (word2str l)) res;*)\r\n                  Set.flatMap (fun v ->\r\n                                (*(if x = v\r\n                                then (\r\n                                  Printf.printf \"\\tx = v (%c = %c)\\n\" x v;\r\n                                  Set.iter (fun p -> Printf.printf \"\\t\\t{%s}\\n\" (word2str p)) (Set.union res (Set.map (fun l -> v::l) res))\r\n                                )\r\n                                else (\r\n                                  Printf.printf \"\\tx =/= v (%c =/= %c)\\n\" x v;\r\n                                  Set.iter (fun p -> Printf.printf \"\\t\\t{%s}\\n\" (word2str p)) (Set.map (fun l -> x::l) res)\r\n                                ));*)\r\n                                if x = v\r\n                                then Set.union res (Set.map (fun l -> v::l) res)\r\n                                else Set.map (fun l -> x::l) res\r\n                  ) vars\r\n    in\r\n    let changeProds vars prod = \r\n      let {head=h; body=b} = prod in\r\n      if List.length b = 0 then Set.empty\r\n      else (\r\n        let prodBodiesSet = Set.filter (fun p -> List.length p <> 0) (combi vars b) in\r\n        Set.map (fun b -> {head = h; body = b} ) prodBodiesSet\r\n      )\r\n    in\r\n    let nullableVars = Set.filter (fun v -> doWordGenerateEmpty [v] rep) rep.variables in\r\n    if Set.size nullableVars = 0 \r\n    then (\r\n      new ContextFreeGrammarBasic.model (Arg.Representation {\r\n\t        alphabet = rep.alphabet;\r\n\t        variables = rep.variables;\r\n\t        initial = rep.initial;\r\n\t        rules = rep.rules\r\n\t      })\r\n    )\r\n    else (\r\n      let toChangeProds = Set.filter (fun {head=h;body=b} -> \r\n                                        Set.exists (\r\n                                          fun v -> List.length b >= 1 && List.mem v b\r\n                                        ) nullableVars\r\n                           ) rep.rules \r\n      in\r\n      let unchangedProds = Set.filter (\r\n                            fun p -> List.length p.body >= 1\r\n                           ) (Set.diff rep.rules toChangeProds) in\r\n      let newProds = Set.flatMap (changeProds nullableVars) toChangeProds in\r\n(*      Set.iter (fun p -> Printf.printf \"{%c;%s}\\n\" p.head (word2str p.body) ) newProds;*)\r\n(*      if Set.belongs rep.initial nullableVars\r\n      then (\r\n        let newInitial = getNewVar rep.variables in\r\n        let newInitialProds = Set.make [ { head = newInitial; body = []}; { head = newInitial; body = [rep.initial]} ] in\r\n        let newProds = Set.union newInitialProds newProds in\r\n        new ContextFreeGrammarBasic.model (Arg.Representation {\r\n\t        alphabet = rep.alphabet;\r\n\t        variables = Set.cons newInitial rep.variables;\r\n\t        initial = newInitial;\r\n\t        rules = Set.union newProds unchangedProds\r\n\t      } )\r\n      ) else ( *)\r\n        new ContextFreeGrammarBasic.model (Arg.Representation {\r\n\t        alphabet = rep.alphabet;\r\n\t        variables = rep.variables;\r\n\t        initial = rep.initial;\r\n\t        rules = Set.union newProds unchangedProds\r\n\t      } (* ) *)\r\n      )\r\n    )\r\n  let transformationToString (t: transformation) = (* PEDRO CARLOS *)\r\n    ContextFreeGrammarBasic.show t.grammar#representation   \r\n  \r\n  let removeEmptyProductions (rep:t) =\r\n    { tType = epsilonRemovalTransform; grammar = removeEmptyProductions2 rep }\r\n  \r\n\r\n  let isUnitProd body (rep:t) =\r\n    let rec isUnitProd2 cS cB p =\r\n      match cB with\r\n      | [] -> false\r\n      | x::xs -> if doWordGenerateEmpty cB rep && doWordGenerateEmpty p rep\r\n                  then true\r\n                  else isUnitProd2 x xs (p@[cS])\r\n    in\r\n    let isUnitProdAux r (rep:t) =\r\n      match r with\r\n      | [] -> false\r\n      | x::xs -> isUnitProd2 x xs []\r\n    in\r\n    if (List.length body = 1 && Set.belongs (List.hd body) rep.variables) \r\n    then true \r\n    else (\r\n      if List.length body > 1 && List.for_all ( fun c -> Set.belongs c rep.variables ) body\r\n        then isUnitProdAux body rep \r\n        else false\r\n      )\r\n\r\n  let hasUnitProductions (rep:t) =\r\n    Set.size (Set.filter (fun {head = _; body = b} -> isUnitProd b rep ) rep.rules) <> 0\r\n\r\n\r\n  let rec findUnitPair2 cS cB p (rep:t) =\r\n    match cB with\r\n    | [] -> []\r\n    | x::xs -> if doWordGenerateEmpty cB rep && doWordGenerateEmpty p rep\r\n                then [cS]\r\n                else findUnitPair2 x xs (p@[cS]) rep\r\n\r\n  let findUnitPairAux r (rep:t) =\r\n    match r with\r\n    | [] -> []\r\n    | x::xs -> findUnitPair2 x xs [] rep\r\n             \r\n  let rec findUnitPairX origVar var seen (rep:t) =\r\n    if Set.belongs var seen then [] else (\r\n      let rules = bodiesOfHead var rep.rules in\r\n      let results = List.flatten (\r\n                      List.map (fun r -> \r\n                          if List.length r = 1 && Set.belongs (List.hd r) rep.variables\r\n                          then (\r\n                            if Set.belongs (List.hd r) seen\r\n                            then []@findUnitPairX origVar (List.hd r) (Set.cons var seen) rep\r\n                            else r@findUnitPairX origVar (List.hd r) (Set.cons var seen) rep\r\n                          )\r\n                          else  findUnitPairAux r rep \r\n                      ) (Set.toList rules)\r\n                    ) \r\n      in\r\n      results\r\n    )\r\n    \r\n  let findUnitPair var (rep:t) =\r\n    let results = List.map (fun r -> (var, r)) (findUnitPairX var var Set.empty rep) in\r\n    [(var, var)] @ results\r\n(*    (var,(findUnitPairX var Set.empty rep))*)\r\n\r\n  (*Used to sort unit pair lists by biggest length to lowest length*)\r\n  let compareUnitPairList l1 l2 =\r\n    if List.length l1 > List.length l2 then -1\r\n    else (if List.length l1 < List.length l2 then 1\r\n    else 0)  \r\n   \r\n  let getNonUnitProductions var (rep:t) = \r\n    let prods = bodiesOfHead var rep.rules in\r\n(*    Printf.printf \"var = %c\\n\" var;*)\r\n(*    Set.iter (fun p -> Printf.printf \"\\tIs %c -> %s unit? %b\\n\" var (word2str p) (isUnitProd p rep)) prods;*)\r\n(*    Printf.printf \"\\n\";*)\r\n    Set.filter (fun p -> not (isUnitProd p rep)) prods\r\n\r\n  let removeUnitProductions (rep:t) = \r\n    let perVarPair pair (rep:t) =\r\n      let (h,b) = pair in\r\n      let nUnitProds = getNonUnitProductions b rep in\r\n(*      Set.iter (fun p -> Printf.printf \"%c -> %s\\n\" h (word2str p)) nUnitProds;*)\r\n      Set.toList (Set.map (fun p -> {head = h; body = p}) nUnitProds)\r\n    in\r\n    let perVar pairs (rep:t) =\r\n      List.flatten (List.map (fun p -> perVarPair p rep) pairs)\r\n    in\r\n    let unitPairs = List.map (fun v -> findUnitPair v rep) (Set.toList rep.variables) in\r\n    (*let unitPairs = List.sort compareUnitPairList unitPairs in*)\r\n    let newProds = List.flatten (\r\n                    List.map (fun l ->\r\n                      perVar l rep\r\n                     ) unitPairs \r\n                   ) in\r\n    let result = new ContextFreeGrammarBasic.model (Arg.Representation {\r\n\t      alphabet = rep.alphabet;\r\n\t      variables = rep.variables;\r\n\t      initial = rep.initial;\r\n\t      rules = Set.make newProds\r\n\t    } )\r\n\t  in\r\n\t    {tType = unitRemovalTransform; grammar = result}\r\n\r\n    \r\n    \r\n  let generateRecursiveDescendentParser lang (rep:t) =\r\n    match String.lowercase_ascii lang with\r\n      | \"c\" -> let parser = new RDParserC.parser in parser#build rep\r\n      | \"ocaml\" -> let parser = new RDParserOCaml.parser in parser#build rep\r\n      | \"java\" -> let parser = new RDParserJava.parser in parser#build rep\r\n      | _ -> \"Language \" ^ lang ^ \" is not supported.\\n\"\r\n\r\n\r\n  let transformToLL1 (rep:t) =\r\n    let transform1 = {tType = epsilonRemovalTransform; grammar = (removeEmptyProductions rep).grammar} in\r\n    let transform2 = {tType = unitRemovalTransform; grammar = (removeUnitProductions transform1.grammar#representation).grammar} in\r\n    let cleanResult = clean transform2.grammar#representation in\r\n    let transform3 = {tType = cleanProductiveTransform; grammar = (List.nth cleanResult 0).grammar} in\r\n    let transform4 = {tType = cleanAccessibleTransform; grammar = (List.nth cleanResult 1).grammar} in\r\n    let transform5 = {tType = leftRecursionRemovalTransform; grammar = (removeLeftRecursion transform4.grammar#representation).grammar} in\r\n    let transform6 = {tType = leftFactoringTransform; grammar = (leftFactoring transform5.grammar#representation).grammar} in\r\n    [transform1; transform2; transform3; transform4; transform5; transform6]\r\n  \r\n\r\n  class model (arg: t Arg.alternatives) =\r\n    object(self) inherit ContextFreeGrammarBasic.model arg as super\r\n    \r\n    method isSimplified = simplified\r\n    method rdparserOpts = [ \"OCaml\"; \"C\"; \"Java\"; \"Rust\" ]\r\n    method toggleSimplified = Printf.printf \"simplified is %b toggling to %b\\n\" simplified (not simplified);\r\n                              simplified <- not simplified\r\n    \r\n    method follow testSymbol = follow testSymbol simplified self#representation\r\n    method lookahead rule = lookahead rule simplified self#representation\r\n    method isLL1 = isLL1 simplified self#representation\r\n    method isLeftRecursive = isLeftRecursive self#representation\r\n    method createParsingTable = createParsingTable simplified self#representation\r\n    method hasParsingTableConflict = hasParsingTableConflict simplified self#representation\r\n    method acceptZ w = acceptZ w simplified self#representation\r\n    method productiveSymbols = productiveSymbols self#representation\r\n    method accessibleSymbols = accessibleSymbols self#representation\r\n    method productiveRewrite = productiveGrammarRewrite self#representation\r\n    method accessibleRewrite = accessibleGrammarRewrite self#representation\r\n    method clean = clean self#representation\r\n    method isFullyProductive = isCFGFullyProductive self#representation\r\n    method isFullyAccessible = isCFGFullyAccessible self#representation\r\n    method isClean = isClean self#representation\r\n    method removeLeftRecursion = removeLeftRecursion self#representation\r\n    method removeDirectLeftRecursion = removeDirectLeftRecursion self#representation\r\n    method leftFactoring = leftFactoring self#representation\r\n    method isLeftFactoring = isLeftFactoring self#representation\r\n    method leftCorner s = leftCorner s self#representation\r\n    method hasEmptyProductions = hasEmptyProductions self#representation\r\n    method removeEmptyProductions = removeEmptyProductions self#representation\r\n    method hasUnitProductions = hasUnitProductions self#representation\r\n    method removeUnitProductions = removeUnitProductions self#representation\r\n    method generateRecursiveDescendentParser pLang = generateRecursiveDescendentParser pLang self#representation\r\n    method transformToLL1 = transformToLL1 self#representation\r\n  end\r\nend\r\n\r\n\r\n# 3 \"src/ContextFreeGrammarLR.ml\"\r\n(*\r\n * ContextFreeGrammarLR.ml\r\n *\r\n * This file is part of the OCamlFlat library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Bernardo Sousa (br)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n * sep/2022 (br) - Bug fixes.\r\n * july/2022 (br) - Added step-by-step table creation.\r\n * may/2022 (br) - Most of the LR theory implemented.\r\n * mar/2022 (amd/br) - Skeleton.\r\n *)\r\n\r\n(*\r\n * Description: A very simple parser for CFG syntax.\r\n *)\r\n \r\nopen BasicTypes\r\nopen ContextFreeGrammarBasic  \r\n\r\nmodule LRAux =\r\nstruct\r\n\tlet word s = str2word s\r\n\t\t\r\n\tlet rec nats n = if n = 0 then [] else nats(n-1) @ [string_of_int (n-1)]\r\n\t\r\n\tlet rec pop n l (*uses reverse stack and removes n heads from stack *)= \r\n\t\tmatch l with\r\n\t\t| [] -> []\r\n\t\t| x::xs -> if(n>0) then pop (n-1) xs else x::pop n xs  \r\n\t\r\n\t\r\n\tlet getTail l = (*remove head from list *)\r\n\t\tmatch l with\r\n\t\t| [] -> []\r\n\t\t|_::xs -> xs\r\n\t\t\r\n\tlet rec rev l =\r\n\t\tmatch l with\r\n\t\t| [] -> []\r\n\t\t| x::xs -> (rev xs) @ x\r\n\t\r\n\t\r\nend\t\r\n\r\nmodule LR0Grammar =\r\nstruct\r\n\topen LRAux\r\n\ttype t = ContextFreeGrammarBasic.t\r\n\r\n\ttype lr0Item = {head:symbol; body1:symbol list; body2:symbol list}\t\t\r\n\ttype lr0State = lr0Item set\r\n\ttype lr0Diagram = lr0State set * (lr0State * symbol * lr0State ) set\r\n\t\r\n\ttype stateName = string\r\n\t\r\n\ttype lr0StateId = stateName * lr0State \r\n\ttype lr0DiagramId = lr0StateId set * (lr0StateId * symbol * lr0StateId ) set\r\n\t\r\n\ttype lr0Action = Accept | Shift | Reduce of rule \r\n\ttype lr0TableEntry = stateName * (symbol * stateName) set * lr0Action\r\n\ttype lr0Table = lr0TableEntry set\r\n\t\r\n\tlet rule2Item (rule: rule) : lr0Item = (* converte uma regra num item novo, com o ponto á esquerda do corpo desse item *)\r\n\t\t{head = rule.head; body1 = []; body2 = rule.body} \r\n\t\t\r\n\t\r\n\tlet kernelAdvanceItem {head=h; body1=b1; body2=b2} = (* função auxiliar para avançar o ponto de um item em um simbolo para o nucleo do proximo estado. Ex: A ->.ab para A -> a.b *)\r\n\t\tmatch b2 with\r\n\t\t| [] -> Error.fatal \"kernelAdvanceItem: Este caso nem deve ser alcançavel\"\r\n\t\t| x::xs -> {head = h; body1 = b1 @ [x]; body2 = xs} \r\n\t\r\n\t\r\n\r\n\t\r\n\t\t\r\n\tlet getDirector {head=_; body1=_; body2=b2} = (* obtem o simbolo diretor de um item *)\r\n\t\tmatch b2 with \r\n\t\t\t| [] -> epsilon (* epsilon, aka no symbol *) \r\n\t\t\t| x::_ -> x\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\r\n\t\t\t\r\n\tlet getDirectors state = (* Aplica a função getDirector a todos os itens de um dado estado*)\r\n\t\tSet.filter (fun d-> d <> epsilon)(Set.map getDirector state)\r\n\t\r\n\t\t\r\n\t\t\r\n\tlet getRulesWithThisHead rules director = (* recebe o conjunto de regras da gramática e filtra esse conjunto para obter as regras cuja cabeça tem aquele simbolo diretor *)\r\n\t\tSet.filter (fun {head = h; body =_} -> h = director) rules \r\n\t\t\r\n\t\r\n\tlet diagramsJoin2 (s0,t0) (s1,t1) = (Set.union s0 s1, Set.union t0 t1) (* juntar dois diagramas LR0 para obter um diagrama LR0 resultante da união *)\t\r\n\t\r\n\tlet rec diagramsJoinList l : lr0Diagram = (* Juntar um conjunto de diagramas para produzir o diagrama LR0, cada diagrama desta lista corresponde a um estado rescrito como diagrama *)\r\n\t\tmatch l with\r\n\t\t| [] -> (Set.empty , Set.empty) \r\n\t\t| d::ds -> diagramsJoin2 d (diagramsJoinList ds)\r\n\t\r\n\t\r\n\tlet isNextSymbolNotAVariable {head=h; body1=b1; body2=b2} (cfg:t)=\r\n\t\tif(List.length b2 = 0) then true\r\n\t\telse\r\n\t\t\tif(Set.belongs (List.hd b2) cfg.variables) then false else true\r\n\t\r\n\tlet isCompleteItem {head=h; body1=b1; body2=b2} =\r\n\t\tb2 = []\r\n\t\r\n\tlet isStateInConflict lr0State cfg = \r\n\t\tlet completeItems = Set.filter(isCompleteItem) lr0State in\r\n\t\tif(Set.size completeItems < 1 ) then false\r\n\t\telse if(Set.size completeItems > 1 ) then true\r\n\t\telse\r\n\t\t\tlet itemsProneToConflict = Set.filter(fun it -> isNextSymbolNotAVariable it cfg) lr0State in\r\n\t\t\tif(Set.size itemsProneToConflict > 1) then true else false\r\n\t\r\n\tlet makeLR0DiagramId diagram : lr0DiagramId (* Cria etiquetas para os estados e os mesmos estados contidos nas transições do diagrama*) =\r\n\t\tlet (states,transitions) = diagram in\r\n\t\tlet dictionary = List.combine (Set.toList states) (nats (Set.size states)) in\r\n\t\tlet statesId = Set.map (fun s -> (List.assoc s dictionary,s) ) states in\r\n\t\tlet transitionsId = Set.map (fun (a,b,c) -> ((List.assoc a dictionary, a), b,(List.assoc c dictionary, c))) transitions in\r\n\t\t\t(statesId, transitionsId)\r\n\t\r\n\t\r\n\tlet makeLR0TableEntry (id, lr0State) (cfg:t) transitions = \r\n\t\tlet stateTransitions = Set.filter (fun ((a,_),_,_)-> a = id) transitions in\r\n\t\t\tif Set.size stateTransitions = 0 then\r\n\t\t\t\tlet {head = h;body1 = b1;body2 = b2} = List.hd (Set.toList lr0State) in\r\n\t\t\t\t\tif h = cfg.initial then \r\n\t\t\t\t\t\t(id,Set.empty,Accept)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t(id,Set.empty,Reduce ({head = h;body = b1}))\t\t\t\r\n\t\t\telse  \r\n\t\t\t\tlet nextShifts = Set.map (fun (a,b,(cId,c)) -> (b,cId)) stateTransitions in\r\n\t\t\t\t\t(id, nextShifts, Shift)\r\n\t\t\r\n\t(* falta uma função para aceitar/recusar palavra usando a tabela *)\r\n\t\r\n\t(*pre: isLR0 cfg *)\r\n\tlet makeLR0Table (labeledDiagram:lr0DiagramId) cfg : lr0Table = (* recebe um diagrama numerado e constroi a tabela de parsing a partir das transições *) \r\n\t\tlet (statesId, transitionsId) = labeledDiagram in\r\n\t\t\tSet.map (fun s -> makeLR0TableEntry s cfg transitionsId) statesId\r\n\t\r\n\t\r\n\tlet startRules (cfg: t) =\r\n\t\tlet initial = cfg.initial in\r\n\t\tlet rules = cfg.rules in\r\n\t\t\tSet.filter (fun {head=h; body=_} -> h = initial) rules\r\n\t\t\t\r\n\t\t\r\n\t\t\r\n\tlet lr0StateClosureStep (cfg: t) currentItems = (* Create items for current directors *)\r\n\t\tlet directors = getDirectors currentItems in\r\n\t\tlet varDirectors = Set.inter directors cfg.variables in\r\n\t\tlet newRules = Set.flatMap (fun d -> getRulesWithThisHead cfg.rules d) varDirectors in\r\n\t\tlet newItems = Set.map rule2Item newRules in\r\n\t\t\tSet.union currentItems newItems \r\n\t\t\r\n\t\t\r\n\tlet rec lr0StateClosure cfg currentItems : lr0State = (* Create all items for a singular state *)\r\n\t\tlet next = lr0StateClosureStep cfg currentItems in\r\n\t\tlet next2 = Set.union currentItems next in\r\n\t\t\tif Set.size next2 = Set.size currentItems then next2\r\n\t\t\telse lr0StateClosure cfg next2\r\n\r\n\r\n\t\t\r\n\tlet makeSingularNextLR0Diagram (cfg:t) prevState symbol : lr0Diagram = (* Creates a diagram containing only 1 state using the previous state and the transition symbol*)\r\n\t\tlet items4Kernel = Set.filter (fun it -> getDirector it = symbol) prevState in (* falta avançar o ponto *)\r\n\t\tlet kernel = Set.map (kernelAdvanceItem) items4Kernel in\r\n\t\tlet closure = lr0StateClosure cfg kernel in\r\n\t\t\t(Set.make [prevState; closure], Set.make [(prevState ,symbol , closure )])\r\n\t\t\t\t\t\r\n\r\n\t\r\n\tlet makeNextLR0Diagram (cfg:t) prevState : lr0Diagram = (* For each director symbol on the previous state, create a diagram and join all obtained diagrams into a single diagram*)\r\n\t\tlet dirs = getDirectors prevState in\r\n\t\tlet diagrams = Set.map (fun d -> makeSingularNextLR0Diagram cfg prevState d) dirs in\r\n\t\t\tdiagramsJoinList (Set.toList diagrams) \r\n\r\n\t\t\t\r\n\t\t\r\n\tlet makeNextLR0DiagramAll (cfg:t) states : lr0Diagram = (* build the diagram using the initial state, then use the makeNextLR0Diagram function to calculate all states obtainable from the initial state*)\r\n\t\tlet diagrams = Set.map (fun s -> makeNextLR0Diagram cfg s) states in\r\n\t\t\tdiagramsJoinList (Set.toList diagrams)\r\n\t\t\t\r\n\t\r\n\tlet makeFirstLR0Diagram (cfg:t) : lr0Diagram = (* O primeiro estado tem um procedimento de criação um pouco differente *) \r\n\t\tlet kernel = Set.map rule2Item (startRules cfg) in\r\n\t\tlet closure = lr0StateClosure cfg kernel in\r\n\t\t(Set.make [closure], Set.empty)\r\n\t\t\r\n\t\t(*Set.make [closure] (* apesar de ser criado um par, nesta função só se cria o conjunto de items, o conjunto vazio das transições vazias é criado no makeLR0Diagram *) *)\r\n\t\t\r\n\r\n\t\r\n\tlet rec makeLR0DiagramX (cfg:t) diagram = (* função auxiliar que irá produzir o diagrama LR0 *)\r\n\t\tlet (states,transitions) : lr0Diagram = diagram in \r\n\t\tlet next = makeNextLR0DiagramAll cfg states in\r\n\t\tlet next2 = diagramsJoin2 next (states,transitions) in\r\n\t\tlet (states2,transitions2) = next2 in\r\n\t\t\tif Set.size states = Set.size states2 && Set.size transitions = Set.size transitions2 then next2\r\n\t\t\telse makeLR0DiagramX cfg next2 \r\n\t\t\t\t\t \r\n\r\n\tlet makeLR0Diagram (cfg:t) = makeLR0DiagramX cfg (makeFirstLR0Diagram cfg)  (* ponto de partida na construlão do diagrama LR0 *)\r\n\t\r\n\t(*\r\n\ttype stackEntry = StateEntry of stateName | SymbolEntry of symbol\r\n\t\r\n\tlet getState e =\r\n\t\tmatch e with\r\n\t\t| StateEntry s -> s\r\n\t\t| _ -> Error.fatal \"getState: desnecessário\" \r\n\t\t\r\n\tlet getSymbol s =\r\n\t\tmatch s with\r\n\t\t| SymbolEntry s -> s\r\n\t\t| _ -> Error.fatal \"getState: desnecessário\" \r\n\t*)\t\r\n\tlet rec parseOperationV2 lr0Table word revStack (cfg:t) = \r\n\t\tlet currentState = int_of_string (List.hd revStack) in \r\n\t\tlet (id,shifts,action) = Set.nth lr0Table currentState in (* get corresponding table entry *)\t\r\n\t\tmatch action with\r\n\t\t| Shift -> \r\n\t\t\tbegin\r\n\t\t\t\tmatch word with\r\n\t\t\t\t| [] -> false\r\n\t\t\t\t| s::_ -> \r\n\t\t\t\t\tif(Set.belongs s cfg.alphabet || Set.belongs s cfg.variables) then\r\n\t\t\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = s) shifts in\r\n\t\t\t\t\t\t\tif(Set.size targetShifts = 0) then false\r\n\t\t\t\t\t\t\t(* Error.fatal (String.of_seq (List.to_seq ([char_of_int ((int_of_char '0') + currentState)] @ [s]))) *)\r\n\t\t\t\t\t\t\t(* para testar Error.fatal (String.of_seq (List.to_seq [s])) (* Casos corretos estão a ir parar aqui por alguma razão, provavelmente após uma redução *) *)\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\r\n\t\t\t\t\t\t\t\tlet nextRevStack = [nextState] @ [symb2str nextSymbol] @ revStack in\r\n\t\t\t\t\t\t\t\t\tparseOperationV2 lr0Table (getTail word) nextRevStack cfg\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tError.fatal \"singleParseOperation: este simbolo não pertence ao alfabeto desta gramatica\"\r\n\t\t\tend\r\n\t\t| Accept -> \r\n\t\t\tword = [dollar]\t\r\n\t\t| Reduce({head = h;body = b}) -> \r\n\t\t\tlet popNumber = List.length b in\r\n\t\t\tlet nextRevStack = pop (popNumber*2) revStack in\r\n\t\t\tlet wordWithAddedHead = [h] @ word in\r\n\t\t\t\tparseOperationV2 lr0Table (wordWithAddedHead) nextRevStack cfg (*Add the variable, aka head of the reduction rule, to the word being processed *)\r\n\t\t\t\t\t\r\n\t\r\n\t(* pre: isLR0 cfg \r\n\t   pre: isWordValid word cfg *)\r\n\tlet acceptWordLR0V2 (word:symbol list) cfg : bool = \r\n\t\tlet lr0Table = makeLR0Table (makeLR0DiagramId (makeLR0Diagram cfg)) cfg in\r\n\t\tlet revStack = [\"0\"] in (*char list due to mix of numbers and symbols *) \r\n\t\t\tparseOperationV2 lr0Table (word @ [dollar]) revStack cfg\t\r\n\t\t\r\n\r\n\t(* let nextStack = [StateEntry nextState; StateSymbol nextSymbol] @ stack in *)\r\n\t\r\n\tlet rec parseOperation lr0Table word stateStack symbolStack (cfg:t) = \r\n\t\tlet currentState = int_of_string (List.hd stateStack) in \r\n\t\tlet (id,shifts,action) = Set.nth lr0Table currentState in (* get corresponding table entry *)\t\r\n\t\tmatch action with\r\n\t\t| Shift -> \r\n\t\t\tbegin\r\n\t\t\t\tmatch word with\r\n\t\t\t\t| [] -> false\r\n\t\t\t\t| s::_ -> \r\n\t\t\t\t\tif(Set.belongs s cfg.alphabet || Set.belongs s cfg.variables) then\r\n\t\t\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = s) shifts in\r\n\t\t\t\t\t\t\tif(Set.size targetShifts = 0) then false\r\n\t\t\t\t\t\t\t(* Error.fatal (String.of_seq (List.to_seq ([char_of_int ((int_of_char '0') + currentState)] @ [s]))) *)\r\n\t\t\t\t\t\t\t(* para testar Error.fatal (String.of_seq (List.to_seq [s])) (* Casos corretos estão a ir parar aqui por alguma razão, provavelmente após uma redução *) *)\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\r\n\t\t\t\t\t\t\t\tlet nextStateStack = [nextState] @ stateStack in\r\n\t\t\t\t\t\t\t\tlet nextSymbolStack = [nextSymbol] @ symbolStack in\r\n\t\t\t\t\t\t\t\t\tparseOperation lr0Table (getTail word) nextStateStack nextSymbolStack cfg\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tError.fatal \"singleParseOperation: este simbolo não pertence ao alfabeto desta gramatica\"\r\n\t\t\tend\r\n\t\t| Accept -> \r\n\t\t\tword = [dollar]\t\r\n\t\t| Reduce({head = h;body = b}) -> \r\n\t\t\tlet popNumber = List.length b in\r\n\t\t\tlet nextStateStack = (pop popNumber stateStack) in\r\n\t\t\tlet nextSymbolStack = (pop popNumber symbolStack) in\r\n\t\t\tlet wordWithAddedHead = [h] @ word in\r\n\t\t\t\tparseOperation lr0Table (wordWithAddedHead) nextStateStack nextSymbolStack cfg (*Add the variable, aka head of the reduction rule, to the word being processed *)\r\n\t\t\t\t\t\r\n\t\r\n\t(* pre: isLR0 cfg \r\n\t   pre: isWordValid word cfg *)\r\n\tlet acceptWordLR0 (word:symbol list) cfg : bool = \r\n\t\tlet lr0Table = makeLR0Table (makeLR0DiagramId (makeLR0Diagram cfg)) cfg in\r\n\t\tlet stateRevStack = [\"0\"] in (*char list due to mix of numbers and symbols *) \r\n\t\tlet symbolRevStack : symbol list = [] in\r\n\t\t\tparseOperation lr0Table (word @ [dollar]) stateRevStack symbolRevStack cfg\r\n\t\t\t\r\n\t(* Added functions to provide a step-by step LR0 visualization of accepting *)\r\n\r\n\ttype lr0TableStep = symbol list * string list * symbol list * lr0Table * bool\r\n\t\r\n\tlet acceptWordLR0Init (word:symbol list) cfg : lr0TableStep =\r\n\t\tlet lr0Table = makeLR0Table (makeLR0DiagramId (makeLR0Diagram cfg)) cfg in\r\n\t\tlet stateRevStack = [\"0\"] in (*char list due to mix of numbers and symbols *) \r\n\t\tlet symbolRevStack : symbol list = [] in\r\n\t\tlet valid = true in\r\n\t\tlet initStep = ((word @ [dollar]),stateRevStack,symbolRevStack,lr0Table,valid) in\r\n\t\t\tinitStep\r\n\t\r\n\tlet parseStepLR0Operation (step:lr0TableStep) (cfg:t) : lr0TableStep = \r\n\t\tlet (word, stateStack, symbolStack, lr0Table, valid) = step in\r\n\t\tlet currentState = int_of_string (List.hd stateStack) in \r\n\t\tlet (id,shifts,action) = Set.nth lr0Table currentState in (* get corresponding table entry *)\t\r\n\t\tmatch action with\r\n\t\t| Shift -> \r\n\t\t\tbegin\r\n\t\t\t\tmatch word with\r\n\t\t\t\t| [] -> (word, stateStack, symbolStack, lr0Table, false)\r\n\t\t\t\t| s::_ -> \r\n\t\t\t\t\tif(Set.belongs s cfg.alphabet || Set.belongs s cfg.variables) then\r\n\t\t\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = s) shifts in\r\n\t\t\t\t\t\t\tif(Set.size targetShifts = 0) then (word, stateStack, symbolStack, lr0Table, false)\r\n\t\t\t\t\t\t\t(* Error.fatal (String.of_seq (List.to_seq ([char_of_int ((int_of_char '0') + currentState)] @ [s]))) *)\r\n\t\t\t\t\t\t\t(* para testar Error.fatal (String.of_seq (List.to_seq [s])) (* Casos corretos estão a ir parar aqui por alguma razão, provavelmente após uma redução *) *)\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\r\n\t\t\t\t\t\t\t\tlet nextStateStack = [nextState] @ stateStack in\r\n\t\t\t\t\t\t\t\tlet nextSymbolStack = [nextSymbol] @ symbolStack in\r\n\t\t\t\t\t\t\t\tlet nextStep = ((getTail word), nextStateStack, nextSymbolStack, lr0Table, valid) in\r\n\t\t\t\t\t\t\t\t\tnextStep\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tError.fatal \"singleParseOperation: este simbolo não pertence ao alfabeto desta gramatica\"\r\n\t\t\tend\r\n\t\t| Accept -> \r\n\t\t\tif (word = [dollar]) then\r\n\t\t\t\t\t((getTail word), stateStack, symbolStack, lr0Table, valid)\r\n\t\t\t\telse \r\n\t\t\t\t\t((getTail word), stateStack, symbolStack, lr0Table, false)\r\n\t\t| Reduce({head = h;body = b}) -> \r\n\t\t\tlet popNumber = List.length b in\r\n\t\t\tlet nextStateStack = (pop popNumber stateStack) in\r\n\t\t\tlet nextSymbolStack = (pop popNumber symbolStack) in\r\n\t\t\tlet wordWithAddedHead = [h] @ word in\r\n\t\t\tlet nextStep = (wordWithAddedHead, nextStateStack, nextSymbolStack, lr0Table, valid) in\r\n\t\t\t\tnextStep\r\n\t\t\r\n\t\r\n\t\r\n\t\r\n\t\t\r\n\tlet acceptWordLR0Step (step:lr0TableStep) cfg : lr0TableStep = \r\n\t\t\tparseStepLR0Operation step cfg\r\n\t\t\t\r\n\t\t\t\r\n\t(* updated acceptStep, you can use the previous version if you want to split the stack contaning both state and symbols*)\r\n\t\r\n\ttype truelr0TableStep = symbol list * string list * lr0Table * string\r\n\t\r\n\tlet acceptWordLR0InitV2 (word:symbol list) cfg : truelr0TableStep =\r\n\t\tlet lr0Table = makeLR0Table (makeLR0DiagramId (makeLR0Diagram cfg)) cfg in\r\n\t\tlet revStack = [\"0\"] in (*char list due to mix of numbers and symbols *) \r\n\t\tlet valid = \"Ongoing\" in\r\n\t\tlet initStep = ((word @ [dollar]),revStack,lr0Table,valid) in\r\n\t\t\tinitStep\r\n\t\r\n\tlet parseStepLR0OperationV2 (step:truelr0TableStep) (cfg:t) : truelr0TableStep = \r\n\t\tlet (word, revStack, lr0Table, valid) = step in (* if you want to print use this: print_string (List.hd revStack ^ \"\\n\"); *)\r\n\t\tlet currentState = int_of_string (List.hd revStack) in \r\n\t\tlet (id,shifts,action) = Set.nth lr0Table currentState in (* get corresponding table entry *)\t\r\n\t\tmatch action with\r\n\t\t| Shift -> \r\n\t\t\tbegin\r\n\t\t\t\tmatch word with\r\n\t\t\t\t| [] -> (word, revStack, lr0Table, \"Rejeitada\")\r\n\t\t\t\t| s::_ -> \r\n\t\t\t\t\tif(Set.belongs s cfg.alphabet || Set.belongs s cfg.variables) then\r\n\t\t\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = s) shifts in\r\n\t\t\t\t\t\t\tif(Set.size targetShifts = 0) then (word, revStack, lr0Table, \"Rejeitada\")\r\n\t\t\t\t\t\t\t(* Error.fatal (String.of_seq (List.to_seq ([char_of_int ((int_of_char '0') + currentState)] @ [s]))) *)\r\n\t\t\t\t\t\t\t(* para testar Error.fatal (String.of_seq (List.to_seq [s])) (* Casos corretos estão a ir parar aqui por alguma razão, provavelmente após uma redução *) *)\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\r\n\t\t\t\t\t\t\t\tlet nextRevStack = [nextState] @ [symb2str nextSymbol] @ revStack in\r\n\t\t\t\t\t\t\t\tlet nextStep = ((getTail word), nextRevStack, lr0Table, valid) in\r\n\t\t\t\t\t\t\t\t\tnextStep\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t(word, revStack, lr0Table, \"Rejeitada\")\r\n\t\t\tend\r\n\t\t| Accept -> \r\n\t\t\tif (word = [dollar]) then\r\n\t\t\t\t\t((getTail word), [symb2str cfg.initial], lr0Table, \"Aceite\")\r\n\t\t\t\telse \r\n\t\t\t\t\t((word), revStack, lr0Table, \"Rejeitada\")\r\n\t\t| Reduce({head = h;body = b}) -> \r\n\t\t\tlet popNumber = List.length b in\r\n\t\t\tlet nextRevStack = pop (popNumber*2) revStack in\r\n\t\t\tlet wordWithAddedHead = [h] @ word in\r\n\t\t\tlet nextStep = (wordWithAddedHead, nextRevStack, lr0Table, valid) in\r\n\t\t\t\tnextStep\r\n\t\r\n\t\t\r\n\tlet acceptWordLR0StepV2 (step:truelr0TableStep) cfg : truelr0TableStep = \r\n\t\t\tparseStepLR0OperationV2 step cfg\r\n\t\t\t\r\n\t\t\r\n\tlet isLR0 cfg = (* verificar se a gramatica é lr0, ou seja, em todos os estados com items completos, não existem simbolos não terminais á direita de um ponto (item não completo *)\r\n\t\tlet (states,transitions) = makeLR0Diagram cfg in\r\n\t\tlet conflictItemStates = Set.filter(fun s -> isStateInConflict s cfg) states in\r\n\t\t\tif(Set.size conflictItemStates > 0) then false else true\r\n\t\r\n\tlet getLR0DiagramId cfg : lr0DiagramId =\r\n\t\tmakeLR0DiagramId (makeLR0Diagram cfg)\r\n\t\t\r\n\tlet getLR0Table cfg : lr0Table =\r\n\t\tmakeLR0Table (makeLR0DiagramId (makeLR0Diagram cfg)) cfg \r\n\t\t\r\n\t(* -------extended LR0 for clarity----------- Allows LR0 Tables to display multiple actions in each state line.*)\t\r\n\t\r\n\tlet isCompleteLR0Item (it:lr0Item) =\r\n\t\tit.body2 = []\r\n\r\n\tlet countCompleteLR0Items lr0State = \r\n\t\tlet completeItems = Set.filter(isCompleteLR0Item) lr0State in\r\n\t\t\tSet.size completeItems\t\r\n\t\r\n\tlet buildLR0ReductionActionsForOne item cfg = (* Warning, input must only contain complete items *)\r\n\t\tif(isCompleteItem item) then\r\n\t\t\tReduce ({head = item.head;body = item.body1})\r\n\t\telse\r\n\t\t\tShift (* this should not happen *)\r\n\r\n\tlet buildLR0ReductionActions completeItems cfg = \r\n\t\tSet.map(fun it -> (buildLR0ReductionActionsForOne it cfg) ) completeItems\r\n\t\r\n\t\t\t\r\n\tlet buildLR0MixedActionsForOne item cfg = \r\n\t\tif(isCompleteItem item) then\r\n\t\t\tReduce ({head = item.head;body = item.body1})\r\n\t\telse\r\n\t\t\tShift\r\n\t\r\n\r\n\tlet buildLR0MixedActions (items:lr0State) cfg =\r\n\t\tSet.map(fun it -> (buildLR0MixedActionsForOne it cfg) ) items\r\n\t\r\n\t\r\n\t\r\n\t\r\n\ttype lr0TableEntryExt = stateName * (symbol * stateName) set * lr0Action set\r\n\ttype lr0TableExt = lr0TableEntryExt set\r\n\t\t\r\n\tlet makeLR0TableEntryExt (id, lr0State) (cfg:t) transitions = \r\n\t\tlet stateTransitions = Set.filter (fun ((a,_),_,_)-> a = id) transitions in\r\n\t\t\tif Set.size stateTransitions = 0 then\r\n\t\t\t\tlet {head = h;body1 = b1;body2 = b2} = List.hd (Set.toList lr0State) in\r\n\t\t\t\t\tif h = cfg.initial then \r\n\t\t\t\t\t\t\t(id,Set.empty,Set.make [Accept])\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tlet lr0Actions : lr0Action set = buildLR0ReductionActions lr0State cfg in\r\n\t\t\t\t\t\t\t(id,Set.empty, lr0Actions)\t\r\n\t\t\telse  \r\n\t\t\t\tlet nextShifts = Set.map (fun (a,b,(cId,c)) -> (b,cId)) stateTransitions in\r\n\t\t\t\t\tif(countCompleteLR0Items lr0State = 0) then (* Não existem reducoes *)\r\n\t\t\t\t\t\t\t(id, nextShifts, Set.make[Shift])\r\n\t\t\t\t\telse (* Existem reducoes e transferencias *)\r\n\t\t\t\t\t\tlet lr0Actions = buildLR0MixedActions lr0State cfg in\r\n\t\t\t\t\t\t\t(id, nextShifts, lr0Actions)\t\r\n\t\t\r\n\r\n\tlet makeLR0TableExt (labeledDiagram:lr0DiagramId) cfg : lr0TableExt = (* recebe um diagrama numerado e constroi a tabela de parsing a partir das transições *) \r\n\t\tlet (statesId, transitionsId) = labeledDiagram in\r\n\t\t\tSet.map (fun s -> makeLR0TableEntryExt s cfg transitionsId) statesId\r\n\t\t\t\r\n\tlet getLR0TableExt cfg : lr0TableExt =\r\n\t\tmakeLR0TableExt (makeLR0DiagramId (makeLR0Diagram cfg)) cfg \r\n\r\n\t\t\r\nend\t\t\r\n\t(* ----- SLR1 -----*)\r\nmodule SLR1Grammar =\r\nstruct\r\n\topen LRAux\r\n\topen LR0Grammar\r\n\ttype t = ContextFreeGrammarBasic.t\r\n\t\r\n(*\r\n\ttype lr0Item = LR0Grammar.lr0Item\t\t\r\n\ttype lr0State = LR0Grammar.lr0State\t\r\n\ttype lr0Diagram = LR0Grammar.lr0Diagram\t\r\n\t\r\n\ttype stateName = LR0Grammar.stateName\r\n\t\r\n\ttype lr0StateId = LR0Grammar.lr0StateId\t\r\n\ttype lr0DiagramId = LR0Grammar.lr0DiagramId\t\t\r\n*)\r\n\t\r\n\ttype slr1Action = Accept | Shift | Reduce of rule \r\n\ttype slr1TableEntry = stateName * (symbol * stateName) set * (symbol * slr1Action set ) set\r\n\ttype slr1Table = slr1TableEntry set\r\n\t\r\n\tlet kernelAdvanceItem {head=h; body1=b1; body2=b2} = (* função auxiliar para avançar o ponto de um item em um simbolo para o nucleo do proximo estado. Ex: A ->.ab para A -> a.b *)\r\n\t\tmatch b2 with\r\n\t\t| [] -> Error.fatal \"kernelAdvanceItem: Este caso nem deve ser alcançavel\"\r\n\t\t| x::xs -> {head = h; body1 = b1 @ [x]; body2 = xs} \r\n\t\r\n\tlet getNextSymbolForLR0Item (it:lr0Item)  =\r\n\t\tmatch it.body2 with\r\n\t\t| [] -> epsilon\r\n\t\t| x::xs -> x\r\n\t\r\n\t(*\r\n\tlet follow w = (* Injected follow to test SLR1 grammars*)\r\n\t\tmatch w with\r\n\t\t| [] -> Set.make [dollar] (* Não deve acontecer*)\r\n\t\t| x::xs -> \r\n\t\t\tif(x = symb \"A\") then Set.make [symb \"c\"]\r\n\t\t\telse if(x = symb \"B\") then Set.make [symb \"d\"]\r\n\t\t\telse if(x = symb \"X\") then Set.make [dollar]\r\n\t\t\telse Set.make [dollar]\r\n    *)\r\n\t\t\t\r\n\tlet followSetForSLR1Item it cfg =\r\n\t\tContextFreeGrammarBasic.follow it.head false cfg\r\n\t\t\r\n\tlet isCompleteLR0Item (it:lr0Item) =\r\n\t\tit.body2 = []\r\n\r\n\tlet countCompleteLR0Items lr0State = \r\n\t\tlet completeItems = Set.filter(isCompleteLR0Item) lr0State in\r\n\t\t\tSet.size completeItems\t\r\n\t\t\t\r\n\tlet buildSLR1ReductionActionsForOne completeItems symbol cfg = (* Warning, input must only contain complete items *)\r\n\t\tlet reductionItems = Set.filter(fun it -> Set.belongs symbol (followSetForSLR1Item it cfg)) completeItems in\r\n\t\t\tSet.map (fun it -> Reduce ({head = it.head;body = it.body1}) ) reductionItems\t\r\n\t\t\t\r\n\r\n\r\n\tlet buildSLR1ReductionActions completeItems alphabet cfg= \r\n\t\tSet.map(fun symbol -> (symbol, buildSLR1ReductionActionsForOne completeItems symbol cfg) ) alphabet\r\n\t\r\n\t\r\n\t\r\n\tlet buildSLR1ShiftActionsForOne items symbol : slr1Action set = \r\n\t\tlet shiftItems = Set.filter(fun it -> (getNextSymbolForLR0Item it) = symbol) items in\r\n\t\tif(Set.size shiftItems > 0) then\r\n\t\t\tSet.make [Shift]\r\n\t\telse\r\n\t\t\tSet.empty\r\n\t\t\t\r\n\r\n\r\n\tlet buildSLR1ShiftActions completeItems alphabet = \r\n\t\tSet.map(fun symbol -> (symbol, buildSLR1ShiftActionsForOne completeItems symbol) ) alphabet\r\n\t\r\n\t\t\t\r\n\tlet buildSLR1MixedActionsForOne items symbol cfg= \r\n\t\tlet reductionItems = Set.filter(fun it -> (Set.belongs symbol (followSetForSLR1Item it cfg)) && isCompleteLR0Item it) items in\r\n\t\tlet fixedreductionItems = Set.filter (fun it-> it.head != cfg.initial) reductionItems in (* Porque este fixed? R: Porque os items de accept podem ser interpretados como reduções. logo vamos ter de separar estes items *)\r\n\t\tlet acceptItems = Set.filter (fun it -> it.head = cfg.initial && symbol = dollar && isCompleteLR0Item it && (Set.belongs it fixedreductionItems) = false) items in\r\n\t\tlet shiftItems = Set.filter(fun it -> (getNextSymbolForLR0Item it) = symbol) items in\r\n\t\tlet reductionEntries = Set.map (fun it -> Reduce ({head = it.head;body = it.body1}) ) fixedreductionItems in\r\n\t\t\r\n\t\tif(Set.size acceptItems > 0) then\r\n\t\t\tif(Set.size shiftItems > 0) then\r\n\t\t\t\tSet.union (Set.union (Set.make [Shift]) reductionEntries) (Set.make [Accept])\r\n\t\t\telse\r\n\t\t\t\tSet.union reductionEntries (Set.make [Accept])\r\n\t\telse\t\r\n\t\t\tif(Set.size shiftItems > 0) then\r\n\t\t\t\tSet.union (Set.make [Shift]) reductionEntries\r\n\t\t\telse\r\n\t\t\t\treductionEntries\r\n\r\n\tlet buildSLR1MixedActions (items:lr0State) alphabet cfg= (* True build function - prototype *) (* transformar na forma do buildLR1ReductionActions *)\r\n\t\tSet.map(fun symbol -> (symbol, buildSLR1MixedActionsForOne items symbol cfg) ) alphabet\r\n\t\r\n\t\t\t\r\n\t\t\t\r\n\tlet makeSLR1TableEntry (id, lr0State) (cfg:t) transitions = \r\n\t\tlet stateTransitions = Set.filter (fun ((a,_),_,_)-> a = id) transitions in\r\n\t\t\tif Set.size stateTransitions = 0 then\r\n\t\t\t\tlet {head = h;body1 = b1;body2 = b2} = List.hd (Set.toList lr0State) in\r\n\t\t\t\t\tif h = cfg.initial then \r\n\t\t\t\t\t\tlet slr1Actions : (symbol * slr1Action set) set = Set.make [dollar,Set.make [Accept]] in\r\n\t\t\t\t\t\t\t(id,Set.empty,slr1Actions)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tlet completeAlphabet = Set.add dollar cfg.alphabet in (* Se o $, final da palavra, não estiver no alfabeto da gramática *)\r\n\t\t\t\t\t\tlet slr1Actions : (symbol * slr1Action set) set = buildSLR1ReductionActions lr0State completeAlphabet cfg in\r\n\t\t\t\t\t\t\t(id,Set.empty, slr1Actions)\t\r\n\t\t\telse  \r\n\t\t\t\tlet nextShifts = Set.map (fun (a,b,(cId,c)) -> (b,cId)) stateTransitions in\r\n\t\t\t\t\tif(countCompleteLR0Items lr0State = 0) then (* Não existem reducoes *)\r\n\t\t\t\t\t\tlet slr1Actions = buildSLR1ShiftActions lr0State cfg.alphabet in\r\n\t\t\t\t\t\t\t(id, nextShifts, slr1Actions)\r\n\t\t\t\t\telse (* Existem reducoes e transferencias *)\r\n\t\t\t\t\t\tlet completeAlphabet = Set.add dollar cfg.alphabet in (* Se o $, final da palavra, não estiver no alfabeto da gramática *)\r\n\t\t\t\t\t\tlet slr1Actions = buildSLR1MixedActions lr0State completeAlphabet cfg in\r\n\t\t\t\t\t\t\t(id, nextShifts, slr1Actions)\t\r\n\t\t\r\n\t\r\n\t(*pre: isLR1 cfg *)\r\n\r\n\tlet makeSLR1Table (labeledDiagram:lr0DiagramId) cfg : slr1Table = (* recebe um diagrama numerado e constroi a tabela de parsing a partir das transições *) \r\n\t\tlet (statesId, transitionsId) = labeledDiagram in\r\n\t\t\tSet.map (fun s -> makeSLR1TableEntry s cfg transitionsId) statesId\r\n\t\t\t\r\n\t\t\t\r\n\t\t\r\n\t\t\r\n\tlet rec parseOperationSLR1 slr1Table word stateStack symbolStack (cfg:t) = \r\n\t\tlet currentState = int_of_string(List.hd stateStack) in \r\n\t\tlet (id,shifts,actionSet) = Set.nth slr1Table currentState in (* get corresponding table entry *)\r\n\t\tlet topSymbol = List.nth word 0 in\r\n\t\t\tif(Set.belongs topSymbol cfg.variables) then (*Fazemos um Shift com uma variavel*)\r\n\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = topSymbol) shifts in\r\n\t\t\t\t\tif(Set.size targetShifts = 0) then false\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\r\n\t\t\t\t\t\tlet nextStateStack = [nextState] @ stateStack in\r\n\t\t\t\t\t\tlet nextSymbolStack = [nextSymbol] @ symbolStack in\r\n\t\t\t\t\t\t\tparseOperationSLR1 slr1Table (getTail word) nextStateStack nextSymbolStack cfg\r\n\t\t\telse \r\n\t\t\t\tlet peekedSymbol = List.nth word 0 in\r\n\t\t\t\tlet peekedsymbolAndActions = Set.filter( fun (s,a) -> s = peekedSymbol && Set.size a > 0 ) actionSet in\r\n\t\t\t\tlet nEntries = Set.size peekedsymbolAndActions in\r\n\t\t\t\t\tif nEntries = 0 then \r\n\t\t\t\t\t\tfalse\r\n\t\t\t\t\telse if nEntries > 1 then\r\n\t\t\t\t\t\tError.fatal \"ParseOperationLR1: conflito\"\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tlet (symbol,actions) = Set.hd peekedsymbolAndActions in (* atualmente está a falhar aqui, com hd failure *)\r\n\t\t\t\t\t\tlet action = Set.hd actions in\r\n\t\t\t\t\t\tmatch action with\r\n\t\t\t\t\t\t| Shift -> \r\n\t\t\t\t\t\t\tbegin\r\n\t\t\t\t\t\t\t\tmatch word with\r\n\t\t\t\t\t\t\t\t| [] -> false\r\n\t\t\t\t\t\t\t\t| s::_ -> \r\n\t\t\t\t\t\t\t\t\tif(Set.belongs s cfg.alphabet || Set.belongs s cfg.variables) then\r\n\t\t\t\t\t\t\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = s) shifts in\r\n\t\t\t\t\t\t\t\t\t\t\tif(Set.size targetShifts = 0) then false\r\n\t\t\t\t\t\t\t\t\t\t\t(* Error.fatal (String.of_seq (List.to_seq ([char_of_int ((int_of_char '0') + currentState)] @ [s]))) *)\r\n\t\t\t\t\t\t\t\t\t\t\t(* para testar Error.fatal (String.of_seq (List.to_seq [s])) (* Casos corretos estão a ir parar aqui por alguma razão, provavelmente após uma redução *) *)\r\n\t\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet nextStateStack = [nextState] @ stateStack in\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet nextSymbolStack = [nextSymbol] @ symbolStack in\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tparseOperationSLR1 slr1Table (getTail word) nextStateStack nextSymbolStack cfg\r\n\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\tError.fatal \"ParseOperationSLR1: este simbolo não pertence ao alfabeto desta gramatica\"\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t| Accept -> \r\n\t\t\t\t\t\t\tword = [dollar]\t\r\n\t\t\t\t\t\t| Reduce({head = h;body = b}) -> \r\n\t\t\t\t\t\t\tlet popNumber = List.length b in\r\n\t\t\t\t\t\t\tlet nextStateStack = (pop popNumber stateStack) in\r\n\t\t\t\t\t\t\tlet nextSymbolStack = (pop popNumber symbolStack) in\r\n\t\t\t\t\t\t\tlet wordWithAddedHead = [h] @ word in\r\n\t\t\t\t\t\t\t\tparseOperationSLR1 slr1Table (wordWithAddedHead) nextStateStack nextSymbolStack cfg (*Add the variable, aka head of the reduction rule, to the word being processed *)\r\n\t\t\t\r\n\t(* pre: isSLR1 cfg \r\n\t   pre: isWordValid word cfg *)\r\n\tlet acceptWordSLR1 (word:symbol list) cfg : bool = \r\n\t\tlet slr1Table = makeSLR1Table (LR0Grammar.makeLR0DiagramId (LR0Grammar.makeLR0Diagram cfg)) cfg in\r\n\t\tlet stateRevStack = [\"0\"] in (*char list due to mix of numbers and symbols *) \r\n\t\tlet symbolRevStack : symbol list = [] in\r\n\t\t\tparseOperationSLR1 slr1Table (word @ [dollar]) stateRevStack symbolRevStack cfg\t\r\n\t\t\t\r\n\t(* Added functions to provide a step-by step SLR1 visualization of accepting *)\r\n\r\n\ttype slr1TableStep = symbol list * string list * symbol list * slr1Table * bool\r\n\t\r\n\tlet acceptWordSLR1Init (word:symbol list) cfg : slr1TableStep =\r\n\t\tlet slr1Table = makeSLR1Table (LR0Grammar.makeLR0DiagramId (LR0Grammar.makeLR0Diagram cfg)) cfg in\r\n\t\tlet stateRevStack = [\"0\"] in (*char list due to mix of numbers and symbols *) \r\n\t\tlet symbolRevStack : symbol list = [] in\r\n\t\tlet valid = true in\r\n\t\tlet initStep = ((word @ [dollar]),stateRevStack,symbolRevStack,slr1Table,valid) in\r\n\t\t\tinitStep\r\n\t\r\n\tlet parseStepSLR1Operation (step:slr1TableStep) (cfg:t) : slr1TableStep = \r\n\t\tlet (word, stateStack, symbolStack, slr1Table, valid) = step in\r\n\t\tlet currentState = int_of_string(List.hd stateStack) in \r\n\t\tlet (id,shifts,actionSet) = Set.nth slr1Table currentState in (* get corresponding table entry *)\r\n\t\tlet topSymbol = List.nth word 0 in\r\n\t\t\tif(Set.belongs topSymbol cfg.variables) then (*Fazemos um Shift com uma variavel*)\r\n\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = topSymbol) shifts in\r\n\t\t\t\t\tif(Set.size targetShifts = 0) then (word, stateStack, symbolStack, slr1Table, false)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\r\n\t\t\t\t\t\tlet nextStateStack = [nextState] @ stateStack in\r\n\t\t\t\t\t\tlet nextSymbolStack = [nextSymbol] @ symbolStack in\r\n\t\t\t\t\t\tlet nextStep = ((getTail word), nextStateStack, nextSymbolStack, slr1Table, valid) in\r\n\t\t\t\t\t\t\tnextStep\r\n\t\t\telse \r\n\t\t\t\tlet peekedSymbol = List.nth word 0 in\r\n\t\t\t\tlet peekedsymbolAndActions = Set.filter( fun (s,a) -> s = peekedSymbol && Set.size a > 0 ) actionSet in\r\n\t\t\t\tlet nEntries = Set.size peekedsymbolAndActions in\r\n\t\t\t\t\tif nEntries = 0 then \r\n\t\t\t\t\t\t(word, stateStack, symbolStack, slr1Table, false)\r\n\t\t\t\t\telse if nEntries > 1 then\r\n\t\t\t\t\t\tError.fatal \"parseStepSLR1Operation: conflito\"\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tlet (symbol,actions) = Set.hd peekedsymbolAndActions in (* atualmente está a falhar aqui, com hd failure *)\r\n\t\t\t\t\t\tlet action = Set.hd actions in\r\n\t\t\t\t\t\tmatch action with\r\n\t\t\t\t\t\t| Shift -> \r\n\t\t\t\t\t\t\tbegin\r\n\t\t\t\t\t\t\t\tmatch word with\r\n\t\t\t\t\t\t\t\t| [] -> (word, stateStack, symbolStack, slr1Table, false)\r\n\t\t\t\t\t\t\t\t| s::_ -> \r\n\t\t\t\t\t\t\t\t\tif(Set.belongs s cfg.alphabet || Set.belongs s cfg.variables) then\r\n\t\t\t\t\t\t\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = s) shifts in\r\n\t\t\t\t\t\t\t\t\t\t\tif(Set.size targetShifts = 0) then (word, stateStack, symbolStack, slr1Table, false)\r\n\t\t\t\t\t\t\t\t\t\t\t(* Error.fatal (String.of_seq (List.to_seq ([char_of_int ((int_of_char '0') + currentState)] @ [s]))) *)\r\n\t\t\t\t\t\t\t\t\t\t\t(* para testar Error.fatal (String.of_seq (List.to_seq [s])) (* Casos corretos estão a ir parar aqui por alguma razão, provavelmente após uma redução *) *)\r\n\t\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet nextStateStack = [nextState] @ stateStack in\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet nextSymbolStack = [nextSymbol] @ symbolStack in\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet nextStep = ((getTail word), nextStateStack, nextSymbolStack, slr1Table, valid) in\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tnextStep\r\n\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\tError.fatal \"parseStepSLR1Operation: este simbolo não pertence ao alfabeto desta gramatica\"\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t| Accept -> \r\n\t\t\t\t\t\t\tif (word = [dollar]) then\r\n\t\t\t\t\t\t\t\t((getTail word), stateStack, symbolStack, slr1Table, valid)\r\n\t\t\t\t\t\t\telse \r\n\t\t\t\t\t\t\t\t((getTail word), stateStack, symbolStack, slr1Table, false)\r\n\t\t\t\t\t\t| Reduce({head = h;body = b}) -> \r\n\t\t\t\t\t\t\tlet popNumber = List.length b in\r\n\t\t\t\t\t\t\tlet nextStateStack = (pop popNumber stateStack) in\r\n\t\t\t\t\t\t\tlet nextSymbolStack = (pop popNumber symbolStack) in\r\n\t\t\t\t\t\t\tlet wordWithAddedHead = [h] @ word in\r\n\t\t\t\t\t\t\tlet nextStep = (wordWithAddedHead, nextStateStack, nextSymbolStack, slr1Table, valid) in\r\n\t\t\t\t\t\t\t\tnextStep\r\n\t\t\r\n\t\r\n\t\r\n\t\r\n\t\t\r\n\tlet acceptWordSLR1Step (step:slr1TableStep) cfg : slr1TableStep = \r\n\t\t\tparseStepSLR1Operation step cfg\r\n\t\t\t\t\t\r\n\t\t\t\r\n\t(* updated accept *)\r\n\ttype trueslr1TableStep = symbol list * string list * slr1Table * string\r\n\t\r\n\tlet acceptWordSLR1InitV2 (word:symbol list) cfg : trueslr1TableStep =\r\n\t\tlet slr1Table = makeSLR1Table (LR0Grammar.makeLR0DiagramId (LR0Grammar.makeLR0Diagram cfg)) cfg in\r\n\t\tlet revStack = [\"0\"] in \r\n\t\tlet valid = \"Ongoing\" in\r\n\t\tlet initStep = ((word @ [dollar]),revStack,slr1Table,valid) in\r\n\t\t\tinitStep\r\n\t\r\n\tlet parseStepSLR1OperationV2 (step:trueslr1TableStep) (cfg:t) : trueslr1TableStep = \r\n\t\tlet (word, revStack, slr1Table, valid) = step in\r\n\t\t(*print_string (List.hd revStack ^ \"\\n\");\r\n\t\tprint_string (valid); *)\r\n\t\tlet currentState = int_of_string(List.hd revStack) in \r\n\t\tlet (id,shifts,actionSet) = Set.nth slr1Table currentState in (* get corresponding table entry *)\r\n\t\t(* print_string ((word2str word) ^ \"\\n\"); *)\r\n\t\tif(List.length word = 0) then\r\n\t\t\t(word, revStack, slr1Table, \"Rejeitada\")\r\n\t\telse\r\n\t\t\tlet topSymbol = List.nth word 0 in\r\n\t\t\t\tif(Set.belongs topSymbol cfg.variables) then (*Fazemos um Shift com uma variavel*)\r\n\t\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = topSymbol) shifts in\r\n\t\t\t\t\t\tif(Set.size targetShifts = 0) then (word, revStack, slr1Table, \"Rejeitada\")\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\r\n\t\t\t\t\t\t\tlet nextRevStack = [nextState] @ [symb2str nextSymbol] @ revStack in\r\n\t\t\t\t\t\t\tlet nextStep = ((getTail word), nextRevStack, slr1Table, valid) in\r\n\t\t\t\t\t\t\t\tnextStep\r\n\t\t\t\telse \r\n\t\t\t\t\tlet peekedSymbol = List.nth word 0 in\r\n\t\t\t\t\tlet peekedsymbolAndActions = Set.filter( fun (s,a) -> s = peekedSymbol && Set.size a > 0 ) actionSet in\r\n\t\t\t\t\tlet nEntries = Set.size peekedsymbolAndActions in\r\n\t\t\t\t\t\tif nEntries = 0 then \r\n\t\t\t\t\t\t\t(word, revStack, slr1Table, \"Rejeitada\")\r\n\t\t\t\t\t\telse if nEntries > 1 then\r\n\t\t\t\t\t\t\t(word, revStack, slr1Table, \"Conflito\")\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tlet (symbol,actions) = Set.hd peekedsymbolAndActions in (* atualmente está a falhar aqui, com hd failure *)\r\n\t\t\t\t\t\t\t(* Durante o accept, se encontrar um conflito, para imediatamente e retorna \"... Conflito ...\" AMD *)\r\n\t\t\t\t\t\t\tif Set.size actions > 1 then (* NEW *)\r\n\t\t\t\t\t\t\t\t(word, revStack, slr1Table, \"Conflito\")\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tlet action = Set.hd actions in\r\n\t\t\t\t\t\t\tmatch action with\r\n\t\t\t\t\t\t\t| Shift -> \r\n\t\t\t\t\t\t\t\tbegin\r\n\t\t\t\t\t\t\t\t\tmatch word with\r\n\t\t\t\t\t\t\t\t\t| [] -> (word, revStack, slr1Table, \"Rejeitada\")\r\n\t\t\t\t\t\t\t\t\t| s::_ -> \r\n\t\t\t\t\t\t\t\t\t\tif(Set.belongs s cfg.alphabet || Set.belongs s cfg.variables) then\r\n\t\t\t\t\t\t\t\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = s) shifts in\r\n\t\t\t\t\t\t\t\t\t\t\t\tif(Set.size targetShifts = 0) then (word, revStack, slr1Table, \"Rejeitada\")\r\n\t\t\t\t\t\t\t\t\t\t\t\t(* Error.fatal (String.of_seq (List.to_seq ([char_of_int ((int_of_char '0') + currentState)] @ [s]))) *)\r\n\t\t\t\t\t\t\t\t\t\t\t\t(* para testar Error.fatal (String.of_seq (List.to_seq [s])) (* Casos corretos estão a ir parar aqui por alguma razão, provavelmente após uma redução *) *)\r\n\t\t\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet nextRevStack = [nextState] @ [symb2str nextSymbol] @ revStack in\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet nextStep = ((getTail word), nextRevStack, slr1Table, valid) in\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnextStep\r\n\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t\t(word, revStack, slr1Table, \"Simbolo Inválido\")\r\n\t\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\t| Accept -> \r\n\t\t\t\t\t\t\t\tif (word = [dollar]) then\r\n\t\t\t\t\t\t\t\t\t((getTail word), [symb2str cfg.initial], slr1Table, \"Aceite\")\r\n\t\t\t\t\t\t\t\telse \r\n\t\t\t\t\t\t\t\t\t((word), revStack, slr1Table, \"Rejeitada\")\r\n\t\t\t\t\t\t\t| Reduce({head = h;body = b}) -> \r\n\t\t\t\t\t\t\t\tlet popNumber = List.length b in\r\n\t\t\t\t\t\t\t\tlet nextRevStack = pop (popNumber*2) revStack in\r\n\t\t\t\t\t\t\t\tlet wordWithAddedHead = [h] @ word in\r\n\t\t\t\t\t\t\t\tlet nextStep = (wordWithAddedHead, nextRevStack, slr1Table, valid) in\r\n\t\t\t\t\t\t\t\t\tnextStep\r\n\t\t\r\n\t\r\n\t\r\n\t\r\n\t\t\r\n\tlet acceptWordSLR1StepV2 (step:trueslr1TableStep) cfg : trueslr1TableStep = \r\n\t\t\tparseStepSLR1OperationV2 step cfg\r\n\t\t\t\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\r\n\tlet entryHasConflict slr1TableEntry : bool =\r\n\t\tlet (id,shifts,actionSet) = slr1TableEntry in\r\n\t\tlet entryConflicts = Set.filter ( fun (_, actions) -> Set.size actions > 1) actionSet in\r\n\t\t\tnot (Set.isEmpty entryConflicts)\r\n\t\r\n\tlet isSLR1 cfg : bool =\r\n\t\tlet slr1Table = makeSLR1Table (makeLR0DiagramId (makeLR0Diagram cfg)) cfg in\r\n\t\tlet conflicts = Set.filter (entryHasConflict) slr1Table in\r\n\t\t\tSet.isEmpty conflicts\r\n\t\t\t\r\n\t\t\t\r\n\tlet getSLR1DiagramId cfg : lr0DiagramId = (* igual ao LR0 *)\r\n\t\tmakeLR0DiagramId (makeLR0Diagram cfg)\r\n\t\t\r\n\tlet getSLR1Table cfg : slr1Table =\r\n\t\tmakeSLR1Table (makeLR0DiagramId (makeLR0Diagram cfg)) cfg \r\n\r\nend\r\n\t(* ----- LR1 -----*)\r\nmodule LR1Grammar =\r\nstruct\r\n\topen LRAux\r\n\ttype t = ContextFreeGrammarBasic.t\r\n\t\r\n\ttype lr1Item = {head:symbol; body1:symbol list; body2:symbol list; lookahead:symbols}\t\r\n\ttype lr1State = lr1Item set\r\n\ttype lr1Diagram = lr1State set * (lr1State * symbol * lr1State ) set\r\n\t\r\n\ttype stateName = string\r\n\ttype lr1StateId = stateName * lr1State \r\n\ttype lr1DiagramId = lr1StateId set * (lr1StateId * symbol * lr1StateId ) set\r\n\t\r\n\r\n\ttype lr1Action = Accept | Shift | Reduce of rule\r\n\ttype lr1TableEntry = stateName * (symbol * stateName) set * (symbol * lr1Action set ) set (* talvez seja (symbol * lr1Action set ) set *)\r\n\ttype lr1Table = lr1TableEntry set\r\n\t\r\n\tlet isCompleteLR1Item {head=h; body1=b1; body2=b2;lookahead=l} =\r\n\t\tb2 = []\r\n\r\n\tlet countCompleteLR1Items lr1State = \r\n\t\tlet completeItems = Set.filter(isCompleteLR1Item) lr1State in\r\n\t\t\tSet.size completeItems\r\n\t\t\t\r\n\t\t\t\r\n\tlet getNextSymbolForLR1Item {head=h; body1=b1; body2=b2;lookahead=l}  =\r\n\t\tmatch b2 with\r\n\t\t| [] -> epsilon\r\n\t\t| x::xs -> x\r\n\t\t\r\n\tlet getDirectorLR1 {head=_; body1=_; body2=b2; lookahead=l} = (* obtem o simbolo diretor de um item *)\r\n\t\tmatch b2 with \r\n\t\t\t| [] -> epsilon (* epsilon, aka no symbol *) \r\n\t\t\t| x::_ -> x\r\n\t\t\t\r\n\t(*\r\n\tlet first symbols = (* Injected first to test LR1 grammars lookahead - Luis Monteiro *)\r\n\t\tmatch symbols with\r\n\t\t| [] -> Set.make ['$'] (* Não deve acontecer*)\r\n\t\t| x::xs -> \r\n\t\t\tif(x = 'A') then ['$';'a';'b']\r\n\t\t\telse if(x = 'B') then ['a';'b']\r\n\t\t\telse if(x = 'a') then ['a']\r\n\t\t\telse ['b']\r\n\t*)\t\t\r\n\t(*\t\t\r\n\tlet first symbols = (* Injected first to test LALR1 grammars lookahead - Luis Monteiro *)\r\n\t\tmatch symbols with\r\n\t\t| [] -> Set.make [dollar] (* Não deve acontecer*)\r\n\t\t| x::xs -> \r\n\t\t\tif(x = symb \"X\") then Set.make [symb \"c\"; symb \"d\"]\r\n\t\t\telse if(x = symb \"C\") then Set.make [symb \"c\"; symb \"d\"]\r\n\t\t\telse if(x = symb \"c\") then Set.make [symb \"c\"]\r\n\t\t\telse Set.make [symb \"d\"]\r\n\t*)\r\n\tlet getDirectorWithLookaheadLR1 {head=_; body1=_; body2=b2; lookahead=l} cfg = (* obtem o simbolo diretor de um item *)\r\n\t\tmatch b2 with \r\n\t\t\t| [] -> (epsilon,Set.empty) (* epsilon, aka no symbol *) \r\n\t\t\t| x::xs -> if(List.length b2 > 1) then (x,ContextFreeGrammarBasic.first xs true cfg) else (x,l)\t\r\n\t\t\t\r\n\t\t\t\r\n\tlet getDirectorsLR1 state = (* Aplica a função getDirector a todos os itens de um dado estado*)\r\n\t\tSet.filter (fun d-> d <> epsilon)(Set.map getDirectorLR1 state)\r\n\t\t\t\r\n\t(* função auxiliar para avançar o ponto de um item em um simbolo para\r\n\t    o nucleo do proximo estado. Ex: A ->.ab para A -> a.b *)\r\n\tlet kernelAdvanceLR1Item {head=h; body1=b1; body2=b2;lookahead = l} =\r\n\t\tmatch b2 with\r\n\t\t| [] -> Error.fatal \"kernelAdvanceItem: Este caso nem deve ser alcançavel\"\r\n\t\t| x::xs -> {head = h; body1 = b1 @ [x]; body2 = xs;lookahead = l} \r\n\t\t\t\r\n\tlet buildLR1Item {head=h; body1=b1; body2=b2; lookahead=_} lookahead =\r\n\t\t{head=h; body1=b1; body2=b2; lookahead=lookahead}\r\n\t\t\t\t\r\n\tlet getDirectorsWithLookaheadLR1 (state:lr1State) cfg = (* Aplica a função getDirectorWithLookaheadLR1 a todos os itens de um dado estado*)\r\n\t\tSet.filter (fun (d,l)-> d <> epsilon)(Set.map (fun it -> getDirectorWithLookaheadLR1 it cfg) state) \r\n\t\t\r\n\tlet hasSameCore {head=h1; body1=b1; body2=b2; lookahead=l1} {head=h2; body1=b21; body2=b22; lookahead=l2} = \r\n\t\t(h1 = h2 && b1 = b21 && b2 = b22)\r\n\t\t\r\n\tlet mergeTwoItemsWithSameCore {head=h1; body1=b1; body2=b2; lookahead=l1} {head=h2; body1=b21; body2=b22; lookahead=l2} =\r\n\t\tlet combinedLookahead = Set.union l1 l2 in\r\n\t\t{head=h1; body1=b1;body2=b2;lookahead=combinedLookahead}\r\n\t\t\r\n\tlet mergeOneItem item currentItems = (* careful with the args order*)\r\n\t\tlet (a,b) = Set.partition (fun i -> hasSameCore item i ) currentItems in\r\n\t\t\tif Set.size a = 0 then Set.add item currentItems\r\n\t\t\telse Set.add (mergeTwoItemsWithSameCore (Set.hd a) item) b\t\r\n\t\t\t\r\n\t(*\r\n\tlet mergeItems2 currentItems newItems =\r\n\t\tlet rec process currentItems newItems =\r\n\t\t\tmatch newItems with\r\n\t\t\t| [] -> currentItems \r\n\t\t\t| i::is -> process (mergeOneItem i currentItems) is \r\n\t\tin\r\n\t\t\tprocess currentItems (Set.toList newItems) \t\t\r\n\t*)\r\n\t\r\n\t\t\t\r\n\tlet rec mergeItems currentItems newItems =\r\n\t\tif Set.isEmpty newItems then\r\n\t\t\tcurrentItems\r\n\t\telse\r\n\t\t\tlet (i,is) = Set.cut newItems in\r\n\t\t\t\tmergeItems (mergeOneItem i currentItems) is \r\n\t\r\n\t(*\t\t\t\r\n\tlet rec mergeItems currentItems newItems =\r\n\t\tSet.match_ newItems \r\n\t\t\t(fun () -> currentItems)\r\n\t\t\t(fun i is -> mergeItems (mergeOneItem i currentItems) is)\r\n\t*)\r\n\t\r\n\tlet rule2ItemLR1 (rule: rule) lookahead =\r\n\t\t{head = rule.head; body1 = []; body2 = rule.body; lookahead = lookahead} \r\n\t\r\n\tlet generateItemsForVarDirectorWithLookahead director rules lookahead = \r\n\t\tlet itemRules = Set.filter (fun {head = h; body =_} -> h = director) rules in \r\n\t\tlet items = Set.map (fun r -> rule2ItemLR1 r lookahead) itemRules in\t\r\n\t\t\titems\r\n\t\t\t\r\n\tlet diagramsJoin2LR1 (s0,t0) (s1,t1) = (Set.union s0 s1, Set.union t0 t1) (* juntar dois diagramas LR0 para obter um diagrama LR0 resultante da união *)\t\r\n\t\r\n\tlet rec diagramsJoinListLR1 l : lr1Diagram = (* Juntar um conjunto de diagramas para produzir o diagrama LR0, cada diagrama desta lista corresponde a um estado rescrito como diagrama *)\r\n\t\tmatch l with\r\n\t\t| [] -> (Set.empty , Set.empty) \r\n\t\t| d::ds -> diagramsJoin2LR1 d (diagramsJoinListLR1 ds)\r\n\t\r\n\t\r\n\t\r\n\tlet makeLR1DiagramId diagram : lr1DiagramId (* Cria etiquetas para os estados e os mesmos estados contidos nas transições do diagrama*) =\r\n\t\tlet (states,transitions) = diagram in\r\n\t\tlet dictionary = List.combine (Set.toList states) (nats (Set.size states)) in\r\n\t\tlet statesId = Set.map (fun s -> (List.assoc s dictionary,s) ) states in\r\n\t\tlet transitionsId = Set.map (fun (a,b,c) -> ((List.assoc a dictionary, a), b,(List.assoc c dictionary, c))) transitions in\r\n\t\t\t(statesId, transitionsId)\r\n\t\r\n\r\n\r\n\r\n\tlet buildLR1ReductionActionsForOne completeItems symbol = (* Warning, input must only contain complete items *)\r\n\t\tlet reductionItems = Set.filter(fun it -> Set.belongs symbol it.lookahead) completeItems in\r\n\t\t\tSet.map (fun it -> Reduce ({head = it.head;body = it.body1}) ) reductionItems\t\r\n\t\t\t\r\n\r\n\r\n\tlet buildLR1ReductionActions completeItems alphabet = \r\n\t\tSet.map(fun symbol -> (symbol, buildLR1ReductionActionsForOne completeItems symbol) ) alphabet\r\n\t\r\n\t\r\n\tlet buildLR1ShiftActionsForOne items symbol : lr1Action set = \r\n\t\tlet shiftItems = Set.filter(fun it -> (getNextSymbolForLR1Item it) = symbol) items in\r\n\t\tif(Set.size shiftItems > 0) then\r\n\t\t\tSet.make [Shift]\r\n\t\telse\r\n\t\t\tSet.empty\r\n\t\t\t\r\n\r\n\r\n\tlet buildLR1ShiftActions completeItems alphabet = \r\n\t\tSet.map(fun symbol -> (symbol, buildLR1ShiftActionsForOne completeItems symbol) ) alphabet\r\n\t\r\n\t\r\n\r\n\tlet buildLR1MixedActionsForOne cfgInitial items symbol = \r\n\t\tlet reductionItems = Set.filter(fun it -> (Set.belongs symbol it.lookahead) && isCompleteLR1Item it) items in\r\n\t\tlet fixedreductionItems = Set.filter (fun it-> it.head != cfgInitial) reductionItems in\r\n\t\tlet acceptItems = Set.filter (fun it -> it.head = cfgInitial && symbol = dollar && isCompleteLR1Item it && (Set.belongs it fixedreductionItems) = false) items in\r\n\t\tlet shiftItems = Set.filter(fun it -> (getNextSymbolForLR1Item it) = symbol) items in\r\n\t\tlet reductionEntries = Set.map (fun it -> Reduce ({head = it.head;body = it.body1}) ) fixedreductionItems in\r\n\t\r\n\t\tif(Set.size acceptItems > 0) then\r\n\t\t\tif(Set.size shiftItems > 0) then\r\n\t\t\t\tSet.union (Set.union (Set.make [Shift]) reductionEntries) (Set.make [Accept])\r\n\t\t\telse\r\n\t\t\t\tSet.union reductionEntries (Set.make [Accept])\r\n\t\telse\t\r\n\t\t\tif(Set.size shiftItems > 0) then\r\n\t\t\t\tSet.union (Set.make [Shift]) reductionEntries\r\n\t\t\telse\r\n\t\t\t\treductionEntries\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\r\n\tlet buildLR1MixedActions cfgInitial (items:lr1State) alphabet = (* True build function - prototype *) (* transformar na forma do buildLR1ReductionActions *)\r\n\t\tSet.map(fun symbol -> (symbol, buildLR1MixedActionsForOne cfgInitial items symbol) ) alphabet\r\n\t\t\r\n\t\t\t\r\n\tlet makeLR1TableEntry (id, lr1State) (cfg:t) transitions = (* possivelmente dar merge aos buildLR1Actions?*)\r\n\t\tlet stateTransitions = Set.filter (fun ((a,_),_,_)-> a = id) transitions in\r\n\t\t\tif Set.size stateTransitions = 0 then (* this part seems fine *)\r\n\t\t\t\tlet {head = h;body1 = b1;body2 = b2;lookahead = l} = List.hd (Set.toList lr1State) in\r\n\t\t\t\t\tif h = cfg.initial then \r\n\t\t\t\t\t\tlet lr1Actions : (symbol * lr1Action set) set = Set.make [dollar,Set.make [Accept]] in\r\n\t\t\t\t\t\t\t(id,Set.empty,lr1Actions)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tlet completeAlphabet = Set.add dollar cfg.alphabet in (* Se o $, final da palavra, não estiver no alfabeto da gramática *)\r\n\t\t\t\t\t\tlet lr1Actions : (symbol * lr1Action set) set = buildLR1ReductionActions lr1State completeAlphabet in\r\n\t\t\t\t\t\t\t(id,Set.empty, lr1Actions)\t\t\r\n\t\t\telse  (* Existem Shifts e possivelmente tambem reducoes *)\r\n\t\t\t\tlet nextShifts = Set.map (fun (a,b,(cId,c)) -> (b,cId)) stateTransitions in\r\n\t\t\t\t\tif(countCompleteLR1Items lr1State = 0) then (* Não existem reducoes *)\r\n\t\t\t\t\t\tlet lr1Actions = buildLR1ShiftActions lr1State cfg.alphabet in\r\n\t\t\t\t\t\t\t(id, nextShifts, lr1Actions)\r\n\t\t\t\t\telse (* Existem reducoes e transferencias *)\r\n\t\t\t\t\t\tlet completeAlphabet = Set.add dollar cfg.alphabet in (* Se o $, final da palavra, não estiver no alfabeto da gramática *)\r\n\t\t\t\t\t\tlet lr1Actions = buildLR1MixedActions cfg.initial lr1State completeAlphabet in\r\n\t\t\t\t\t\t\t(id, nextShifts, lr1Actions)\r\n\t\t\t\t\t\r\n\t\r\n\t(*pre: isLR1 cfg *)\r\n\tlet makeLR1Table (labeledDiagram:lr1DiagramId) cfg : lr1Table = (* recebe um diagrama numerado e constroi a tabela de parsing a partir das transições *) \r\n\t\tlet (statesId, transitionsId) = labeledDiagram in\r\n\t\t\tSet.map (fun s -> makeLR1TableEntry s cfg transitionsId) statesId\r\n\r\n\r\n\t\r\n\t\t\r\n\tlet lr1StateClosureStep (cfg: t) currentItems = (* Create items for current directors *)\r\n\t\tlet directorsWithLookahead : (symbol * symbols) set = getDirectorsWithLookaheadLR1 currentItems cfg in\r\n\t\t\r\n\t\tlet varDirectorsWithLookahead = Set.filter (fun (d,_) -> Set.belongs d cfg.variables) directorsWithLookahead in\r\n\t\tlet newItems = Set.flatMap (fun (d,l) -> generateItemsForVarDirectorWithLookahead d cfg.rules l) varDirectorsWithLookahead in\r\n\t\tlet mergedItems = mergeItems currentItems newItems in\r\n\t\t\tmergedItems\r\n\t\t\r\n\t\t\r\n\tlet rec lr1StateClosure cfg currentItems : lr1State = (* Create all items for a singular state *)\r\n\t\tlet next = lr1StateClosureStep cfg currentItems in\r\n\t\t\tif Set.subset next currentItems then next\r\n\t\t\telse lr1StateClosure cfg next\r\n\t\t\t\r\n\t\t\t\r\n\t\r\n\tlet makeSingularNextLR1Diagram (cfg:t) prevState symbol : lr1Diagram = (* Creates a diagram containing only 1 state using the previous state and the transition symbol*)\r\n\t\tlet items4Kernel = Set.filter (fun it -> getDirectorLR1 it = symbol) prevState in (* falta avançar o ponto *)\r\n\t\tlet kernel = Set.map (kernelAdvanceLR1Item) items4Kernel in\r\n\t\tlet closure = lr1StateClosure cfg kernel in\r\n\t\t\t(Set.make [prevState; closure], Set.make [(prevState ,symbol , closure )])\r\n\t\t\t\t\t\r\n\r\n\t\r\n\tlet makeNextLR1Diagram (cfg:t) prevState : lr1Diagram = (* For each director symbol on the previous state, create a diagram and join all obtained diagrams into a single diagram*)\r\n\t\tlet dirs = getDirectorsLR1 prevState in\r\n\t\tlet diagrams = Set.map (fun d -> makeSingularNextLR1Diagram cfg prevState d) dirs in\r\n\t\t\tdiagramsJoinListLR1 (Set.toList diagrams) \r\n\r\n\t\t\t\r\n\t\t\r\n\tlet makeNextLR1DiagramAll (cfg:t) states : lr1Diagram = (* build the diagram using the initial state, then use the makeNextLR0Diagram function to calculate all states obtainable from the initial state*)\r\n\t\tlet diagrams = Set.map (fun s -> makeNextLR1Diagram cfg s) states in\r\n\t\t\tdiagramsJoinListLR1 (Set.toList diagrams)\r\n\r\n\t\t\r\n\t\t\r\n\tlet rec makeLR1DiagramX (cfg:t) diagram = (* função auxiliar que irá produzir o diagrama LR1 *)\r\n\t\tlet (states,transitions) : lr1Diagram = diagram in \r\n\t\tlet next = makeNextLR1DiagramAll cfg states in\r\n\t\tlet next2 = diagramsJoin2LR1 next (states,transitions) in\r\n\t\tlet (states2,transitions2) = next2 in\r\n\t\t\tif Set.size states = Set.size states2 && Set.size transitions = Set.size transitions2 then next2\r\n\t\t\telse makeLR1DiagramX cfg next2 \r\n\t\t\t\r\n\t\t\t\r\n\tlet makeFirstLR1Diagram (cfg:t) : lr1Diagram = (* O primeiro estado tem um procedimento de criação um pouco differente *) \r\n\t\tlet kernel = Set.map (fun r -> rule2ItemLR1 r (Set.make [dollar])) (LR0Grammar.startRules cfg) in\t\r\n\t\t(*let kernelWithLookahead : lr1Item = buildLR1KernelItems kernel '$' in *)\r\n\t\tlet closure = lr1StateClosure cfg kernel in\r\n\t\t\t(Set.make [closure], Set.empty)\t\r\n\t\r\n\tlet makeLR1Diagram (cfg:t) = makeLR1DiagramX cfg (makeFirstLR1Diagram cfg)  (* ponto de partida na construção do diagrama LR1 *)\r\n\t\r\n\t\r\n\tlet rec parseOperationLR1 lr1Table word stateStack symbolStack (cfg:t) = \r\n\t\tlet currentState = int_of_string(List.hd stateStack) in \r\n\t\tlet (id,shifts,actionSet) = Set.nth lr1Table currentState in (* get corresponding table entry *)\r\n\t\tlet topSymbol = List.nth word 0 in\r\n\t\t\tif(Set.belongs topSymbol cfg.variables) then (*Fazemos um Shift com uma variavel*)\r\n\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = topSymbol) shifts in\r\n\t\t\t\t\tif(Set.size targetShifts = 0) then false\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\r\n\t\t\t\t\t\tlet nextStateStack = [nextState] @ stateStack in\r\n\t\t\t\t\t\tlet nextSymbolStack = [nextSymbol] @ symbolStack in\r\n\t\t\t\t\t\t\tparseOperationLR1 lr1Table (getTail word) nextStateStack nextSymbolStack cfg\r\n\t\t\telse \r\n\t\t\t\tlet peekedSymbol = List.nth word 0 in\r\n\t\t\t\tlet peekedsymbolAndActions = Set.filter( fun (s,a) -> s = peekedSymbol && Set.size a > 0 ) actionSet in\r\n\t\t\t\tlet nEntries = Set.size peekedsymbolAndActions in\r\n\t\t\t\t\tif nEntries = 0 then \r\n\t\t\t\t\t\tfalse\r\n\t\t\t\t\telse if nEntries > 1 then\r\n\t\t\t\t\t\tError.fatal \"ParseOperationLR1: conflito\"\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tlet (symbol,actions) = Set.hd peekedsymbolAndActions in (* atualmente está a falhar aqui, com hd failure *)\r\n\t\t\t\t\t\tlet action = Set.hd actions in\r\n\t\t\t\t\t\tmatch action with\r\n\t\t\t\t\t\t| Shift -> \r\n\t\t\t\t\t\t\tbegin\r\n\t\t\t\t\t\t\t\tmatch word with\r\n\t\t\t\t\t\t\t\t| [] -> false\r\n\t\t\t\t\t\t\t\t| s::_ -> \r\n\t\t\t\t\t\t\t\t\tif(Set.belongs s cfg.alphabet || Set.belongs s cfg.variables) then\r\n\t\t\t\t\t\t\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = s) shifts in\r\n\t\t\t\t\t\t\t\t\t\t\tif(Set.size targetShifts = 0) then false\r\n\t\t\t\t\t\t\t\t\t\t\t(* Error.fatal (String.of_seq (List.to_seq ([char_of_int ((int_of_char '0') + currentState)] @ [s]))) *)\r\n\t\t\t\t\t\t\t\t\t\t\t(* para testar Error.fatal (String.of_seq (List.to_seq [s])) (* Casos corretos estão a ir parar aqui por alguma razão, provavelmente após uma redução *) *)\r\n\t\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet nextStateStack = [nextState] @ stateStack in\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet nextSymbolStack = [nextSymbol] @ symbolStack in\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tparseOperationLR1 lr1Table (getTail word) nextStateStack nextSymbolStack cfg\r\n\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\tError.fatal \"ParseOperationLR1: este simbolo não pertence ao alfabeto desta gramatica\"\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t| Accept -> \r\n\t\t\t\t\t\t\tword = [dollar]\t\r\n\t\t\t\t\t\t| Reduce({head = h;body = b}) -> \r\n\t\t\t\t\t\t\tlet popNumber = List.length b in\r\n\t\t\t\t\t\t\tlet nextStateStack = (pop popNumber stateStack) in\r\n\t\t\t\t\t\t\tlet nextSymbolStack = (pop popNumber symbolStack) in\r\n\t\t\t\t\t\t\tlet wordWithAddedHead = [h] @ word in\r\n\t\t\t\t\t\t\t\tparseOperationLR1 lr1Table (wordWithAddedHead) nextStateStack nextSymbolStack cfg (*Add the variable, aka head of the reduction rule, to the word being processed *)\r\n\t\t\t\t\t\t\t\t\r\n\t\r\n\t(* pre: isLR1 cfg \r\n\t   pre: isWordValid word cfg *)\r\n\tlet acceptWordLR1 (word:symbol list) cfg : bool = \r\n\t\tlet lr1Table = makeLR1Table (makeLR1DiagramId (makeLR1Diagram cfg)) cfg in\r\n\t\tlet stateRevStack = [\"0\"] in (*char list due to mix of numbers and symbols *) \r\n\t\tlet symbolRevStack : symbol list = [] in\r\n\t\t\tparseOperationLR1 lr1Table (word @ [dollar]) stateRevStack symbolRevStack cfg\r\n\t\t\t\r\n\t\t\t\r\n\t(* Added functions to provide a step-by step LR1 visualization of accepting *)\r\n\r\n\ttype lr1TableStep = symbol list * string list * symbol list * lr1Table * bool\r\n\t\r\n\tlet acceptWordLR1Init (word:symbol list) cfg : lr1TableStep =\r\n\t\tlet lr1Table = makeLR1Table (makeLR1DiagramId (makeLR1Diagram cfg)) cfg in\r\n\t\tlet stateRevStack = [\"0\"] in (*char list due to mix of numbers and symbols *) \r\n\t\tlet symbolRevStack : symbol list = [] in\r\n\t\tlet valid = true in\r\n\t\tlet initStep = ((word @ [dollar]),stateRevStack,symbolRevStack,lr1Table,valid) in\r\n\t\t\tinitStep\r\n\t\r\n\tlet parseStepLR1Operation (step:lr1TableStep) (cfg:t) : lr1TableStep = \r\n\t\tlet (word, stateStack, symbolStack, lr1Table, valid) = step in\r\n\t\tlet currentState = int_of_string(List.hd stateStack) in \r\n\t\tlet (id,shifts,actionSet) = Set.nth lr1Table currentState in (* get corresponding table entry *)\r\n\t\tlet topSymbol = List.nth word 0 in\r\n\t\t\tif(Set.belongs topSymbol cfg.variables) then (*Fazemos um Shift com uma variavel*)\r\n\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = topSymbol) shifts in\r\n\t\t\t\t\tif(Set.size targetShifts = 0) then (word, stateStack, symbolStack, lr1Table, false)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\r\n\t\t\t\t\t\tlet nextStateStack = [nextState] @ stateStack in\r\n\t\t\t\t\t\tlet nextSymbolStack = [nextSymbol] @ symbolStack in\r\n\t\t\t\t\t\tlet nextStep = ((getTail word), nextStateStack, nextSymbolStack, lr1Table, valid) in\r\n\t\t\t\t\t\t\tnextStep\r\n\t\t\telse \r\n\t\t\t\tlet peekedSymbol = List.nth word 0 in\r\n\t\t\t\tlet peekedsymbolAndActions = Set.filter( fun (s,a) -> s = peekedSymbol && Set.size a > 0 ) actionSet in\r\n\t\t\t\tlet nEntries = Set.size peekedsymbolAndActions in\r\n\t\t\t\t\tif nEntries = 0 then \r\n\t\t\t\t\t\t(word, stateStack, symbolStack, lr1Table, false)\r\n\t\t\t\t\telse if nEntries > 1 then\r\n\t\t\t\t\t\tError.fatal \"parseStepLR1Operation: conflito\"\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tlet (symbol,actions) = Set.hd peekedsymbolAndActions in (* atualmente está a falhar aqui, com hd failure *)\r\n\t\t\t\t\t\tlet action = Set.hd actions in\r\n\t\t\t\t\t\tmatch action with\r\n\t\t\t\t\t\t| Shift -> \r\n\t\t\t\t\t\t\tbegin\r\n\t\t\t\t\t\t\t\tmatch word with\r\n\t\t\t\t\t\t\t\t| [] -> (word, stateStack, symbolStack, lr1Table, false)\r\n\t\t\t\t\t\t\t\t| s::_ -> \r\n\t\t\t\t\t\t\t\t\tif(Set.belongs s cfg.alphabet || Set.belongs s cfg.variables) then\r\n\t\t\t\t\t\t\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = s) shifts in\r\n\t\t\t\t\t\t\t\t\t\t\tif(Set.size targetShifts = 0) then (word, stateStack, symbolStack, lr1Table, false)\r\n\t\t\t\t\t\t\t\t\t\t\t(* Error.fatal (String.of_seq (List.to_seq ([char_of_int ((int_of_char '0') + currentState)] @ [s]))) *)\r\n\t\t\t\t\t\t\t\t\t\t\t(* para testar Error.fatal (String.of_seq (List.to_seq [s])) (* Casos corretos estão a ir parar aqui por alguma razão, provavelmente após uma redução *) *)\r\n\t\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet nextStateStack = [nextState] @ stateStack in\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet nextSymbolStack = [nextSymbol] @ symbolStack in\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet nextStep = ((getTail word), nextStateStack, nextSymbolStack, lr1Table, valid) in\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tnextStep\r\n\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\tError.fatal \"parseStepLR1Operation: este simbolo não pertence ao alfabeto desta gramatica\"\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t| Accept -> \r\n\t\t\t\t\t\t\tif (word = [dollar]) then\r\n\t\t\t\t\t\t\t\t((getTail word), stateStack, symbolStack, lr1Table, valid)\r\n\t\t\t\t\t\t\telse \r\n\t\t\t\t\t\t\t\t((getTail word), stateStack, symbolStack, lr1Table, false)\r\n\t\t\t\t\t\t| Reduce({head = h;body = b}) -> \r\n\t\t\t\t\t\t\tlet popNumber = List.length b in\r\n\t\t\t\t\t\t\tlet nextStateStack = (pop popNumber stateStack) in\r\n\t\t\t\t\t\t\tlet nextSymbolStack = (pop popNumber symbolStack) in\r\n\t\t\t\t\t\t\tlet wordWithAddedHead = [h] @ word in\r\n\t\t\t\t\t\t\tlet nextStep = (wordWithAddedHead, nextStateStack, nextSymbolStack, lr1Table, valid) in\r\n\t\t\t\t\t\t\t\tnextStep\r\n\t\t\r\n\t\r\n\t\r\n\t\r\n\t\t\r\n\tlet acceptWordLR1Step (step:lr1TableStep) cfg : lr1TableStep = \r\n\t\t\tparseStepLR1Operation step cfg\r\n\t\t\t\r\n\t\t\t\r\n\t(* updated accept *)\r\n\ttype truelr1TableStep = symbol list * string list * lr1Table * string\r\n\t\r\n\tlet acceptWordLR1InitV2 (word:symbol list) cfg : truelr1TableStep =\r\n\t\tlet lr1Table = makeLR1Table (makeLR1DiagramId (makeLR1Diagram cfg)) cfg in\r\n\t\tlet revStack = [\"0\"] in \r\n\t\tlet valid = \"Ongoing\" in\r\n\t\tlet initStep = ((word @ [dollar]),revStack,lr1Table,valid) in\r\n\t\t\tinitStep\r\n\t\r\n\tlet parseStepLR1OperationV2 (step:truelr1TableStep) (cfg:t) : truelr1TableStep = \r\n\t\tlet (word, revStack, lr1Table, valid) = step in\r\n\t\tlet currentState = int_of_string(List.hd revStack) in \r\n\t\tlet (id,shifts,actionSet) = Set.nth lr1Table currentState in (* get corresponding table entry *)\r\n\t\tif(List.length word = 0) then\r\n\t\t\t(word, revStack, lr1Table, \"Rejeitada\")\r\n\t\telse\r\n\t\t\tlet topSymbol = List.nth word 0 in\r\n\t\t\t\tif(Set.belongs topSymbol cfg.variables) then (*Fazemos um Shift com uma variavel*)\r\n\t\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = topSymbol) shifts in\r\n\t\t\t\t\t\tif(Set.size targetShifts = 0) then (word, revStack, lr1Table, \"Rejeitada\")\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\r\n\t\t\t\t\t\t\tlet nextRevStack = [nextState] @ [symb2str nextSymbol] @ revStack in\r\n\t\t\t\t\t\t\tlet nextStep = ((getTail word), nextRevStack, lr1Table, valid) in\r\n\t\t\t\t\t\t\t\tnextStep\r\n\t\t\t\telse \r\n\t\t\t\t\tlet peekedSymbol = List.nth word 0 in\r\n\t\t\t\t\tlet peekedsymbolAndActions = Set.filter( fun (s,a) -> s = peekedSymbol && Set.size a > 0 ) actionSet in\r\n\t\t\t\t\tlet nEntries = Set.size peekedsymbolAndActions in\r\n\t\t\t\t\t\tif nEntries = 0 then \r\n\t\t\t\t\t\t\t(word, revStack, lr1Table, \"Rejeitada\")\r\n\t\t\t\t\t\telse if nEntries > 1 then\r\n\t\t\t\t\t\t\t(word, revStack, lr1Table, \"Conflito\")\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tlet (symbol,actions) = Set.hd peekedsymbolAndActions in (* atualmente está a falhar aqui, com hd failure *)\r\n\t\t\t\t\t\t\t(*Durante o accept, se encontrar um conflito, para imediatamente e retorna \"... Conflito ...\"\r\n\t\t\t\t\t\t\t\tUma possibilidade possivel. Se há conflitos, só ficam ativos os botões de Accept que sejam imunes a esses conflitos.\r\n\t\t\t\t\t\t\t\t*)\r\n\t\r\n\t\t\t\t\t\t\tif Set.size actions > 1 then (* NEW *)\r\n\t\t\t\t\t\t\t\t(word, revStack, lr1Table, \"Conflito\")\r\n\t\t\t\t\t\t\telse\r\n\r\n\t\t\t\t\t\tlet action = Set.hd actions in\r\n\t\t\t\t\t\t\tmatch action with\r\n\t\t\t\t\t\t\t| Shift -> \r\n\t\t\t\t\t\t\t\tbegin\r\n\t\t\t\t\t\t\t\t\tmatch word with\r\n\t\t\t\t\t\t\t\t\t| [] -> (word, revStack, lr1Table, \"Rejeitada\")\r\n\t\t\t\t\t\t\t\t\t| s::_ -> \r\n\t\t\t\t\t\t\t\t\t\tif(Set.belongs s cfg.alphabet || Set.belongs s cfg.variables) then\r\n\t\t\t\t\t\t\t\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = s) shifts in\r\n\t\t\t\t\t\t\t\t\t\t\t\tif(Set.size targetShifts = 0) then (word, revStack, lr1Table, \"Rejeitada\")\r\n\t\t\t\t\t\t\t\t\t\t\t\t(* Error.fatal (String.of_seq (List.to_seq ([char_of_int ((int_of_char '0') + currentState)] @ [s]))) *)\r\n\t\t\t\t\t\t\t\t\t\t\t\t(* para testar Error.fatal (String.of_seq (List.to_seq [s])) (* Casos corretos estão a ir parar aqui por alguma razão, provavelmente após uma redução *) *)\r\n\t\t\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet nextRevStack = [nextState] @ [symb2str nextSymbol] @ revStack in\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet nextStep = ((getTail word), nextRevStack, lr1Table, valid) in\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnextStep\r\n\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t\t(word, revStack, lr1Table, \"Simbolo Inválido\")\r\n\t\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\t| Accept -> \r\n\t\t\t\t\t\t\t\tif (word = [dollar]) then\r\n\t\t\t\t\t\t\t\t\t((getTail word), [symb2str cfg.initial], lr1Table, \"Aceite\")\r\n\t\t\t\t\t\t\t\telse \r\n\t\t\t\t\t\t\t\t\t((getTail word), revStack, lr1Table, \"Rejeitada\")\r\n\t\t\t\t\t\t\t| Reduce({head = h;body = b}) -> \r\n\t\t\t\t\t\t\t\tlet popNumber = List.length b in\r\n\t\t\t\t\t\t\t\tlet nextRevStack = pop (popNumber*2) revStack in\r\n\t\t\t\t\t\t\t\tlet wordWithAddedHead = [h] @ word in\r\n\t\t\t\t\t\t\t\tlet nextStep = (wordWithAddedHead, nextRevStack, lr1Table, valid) in\r\n\t\t\t\t\t\t\t\t\tnextStep\r\n\t\t\r\n\t\r\n\t\r\n\t\r\n\t\t\r\n\tlet acceptWordLR1StepV2 (step:truelr1TableStep) cfg : truelr1TableStep = \r\n\t\t\tparseStepLR1OperationV2 step cfg\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\r\n\tlet entryHasConflict lr1TableEntry : bool =\r\n\t\tlet (id,shifts,actionSet) = lr1TableEntry in\r\n\t\tlet entryConflicts = Set.filter ( fun (_, actions) -> Set.size actions > 1) actionSet in\r\n\t\t\tSet.size entryConflicts > 0\r\n\t\r\n\tlet isLR1 cfg : bool =\r\n\t\tlet slr1Table = makeLR1Table (makeLR1DiagramId (makeLR1Diagram cfg)) cfg in\r\n\t\tlet conflicts = Set.filter (entryHasConflict) slr1Table in\r\n\t\t\tSet.size conflicts = 0\r\n\t\t\t\r\n\t\t\t\r\n\tlet getLR1DiagramId cfg : lr1DiagramId =\r\n\t\tmakeLR1DiagramId (makeLR1Diagram cfg)\r\n\t\t\r\n\tlet getLR1Table cfg : lr1Table =\r\n\t\tmakeLR1Table (makeLR1DiagramId (makeLR1Diagram cfg)) cfg \r\n\t\r\nend\t\r\n\t(* ----- LALR1 -----*)\r\nmodule LALR1Grammar =\r\n\tstruct\r\n\topen LRAux\r\n\topen LR0Grammar\t\r\n\topen LR1Grammar\t\r\n\t\t\r\n\t\t\r\n\tlet itemsSameCores it1 it2 =\r\n\t\tit1.head = it2.head && it1.body1 = it2.body1 && it1.body2 = it2.body2\r\n\t\t\r\n\tlet itemsJoinLookahead it1 it2 =\r\n\t\t{head = it1.head; body1 = it1.body1; body2 = it1.body2; lookahead = (Set.union it1.lookahead it2.lookahead)}\r\n\t\r\n\t\r\n\tlet getStateCore (state:lr1State) =\r\n\t\tSet.map (fun it -> {head = it.head; body1 = it.body1; body2 = it.body2}) state\r\n\t\r\n\t\r\n\tlet haveSameCores lr1state1 lr1state2 =\r\n\t\tlet state1Core = getStateCore lr1state1 in\r\n\t\tlet state2Core = getStateCore lr1state2 in\r\n\t\t\tSet.equals state1Core state2Core\r\n\t\t\t\t\r\n\t(*pre: hasSameCores state1 state2 *)\r\n\tlet mergeLR1States state1 state2 =\r\n\t\tSet.map (fun it -> \r\n\t\t\tlet fit = Set.find (fun it2 -> itemsSameCores it it2) state2 in itemsJoinLookahead it fit) state1 \r\n\t\r\n\t\r\n\t\r\n\ttype lr1StateId = stateName * lr1State \r\n\ttype lr1DiagramId = lr1StateId set * (lr1StateId * symbol * lr1StateId ) set\r\n\t\t\r\n\tlet rec lr1StateFusionId statesId  = (* Esta deve ser a função a aplicar na versão final, a differença é que esta função trabalha com o diagrama diretamente (a parte dos estados identificados) *)\r\n\t\tmatch statesId with\r\n\t\t| [] -> []\r\n\t\t| (id,x)::xs -> \r\n\t\t\tlet ss = lr1StateFusionId xs in\r\n\t\t\tlet (a,b) = List.partition (fun (_,y)-> haveSameCores x y) ss in \r\n\t\t\t\tmatch a with\r\n\t\t\t\t| [] -> (id,x)::ss \r\n\t\t\t\t| [(id2,y)] -> (id^\",\"^id2,mergeLR1States x y)::b(* fundir x com y*)\r\n\t\t\t\t| _ -> Error.fatal \"lr1StateFusionFail\"\t\r\n\t\t\r\n\t\t\t\t\r\n\t\r\n\tlet rec lr1StateFusion states  =\r\n\t\tmatch states with\r\n\t\t| [] -> []\r\n\t\t| x::xs -> \r\n\t\t\tlet ss = lr1StateFusion xs in\r\n\t\t\tlet (a,b) = List.partition (haveSameCores x) ss in \r\n\t\t\t\tmatch a with\r\n\t\t\t\t| [] -> x::ss \r\n\t\t\t\t| [y] -> mergeLR1States x y::b(* fundir x com y*)\r\n\t\t\t\t| _ -> Error.fatal \"lr1StateFusionFail\"\r\n\t\t\r\n\tlet translate state fstates =\r\n\t\tSet.find (fun s -> haveSameCores state s) fstates\r\n\t\t\r\n\t\t\t\t\r\n\tlet lr1TransFusion trans fstates =\r\n\t\tSet.map (fun (s1,sym,s2) -> (translate s1 fstates,sym,translate s2 fstates)) trans\r\n\t\t\t\t\r\n\t\r\n\tlet makeLALR1FromLR1 diagram =\r\n\t\tlet (states,transitions) : lr1Diagram = diagram in \r\n\t\tlet fstates = lr1StateFusion (Set.toList states) in\r\n\t\tlet ftrans = lr1TransFusion transitions (Set.make fstates) in\r\n\t\tlet lalr1Diagram : lr1Diagram = ((Set.make fstates),ftrans) in\r\n\t\t\tlalr1Diagram\r\n\t\t\t\r\n\t\t\t\r\n\t(* pre: isLR1 cfg \r\n\t   pre: isWordValid word cfg *)\r\n\tlet acceptWordLALR1 (word: word) cfg : bool = \r\n\t\tlet lr1Table = makeLR1Table (makeLR1DiagramId (makeLALR1FromLR1 (makeLR1Diagram cfg))) cfg in\r\n\t\tlet stateRevStack = [\"0\"] in (*char list due to mix of numbers and symbols *) \r\n\t\tlet symbolRevStack : symbol list = [] in\r\n\t\t\tparseOperationLR1 lr1Table (word @ [dollar]) stateRevStack symbolRevStack cfg\r\n\t\t\t\r\n\t\t\t\r\n\t(* Added functions to provide a step-by step LR1 visualization of accepting *)\r\n\r\n\ttype lr1TableStep = symbol list * string list * symbol list * lr1Table * bool\r\n\t\r\n\tlet acceptWordLALR1Init (word:symbol list) cfg : lr1TableStep =\r\n\t\tlet lr1Table = makeLR1Table (makeLR1DiagramId (makeLALR1FromLR1 (makeLR1Diagram cfg))) cfg in\r\n\t\tlet stateRevStack = [\"0\"] in (*char list due to mix of numbers and symbols *) \r\n\t\tlet symbolRevStack : symbol list = [] in\r\n\t\tlet valid = true in\r\n\t\tlet initStep = ((word @ [dollar]),stateRevStack,symbolRevStack,lr1Table,valid) in\r\n\t\t\tinitStep\r\n\t\r\n\tlet parseStepLALR1Operation (step:lr1TableStep) (cfg:t) : lr1TableStep = \r\n\t\tlet (word, stateStack, symbolStack, lr1Table, valid) = step in\r\n\t\tlet currentState = int_of_string(List.hd stateStack) in \r\n\t\tlet (id,shifts,actionSet) = Set.nth lr1Table currentState in (* get corresponding table entry *)\r\n\t\tlet topSymbol = List.nth word 0 in\r\n\t\t\tif(Set.belongs topSymbol cfg.variables) then (*Fazemos um Shift com uma variavel*)\r\n\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = topSymbol) shifts in\r\n\t\t\t\t\tif(Set.size targetShifts = 0) then (word, stateStack, symbolStack, lr1Table, false)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\r\n\t\t\t\t\t\tlet nextStateStack = [nextState] @ stateStack in\r\n\t\t\t\t\t\tlet nextSymbolStack = [nextSymbol] @ symbolStack in\r\n\t\t\t\t\t\tlet nextStep = ((getTail word), nextStateStack, nextSymbolStack, lr1Table, valid) in\r\n\t\t\t\t\t\t\tnextStep\r\n\t\t\telse \r\n\t\t\t\tlet peekedSymbol = List.nth word 0 in\r\n\t\t\t\tlet peekedsymbolAndActions = Set.filter( fun (s,a) -> s = peekedSymbol && Set.size a > 0 ) actionSet in\r\n\t\t\t\tlet nEntries = Set.size peekedsymbolAndActions in\r\n\t\t\t\t\tif nEntries = 0 then \r\n\t\t\t\t\t\t(word, stateStack, symbolStack, lr1Table, false)\r\n\t\t\t\t\telse if nEntries > 1 then\r\n\t\t\t\t\t\tError.fatal \"parseStepLR1Operation: conflito\"\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tlet (symbol,actions) = Set.hd peekedsymbolAndActions in (* atualmente está a falhar aqui, com hd failure *)\r\n\t\t\t\t\t\tlet action = Set.hd actions in\r\n\t\t\t\t\t\tmatch action with\r\n\t\t\t\t\t\t| Shift -> \r\n\t\t\t\t\t\t\tbegin\r\n\t\t\t\t\t\t\t\tmatch word with\r\n\t\t\t\t\t\t\t\t| [] -> (word, stateStack, symbolStack, lr1Table, false)\r\n\t\t\t\t\t\t\t\t| s::_ -> \r\n\t\t\t\t\t\t\t\t\tif(Set.belongs s cfg.alphabet || Set.belongs s cfg.variables) then\r\n\t\t\t\t\t\t\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = s) shifts in\r\n\t\t\t\t\t\t\t\t\t\t\tif(Set.size targetShifts = 0) then (word, stateStack, symbolStack, lr1Table, false)\r\n\t\t\t\t\t\t\t\t\t\t\t(* Error.fatal (String.of_seq (List.to_seq ([char_of_int ((int_of_char '0') + currentState)] @ [s]))) *)\r\n\t\t\t\t\t\t\t\t\t\t\t(* para testar Error.fatal (String.of_seq (List.to_seq [s])) (* Casos corretos estão a ir parar aqui por alguma razão, provavelmente após uma redução *) *)\r\n\t\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet nextStateStack = [nextState] @ stateStack in\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet nextSymbolStack = [nextSymbol] @ symbolStack in\r\n\t\t\t\t\t\t\t\t\t\t\t\tlet nextStep = ((getTail word), nextStateStack, nextSymbolStack, lr1Table, valid) in\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tnextStep\r\n\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\tError.fatal \"parseStepLR1Operation: este simbolo não pertence ao alfabeto desta gramatica\"\r\n\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t| Accept -> \r\n\t\t\t\t\t\t\tif (word = [dollar]) then\r\n\t\t\t\t\t\t\t\t((getTail word), stateStack, symbolStack, lr1Table, valid)\r\n\t\t\t\t\t\t\telse \r\n\t\t\t\t\t\t\t\t((getTail word), stateStack, symbolStack, lr1Table, false)\r\n\t\t\t\t\t\t| Reduce({head = h;body = b}) -> \r\n\t\t\t\t\t\t\tlet popNumber = List.length b in\r\n\t\t\t\t\t\t\tlet nextStateStack = (pop popNumber stateStack) in\r\n\t\t\t\t\t\t\tlet nextSymbolStack = (pop popNumber symbolStack) in\r\n\t\t\t\t\t\t\tlet wordWithAddedHead = [h] @ word in\r\n\t\t\t\t\t\t\tlet nextStep = (wordWithAddedHead, nextStateStack, nextSymbolStack, lr1Table, valid) in\r\n\t\t\t\t\t\t\t\tnextStep\r\n\t\t\r\n\t\r\n\t\r\n\t\r\n\t\t\r\n\tlet acceptWordLALR1Step (step:lr1TableStep) cfg : lr1TableStep = \r\n\t\t\tparseStepLALR1Operation step cfg\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t(* updated accept *)\r\n\t\r\n\tlet acceptWordLALR1InitV2 (word:symbol list) cfg : truelr1TableStep =\r\n\t\tlet lr1Table = makeLR1Table (makeLR1DiagramId (makeLALR1FromLR1 (makeLR1Diagram cfg))) cfg in\r\n\t\tlet revStack = [\"0\"] in \r\n\t\tlet valid = \"Ongoing\" in\r\n\t\tlet initStep = ((word @ [dollar]),revStack,lr1Table,valid) in\r\n\t\t\tinitStep\r\n\t\r\n\tlet parseStepLALR1OperationV2 (step:truelr1TableStep) (cfg:t) : truelr1TableStep = \r\n\t\tlet (word, revStack, lr1Table, valid) = step in\r\n\t\tlet currentState = int_of_string(List.hd revStack) in \r\n\t\tlet (id,shifts,actionSet) = Set.nth lr1Table currentState in (* get corresponding table entry *)\r\n\t\tif(List.length word = 0) then\r\n\t\t\t(word, revStack, lr1Table, \"Rejeitada\")\r\n\t\telse\r\n\t\t\tlet topSymbol = List.nth word 0 in\r\n\t\t\t\tif(Set.belongs topSymbol cfg.variables) then (*Fazemos um Shift com uma variavel*)\r\n\t\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = topSymbol) shifts in\r\n\t\t\t\t\t\tif(Set.size targetShifts = 0) then (word, revStack, lr1Table, \"Rejeitada\")\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\r\n\t\t\t\t\t\t\tlet nextRevStack = [nextState] @ [symb2str nextSymbol] @ revStack in\r\n\t\t\t\t\t\t\tlet nextStep = ((getTail word), nextRevStack, lr1Table, valid) in\r\n\t\t\t\t\t\t\t\tnextStep\r\n\t\t\t\telse \r\n\t\t\t\t\tlet peekedSymbol = List.nth word 0 in\r\n\t\t\t\t\tlet peekedsymbolAndActions = Set.filter( fun (s,a) -> s = peekedSymbol && Set.size a > 0 ) actionSet in\r\n\t\t\t\t\tlet nEntries = Set.size peekedsymbolAndActions in\r\n\t\t\t\t\t\tif nEntries = 0 then \r\n\t\t\t\t\t\t\t(word, revStack, lr1Table, \"Rejeitada\")\r\n\t\t\t\t\t\telse if nEntries > 1 then\r\n\t\t\t\t\t\t\t(word, revStack, lr1Table, \"Conflito\")\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tlet (symbol,actions) = Set.hd peekedsymbolAndActions in (* atualmente está a falhar aqui, com hd failure *)\r\n\r\n\t\t\t\t\t\t\t(*Durante o accept, se encontrar um conflito, para imediatamente e retorna \"... Conflito ...\"*)\r\n\t\t\t\t\t\t\tif Set.size actions > 1 then (* NEW *)\r\n\t\t\t\t\t\t\t\t(word, revStack, lr1Table, \"Conflito\")\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tlet action = Set.hd actions in\r\n\t\t\t\t\t\t\tmatch action with\r\n\t\t\t\t\t\t\t| Shift -> \r\n\t\t\t\t\t\t\t\tbegin\r\n\t\t\t\t\t\t\t\t\tmatch word with\r\n\t\t\t\t\t\t\t\t\t| [] -> (word, revStack, lr1Table, \"Rejeitada\")\r\n\t\t\t\t\t\t\t\t\t| s::_ -> \r\n\t\t\t\t\t\t\t\t\t\tif(Set.belongs s cfg.alphabet || Set.belongs s cfg.variables) then\r\n\t\t\t\t\t\t\t\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = s) shifts in\r\n\t\t\t\t\t\t\t\t\t\t\t\tif(Set.size targetShifts = 0) then (word, revStack, lr1Table, \"Rejeitada\")\r\n\t\t\t\t\t\t\t\t\t\t\t\t(* Error.fatal (String.of_seq (List.to_seq ([char_of_int ((int_of_char '0') + currentState)] @ [s]))) *)\r\n\t\t\t\t\t\t\t\t\t\t\t\t(* para testar Error.fatal (String.of_seq (List.to_seq [s])) (* Casos corretos estão a ir parar aqui por alguma razão, provavelmente após uma redução *) *)\r\n\t\t\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet nextRevStack = [nextState] @ [symb2str nextSymbol] @ revStack in\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet nextStep = ((getTail word), nextRevStack, lr1Table, valid) in\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnextStep\r\n\t\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\t\t(word, revStack, lr1Table, \"Simbolo Inválido\")\r\n\t\t\t\t\t\t\t\tend\r\n\t\t\t\t\t\t\t| Accept -> \r\n\t\t\t\t\t\t\t\tif (word = [dollar]) then\r\n\t\t\t\t\t\t\t\t\t((getTail word), [symb2str cfg.initial], lr1Table, \"Aceite\")\r\n\t\t\t\t\t\t\t\telse \r\n\t\t\t\t\t\t\t\t\t((getTail word), revStack, lr1Table, \"Rejeitada\")\r\n\t\t\t\t\t\t\t| Reduce({head = h;body = b}) -> \r\n\t\t\t\t\t\t\t\tlet popNumber = List.length b in\r\n\t\t\t\t\t\t\t\tlet nextRevStack = pop (popNumber*2) revStack in\r\n\t\t\t\t\t\t\t\tlet wordWithAddedHead = [h] @ word in\r\n\t\t\t\t\t\t\t\tlet nextStep = (wordWithAddedHead, nextRevStack, lr1Table, valid) in\r\n\t\t\t\t\t\t\t\t\tnextStep\r\n\t\t\r\n\t\r\n\t\r\n\t\r\n\t\t\r\n\tlet acceptWordLALR1StepV2 (step:truelr1TableStep) cfg : truelr1TableStep = \r\n\t\t\tparseStepLALR1OperationV2 step cfg\r\n\t\t\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\tlet entryHasConflict slr1TableEntry : bool =\r\n\t\tlet (id,shifts,actionSet) = slr1TableEntry in\r\n\t\tlet entryConflicts = Set.filter ( fun (_, actions) -> Set.size actions > 1) actionSet in\r\n\t\t\tnot (Set.isEmpty entryConflicts)\r\n\t\r\n\tlet isLALR1 cfg : bool =\r\n\t\tlet lalr1Table = makeLR1Table (makeLR1DiagramId (makeLALR1FromLR1 (makeLR1Diagram cfg))) cfg in\r\n\t\tlet conflicts = Set.filter (entryHasConflict) lalr1Table in\r\n\t\t\tSet.isEmpty conflicts\r\n\t\t\t\r\n\t\t\t\r\n\tlet getLALR1DiagramId cfg : lr1DiagramId =\r\n\t\t makeLR1DiagramId (makeLALR1FromLR1 (makeLR1Diagram cfg))\r\n\t\t\r\n\tlet getLALR1Table cfg : lr1Table =\r\n\t\tmakeLR1Table (makeLR1DiagramId (makeLALR1FromLR1 (makeLR1Diagram cfg))) cfg\r\nend\r\n\r\nmodule ContextFreeGrammarLR =\r\nstruct\r\n\ttype t = ContextFreeGrammarBasic.t\r\n\topen LR0Grammar\r\n\topen SLR1Grammar\r\n\topen LR1Grammar\r\n\topen LALR1Grammar\r\n\t\r\n\tclass model (arg: t Arg.alternatives) =\r\n\t\tobject(self) inherit ContextFreeGrammarLL1.model arg as super\r\n\t\t\r\n\t\t\t\t\r\n\t\t\tmethod isLR0 : bool =\r\n\t\t\t\tisLR0 (self#representation)\r\n\t\t\t\t\r\n\t\t\tmethod getLR0DiagramId : LR0Grammar.lr0DiagramId =\r\n\t\t\t\tgetLR0DiagramId (self#representation)\r\n\t\t\t\t\r\n\t\t\tmethod getLR0Table : LR0Grammar.lr0Table =\r\n\t\t\t\tgetLR0Table (self#representation)\r\n\t\t\t\t\r\n\t\t\tmethod getLR0TableExt : LR0Grammar.lr0TableExt =\r\n\t\t\t\tgetLR0TableExt (self#representation)\r\n\t\t\t\t\r\n\t\t(* SLR1 *)\r\n\t\t\tmethod isSLR1 : bool =\r\n\t\t\t\tisSLR1 (self#representation)\r\n\t\t\t\t\r\n\t\t\tmethod getSLR1Table : SLR1Grammar.slr1Table =\r\n\t\t\t\tgetSLR1Table (self#representation)\r\n\t\t\t\t\r\n\t\t(* LR1 *)\t\r\n\t\t\r\n\t\t\tmethod isLR1 : bool =\r\n\t\t\t\tisLR1 (self#representation)\r\n\t\t\t\r\n\t\t\tmethod getLR1DiagramId : LR1Grammar.lr1DiagramId =\r\n\t\t\t\tgetLR1DiagramId (self#representation)\r\n\t\t\t\r\n\t\t\tmethod getLR1Table : LR1Grammar.lr1Table =\r\n\t\t\t\tgetLR1Table (self#representation)\r\n\t\t\t\t\r\n\t\t(* LALR1 *)\t\t\r\n\t\t\tmethod isLALR1 : bool =\r\n\t\t\t\tisLALR1 (self#representation)\r\n\t\t\t\r\n\t\t\tmethod getLALR1DiagramId : LR1Grammar.lr1DiagramId =\r\n\t\t\t\tgetLALR1DiagramId (self#representation)\r\n\t\t\t\t\r\n\t\t\tmethod getLALR1Table : LR1Grammar.lr1Table =\r\n\t\t\t\tgetLALR1Table (self#representation)\r\n\tend\r\nend\r\n\r\n# 1 \"src/ContextFreeGrammar.ml\"\r\n(*\r\n * ContextFreeGrammar.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by João Gonçalves (jg)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n????\r\n *)\r\n\r\n(*\r\n * Description: Context-free grammar functionality.\r\n *\r\n * TODO: More cleanup.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule ContextFreeGrammar =\r\nstruct\r\n\tinclude ContextFreeGrammarSupport\r\n\r\n\tclass model (arg: t Arg.alternatives) =\r\n\t\tobject(self) inherit ContextFreeGrammarLR.model arg as super\r\n     end\r\nend\r\n# 1 \"src/AttributeGrammarSupport.ml\"\r\n(*\r\n * AttributeGrammarSupport.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * mar/2025 (amd) - New module\r\n *)\r\n\r\n(*\r\n * Description: Support types and functions for FAs.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule AttributeGrammarBasics =\r\nstruct\r\n\ttype attribute = symbol\r\n\ttype attributes = attribute set\r\n\ttype attrArg = variable * int\r\n\ttype expression =\r\n\t\t| Int of int\r\n\t\t| String of string\r\n\t\t| Bool of bool\r\n\t\t| Apply of attribute * attrArg\r\n\t\t| Expr of string * expression * expression\r\n\ttype equation = expression * expression\r\n\ttype equations = equation set\r\n\ttype condition = expression\r\n\ttype conditions = condition set\r\n\r\n\ttype rule = {\r\n\t\thead : symbol;\r\n\t\tbody : word;\r\n\t\tequations : equations;\r\n\t\tconditions : conditions\r\n\t}\r\n\ttype rules = rule set\r\n\r\n\ttype t = {\r\n\t\talphabet : symbols;\r\n\t\tvariables : variables;\r\n\t\tsynthesized : attributes;\r\n\t\tinherited : attributes;\r\n\t\tinitial : variable;\r\n\t\trules : rules\r\n\t}\r\n\r\n\ttype evaluation = (attribute * int) set\r\n\t\r\n\ttype node = symbol * evaluation\r\n\t\r\n\ttype parseTree =\r\n\t\t  Leaf of node\r\n\t\t| Root of node * parseTree list\r\n\r\n\tlet kind = \"attribute grammar\"\r\n\r\n\tlet ag_zero: t = {\r\n\t\talphabet = Set.empty;\r\n\t\tvariables = Set.make [draftVar];\r\n\t\tinherited = Set.empty;\r\n\t\tsynthesized = Set.empty;\r\n\t\tinitial = draftVar;\r\n\t\trules = Set.empty;\r\n\t}\r\nend\r\n\r\nmodule ExpressionSyntax =\r\nstruct\r\n\topen CharType\r\n\topen Scanner\r\n\topen AttributeGrammarBasics\r\n\r\n(* Literals: T, F, 1, 10, 100, \"\", \"ola\"\r\n   Ops: [<, <=, <>, >, >=, =] [+] [*]\r\n*)\r\n\tlet parseApply (): expression =\r\n\t\tlet attr = getAlpha () in\r\n\t\tlet _ = getChar '(' in\r\n\t\tlet v, i = getCharInt () in\r\n\t\tlet _ = getChar ')' in\r\n\t\t\tApply (char2symb attr, (char2symb v, i))\r\n\t\t\r\n\tlet rec parseExp3 (): expression =\r\n\t\tmatch peek () with\r\n\t\t| c when isDigit c -> Int (getInt ())\r\n\t\t| '\\'' -> String (getDelim '\\'' '\\'')\r\n\t\t| 'T' -> skip (); Bool true\r\n\t\t| 'F' -> skip (); Bool false\r\n\t\t| '(' -> let _ = getChar '(' in\r\n\t\t\t\tlet e = parseExp0 () in\r\n\t\t\t\tlet _ = getChar ')' in\r\n\t\t\t\t\tExpr (\"(\", e, Int 0)\r\n\t\t| _ -> parseApply ()\r\n\r\n\tand parseExp2 (): expression =\r\n\t\tlet l = parseExp3 () in\r\n\t\tlet c = peek () in\r\n\t\t\tif c = '*' then (\r\n\t\t\t\tskip();\r\n\t\t\t\tExpr (\"*\", l, parseExp2 ())\r\n\t\t\t)\r\n\t\t\telse\r\n\t\t\t\tl\r\n\t\t\r\n\tand parseExp1 (): expression =\r\n\t\tlet l = parseExp2 () in\r\n\t\tlet c = peek () in\r\n\t\t\tif c = '+' then (\r\n\t\t\t\tskip();\r\n\t\t\t\tExpr (\"+\", l, parseExp1 ())\r\n\t\t\t)\r\n\t\t\telse\r\n\t\t\t\tl\r\n\t\r\n\tand parseExp0 (): expression =\r\n\t\tlet l = parseExp1 () in\r\n\t\t\tmatch peek () with\r\n\t\t\t| '<' ->\r\n\t\t\t\tskip();\r\n\t\t\t\t(match peek () with\r\n\t\t\t\t| '=' -> skip (); Expr (\"<=\", l, parseExp0 ())\r\n\t\t\t\t| '>' -> skip (); Expr (\"<>\", l, parseExp0 ())\r\n\t\t\t\t| _ -> Expr (\"<\", l, parseExp0 ()))\r\n\t\t\t| '=' ->\r\n\t\t\t\tskip(); Expr (\"=\", l, parseExp0 ())\r\n\t\t\t| '>' ->\r\n\t\t\t\tskip();\r\n\t\t\t\t(match peek () with\r\n\t\t\t\t| '=' -> skip (); Expr (\">=\", l, parseExp0 ())\r\n\t\t\t\t| _ -> Expr (\">\", l, parseExp0 ()))\r\n\t\t\t| _ ->\r\n\t\t\t\tl\r\n\t\t\r\n\tlet parseExpression (): expression =\r\n\t\tparseExp0 ()\r\n\t\r\n\tlet rec expression2str e =\r\n\t\tmatch e with\r\n\t\t| Int i ->\r\n\t\t\tstring_of_int i\r\n\t\t| String s ->\r\n\t\t\t\"\\\"\" ^ s ^ \"\\\"\"\r\n\t\t| Bool b ->\r\n\t\t\tif b then \"T\" else \"F\"\r\n\t\t| Apply (attr, (var, i)) when i = -1 ->\r\n\t\t\tsymb2str attr ^ \"(\" ^ symb2str var ^ \")\"\r\n\t\t| Apply (attr, (var, i)) ->\r\n\t\t\tsymb2str attr ^ \"(\" ^ symb2str var ^ string_of_int i ^ \")\"\r\n\t\t| Expr (\"(\", l, _) ->\r\n\t\t\t\"(\" ^ expression2str l ^ \")\"\r\n\t\t| Expr (op, l, r) ->\r\n\t\t\texpression2str l ^ \" \" ^ op ^ \" \" ^ expression2str r\r\nend\r\n\r\nmodule EquationsSyntax =\r\nstruct\r\n\topen CharType\r\n\topen Scanner\r\n\topen AttributeGrammarBasics\r\n\t\r\n\tlet parseEquation (): equation =\r\n\t\tlet l = ExpressionSyntax.parseApply () in\r\n\t\t\tlet _ = getChar '=' in\r\n\t\t\tlet r = ExpressionSyntax.parseExpression () in\r\n\t\t\t\t(l, r)\r\n\r\n\tlet rec parseEquationsX (): equations =\r\n\t\tmatch peek() with\r\n\t\t\t| '}' -> Set.empty\r\n\t\t\t| _ ->\r\n\t\t\t\tlet e = parseEquation () in\r\n\t\t\t\t\tmatch peek () with\r\n\t\t\t\t\t| ';' -> skip (); Set.cons e (parseEquationsX ())\r\n\t\t\t\t\t| '}' -> Set.make [e]\r\n\t\t\t\t\t| _ -> rubbish \"at the end of equation\"\r\n\r\n\tlet parseEquations (): equations =\r\n\t\tmatch peek() with\r\n\t\t\t| '{' -> skip();\r\n\t\t\t\t\tlet res = parseEquationsX () in\r\n\t\t\t\t\tlet _ = getChar '}' in\r\n\t\t\t\t\t\tres\r\n\t\t\t| _ -> Set.empty\r\n\r\n\tlet equation2str (l, r) =\r\n\t\tExpressionSyntax.expression2str l\r\n\t\t^ \" = \"\r\n\t\t^ ExpressionSyntax.expression2str r\r\nend\r\n\r\nmodule ConditionsSyntax =\r\nstruct\r\n\topen CharType\r\n\topen Scanner\r\n\topen AttributeGrammarBasics\r\n\r\n\tlet parseCondition (): condition =\r\n\t\tExpressionSyntax.parseExpression ()\r\n\r\n\tlet rec parseConditionsX (): conditions =\r\n\t\tmatch peek() with\r\n\t\t| ']' -> Set.empty\r\n\t\t| _ ->\r\n\t\t\tlet e = parseCondition () in\r\n\t\t\t\tmatch peek () with\r\n\t\t\t\t| ';' -> skip (); Set.cons e (parseConditionsX ())\r\n\t\t\t\t| ']' -> Set.make [e]\r\n\t\t\t\t| _ -> rubbish \"at the end of condition\"\r\n\t\t\t\r\n\tlet parseConditions (): conditions =\r\n\t\tmatch peek() with\r\n\t\t| '[' -> skip();\r\n\t\t\t\tlet res = parseConditionsX () in\r\n\t\t\t\tlet _ = getChar ']' in\r\n\t\t\t\t\tres\r\n\t\t| _ -> Set.empty\r\n\r\n\tlet condition2str c =\r\n\t\tExpressionSyntax.expression2str c\r\nend\t\r\n\r\nmodule AttributeGrammarSyntax =\r\nstruct\r\n\topen CharType\r\n\topen Scanner\r\n\topen AttributeGrammarBasics\r\n\r\n\tlet parseSymbol () : symbol =\r\n\t\tif peek () = '<' then\r\n\t\t\tlet str = getDelim '<' '>' in \r\n\t\t\t\tstr2symb (\"<\" ^ str ^ \">\")\r\n\t\telse\r\n\t\t\tchar2symb (get ())\r\n\t\t\t\t\t\t\r\n\tlet parseHead (): symbol =\r\n\t\tmatch peek() with\r\n\t\t| ' ' -> invalid \"Empty rule\"\r\n\t\t| _ -> parseSymbol ()\r\n\t\t\r\n\tlet parseNeck (): unit =\r\n\t\tgetStr \"->\"\r\n\r\n\tlet rec parseBody (): word =\r\n\t\tmatch peek() with\r\n\t\t| ' ' | '{' -> []\r\n\t\t| '~' -> skip(); parseBody ()\r\n\t\t| _ -> let sy = parseSymbol () in\r\n\t\t\t\t\tsy::parseBody ()\r\n\r\n\tlet parseFinish (): unit =\r\n\t\tmatch peek() with\r\n\t\t| ' ' -> ()\r\n\t\t| _ -> \trubbish \"at the end of rule\"\r\n\r\n\tlet parseLine line: rules =\r\n\t\tif String.trim line = \"\" then\r\n\t\t\tSet.empty\r\n\t\telse begin\r\n\t\t\tScanner.start \"AttributeGrammarSyntax\" line;\r\n\t\t\ttry\r\n\t\t\t\tlet finish l = if l = [] then [epsilon] else l in\r\n\t\t\t\tlet h = parseHead () in\r\n\t\t\t\tlet _ = parseNeck () in\r\n\t\t\t\tlet b = parseBody () in\r\n\t\t\t\tlet e = EquationsSyntax.parseEquations () in\r\n\t\t\t\tlet c = ConditionsSyntax.parseConditions () in\r\n\t\t\t\tlet _ = parseFinish () in\r\n\t\t\t\t\tSet.make [{head=h; body=finish b;\r\n\t\t\t\t\t\tequations=e; conditions=c}]\r\n\t\t\twith Not_found ->\r\n\t\t\t\tSet.empty\r\n\t\tend\r\n\r\n\tlet parse rs: rules =\r\n\t\tSet.flatMap parseLine rs\r\n\t\t\t\t\t\r\n\tlet rule2str {head=h; body=b; equations=eqs; conditions=conds}: string =\r\n\t\tlet rule = (symb2str h) ^ \" -> \" ^ (word2str b) in\r\n\t\tlet eqs = Set.toList eqs in\r\n\t\tlet eqs = String.concat \"; \" (List.map EquationsSyntax.equation2str eqs) in\r\n\t\tlet eqs = if eqs = \"\" then \"\" else \" {\" ^ eqs ^ \"}\" in\r\n\t\tlet conds = Set.toList conds in\r\n\t\tlet conds = String.concat \"; \" (List.map ConditionsSyntax.condition2str conds) in\r\n\t\tlet conds = if conds = \"\" then \"\" else \" [\" ^ conds ^ \"]\" in\r\n\t\t\trule ^  eqs ^ conds\r\n\r\n\tlet toString rs: string =\r\n\t\tlet rl = Set.toList rs in\r\n\t\t\tString.concat \"\\n\" (List.map rule2str rl)\r\n\r\n\tlet toStringList rs: string list =\r\n\t\tlet rl = Set.toList rs in\r\n\t\t\tList.map rule2str rl\r\n\t\r\n\tlet (-->) h b : rule =\r\n\t\t{ head = h; body = str2word b;\r\n\t\tequations=Set.empty; conditions=Set.empty }\r\n\r\n\tlet show rs =\r\n\t\tUtil.println [toString rs]\r\nend\r\n\r\n\r\nmodule AttributeGrammarJSon =\r\nstruct\r\nend\r\n\r\nmodule AttributeGrammarConversions =\r\nstruct\r\n\topen AttributeGrammarBasics\r\n\topen AttributeGrammarSyntax\r\n\r\n\tlet fromJSon (j: JSon.t): t =\r\n\t\tif JSon.isNull j || not (JSon.hasField j \"kind\") then\r\n\t\t\tag_zero\r\n\t\telse {\r\n\t\t\talphabet = JSon.fieldSymbolSet j \"alphabet\";\r\n\t\t\tvariables = JSon.fieldSymbolSet j \"variables\";\r\n\t\t\tinherited = JSon.fieldSymbolSet j \"inherited\";\r\n\t\t\tsynthesized = JSon.fieldSymbolSet j \"synthesized\";\r\n\t\t\tinitial = JSon.fieldSymbol j \"initial\";\r\n\t\t\trules = AttributeGrammarSyntax.parse (JSon.fieldStringSet j \"rules\");\r\n\t\t}\r\n\r\n\tlet toJSon0 (rep: t): JSon.t =\r\n\t\tJSon.makeAssoc [\r\n\t\t\t(\"alphabet\", JSon.makeSymbolSet rep.alphabet);\r\n\t\t\t(\"variables\", JSon.makeSymbolSet rep.variables);\r\n\t\t\t(\"inherited\", JSon.makeSymbolSet rep.inherited);\r\n\t\t\t(\"synthesized\", JSon.makeSymbolSet rep.synthesized);\r\n\t\t\t(\"initial\", JSon.makeSymbol rep.initial);\r\n\t\t\t(\"rules\", JSon.makeStringSet (Set.map rule2str rep.rules))\r\n\t\t]\r\n\t\r\n\tlet toJSon2 (id: Entity.t) (rep: t): JSon.t =\r\n\t\t JSon.append (Entity.toJSon id) (toJSon0 rep)\r\n\r\n\tlet toJSon (rep: t): JSon.t =\r\n\t\t toJSon2 (Entity.dummyId kind) rep\r\nend\r\n\r\nmodule AttributeGrammarBasicFunctions =\r\nstruct\r\n\topen AttributeGrammarBasics\r\n\topen AttributeGrammarConversions\r\n\r\n\tlet make2 (arg: t Arg.alternatives) validate: Entity.t * t =\r\n\t\tEntity.make2 arg fromJSon kind validate\r\n\r\n\tlet make (arg: t Arg.alternatives) validate: t =\r\n\t\tsnd (make2 arg validate)\r\n\r\n\tlet show (rep: t): unit =\r\n\t\tlet j = toJSon rep in\r\n\t\t\tJSon.show j\r\n\r\n\tlet show2 (id: Entity.t) (rep: t): unit =\r\n\t\tlet j = toJSon2 id rep in\r\n\t\t\tJSon.show j\r\nend\r\n\r\nmodule AttributeGrammarX =\r\nstruct\r\n\topen AttributeGrammarBasics\r\nend\r\n\r\nmodule AttributeGrammarLearnOCaml =\r\nstruct\r\n\topen AttributeGrammarBasics\r\n\topen AttributeGrammarX\r\n\r\n\tlet moduleName =\r\n\t\t\"AttributeGrammar\"\r\n\r\n\tlet xTypeName =\r\n\t\t\"AttributeGrammar\"\r\n\r\n\tlet solution (name: string) (rep: t): string =\r\n\t\t\"\"\r\n\r\n\tlet prelude : string =\r\n\t\t\"\"\r\n\r\n\tlet example : JSon.t =\r\n\t\tJNull\r\nend\r\n\r\nmodule AttributeGrammarSupport =\r\nstruct\r\n\tinclude AttributeGrammarBasics\r\n\tinclude AttributeGrammarConversions\r\n\tinclude AttributeGrammarBasicFunctions\r\n\tinclude AttributeGrammarLearnOCaml\r\nend\r\n# 1 \"src/AttributeGrammar.ml\"\r\n(*\r\n * AttributeGrammar.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Pedro Bailão (pb)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * ???/2025 (pb) - ....\r\n * feb/2025 (amd) - New file \"AttributeGrammar.ml\".\r\n *)\r\n\r\n(*\r\n * Description: Attribute grammar functionality.\r\n *\r\n * TODO: More cleanup.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule AttributeGrammarPrivate =\r\nstruct\r\n\topen AttributeGrammarSupport\r\n\r\n\tlet ag2cfg (rep: t): ContextFreeGrammarBasic.t =\r\n\t\tContextFreeGrammarBasic.cfg_zero\r\n\t\r\n\tlet validateAG (name: string) (rep: t): unit =\r\n\t\t()\r\n\t\r\n\tlet validate (name: string) (rep: t): unit =\r\n\t\tlet cfg = ag2cfg rep in\r\n\t\t\tContextFreeGrammarPrivate.validate \"_\" cfg;\r\n\t\t\tvalidateAG \"_\" rep\r\n\r\n\tlet accept (rep: t) (w: word): bool =\r\n\t\tfalse\r\nend\r\n\r\nmodule AttributeGrammar =\r\nstruct\r\n\tinclude AttributeGrammarSupport\r\n\topen AttributeGrammarPrivate\r\n\r\n\t(* Make *)\r\n\tlet make2 (arg: t Arg.alternatives): Entity.t * t = make2 arg validate\r\n\tlet make (arg: t Arg.alternatives): t = make arg validate\r\n\r\n\t(* Exercices support *)\r\n\tlet checkProperty (fa: t) (prop: string) =\r\n\t\tmatch prop with\r\n\t\t\t| _ -> Model.checkProperty prop\r\n\tlet checkExercise ex fa = Model.checkExercise ex (accept fa) (checkProperty fa)\t\r\n\tlet checkExerciseFailures ex fa = Model.checkExerciseFailures ex (accept fa) (checkProperty fa)\r\n\r\n\t(* Ops *)\r\n\tlet stats = Model.stats\r\n\tlet accept = accept\r\nend\r\n\r\nmodule AttributeGrammarTop =\r\nstruct\r\n\topen AttributeGrammar\r\nend\r\n\r\nopen AttributeGrammarTop\r\n\r\nmodule AttributeGrammarSupportTests : sig end =\r\nstruct\r\n\topen AttributeGrammar\r\n\t\r\n\tlet active = false\r\n\t\r\n\tlet ag = {| {\r\n\t\tkind : \"attribute grammar\",\r\n\t\tdescription : \"\",\r\n\t\tname : \"ag\",\r\n\t\talphabet : [\"[\", \"]\"],\r\n\t\tvariables : [\"S\"],\r\n\t\tinherited : [],\r\n\t\tsynthesized : [],\r\n\t\tinitial : \"S\",\r\n\t\trules : [ \"S -> [S] {l(S) = 2; l(S) = 'ole'; l(S0) = l(S1)} [123 + 56; 56; 'ola']\",\r\n\t\t\t\t  \"S -> SS {l(S) = l(S1) + 3 + 'ola' + l(S12345)}\",\r\n\t\t\t\t  \"S -> ~ {l(S0) = 6}\",\r\n\t\t\t\t  \"S -> ~ {l(S0) = 1+2*3<T>F<=T>=5=T<>T+(1*2)}\"\r\n\t\t\t\t]\r\n\t} |}\r\n\r\n\tlet test0 () =\r\n\t\tlet j = JSon.parse ag in\r\n\t\tlet g = fromJSon j in\r\n\t\tlet h = toJSon g in\r\n\t\t\tJSon.show h\r\n\r\n\tlet test1 () =\r\n\t\tlet g = make (Arg.Text ag) in\r\n\t\tlet h = toJSon g in\r\n\t\t\tJSon.show h\r\n\r\n\tlet runAll =\r\n\t\tif Util.testing active \"AttributeGrammarSupport\" then begin\r\n\t\t\tUtil.header \"test0\";\r\n\t\t\ttest1 ();\r\n\t\t\tUtil.header \"\"\r\n\t\tend\r\nend\r\n\r\n\r\n# 3 \"src/PushdownAutomatonSupport.ml\"\r\n(*\r\n * PushdownAutomaton.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Carlos Freitas (cf)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * ???/2022 (cf) - ???.\r\n * may/2022 (amd) - Initial skeleton.\r\n *)\r\n\r\n(*\r\n * Description: Pushdown automata functionality.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule PushdownAutomatonBasics =\r\nstruct\r\n\ttype transition =\r\n\t\t  state\t\t\t(* state *)\r\n\t\t* symbol\t\t(* current symbol on top of the stack *)\r\n\t\t* symbol\t\t(* consumed input symbol *)\r\n\t\t* state\t\t\t(* next state *)\r\n\t\t* symbol list\t(* new top of stack*)\r\n\ttype transitions = transition set\r\n\t\t\r\n\ttype t = {\r\n\t\tinputAlphabet : symbols;\r\n\t\tstackAlphabet : symbols;\r\n\t\tstates : states;\r\n\t\tinitialState : state;\r\n\t\tinitialStackSymbol : symbol;\r\n\t\ttransitions : transitions;\r\n\t\tacceptStates : states;\r\n\t\tcriteria: bool; (* true = acceptStates | false = emptyStack *) \r\n\t}\r\n\t\r\n\tlet kind = \"pushdown automaton\"\r\n\t\r\n\tlet pda_zero: t = {\r\n\t\tinputAlphabet = Set.empty;\r\n\t\tstackAlphabet = Set.make [draftVar];\r\n\t\tstates = Set.make [draftState];\r\n\t\tinitialState = draftState;\r\n\t\tinitialStackSymbol = draftVar;\r\n\t\ttransitions = Set.empty;\r\n\t\tacceptStates = Set.empty;\r\n\t\tcriteria = false\r\n\t}\r\nend\r\n\r\nmodule PushdownAutomatonConversions =\r\nstruct\r\n\topen PushdownAutomatonBasics\r\n\r\n\tlet fromJSon (j: JSon.t): t =\r\n\t\tif JSon.isNull j || not (JSon.hasField j \"kind\") then\r\n\t\t\tpda_zero\r\n\t\telse {\r\n\t\t\tinputAlphabet = JSon.fieldSymbolSet j \"inputAlphabet\";\r\n\t\t\tstackAlphabet = JSon.fieldSymbolSet j \"stackAlphabet\";\r\n\t\t\tstates = JSon.fieldStateSet j \"states\";\r\n\t\t\tinitialState = JSon.fieldState j \"initialState\";\r\n\t\t\tinitialStackSymbol = JSon.fieldSymbol j \"initialStackSymbol\";\r\n\t\t\ttransitions = JSon.fieldQuintupletsSet j \"transitions\";\r\n\t\t\tacceptStates = JSon.fieldStateSet j \"acceptStates\";\r\n\t\t\tcriteria = JSon.fieldBool j \"criteria\"\r\n\t\t}\r\n\r\n\tlet toJSon0 (rep: t): JSon.t =\r\n\t\tJSon.makeAssoc [\r\n\t\t\t(\"inputAlphabet\", JSon.makeSymbolSet rep.inputAlphabet);\r\n\t\t\t(\"stackAlphabet\", JSon.makeSymbolSet rep.stackAlphabet);\r\n\t\t\t(\"states\", JSon.makeStateSet rep.states);\r\n\t\t\t(\"initialState\", JSon.makeState rep.initialState);\r\n\t\t\t(\"initialStackSymbol\", JSon.makeSymbol rep.initialStackSymbol);\r\n\t\t\t(\"transitions\", JSon.makeQuintupletsSet rep.transitions);\r\n\t\t\t(\"acceptStates\", JSon.makeStateSet rep.acceptStates);\r\n\t\t\t(\"criteria\", JSon.makeBool rep.criteria)\r\n\t\t]\r\n\t\r\n\tlet toJSon2 (id: Entity.t) (rep: t): JSon.t =\r\n\t\t JSon.append (Entity.toJSon id) (toJSon0 rep)\r\n\r\n\r\n\t\r\n\tlet toJSon (rep: t): JSon.t =\r\n\t\t toJSon2 (Entity.dummyId kind) rep\r\nend\r\n\r\nmodule PushdownAutomatonBasicFunctions =\r\nstruct\r\n\topen PushdownAutomatonBasics\r\n\topen PushdownAutomatonConversions\r\n\r\n\tlet make2 (arg: t Arg.alternatives) validate: Entity.t * t =\r\n\t\tEntity.make2 arg fromJSon kind validate\r\n\r\n\tlet make (arg: t Arg.alternatives) validate: t =\r\n\t\tsnd (make2 arg validate)\r\n\r\n\tlet show (rep: t): unit =\r\n\t\tlet j = toJSon rep in\r\n\t\t\tJSon.show j\r\n\r\n\tlet show2 (id: Entity.t) (rep: t): unit =\r\n\t\tlet j = toJSon2 id rep in\r\n\t\t\tJSon.show j\r\nend\r\n\r\nmodule PushdownAutomatonX =\r\nstruct\r\n\topen PushdownAutomatonBasics\r\n\r\n\ttype tx = {\r\n\t\tinputAlphabet: symbol list;\r\n\t\tstackAlphabet: symbol list;\r\n\t\tstates: state list;\r\n\t\tinitialState: state;\r\n\t\tinitialStackSymbol: symbol;\r\n\t\ttransitions: transition list;\r\n\t\tacceptStates: state list;\r\n\t\tcriteria: bool\r\n\t}\r\n\r\n\tlet internalize (pda: tx): t = {\r\n\t\tinputAlphabet = Set.make pda.inputAlphabet;\r\n\t\tstackAlphabet = Set.make pda.stackAlphabet;\r\n\t\tstates = Set.make pda.states;\r\n\t\tinitialState = pda.initialState;\r\n\t\tinitialStackSymbol = pda.initialStackSymbol;\r\n\t\ttransitions = Set.make pda.transitions;\r\n\t\tacceptStates = Set.make pda.acceptStates;\r\n\t\tcriteria = pda.criteria\r\n\t}\r\n\r\n\tlet externalize (pda: t): tx = {\r\n\t\tinputAlphabet = Set.toList pda.inputAlphabet;\r\n\t\tstackAlphabet = Set.toList pda.stackAlphabet;\r\n\t\tstates = Set.toList pda.states;\r\n\t\tinitialState = pda.initialState;\r\n\t\tinitialStackSymbol = pda.initialStackSymbol;\r\n\t\ttransitions = Set.toList pda.transitions;\r\n\t\tacceptStates = Set.toList pda.acceptStates;\r\n\t\tcriteria = pda.criteria\r\n\t}\r\nend\r\n\r\nmodule PushdownAutomatonLearnOCaml =\r\nstruct\r\n\topen PushdownAutomatonBasics\r\n\topen PushdownAutomatonX\r\n\r\n\tlet moduleName =\r\n\t\t\"PushdownAutomaton\"\r\n\r\n\tlet xTypeName =\r\n\t\t\"pushdownAutomaton\"\r\n\r\n\r\n\tlet solution (name: string) (rep: t): string =\r\n\t\t\"\"\r\n\r\n\tlet prelude : string =\r\n\t\t\"\"\r\n\r\n\tlet example : JSon.t =\r\n\t\tJSon.parse {|\r\n\t\t{\r\n\t\t\tkind : \"finite automaton\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"pda example\",\r\n\t\t\talphabet: [\"w\", \"z\"],\r\n\t\t\tstates : [\"START\", \"X\", \"Z\"],\r\n\t\t\tinitialState : \"START\",\r\n\t\t\ttransitions : [\r\n\t\t\t\t[\"START\", \"w\", \"X\"], [\"X\", \"z\", \"X\"]\r\n\t\t\t],\r\n\t\t\tacceptStates : [\"Z\"]\r\n\t\t}\r\n\t\t|}\t(* please, do not change this line *)\r\nend\r\n\r\nmodule PushdownAutomatonSupport =\r\nstruct\r\n\tinclude PushdownAutomatonBasics\r\n\tinclude PushdownAutomatonConversions\r\n\tinclude PushdownAutomatonBasicFunctions\r\n\tinclude PushdownAutomatonLearnOCaml\r\nend\r\n\r\n\r\n# 3 \"src/PushdownAutomaton.ml\"\r\n(*\r\n * PushdownAutomaton.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Carlos Freitas (cf)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * mar/2023 (cf) - First release.\r\n * may/2022 (amd) - Initial skeleton.\r\n *)\r\n\r\n(*\r\n * Description: Pushdown automata functionality.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule PushdownAutomatonPrivate =\r\nstruct\r\n\topen PushdownAutomatonSupport\r\n\r\n\t(* TYPES *)\r\n\ttype configuration =\r\n\t\t  state\r\n\t\t* symbol list\r\n\ttype configurations = configuration set\r\n\r\n\ttype path = configuration list\r\n\ttype paths = path list\r\n\r\n\ttype stack = symbol list\r\n\r\n\ttype configuration_ =\r\n\t\t  state\r\n\t\t* stack\r\n\t\t* word\r\n\ttype configurations_ = configuration_ set\r\n\r\n\ttype searchTreeRef =\r\n\t\t  \tNotAcceptLeafRef of configuration_\r\n    \t| AcceptLeafRef of configuration_\r\n      | NodeRef of configuration_ * searchTreeRef set ref\r\n\r\n\ttype searchTree =\r\n\t\t  \tNotAcceptLeaf of configuration_\r\n    \t| AcceptLeaf of configuration_\r\n      | Node of configuration_ * searchTree set\r\n      | BestNode of configuration_ * searchTree set\r\n\r\n\t(* CONSTANTS *)\r\n\tlet stackSpecialSymb: symbol = symb \"z\"\r\n\tlet stackConverterSymb: symbol = symb \"$\"\r\n\r\n\texception TooManyTries\r\n\tlet maxTries = 100\r\n\r\n\r\n\t(* AUXILIARY *)\r\n\r\n\tlet transitionGet1 trns = Set.map ( fun (a,_,_,_,_) -> a ) trns\r\n\tlet transitionGet2 trns = Set.map ( fun (_,b,_,_,_) -> b ) trns\r\n\tlet transitionGet3 trns = Set.map ( fun (_,_,c,_,_) -> c ) trns\r\n\tlet transitionGet4 trns = Set.map ( fun (_,_,_,d,_) -> d ) trns\r\n\tlet transitionGet345 trns = Set.map ( fun (_,_,c,d,e) -> (c, d, e) ) trns\r\n\tlet transitionGet45 trns = Set.map ( fun (_,_,_,d,e) -> (d, e) ) trns\r\n\tlet transitionGet5 trns = Set.map ( fun (_,_,_,_,e) -> e ) trns\r\n\tlet transitionGet5Flat trns = Set.flatten (Set.map ( fun (_,_,_,_,e) -> Set.make e ) trns)\r\n\r\n\tlet getStackSymbols trns =\r\n\t\tlet stackSymbtoPutInStack =\r\n\t\t\tSet.fold_left ( fun acc symbList ->\r\n\t\t\t\tSet.union acc (Set.make symbList)\r\n\t\t\t) Set.empty (transitionGet5 trns)\r\n\t\tin\r\n\t\t\tSet.union (transitionGet2 trns) stackSymbtoPutInStack\r\n\r\n\tlet configurationGet1 configs = Set.map ( fun (a,_) -> a ) configs\r\n\tlet configurationGet2 configs = Set.map ( fun (_,b) -> b ) configs\r\n\r\n\tlet configuration_Get1 configs = Set.map ( fun (a,_,_) -> a ) configs\r\n    let configuration_Get2 configs = Set.map ( fun (_,b,_) -> b ) configs\r\n    let configuration_Get3 configs = Set.map ( fun (_,_,c) -> c ) configs\r\n\r\n    \r\n\tlet validate (name: string) (pda: t): unit = (\r\n\r\n\t\t(* the alphabet must not contain \"~\" *)\r\n\t\tlet validAlphabet = not (Set.belongs epsilon pda.inputAlphabet) in\r\n\r\n\t\t(* does initial state belong to the set of all states *)\r\n\t\tlet validInitSt = Set.belongs pda.initialState pda.states in\r\n\r\n\t\t(* does initial stack symbol belong to the stack alphabet *)\r\n\t\tlet validInitStackSymbol = Set.belongs pda.initialStackSymbol pda.stackAlphabet in\r\n\r\n\t\t(* are all accepted states members of all states *)\r\n\t\tlet validAccSts = Set.subset pda.acceptStates pda.states in\r\n\r\n\t\tlet fromSt = transitionGet1 pda.transitions in\r\n\t\tlet syfromStack = transitionGet2 pda.transitions in\r\n\t\tlet sy = transitionGet3 pda.transitions in\r\n\t\tlet toSt = transitionGet4 pda.transitions in\r\n\t\tlet sysToStack = transitionGet5Flat pda.transitions in\r\n\t\tlet alpha = Set.add epsilon pda.inputAlphabet in\r\n\r\n\t\t(* do all transitions have states belonging to all states, symbols belonging to the alphabet and stackSymbol belonging to stack alphabet *)\r\n\t\tlet validTrns =\r\n\t\t\t(Set.subset fromSt pda.states) &&\r\n\t\t\t(Set.subset syfromStack pda.stackAlphabet) &&\r\n\t\t\t(Set.subset sy alpha) &&\r\n\t\t\t(Set.subset toSt pda.states) &&\r\n\t\t\t(Set.subset sysToStack pda.stackAlphabet)\r\n\t\tin\r\n\r\n\t\tif not validAlphabet then\r\n\t\t\tError.error name\r\n\t\t\t\t\"The alphabet contains epsilon '~', and it should not\" ();\r\n\t\t\tif not validInitSt then\r\n\t\t\t\tError.error name\r\n\t\t\t\t\t\"The initial state does not belong to the set of all states\" ();\r\n\t\t\tif not validInitStackSymbol then\r\n\t\t\t\tError.error name\r\n\t\t\t\t\t\"The initial stack symbol does not belong to the stack alphabet\" ();\r\n\t\t\tif not validAccSts then\r\n\t\t\t\tError.error name\r\n\t\t\t\t\t\"Some accept states do not belong to the set of all states\" ();\r\n\t\t\tif not validTrns then\r\n\t\t\t\tError.error name\r\n\t\t\t\t\t\"Some transitions are invalid\" ()\r\n\t\t)\r\n\r\n\tlet rec fixedPointN (f: 'a -> 'a)(x: 'a) (moves: int): 'a =\r\n\t\tif moves = 0 then raise TooManyTries;\r\n\t\tlet next = f x in\r\n\t\t\tif x = next then x\r\n\t\t\telse fixedPointN f next (moves-1)\r\n\r\n\tlet fixedPointMaxTries f x = fixedPointN f x maxTries\r\n\r\n\tlet getValidNonEmptyTransitions currentState topStackSymb trns: transitions =\r\n\t\tSet.filter (fun (a,b,c,_,_) -> a = currentState && b = topStackSymb && c <> epsilon) trns\r\n\r\n\tlet mapStepsToConfigurationAndSymbol steps stack: (configuration * symbol) set =\r\n\t\tSet.map (fun ((symb, nextState, toPutInStack)) -> ((nextState, toPutInStack @ stack), symb)) steps\r\n\r\n\tlet getNextConfigurationsWithSymbols trns (currentState, stack): (configuration * symbol) set =\r\n\t\tmatch stack with\r\n\t\t|\t[] -> Set.make []\r\n\t\t| topStackSymb::restStack ->\r\n\t\t\t\tlet nextSteps = transitionGet345 (getValidNonEmptyTransitions currentState topStackSymb trns) in\r\n\t\t\t\t\tmapStepsToConfigurationAndSymbol nextSteps restStack\r\n\r\n\tlet getNextConfigurationsWithSymbols trns configurations: (configuration * symbol) set =\r\n\t\tSet.flatMap (getNextConfigurationsWithSymbols trns) configurations\r\n\r\n\tlet addSymbToWords (w: symbol) (words: words): words =\r\n\t\tSet.map (fun word -> w::word ) words\r\n\r\n\r\n\tlet mapStepsToConfiguration steps stack: configurations =\r\n\t\tSet.map (fun ((nextState, toPutInStack)) -> (nextState, toPutInStack @ stack)) steps\r\n\r\n\tlet getValidTransitions currentState topStackSymb w trns: transitions =\r\n\t\tSet.filter (fun (a,b,c,_,_) -> a = currentState && b = topStackSymb && (c = w)) trns\r\n\r\n\tlet getNextConfigurationsFromConfig w trns (currentState, stack): configurations =\r\n\t\tmatch stack with\r\n\t\t|\t[] -> Set.make []\r\n\t\t| topStackSymb::restStack ->\r\n\t\t\t\tlet nextSteps = transitionGet45 (getValidTransitions currentState topStackSymb w trns) in\r\n\t\t\t\t\tmapStepsToConfiguration nextSteps restStack\r\n\r\n\tlet getNextConfigurations w trns configurations: configurations =\r\n\t\tSet.flatMap (getNextConfigurationsFromConfig w trns) configurations\r\n\r\n\tlet addNextConfigurations w trns configurations: configurations =\r\n\t\tlet nextConfigs = getNextConfigurations w trns configurations in\r\n\t\tSet.union nextConfigs configurations\r\n\r\n\tlet exploreEmptyTransitions trns configurations: configurations =\r\n\t\tfixedPointMaxTries (addNextConfigurations epsilon trns) configurations\r\n\r\n\tlet isInAcceptState configs acceptStates criteria: bool =\r\n\t\tif criteria then Set.inter (configurationGet1 configs) acceptStates <> Set.empty\r\n\t\telse Set.exists (fun stack -> stack = []) (configurationGet2 configs)\r\n\r\n\tlet tickComputation w configurations transitions: configurations =\r\n\t\t\tlet nextConfigs = getNextConfigurations w transitions configurations in\r\n\t\t\t\texploreEmptyTransitions transitions nextConfigs\r\n\r\n\tlet getInitialConfig initialState initialStackSymbol transitions =\r\n\t\tlet initialConfig = Set.make [(initialState, [initialStackSymbol])] in\r\n\t\t\texploreEmptyTransitions transitions initialConfig\r\n\r\n\tlet generate length pda: words = (* ! AMD TROCAR !!! *)\r\n\t\tlet rec gen n configuration =\r\n\t\t\tlet configs = exploreEmptyTransitions pda.transitions (Set.make [configuration]) in\r\n\t\t\tif n = 0 then\r\n\t\t\t\tif isInAcceptState configs pda.acceptStates pda.criteria then Set.make [[]] else Set.empty\r\n\t\t\telse\r\n\t\t\t\tlet newConfigsAndSymbols = getNextConfigurationsWithSymbols pda.transitions configs in\r\n\t\t\t\t\tlet genX symb n config = addSymbToWords symb (gen (n-1) config) in (*exprimentar uniao para n-1*)\r\n\t\t\t\t\t\tSet.flatMap (fun (config, symb) -> genX symb n config) newConfigsAndSymbols\r\n\t\tin\r\n\t\t\tlet initialConfig = (pda.initialState, [pda.initialStackSymbol]) in\r\n\t\t\t\tgen length initialConfig\r\n\r\n\tlet printConfig (state,stack,word) =\r\n\t\tlet open Util in\r\n\t\tPrintf.printf \"(%s, \" (state2str state);\r\n\t\tprint (List.map symb2str stack); print_string \", \";\r\n\t\tprint_string (word2str word); print_string \")\\n\"\r\n\r\n\tlet rec printSearchTree = function\r\n\t\t| NotAcceptLeaf c -> print_string \"NotAcceptLeaf \"; printConfig c\r\n\t\t| AcceptLeaf c -> print_string \"AcceptLeaf \"; printConfig c\r\n\t\t| Node (c,nodes) -> print_string \"Node \";printConfig c; Set.iter printSearchTree nodes\r\n\t\t| BestNode (c,nodes) -> print_string \"BestNode \";printConfig c; Set.iter printSearchTree nodes\r\n\r\n\tlet configIsInAcceptState_ acceptStates criteria (state, stack, word): bool =\r\n\t\t\tword = [] && (if criteria then Set.belongs state acceptStates else stack = [])\r\n\r\n\tlet configsAreInAcceptState_ acceptStates criteria configs: bool =\r\n\t\tSet.exists (configIsInAcceptState_ acceptStates criteria) configs\r\n\r\n\tlet advanceOneTransition transitions (state, stack, word): configurations_ =\r\n\t\tlet getNextConfig restStack wordLeft (_,_,_,nextState,toPutInStack) = (nextState, toPutInStack@restStack, wordLeft) in\r\n\t\tlet buildNewTransitions restStack restWord validTrns = Set.map (getNextConfig restStack restWord) validTrns in\r\n\t\tlet getNextConfigs inputSymbol restWord topStack restStack =\r\n\t\t\tlet validTransitions = getValidTransitions state topStack inputSymbol transitions in\r\n\t\t\t\tbuildNewTransitions restStack restWord validTransitions\r\n\tin\r\n\t\tmatch stack, word with\r\n\t\t| [], _ -> Set.empty\r\n\t\t| s::ss, [] -> getNextConfigs epsilon [] s ss\r\n\t\t| s::ss, w::ww ->\r\n\t\t\tlet nextConfigConsumed = getNextConfigs w ww s ss in\r\n\t\t\tlet nextConfigNotConsumed = getNextConfigs epsilon (w::ww) s ss  in\r\n\t\t\t\tSet.union nextConfigConsumed nextConfigNotConsumed\r\n\r\n\tlet accept pda word: bool =\r\n\t\tlet rec acceptRec configurations: bool =\r\n\t\t\tSet.match_ configurations\r\n\t\t\t(fun () -> false)\r\n\t\t\t(fun _ _ ->\r\n\t\t\t\tif configsAreInAcceptState_ pda.acceptStates pda.criteria configurations then true\r\n\t\t\t\telse\r\n\t\t\t\t\tlet nextConfigs = Set.flatMap (advanceOneTransition pda.transitions) configurations in\r\n\t\t\t\t\tif Set.equals configurations nextConfigs then false\r\n\t\t\t\t\telse acceptRec nextConfigs\r\n\t\t\t)\r\n\t\tin\r\n\t\t\tlet getInitialConfig = Set.make [(pda.initialState, [pda.initialStackSymbol], word)] in\r\n\t\t\t\tacceptRec getInitialConfig\r\n\r\n\tlet configHasNoSymbolToConsume (_,_,word) = word=[]\r\n\r\n\tlet buildEndNode acceptStates criteria transitions config =\r\n\t\tif configIsInAcceptState_ acceptStates criteria config then AcceptLeafRef(config)\r\n        else if configHasNoSymbolToConsume config && (advanceOneTransition transitions config) = Set.empty then NotAcceptLeafRef(config)\r\n        else NodeRef(config, ref (Set.make[]))\r\n\r\n\tlet foundAcceptConfig searchTreeSet =\r\n\t\tSet.exists (fun node -> match node with | AcceptLeafRef _ -> true | _ -> false) searchTreeSet\r\n\r\n\tlet filterSearchNode searchTreeSet =\r\n\t\tSet.filter (fun node -> match node with | NodeRef _ -> true | _ -> false) searchTreeSet\r\n\r\n\texception ShouldNotHappen\r\n\tlet getNodeElements = function\r\n\t\t| NodeRef(config, setNodes) -> (config, setNodes)\r\n\t\t| _ -> raise ShouldNotHappen\r\n\r\n\tlet getNextConfigsPair searchTreeSet transitions =\r\n\t\tSet.map (fun tree ->\r\n\t\t\tlet (config, _) = getNodeElements tree in\r\n\t\t\tlet nextConfigs = advanceOneTransition transitions config in\r\n            \t(tree, nextConfigs)\r\n\t\t) searchTreeSet\r\n\r\n\tlet buildTree acceptStates criteria transitions pairTreesAndNextConfigs =\r\n\t\tSet.flatMap (fun (tree, nextConfigs) ->\r\n\t\t\tlet (_, setNodes) = getNodeElements tree in\r\n\t\t\tlet newNodes = Set.map (buildEndNode acceptStates criteria transitions) nextConfigs in\r\n            setNodes := newNodes;\r\n            \tnewNodes\r\n\t\t) pairTreesAndNextConfigs\r\n\r\n\tlet buildSearchTree (word: word) pda: searchTreeRef =\r\n\t\tlet rec buildSearchTree (forest: searchTreeRef set) =\r\n\t\t\tSet.match_ forest\r\n\t\t\t(fun () -> ())\r\n\t\t\t(fun _ _ ->\r\n\t\t\t\tlet pairTreesAndNextConfigs = getNextConfigsPair forest pda.transitions in\r\n\t\t\t\tlet nextNodes = buildTree pda.acceptStates pda.criteria pda.transitions pairTreesAndNextConfigs in\r\n\t\t\t\tif foundAcceptConfig nextNodes || Set.equals forest nextNodes then ()\r\n\t\t\t\telse buildSearchTree (filterSearchNode nextNodes)\r\n\t\t\t)\r\n\t\tin\r\n\t\t\tlet initialConfig = (pda.initialState, [pda.initialStackSymbol], word) in\r\n\t\t\tif configIsInAcceptState_ pda.acceptStates pda.criteria initialConfig then AcceptLeafRef(initialConfig)\r\n\t\t\telse\r\n\t\t\t\tlet searchTree: searchTreeRef = NodeRef(initialConfig, ref (Set.make [])) in\r\n\t\t\t\t\tbuildSearchTree (Set.make [searchTree]);\r\n\t\t\t\t\tsearchTree\r\n\r\n\tlet isBestNode = function | AcceptLeaf _ -> true | BestNode _ -> true | _ -> false\r\n\tlet hasBestPath searchTreeSet =\r\n    \tSet.exists isBestNode searchTreeSet\r\n\r\n\tlet rec mapBestPath: searchTreeRef -> searchTree = function\r\n\t\t| AcceptLeafRef c -> AcceptLeaf(c)\r\n\t\t| NotAcceptLeafRef c -> NotAcceptLeaf(c)\r\n\t\t| NodeRef(c, treeSet) ->\r\n\t\t\tlet nextLayer = Set.map mapBestPath !treeSet in\r\n\t\t\tif hasBestPath nextLayer then BestNode(c, nextLayer) else Node(c, nextLayer)\r\n\r\n\tlet getSearchTree word pda =\r\n\t\tbuildSearchTree word pda |> mapBestPath\r\n\r\n\tlet transformConfig (state,stack,word) = (state,stack)\r\n\r\n\tlet getWordFromNode = function\r\n\t\t| AcceptLeaf((_,_,word)) -> word\r\n\t\t| NotAcceptLeaf((_,_,word)) -> word\r\n\t\t| Node((_,_,word), _) -> word\r\n\t\t| BestNode((_,_,word), _) -> word\r\n\r\n\tlet getBestNodeAndWord setNodes =\r\n    \tlet node = Set.find isBestNode setNodes in\r\n    \t\t(node, getWordFromNode node)\r\n\r\n\tlet rec buildBestPath: searchTree -> path = function\r\n\t\t| AcceptLeaf(c) -> [transformConfig c]\r\n\t\t| NotAcceptLeaf(c) -> []\r\n\t\t| Node(c, treeSet) -> []\r\n\t\t| BestNode((_,_,word) as c, treeSet) ->\r\n\t\t\t\t\tlet (nextBestNode, nextWord) = getBestNodeAndWord treeSet in\r\n\t\t\t\t\tif (word = nextWord) then buildBestPath(nextBestNode)\r\n\t\t\t\t\telse (transformConfig c)::buildBestPath(nextBestNode)\r\n\r\n\tlet getBestPath word pda =\r\n\t\t\tgetSearchTree word pda |> buildBestPath\r\n\r\n\tlet getConfigsAndNextNodes: searchTree -> configuration * searchTree set = function\r\n\t\t\t| AcceptLeaf(c) -> (transformConfig c, Set.empty)\r\n\t\t\t| NotAcceptLeaf(c) -> (transformConfig c, Set.empty)\r\n\t\t\t| Node(c, treeSet) -> (transformConfig c, treeSet)\r\n\t\t\t| BestNode(c, treeSet) -> (transformConfig c, treeSet)\r\n\r\n\tlet getAllConfigsAndFilterNextNodesThatConsumeSymbol nodes =\r\n\t\tSet.fold_left (fun (configsAcc,treeSetAcc) tree ->\r\n\t\t\tlet (c,treeSet) = getConfigsAndNextNodes tree in\r\n\t\t\tlet word = getWordFromNode tree in\r\n\t\t\tlet nextTreeSet = Set.filter (fun t -> word <> getWordFromNode t) treeSet in\r\n\t\t\t\t(Set.add c configsAcc, Set.union nextTreeSet treeSetAcc)\r\n\t\t) (Set.empty, Set.empty) nodes\r\n\r\n\tlet getNextEpsilonNodes nodes =\r\n\t\tSet.fold_left (fun treeSetAcc tree ->\r\n\t\t\tlet (_,treeSet) = getConfigsAndNextNodes tree in\r\n\t\t\tlet word = getWordFromNode tree in\r\n\t\t\tlet nextTreeSet = Set.filter (fun t -> word = getWordFromNode t) treeSet in\r\n\t\t\t\tSet.union nodes (Set.union nextTreeSet treeSetAcc)\r\n\t\t) Set.empty nodes\r\n\r\n\tlet rec getConfigsBySymbolConsumedStep (forest: searchTree set): configurations list =\r\n\t\tSet.match_ forest\r\n\t\t(fun () -> [])\r\n\t\t(fun _ _ ->\r\n\t\t\tlet closureNodes = Set.fixedPoint getNextEpsilonNodes forest in\r\n\t\t\tlet (configs, nextNodes) = getAllConfigsAndFilterNextNodesThatConsumeSymbol closureNodes in\r\n\t\t\t\t\tconfigs::(getConfigsBySymbolConsumedStep nextNodes)\r\n\t\t)\r\n\r\n\tlet getConfigsPathBySymbolConsumedAndBestPath word pda: configurations list * path =\r\n\t\tlet searchTree = getSearchTree word pda in\r\n\t\t\tlet bestPath = buildBestPath searchTree in\r\n\t\t\t\tlet configsBySymbolConsumedStep = getConfigsBySymbolConsumedStep (Set.make [searchTree]) in\r\n\t\t\t\t\t(configsBySymbolConsumedStep, bestPath)\r\n\r\n\r\n\r\n\tlet rec generateUntil length pda: words =\r\n\t\tif length < 0 then Set.empty\r\n\t\telse Set.union (generate length pda) (generateUntil (length-1) pda)\r\n\r\n\tlet transformPdaToAcceptStates pda: t =\r\n\t\tlet buildNewTransitions (si: state) (sf: state): transitions = (*si estado inicial, sf estado final*)\r\n\t\t\tlet initialTrsn: transition =\r\n\t\t\t\t(si, stackConverterSymb, epsilon, pda.initialState, [pda.initialStackSymbol; stackConverterSymb]) in\r\n\t\t\tlet buildTrasitionToFinalState s =\r\n\t\t\t\t(state s, stackConverterSymb, epsilon, sf, [stackConverterSymb]) in\r\n\t\t\tlet buildTransitions states = Set.map buildTrasitionToFinalState states in\r\n\t\t\t\tSet.add initialTrsn (buildTransitions pda.states)\r\n\t\tin\r\n\t\tlet convertedPda: t = {\r\n\t\t\tinputAlphabet = pda.inputAlphabet;\r\n\t\t\tstackAlphabet = Set.add stackConverterSymb pda.stackAlphabet;\r\n\t\t\tstates = Set.union (pda.states) (Set.make [state \"Si\"; state \"Sf\"]);\r\n\t\t\tinitialState = state \"Si\";\r\n\t\t\tinitialStackSymbol = stackConverterSymb;\r\n\t\t\ttransitions = Set.union (pda.transitions) (buildNewTransitions (state \"Si\") (state \"Sf\"));\r\n\t\t\tacceptStates = Set.make [(state \"Sf\")];\r\n\t\t\tcriteria = true\r\n\t\t\t}\r\n\t\tin\r\n\t\t\tif pda.criteria then pda else convertedPda\r\n\r\n\tlet transformPdaToAcceptEmptyStack pda: t =\r\n\t\tlet newStackAlphabet = Set.add stackConverterSymb pda.stackAlphabet in\r\n\t\tlet buildNewTransitions si sf: transitions = (*si estado inicial, sf estado final*)\r\n\t\t\tlet initialTrsn: transition = (si, stackConverterSymb, epsilon, pda.initialState, [pda.initialStackSymbol; stackConverterSymb]) in\r\n\t\t\tlet buildFinalTransitionsToConsumeStack stackAlphabet: transitions =\r\n\t\t\t\tSet.map ( fun symbStack -> (sf, symbStack, epsilon, sf, []) ) stackAlphabet\r\n\t\t\tin\r\n\t\t\tlet buildTrasitionsFromAcceptState acceptState: transitions =\r\n\t\t\t\tlet symbsStack = getStackSymbols pda.transitions in\r\n\t\t\t\t\tSet.map ( fun symbStack -> (acceptState, symbStack, epsilon, sf, [symbStack])) symbsStack\r\n\t\t\tin\r\n\t\t\tlet buildTransitions states: transitions = Set.flatten (Set.map buildTrasitionsFromAcceptState pda.acceptStates) in\r\n\t\t\t\tSet.union (Set.add initialTrsn (buildTransitions pda.states)) (buildFinalTransitionsToConsumeStack newStackAlphabet)\r\n\t\tin\r\n\t\tlet convertedPda: t = {\r\n\t\t\tinputAlphabet = pda.inputAlphabet;\r\n\t\t\tstackAlphabet = newStackAlphabet;\r\n\t\t\tstates = Set.union (pda.states) (Set.make [state \"Si\"; state \"Sf\"]);\r\n\t\t\tinitialState = state \"Si\";\r\n\t\t\tinitialStackSymbol = stackConverterSymb;\r\n\t\t\ttransitions = Set.union (pda.transitions) (buildNewTransitions (state \"Si\") (state \"Sf\"));\r\n\t\t\tacceptStates = Set.empty;\r\n\t\t\tcriteria = false\r\n\t\t\t}\r\n\t\tin\r\n\t\t\tif pda.criteria then convertedPda else pda\r\n\r\n\tlet pda2fa pda: FiniteAutomaton.model =\r\n\t\tlet transitionsFa trns = Set.map ( fun (s1,_,a,s2,_) -> (s1,a,s2) ) trns in\r\n\t\tlet fa: FiniteAutomaton.t = {\r\n\t\t\t\talphabet = pda.inputAlphabet;\r\n\t\t\t\tstates = pda.states;\r\n\t\t\t\tinitialState = pda.initialState;\r\n\t\t\t\ttransitions = transitionsFa pda.transitions;\r\n\t\t\t\tacceptStates = pda.acceptStates\r\n\t\t\t} in\r\n\t\tnew FiniteAutomaton.model (Arg.Representation fa)\r\n\r\n(* AMD repetido *)\r\n\tlet fa2pda (fa : FiniteAutomaton.t ): t =\r\n\t\tlet upgradeTransitions trns = Set.map ( fun (s1,symb,s2) -> (s1,stackSpecialSymb,symb,s2,[stackSpecialSymb]) ) trns in\r\n\t\t\t{\r\n\t\t\t\tinputAlphabet = fa.alphabet;\r\n\t\t\t\tstackAlphabet = Set.make [stackSpecialSymb];\r\n\t\t\t\tstates = fa.states;\r\n\t\t\t\tinitialState = fa.initialState;\r\n\t\t\t\tinitialStackSymbol = stackSpecialSymb;\r\n\t\t\t\ttransitions = upgradeTransitions fa.transitions;\r\n\t\t\t\tacceptStates = fa.acceptStates;\r\n\t\t\t\tcriteria = true\r\n\t\t\t}\r\n\r\n\tlet reachable s pda: states =\r\n\t\tlet fa : FiniteAutomaton.model = pda2fa pda in\r\n\t\tfa#reachable (s)\r\n\r\n\tlet productive pda: states =\r\n\t\tlet pdaTransformed = transformPdaToAcceptStates pda in\r\n\t\tlet fa : FiniteAutomaton.model = pda2fa pdaTransformed in\r\n\t\tSet.inter fa#productive pda.states\r\n\r\n\tlet getUsefulStates pda: states =\r\n\t\tlet pdaTransformed = transformPdaToAcceptStates pda in\r\n\t\tlet fa : FiniteAutomaton.model = pda2fa pdaTransformed in\r\n\t\tSet.inter fa#getUsefulStates pda.states\r\n\r\n\tlet getUselessStates pda: states =\r\n\t\tlet pdaTransformed = transformPdaToAcceptStates pda in\r\n\t\tlet fa : FiniteAutomaton.model = pda2fa pdaTransformed in\r\n\t\tSet.inter fa#getUselessStates pda.states\r\n\r\n\r\n\tlet cleanUselessStates pda: t =\r\n\t\tlet getEquivalentTransitions (s1,sym,s2) =\r\n\t\t\tSet.filter (fun (a,b,c,d,e) -> a = s1 && c = sym && d = s2 ) pda.transitions in\r\n\t\tlet getCleanedTransitions faCleanedTransitions =\r\n\t\t\tSet.flatMap getEquivalentTransitions faCleanedTransitions in\r\n\t\tlet pdaTransformed = transformPdaToAcceptStates pda in\r\n\t\tlet fa : FiniteAutomaton.model = pda2fa pdaTransformed in\r\n\t\tlet faClean: FiniteAutomaton.model = fa#cleanUselessStates in\r\n\t\t\t{\r\n\t\t\t\tinputAlphabet = pda.inputAlphabet;\r\n\t\t\t\tstackAlphabet = pda.stackAlphabet;\r\n\t\t\t\tstates = Set.inter faClean#representation.states pda.states;\r\n\t\t\t\tinitialState = pda.initialState;\r\n\t\t\t\tinitialStackSymbol = pda.initialStackSymbol;\r\n\t\t\t\ttransitions = getCleanedTransitions faClean#representation.transitions;\r\n\t\t\t\tacceptStates = Set.inter fa#representation.acceptStates pda.acceptStates;\r\n\t\t\t\tcriteria = pda.criteria\r\n\t\t\t}\r\n\r\n(*trocar para a positiva AMD*)\r\n\tlet isDeterministic pda: bool =\r\n\r\n\t\t(*returns the trasitions for a given state, stackSymbol and inputSymbol, including epsilon transitions*)\r\n\t\tlet trnsFromStateAndSymbs st stackSymb inputSymb =\r\n\t\t\tSet.filter (fun (s1,stackS,symb,_,_) -> (st = s1) && (stackSymb = stackS) && (symb = inputSymb || symb = epsilon)) pda.transitions\r\n\t\tin\r\n\r\n\t\t(*Validates if there is more than one transition possible for a given state, stackSymbol*)\r\n\t\tlet isnotDeterministicForStateAndStackSymbol st stackSymb =\r\n\t\t\tSet.exists (fun symb -> Set.size (trnsFromStateAndSymbs st stackSymb symb) > 1) pda.inputAlphabet\r\n\t\tin\r\n\r\n\t\t(*Validates if a state is non deterministic*)\r\n\t\tlet isStateNonDeterministic st =\r\n\t\t\tSet.exists (fun stackSymb -> isnotDeterministicForStateAndStackSymbol st stackSymb) pda.stackAlphabet\r\n\t\tin\r\n\t\t\tnot (Set.exists (fun st -> isStateNonDeterministic st) pda.states)\r\n\r\n\tlet isFiniteAutomaton pda: bool =\r\n\t\tlet validateTransition (_,a,_,_,b) = [a] = b in\r\n\t\t\tSet.for_all validateTransition pda.transitions\t\r\nend\r\n\r\nmodule PushdownAutomatonJoao =\r\nstruct\r\n\topen PushdownAutomatonSupport\r\n\topen PushdownAutomatonPrivate\r\n\r\n\t(*CODIGO JP*)\r\n\t\r\n\ttype path_ = configuration_ list\r\n\ttype trail = configurations_ list\r\n\r\n\r\n\tlet initialConfigs (pda: t) (w: word) : configurations_ =\r\n\t\t\tSet.make [(pda.initialState, [pda.initialStackSymbol], w)]\r\n\r\n\tlet nextConfigs (pda: t) (st, sa, w) : configurations_ =\r\n\tlet stackLeft = List.tl sa in\r\n\tlet stackTop = List.hd sa in\r\n\tmatch w with\r\n\t| [] ->\r\n\t\tlet empty = Set.filter(fun (st1, sa1, sy, _, _)->\r\n\t\t\tst1 = st && sy = epsilon && sa1 = stackTop\r\n\t\t\t) pda.transitions in \r\n\t\t\t\tSet.map (fun (_,_,_,st2, sa2) -> (st2, sa2@stackLeft, [])) empty\r\n\t| x :: xs ->\r\n\t\tlet nonEmpty = Set.filter (fun (st1, sa1, sy, _, _) ->\r\n\t\t\tst1 = st && sy = x && sa1 = stackTop\r\n\t\t\t) pda.transitions\r\n\t\tin\r\n\t\tlet empty = Set.filter(fun (st1, sa1, sy, _, _)->\r\n\t\t\tst1 = st && sy = epsilon && sa1 = stackTop\r\n\t\t\t) pda.transitions \r\n\t\tin\r\n\t\tlet res1 = Set.map (fun (_, _, _, st2, sa2) -> \r\n\t\t\t(st2, sa2@stackLeft, xs)\r\n\t\t\t) nonEmpty in\r\n\t\tlet res2 = Set.map (fun (_, _, _, st2, sa2) -> \r\n\t\t\t(st2, sa2@stackLeft, w)\r\n\t\t\t) empty in\r\n\t\tSet.union res1 res2\r\n\r\n\tlet isAcceptingConfig (pda: t) (st, sa, w) : bool =\r\n\t\tif (pda.criteria) then (\r\n\t\t\t\t w = [] && Set.belongs st pda.acceptStates\r\n\t\t)\r\n\t\telse (w = [] && sa = [])\r\n\r\n\tlet nextConfigs2 pda (len: int) (st, sa, w) = \r\n\t\tlet stackTop = List.hd sa in\r\n\t\tlet stackLeft = List.tl sa in\r\n\t\t\tlet selected = Set.filter (fun (st1, sa1, _, _, _) -> \r\n\t\t\t\tst1 = st && sa1 = stackTop) pda.transitions in\r\n\t\t\tSet.map (fun (_, _, sy, st2, sa2) -> (st2, sa2@stackLeft, if sy = epsilon then w else sy::w)) selected\r\n\r\n\tlet isAcceptingConfig2 pda (st, sa, _) =\r\n\t\tif (pda.criteria) then Set.belongs st pda.acceptStates else sa = []\r\n\r\n\tlet accept (pda: t) (w: word) : bool =\r\n\t\tModel.accept pda w initialConfigs nextConfigs isAcceptingConfig\r\n\t\r\n\tlet acceptFull (pda: t) (w: word) : bool * path_ * trail =\r\n\t\tModel.acceptFull pda w initialConfigs nextConfigs isAcceptingConfig\r\n\r\n\tlet getWord (_, _, w) = List.rev w;;\r\n\r\n\tlet generate (pda: t) (len: int): words =\r\n\t\tModel.generate pda len initialConfigs nextConfigs2 isAcceptingConfig2 getWord\r\n\r\n\t(*generate*)\r\n\t\r\nend\r\n\r\nmodule PushdownAutomaton =\r\nstruct\r\n\tinclude PushdownAutomatonSupport\r\n\tinclude PushdownAutomatonPrivate\r\n\r\n\t(* Make *)\r\n\tlet make2 (arg: t Arg.alternatives): Entity.t * t = make2 arg validate\r\n\tlet make (arg: t Arg.alternatives): t = make arg validate\r\n\r\n\t(* Exercices support *)\r\n\tlet checkProperty (pda: t) (prop: string) =\r\n\t\tmatch prop with\r\n\t\t\t| \"true\" -> true\r\n\t\t\t| _ -> Model.checkProperty prop\r\n\tlet checkExercise ex pda = Model.checkExercise ex (accept pda) (checkProperty pda)\t\r\n\tlet checkExerciseFailures ex pda = Model.checkExerciseFailures ex (accept pda) (checkProperty pda)\r\n\r\n\t(* Ops *)\r\n\tlet accept = accept\r\n\tlet generate = generate\t\r\n\t\r\n\t(* Class *)\r\n\tclass model (arg: t Arg.alternatives) =\r\n\t\tobject(self) inherit Model.model (make2 arg) as super\r\n\t\t(* Representation *)\r\n\t\t\tmethod representation: t = representation\r\n\t\t(* Kind *)\r\n\t\t\tmethod isPushdownAutomaton : bool = true\r\n\t\t(* Show *)\t\t\t\r\n\t\t\tmethod toJSon: JSon.t = toJSon representation\r\n\t\t\tmethod toJSon2: JSon.t = toJSon2 id representation\r\n\t\t\tmethod show: unit = show representation\r\n\t\t\tmethod show2: unit = show2 id representation\r\n\t\t(* Ops *)\r\n\t\t\tmethod accept (w: word): bool = accept representation w\r\n\t\t\tmethod acceptFull (w: word) : bool * PushdownAutomatonJoao.path_ * PushdownAutomatonJoao.trail = \r\n\t\t\t\tPushdownAutomatonJoao.acceptFull representation w\r\n\t\t\tmethod generate (length: int): words = generate length representation\r\n\t\t\tmethod generateUntil (length: int): words = generateUntil length representation\r\n\t\t\tmethod getSearchTree (w: word): searchTree = getSearchTree w representation\r\n\t\t\tmethod getBestPath (w: word): path = getBestPath w representation\r\n\r\n\t\t\tmethod getConfigsPathBySymbolConsumedAndBestPath word: configurations list * path =\r\n\t\t\t\tgetConfigsPathBySymbolConsumedAndBestPath word representation\r\n\r\n\t\t\tmethod transformPdaToAcceptStates: model =\r\n\t\t\t\tlet pda = transformPdaToAcceptStates representation in\r\n\t\t\t\t\tnew model (Arg.Representation pda)\r\n\r\n\t\t\tmethod transformPdaToAcceptEmptyStack: model =\r\n\t\t\t\tlet pda = transformPdaToAcceptEmptyStack representation in\r\n\t\t\t\t\tnew model (Arg.Representation pda)\r\n\r\n\t\t\tmethod reachable (s: state): states = reachable s representation\r\n\t\t\tmethod productive: states = productive representation\r\n\t\t\tmethod getUsefulStates: states = getUsefulStates representation\r\n\t\t\tmethod getUselessStates: states = getUselessStates representation\r\n\t\t\tmethod cleanUselessStates: model =\r\n\t\t\t\tlet pda = cleanUselessStates representation in\r\n\t\t\t\t\tnew model(Arg.Representation pda)\r\n\t\t\tmethod areAllStatesUseful: bool =\r\n\t\t\t\tlet usefullStates = self#getUsefulStates in\r\n\t\t\t\t\tSet.size representation.states = Set.size usefullStates\r\n\t\t\tmethod isDeterministic: bool = isDeterministic representation\r\n\t\t\tmethod isFiniteAutomaton: bool = isFiniteAutomaton representation\r\n\t\t(* Exercices support *)\r\n\t\t\tmethod checkProperty (prop: string) = Util.println[\"WWW\"]; checkProperty representation prop\r\n\t\t(* Learn-OCaml support *)\r\n\t\t\tmethod moduleName = moduleName\r\n\t\t\tmethod xTypeName = xTypeName\r\n\t\t\tmethod xTypeDeclString : string = prelude\r\n\t\t\tmethod toDisplayString (name: string): string = solution name self#representation\r\n\t\t\tmethod example : JSon.t = example\r\n\tend\r\nend\r\n\r\n\r\n# 3 \"src/TuringMachineSupport.ml\"\r\n(*\r\n * TuringMachineSupport.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * jan/2025 (amd) - Code improved and adjusted for multitape.\r\n * jun/2022 (amd) - New module.\r\n *)\r\n\r\n(*\r\n * Description: Types and functions supporting multitape TMs.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule TuringMachineBasics =\r\nstruct\r\n\ttype symbolM = symbol list\r\n\ttype directionM = direction list\r\n\ttype transition  = state * symbolM * state * symbolM * directionM\r\n\ttype transitions = transition set\r\n\r\n\ttype t = {\r\n\t\tentryAlphabet: symbols;\r\n\t\ttapeAlphabet: symbols;\r\n\t\tempty: symbol;\r\n\t\tstates: states;\r\n\t\tinitialState: state;\r\n\t\ttransitions: transitions;\r\n\t\tacceptStates: states;\r\n\t\tcriteria: bool; (* true = acceptStates | false = stop *)\r\n\t\tlbMarkers: symbol list;\r\n\t\t_nTapes: int\r\n\t}\r\n\r\n\ttype halfTape = symbol list\r\n\ttype tape = halfTape * halfTape\r\n\ttype tapes = tape list\r\n\ttype configuration = state * tapes\r\n\ttype configurations = configuration set\r\n\r\n\ttype path = configuration BasicTypes.path\r\n\ttype trail = configuration BasicTypes.trail\r\n\r\n\tlet kind = \"turing machine\"\r\n\r\n\tlet tm_zero: t = {\r\n\t\tentryAlphabet = Set.empty;\r\n\t\ttapeAlphabet = Set.make [empty];\t\r\n\t\tempty = empty;\r\n\t\tstates = Set.make [draftState];\r\n\t\tinitialState = draftState;\r\n\t\ttransitions = Set.empty;\r\n\t\tacceptStates = Set.empty;\r\n\t\tcriteria = false;\r\n\t\tlbMarkers = [];\r\n\t\t_nTapes = 1\r\n\t}\r\n\t\r\n\tlet nTapes (tm: t): int =\r\n\t\ttm._nTapes\r\n\r\n\tlet multi (tm: t) x =\r\n\t\tList.init (nTapes tm) (fun _-> x)\r\n\r\n\tlet lbLeft (tm: t) =\r\n\t\tList.nth tm.lbMarkers 0\r\n\r\n\tlet lbRight (tm: t) =\r\n\t\tList.nth tm.lbMarkers 1\r\n\r\n\tlet calcNTapes (ts: transitions): int =\r\n\t\tSet.match_ ts\r\n\t\t\t(fun () -> 1)\r\n\t\t\t(fun (_,b,_,_,_) _ -> List.length b)\r\n\r\n\tlet getTransSymbolMs (rep: t): symbolM set =\r\n\t\tlet trns = rep.transitions in\r\n\t\tlet trns2 = Set.map (fun (_,b,_,_,_) -> b) trns in\r\n\t\tlet trns4 = Set.map (fun (_,_,_,d,_) -> d) trns in\r\n\t\t\tSet.union trns2 trns4\r\n\r\n\tlet getTransSymbols (rep: t): symbols =\r\n\t\tSet.flatten (Set.map Set.make (getTransSymbolMs rep))\r\n\r\n\tlet getTransDirectionMs (rep: t): directionM set =\r\n\t\tSet.map (fun (_,_,_,_,e) -> e) rep.transitions\r\n\t\t\r\n\tlet getTransDirections (rep: t): direction set =\r\n\t\tSet.flatten (Set.map Set.make (getTransDirectionMs rep))\r\n\t\tend\r\n\r\nmodule TuringMachineJSon =\r\nstruct\r\n\topen JSon\r\n\topen TuringMachineBasics\r\n\r\n\tlet asDirection (j: JSon.t) (field: string): direction =\r\n\t\tmatch j with\r\n\t\t| JString \"L\" -> L\r\n\t\t| JString \"S\" -> S\r\n\t\t| JString \"R\" -> R\r\n\t\t| _ -> error field \"Expected L|S|R\" dummyDirection\r\n\r\n\tlet asOptionalDirectionList (j: JSon.t) (field: string): direction list =\r\n\t\tmatch j with\r\n\t\t| JList l -> List.map (fun j -> asDirection j field) l\r\n\t\t| JString _ -> [asDirection j field]\r\n\t\t| _ -> error field \"Expected direction list\" []\r\n\r\n\tlet dummyTransition = (\r\n\t\tdummyState,[dummySymb],dummyState,[dummySymb],[dummyDirection]\r\n\t)\r\n\t\r\n\tlet asOptionalSymbolList (j: JSon.t) (field: string): symbol list =\r\n\t\tmatch j with\r\n\t\t| JList l -> List.map (fun j -> asSymbol j field) l\r\n\t\t| JString _ -> [asSymbol j field]\r\n\t\t| _ -> error field \"Expected transition symbols\" []\r\n\t\r\n\tlet asTransition (j: JSon.t) (field: string): transition =\r\n\t\tmatch j with\r\n\t\t| JList [a; b; c; d; e] ->\r\n\t\t\t(\tasState a field,\r\n\t\t\t\tasOptionalSymbolList b field,\r\n\t\t\t\tasState c field,\r\n\t\t\t\tasOptionalSymbolList d field,\r\n\t\t\t\tasOptionalDirectionList e field\r\n\t\t\t)\r\n\t\t| _ -> error field \"Malformed TM transition\" dummyTransition\r\n\r\n\tlet fieldTMTransitionList (j: JSon.t) (field: string): transition list =\r\n\t\tmatch j |> getField field with\r\n\t\t| JNull -> Error.error field \"Missing field\" []\r\n\t\t| JList l -> List.map (fun j -> asTransition j field) l\r\n\t\t| _ -> []\r\n\r\n\tlet fieldTransitions (j: JSon.t) (field: string): transitions  =\r\n\t\tSet.validate (fieldTMTransitionList j field) field\r\n\r\n\tlet makeTransitions (s: transitions): JSon.t =\r\n\t\tJList (List.map (fun (a,b,c,d,e) ->\r\n\t\t\t\t\t\t\tJList [\tJString (state2str a);\r\n\t\t\t\t\t\t\t\t\tJList (List.map (fun s -> JString (symb2str s)) b);\r\n\t\t\t\t\t\t\t\t\tJString (state2str c);\r\n\t\t\t\t\t\t\t\t\tJList (List.map (fun s -> JString (symb2str s)) d);\r\n\t\t\t\t\t\t\t\t\tJList (List.map (fun d -> JString (dirX d)) e)\r\n\t\t\t\t\t\t\t]) (Set.toList s))\r\n\r\nend\r\n\r\nmodule TuringMachineConversions =\r\nstruct\r\n\topen TuringMachineBasics\r\n\r\n\tlet fromJSon (j: JSon.t): t =\r\n\t\tif JSon.isNull j || not (JSon.hasField j \"kind\") then\r\n\t\t\ttm_zero\r\n\t\telse\r\n\t\t\tlet ts = TuringMachineJSon.fieldTransitions j \"transitions\" in\r\n\t\t\t{\r\n\t\t\tentryAlphabet = JSon.fieldSymbolSet j \"entryAlphabet\";\r\n\t\t\ttapeAlphabet = JSon.fieldSymbolSet j \"tapeAlphabet\";\r\n\t\t\tempty = JSon.fieldSymbol j \"empty\";\r\n\t\t\tstates = JSon.fieldStateSet j \"states\";\r\n\t\t\tinitialState = JSon.fieldState j \"initialState\";\r\n\t\t\ttransitions = ts;\r\n\t\t\tacceptStates = JSon.fieldStateSet j \"acceptStates\";\r\n\t\t\tcriteria = JSon.fieldBool j \"criteria\";\r\n\t\t\tlbMarkers = if JSon.hasField j \"markers\" then\t(* optional *)\r\n\t\t\t\t\t\t\tJSon.fieldSymbolList j \"markers\"\r\n\t\t\t\t\t\telse [];\r\n\t\t\t_nTapes = calcNTapes ts\r\n\t\t\t}\r\n\r\n\tlet toJSon0 (tm: t): JSon.t =\r\n\t\tJSon.makeAssoc [\r\n\t\t\t(\"entryAlphabet\", JSon.makeSymbolSet tm.entryAlphabet);\r\n\t\t\t(\"tapeAlphabet\", JSon.makeSymbolSet tm.tapeAlphabet);\r\n\t\t\t(\"empty\", JSon.makeSymbol tm.empty);\r\n\t\t\t(\"states\", JSon.makeStateSet tm.states);\r\n\t\t\t(\"initialState\", JSon.makeState tm.initialState);\r\n\t\t\t(\"transitions\", TuringMachineJSon.makeTransitions tm.transitions);\r\n\t\t\t(\"acceptStates\", JSon.makeStateSet tm.acceptStates);\r\n\t\t\t(\"criteria\", JSon.makeBool tm.criteria);\r\n\t\t\t(\"lbMarkers\", JSon.makeSymbolList tm.lbMarkers);\r\n\t\t]\t\r\n\r\n\tlet toJSon2 (id: Entity.t) (tm: t): JSon.t =\r\n\t\t JSon.append (Entity.toJSon id) (toJSon0 tm)\r\n\t\r\n\tlet toJSon (tm: t): JSon.t =\r\n\t\t toJSon2 (Entity.dummyId kind) tm\r\nend\r\n\r\nmodule TuringMachineBasicFunctions =\r\nstruct\r\n\topen TuringMachineBasics\r\n\topen TuringMachineConversions\r\n\r\n\tlet make2 (arg: t Arg.alternatives) validate: Entity.t * t =\r\n\t\tEntity.make2 arg fromJSon kind validate\r\n\r\n\tlet make (arg: t Arg.alternatives) validate: t =\r\n\t\tsnd (make2 arg validate)\r\n\r\n\tlet show (tm: t): unit =\r\n\t\tlet j = toJSon tm in\r\n\t\t\tJSon.show j\r\n\r\n\tlet show2 (id: Entity.t) (tm: t): unit =\r\n\t\tlet j = toJSon2 id tm in\r\n\t\t\tJSon.show j\r\nend\r\n\r\nmodule TuringMachineX =\r\nstruct\r\n\topen TuringMachineBasics\r\n\r\n\ttype symbolXM = symbolX list\r\n\ttype directionXM = string list\r\n\ttype transitionX  = state * symbolXM * state * symbolXM * directionXM\r\n\r\n\ttype tapeX = string * string\r\n\ttype tapesX = tapeX list\r\n\ttype configurationX = state * tapesX\r\n\ttype configurationsX = configurationX list\r\n\r\n\ttype tx = {\r\n\t\tentryAlphabet: symbolX list;\r\n\t\ttapeAlphabet: symbolX list;\r\n\t\tempty: symbolX;\r\n\t\tstates: state list;\r\n\t\tinitialState: state;\r\n\t\ttransitions: transitionX list;\r\n\t\tacceptStates: state list;\r\n\t\tcriteria: bool;\r\n\t\tlbMarkers: symbolX list;\r\n\t}\r\n\r\n\tlet transI (a,b,c,d,e): transition =\r\n\t\t(a, List.map symbI b, c, List.map symbI d, List.map dirI e)\r\n\tlet transX (a,b,c,d,e): transitionX =\r\n\t\t(a, List.map symbX b, c, List.map symbX d, List.map dirX e)\r\n\r\n\tlet tmI (tmx: tx): t =\r\n\t\tlet ts = Set.make (List.map transI tmx.transitions) in {\r\n\t\t\tentryAlphabet = symbolsI tmx.entryAlphabet;\r\n\t\t\ttapeAlphabet = symbolsI tmx.tapeAlphabet;\t\r\n\t\t\tempty = symbI tmx.empty;\t\r\n\t\t\tstates = Set.make tmx.states;\r\n\t\t\tinitialState = tmx.initialState;\r\n\t\t\ttransitions = ts;\r\n\t\t\tacceptStates = Set.make tmx.acceptStates;\r\n\t\t\tcriteria = tmx.criteria;\r\n\t\t\tlbMarkers = List.map symbI tmx.lbMarkers;\r\n\t\t\t_nTapes = calcNTapes ts\r\n\t\t}\r\n\r\n\tlet tmX (tm: t): tx = {\r\n\t\tentryAlphabet = symbolsX tm.entryAlphabet;\r\n\t\ttapeAlphabet = symbolsX tm.tapeAlphabet;\t\r\n\t\tempty = symbX tm.empty;\r\n\t\tstates = Set.toList tm.states;\r\n\t\tinitialState = tm.initialState;\r\n\t\ttransitions = Set.toList (Set.map transX tm.transitions);\r\n\t\tacceptStates = Set.toList tm.acceptStates;\r\n\t\tcriteria = tm.criteria;\r\n\t\tlbMarkers = List.map symbX tm.lbMarkers;\r\n\t}\r\n\t\r\n\tlet confX ((s,tapes): configuration): configurationX =\r\n\t\tlet tsx = List.map (fun (l,r) ->\r\n\t\t\t\t(word2str (List.rev l), word2str r)) tapes in\r\n\t\t\t(s, tsx)\t\t\r\n\tlet confsX (c: configurations): configurationsX =\r\n\t\tList.map confX (Set.toList c)\r\n\r\n\tlet pathX (p: path): configurationX pathX = pathX confX p\r\n\tlet trailX (t: trail): configurationX trailX = trailX confX t\r\nend\r\n\r\nmodule TuringMachineS =\r\nstruct\r\n\topen TuringMachineBasics\r\n\t\r\n\tlet pairS (a: string) (b: string): string =\r\n\t\t\"(\" ^ a ^ \", \" ^ b ^ \")\"\r\n\tlet wordS (w: word): string = \r\n\t\twordX w\r\n\tlet listS (l: string list): string =\r\n\t\t\"[\" ^ String.concat \", \" l ^ \"]\" \r\n\tlet setS (s: string Set.t): string =\r\n\t\t\"{\" ^ String.concat \", \" (Set.toList s) ^ \"}\" \r\n\tlet confS ((s,tapes): configuration): string =\r\n\t\tlet tsx = List.map (fun (l,r) ->\r\n\t\t\t\tpairS (wordS (List.rev l)) (wordS r)) tapes in\r\n\t\t\tpairS s (listS tsx)\t\t\r\n\r\n\tlet confsS (confS: 'config -> string) (c: configurations): string =\r\n\t\tsetS (Set.map confS c)\r\n\r\n\tlet confsS (c: configurations): string =\r\n\t\tconfsS confS c\r\n\r\n\r\n\r\n\r\n\r\n\tlet pathS (configS: 'config -> string) (p: 'config BasicTypes.path): string =\r\n\t\tlistS (List.map configS p)\r\n\t\r\n\tlet pathS (p: path): string = pathS confS p\r\n\t\r\nend\r\n\r\n\r\nmodule TuringMachineLearnOCaml =\r\nstruct\r\n\topen TuringMachineBasics\r\n\topen TuringMachineX\r\nend\r\n\r\nmodule TuringMachineSupport =\r\nstruct\r\n\tinclude TuringMachineBasics\r\n\tinclude TuringMachineConversions\r\n\tinclude TuringMachineBasicFunctions\r\n\tinclude TuringMachineLearnOCaml\r\nend\r\n\r\n# 1 \"src/TuringMachine.ml\"\r\n(*\r\n * TuringMachine.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Miguel Lourenço (ml)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * jan/2025 (amd) - Adapted for multitape TMs and also reorganized.\r\n * ???/2023 (ml) - Implementation of singletape TMs.\r\n * jun/2022 (amd) - Initial skeleton.\r\n *)\r\n\r\n(*\r\n * Description: Multi-tape Turing machine functionality.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule TuringMachineAcceptPrivate =\r\nstruct\r\n\topen TuringMachineSupport\r\n\r\n\tlet initialConfigs (tm: t) (w: word): configurations =\r\n\t\tlet n = nTapes tm in\r\n\t\tlet emptyTape = ([empty], [empty]) in\r\n\t\tlet firstTape = ([empty], w@[empty]) in\r\n\t\tlet emptyTapes = List.init (n-1) (fun _ -> emptyTape) in\r\n\t\tlet conf = (tm.initialState, firstTape::emptyTapes) in\r\n\t\t\tSet.make [conf]\r\n\r\n\tlet getCurr (ps: tapes): symbolM =\r\n\t\tList.map (fun (l,r) -> List.hd r) ps\r\n\t\r\n\tlet isAcceptingConfig (tm: t) ((s,ps): configuration): bool =\r\n\t\tlet curr = getCurr ps in\r\n\t\tlet ts = tm.transitions in\r\n\t\tlet triggered = Set.filter (fun (a,b,_,_,_) -> a = s && b = curr) ts in\r\n\t\tlet stops = Set.isEmpty triggered in\r\n\t\t\tif tm.criteria then\r\n\t\t\t\tstops && Set.belongs s tm.acceptStates\r\n\t\t\telse\r\n\t\t\t\tstops\r\n\r\n\tlet fix (p: halfTape): halfTape =\t\r\n\t\tmatch p with\r\n\t\t| [] -> [empty]\r\n\t\t| _ -> p\r\n\r\n\tlet updateTape (p: tape) (d: symbol) (e: direction): tape =\r\n\t\tmatch p with\r\n\t\t| l::ls, _::rs ->\r\n\t\t\t(match e with\r\n\t\t\t| R -> (d::l::ls, fix rs)\r\n\t\t\t| L -> (fix ls, l::d::rs)\r\n\t\t\t| S -> (l::ls, d::rs))\r\n\t\t| _, _ -> failwith \"nextTape\"\r\n\t\r\n\tlet rec map3 f l l1 l2 =\r\n\t\tmatch l, l1, l2 with\r\n\t\t| [], [], [] -> []\r\n\t\t| x::xs, y::ys, z::zs -> f x y z:: map3 f xs ys zs\r\n\t\t| _, _, _ -> failwith \"map3\"\r\n\r\n\tlet nextConfig (tm: t) (tr: transition) (conf: configuration): configurations =\r\n\t\tmatch tr, conf with\r\n\t\t| (a,b,c,d,e), (s,ps) when a = s && b = getCurr ps ->\r\n\t\t\tlet ps2 = map3 updateTape ps d e in\r\n\t\t\t\tSet.make [(c, ps2)]\r\n\t\t| _, _ -> Set.empty\r\n\r\n\tlet nextConfigs (tm: t) (config: configuration): configurations = \r\n\t\tSet.flatMap (fun tr -> nextConfig tm tr config) tm.transitions\r\n\r\n\tlet accept (tm: t) (w: word): bool =\r\n\t\tModel.checkWord tm.entryAlphabet w\r\n\t\t&&\r\n\t\tModel.accept tm w\r\n\t\t\t\tinitialConfigs\r\n\t\t\t\tnextConfigs\r\n\t\t\t\tisAcceptingConfig\r\n\r\n\tlet acceptFull (tm: t) (w: word): bool * path * trail = \r\n\t\tif Model.checkWord tm.entryAlphabet w then\r\n\t\t\tModel.acceptFull tm w\r\n\t\t\t\t\t\tinitialConfigs nextConfigs isAcceptingConfig\r\n\t\telse\r\n\t\t\t(false, [], [])\r\nend\r\n\r\nmodule TuringMachineGeneratePrivate =\r\nstruct\r\n\topen TuringMachineSupport\r\n\topen TuringMachineAcceptPrivate\r\n\r\n\tlet generate (tm: t) length =\r\n\t\tModel.generateDumb tm tm.entryAlphabet\r\n\t\t\t\tlength initialConfigs nextConfigs isAcceptingConfig\r\nend\r\n\r\nmodule TuringMachineLBPrivate =\r\nstruct\r\n\topen TuringMachineSupport\r\n\topen TuringMachineAcceptPrivate\r\n\r\n\tlet isLB (rep: t) = \r\n\t\tList.length rep.lbMarkers = 2\r\n\r\n\tlet validateLB (name: string) (rep: t) =\r\n\t\t(* pre: List.length rep.lbMarkers > 0 && validMarkers *)\r\n\t\tlet lbMarkers = Set.make rep.lbMarkers in\r\n\t\t\r\n\t\tlet inEntryAlph =\r\n\t\t\tSet.subset lbMarkers rep.entryAlphabet in\r\n\t\r\n\t\tlet validSymbolM (s: symbolM) =\r\n\t\t\tlet t = Set.make s in\r\n\t\t\tlet i = Set.inter t lbMarkers in\r\n\t\t\tlet withoutMarker =  Set.isEmpty i in\r\n\t\t\t\twithoutMarker || Set.size t = 1 in\r\n\t\t\r\n\t\tlet validSymbolMs =\r\n\t\t\tSet.for_all validSymbolM (getTransSymbolMs rep) in\r\n\t\t\t\r\n\t\tlet isLeftSafe  =\r\n\t\t\tlet leftM = multi rep (lbLeft rep) in\r\n\t\t\tlet lM = multi rep L in\r\n\t\t\tlet safeT (_,b,_,d,e) = b <> leftM || (d = leftM && e <> lM) in\r\n\t\t\t\tSet.for_all safeT rep.transitions in\r\n\r\n\t\tlet isRightSafe =\r\n\t\t\tlet rightM = multi rep (lbRight rep) in\r\n\t\t\tlet rM = multi rep R in\r\n\t\t\tlet safeT (_,b,_,d,e) = b <> rightM || (d = rightM && e <> rM) in\r\n\t\t\t\tSet.for_all safeT rep.transitions in\r\n\r\n\t\tif not inEntryAlph then\r\n\t\t\tError.error name\r\n\t\t\t\t\"The LB markers must belong to the entry alphabet\" ()\r\n\t\t;\t\r\n\t\tif not validSymbolMs then\t\r\n\t\t\tError.error name\r\n\t\t\t\t\"Each LB marker cannot be mixed with other symbols in a transition\" ()\r\n\t\t;\r\n\t\tif not isLeftSafe then\r\n\t\t\tError.error name\r\n\t\t\t\t\"Some transition does not respect the left mark\" ()\r\n\t\t;\r\n\t\tif not isRightSafe then\r\n\t\t\tError.error name\r\n\t\t\t\t\"Some transition does not respect the right mark\" ()\r\n\r\n\tlet checkLB rep: bool =\r\n\t\tlet ok = isLB rep in\r\n\t\tlet mesg = \"Not a LB Turing machine\" in\r\n\t\t\tif not ok then Error.warning mesg;\r\n\t\t\tok\r\n\r\n\tlet acceptLB w rep =\r\n\t\tcheckLB rep\r\n\t\t&&\r\n\t\taccept rep ([lbLeft rep]@w@[lbRight rep])\r\n\r\n\tlet acceptFullLB w rep =\r\n\t\tif checkLB rep then\r\n\t\t\tacceptFull rep ([lbLeft rep]@w@[lbRight rep])\r\n\t\telse\r\n\t\t\t(false, [], [])\r\nend\r\n\r\nmodule TuringMachinePrivate =\r\nstruct\r\n\topen TuringMachineSupport\r\n\r\n(*\r\n\tlet getDefaultMachine: t = {\r\n\t\tentryAlphabet = Set.empty;\r\n\t\ttapeAlphabet = Set.add empty Set.empty;\t\r\n\t\tempty = empty;\r\n\t\tstates = Set.add \"START\" Set.empty;\r\n\t\tinitialState = \"START\";\r\n\t\ttransitions = Set.empty;\r\n\t\tacceptStates = Set.empty;\r\n\t\tcriteria = false;\r\n\t\tlbMarkers = Set.empty\r\n\t}\r\n*)\r\n\r\n\tlet validate (name: string) (rep: t) =\r\n\t\tlet trns = rep.transitions in\r\n\t\tlet trns1 = Set.map (fun (a,_,_,_,_) -> a) trns in\r\n\t\tlet trns2 = Set.map (fun (_,b,_,_,_) -> b) trns in\r\n\t\tlet trns3 = Set.map (fun (_,_,c,_,_) -> c) trns in\r\n\t\tlet trns4 = Set.map (fun (_,_,_,d,_) -> d) trns in\r\n\t\tlet trns5 = Set.map (fun (_,_,_,_,e) -> e) trns in\r\n\t\tlet alpha = Set.add empty rep.tapeAlphabet in\r\n\t\t\r\n\t\tlet validInitSt =\r\n\t\t\tSet.belongs rep.initialState rep.states in\r\n\t\tlet validAccSts =\r\n\t\t\tSet.subset rep.acceptStates rep.states in\r\n\r\n\t\tlet validEntryAlph =\r\n\t\t\tSet.subset rep.entryAlphabet rep.tapeAlphabet in\t\r\n\t\tlet emptyInAlph =\r\n\t\t\tSet.belongs empty rep.tapeAlphabet\r\n\t\t\t&& not (Set.belongs empty rep.entryAlphabet) in\r\n\t\tlet emptyIsEmpty =\r\n\t\t\trep.empty = empty in\r\n\t\t\t\r\n\t\tlet nTapes = nTapes rep in\r\n\t\t\r\n\t\tlet validLengths =\r\n\t\t\tSet.for_all (fun s -> List.length s = nTapes) trns2\r\n\t\t\t&& Set.for_all (fun s -> List.length s = nTapes) trns4\r\n\t\t\t&& Set.for_all (fun s -> List.length s = nTapes) trns5 in\r\n\r\n\t\tlet validTrns =\r\n\t\t\tSet.subset trns1 rep.states\r\n\t\t\t&& Set.subset trns3 rep.states\r\n\t\t\t&& Set.subset (getTransSymbols rep) alpha\r\n\t\t\t&& Set.subset (getTransDirections rep) allDirections in\r\n\r\n(* PEDRO CARLOS -> usar talvez...\r\n\t\tlet validTrns =\r\n\t\t\tif not (Set.subset trns1 rep.states) then\r\n\t\t\t\tError.error name\r\n\t\t\t\t\t\"The source state of some transition does not belong to the set of all states\" false\r\n\t\t\telse if not (Set.subset trns3 rep.states) then\r\n\t\t\t\tError.error name\r\n\t\t\t\t\t\"The destination state of some transition does not belong to the set of all states\" false\r\n\t\t\telse if not (Set.subset (getTransSymbols rep) alpha) then\r\n\t\t\t\tError.error name\r\n\t\t\t\t\t\"The transition symbols are not contained in the tape alphabet\" false\r\n\t\t\telse if not (Set.subset (getTransDirections rep) allDirections) then\r\n\t\t\t\tError.error name\r\n\t\t\t\t\t\"The direction of some transition is not valid\" false\r\n\t\t\telse true\r\n*)\r\n\r\n\t\tlet validMarkers =\r\n\t\t\tif List.length rep.lbMarkers = 2 then\r\n\t\t\t\tlet l = List.nth rep.lbMarkers 0 in\r\n\t\t\t\tlet r = List.nth rep.lbMarkers 1 in\r\n\t\t\t\t\tl <> r\r\n\t\t\telse\r\n\t\t\t\tList.length rep.lbMarkers = 0 in\r\n\r\n\t\tlet validCriteria =\r\n\t\t\trep.criteria || Set.size rep.acceptStates = 0 in\r\n\r\n\t\tif not validInitSt then\r\n\t\t\tError.error name\r\n\t\t\t\t\"The initial state does not belong to the set of all states\" ()\r\n\t\t;\r\n\t\tif not validAccSts then\r\n\t\t\tError.error name\r\n\t\t\t\t\"Some accept states do not belong to the set of all states\" ()\r\n\t\t;\r\n\t\tif not validEntryAlph then\r\n\t\t\tError.error name\r\n\t\t\t\t\"The entry alphabel must be contained in the tape alphabet\" ()\r\n\t\t;\r\n\t\tif not validLengths then\r\n\t\t\tError.error name\r\n\t\t\t\t\"Some transitions have elements with inconsistent lengths\" ()\r\n\t\t;\r\n\t\tif not validTrns then\r\n\t\t\tError.error name\r\n\t\t\t\t\"Some transitions are invalid\" ()\r\n\t\t;\r\n\t\tif not emptyInAlph then\r\n\t\t\tError.error name (\r\n\t\t\t\t\"The empty symbol must be in the tape alphabet\"\r\n\t\t\t\t^ \" but not in the entry alphabet\") ()\r\n\t\t;\r\n\t\tif not emptyIsEmpty then\r\n\t\t\tError.error name\r\n\t\t\t\t\"The empty symbol is not correct, change it to 'B'\" ()\r\n\t\t;\r\n\t\tif not validCriteria then\r\n\t\t\tError.error name\r\n\t\t\t\t\"A TM that uses the stop criteria cannot have accept states\" ()\r\n\t\t;\r\n\t\tif List.length rep.lbMarkers > 0 && validMarkers then\r\n\t\t\tTuringMachineLBPrivate.validateLB name rep\r\n\r\n\tlet downgradeModelToFiniteAutomaton rep = \r\n\t\tlet alphaB = Set.union (Set.make [empty]) rep.tapeAlphabet in\r\n\t\tlet transitionsTm2Fa = Set.map (fun (a,b,c,_,_) -> (a,List.hd b,c)) in\r\n\t\tlet fa: FiniteAutomaton.t = {\r\n\t\t\t\talphabet = alphaB;\r\n\t\t\t\tstates = rep.states;\r\n\t\t\t\tinitialState = rep.initialState;\r\n\t\t\t\ttransitions = transitionsTm2Fa rep.transitions;\r\n\t\t\t\tacceptStates = rep.acceptStates\r\n\t\t\t} in\r\n\t\tnew FiniteAutomaton.model (Arg.Representation fa)\r\n\r\n\tlet reachable s rep = \r\n\t\tlet fa = downgradeModelToFiniteAutomaton rep in\r\n\t\t\tfa#reachable s\r\n\r\n\tlet productive rep =\r\n\t\tif rep.criteria then\r\n\t\t\tlet fa = downgradeModelToFiniteAutomaton rep in\r\n\t\t\t\tfa#productive\r\n\t\telse rep.states\r\n\t\t\r\n\tlet getUsefulStates rep =\r\n\t\tSet.inter (productive rep) (reachable rep.initialState rep)\r\n\r\n\tlet getUselessStates rep =\r\n\t\tSet.diff rep.states (getUsefulStates rep)\r\n\r\n\tlet isDeterministic rep =\r\n\t\tlet fa = downgradeModelToFiniteAutomaton rep in\r\n\t\t\tfa#isDeterministic\r\n\r\n\tlet cleanUselessStates rep =\r\n\t\tlet ts = rep.transitions in\r\n\t\tlet usfSts = getUsefulStates rep in\r\n\t\tlet usfTrs = Set.filter (fun (a,_,c,_,_)\r\n\t\t\t\t-> Set.belongs a usfSts && Set.belongs c usfSts) ts in\r\n\t\tlet tapeAlf = Set.add empty (getTransSymbols rep) in\r\n\t\tlet entryAlf = Set.inter tapeAlf rep.entryAlphabet in\r\n\t\tlet newAccSts = Set.inter rep.acceptStates usfSts in\r\n\t\t\t{ rep with\r\n\t\t\t\tentryAlphabet = entryAlf;\r\n\t\t\t\ttapeAlphabet = tapeAlf;\r\n\t\t\t\tstates = usfSts;\r\n\t\t\t\ttransitions = usfTrs;\r\n\t\t\t\tacceptStates = newAccSts }\r\n\t\t\t(* This and all the other updates of a TM need\r\n\t\t\t\tto be analysed, to check for the validity\r\n\t\t\t\tof the resulting TM. - AMD  *)\r\n\r\n\tlet areAllStatesUseful rep =\r\n\t\tlet fa = downgradeModelToFiniteAutomaton rep in\r\n\t\t\tfa#areAllStatesUseful\r\n\r\n(*\tlet convertToStopCriteria rep =\r\n\t\tlet stEnd = state \"END\" in\r\n\t\tlet endState = stEnd in\r\n\t\tlet completeStates = Set.union (rep.states) (Set.make [endState]) in\r\n\r\n\t\tlet newAlph = Set.union (rep.tapeAlphabet) (Set.make [empty]) in\r\n\t\tlet nonAcceptStates =  Set.filter (fun x -> not (Set.exists (fun y -> y = x) rep.acceptStates)) rep.states in\r\n\r\n\t\tlet missingSymbols st = Set.filter (fun x -> not (Set.exists (fun (a,b,_,_,_) -> a = st && b = x) rep.transitions)) newAlph in\r\n\t\tlet createTransitions st = Set.map (fun x -> (st,x,endState,x,R)) (missingSymbols st) in\r\n\t\tlet newTransList = Set.flatten (Set.map (fun x -> createTransitions x) nonAcceptStates) in\r\n\t\tlet fullTransitions = Set.union (rep.transitions) (newTransList) in\r\n\t\t\t{\r\n\t\t\t\tentryAlphabet = rep.entryAlphabet;\r\n\t\t\t\ttapeAlphabet = rep.tapeAlphabet;\r\n\t\t\t\tempty = rep.empty;\r\n\t\t\t\tstates = completeStates;\r\n\t\t\t\tinitialState = rep.initialState;\r\n\t\t\t\ttransitions = fullTransitions;\r\n\t\t\t\tacceptStates = Set.empty;\r\n\t\t\t\tcriteria = false;\r\n\t\t\t\tlbMarkers = rep.lbMarkers\r\n\t\t\t}\r\n*)\r\n\r\n\tlet convertToStopCriteria rep =\r\n\t\t{ rep with\r\n\t\t\tacceptStates = Set.empty;\r\n\t\t\tcriteria = false }\r\n\r\n\tlet hasState st rep = \r\n\t\tSet.belongs st rep.states\r\n\r\n\tlet hasTransition trs rep =\r\n\t\tSet.belongs trs rep.transitions\r\n\r\n\tlet isFinal st rep = \r\n\t\tSet.belongs st rep.acceptStates\r\n\r\n\tlet isInitial st rep = \r\n\t\tst = rep.initialState\r\n\t\r\n\tlet addState s rep =\r\n\t\t{ rep with\r\n\t\t\tstates = Set.add s rep.states }\r\n\t\t\t\r\n\tlet addInitialState s rep =\r\n\t\t{ rep with\r\n\t\t\tstates = Set.add s rep.states;\r\n\t\t\tinitialState = s }\r\n\r\n\tlet addFinalState s rep =\r\n\t\t{ rep with\r\n\t\t\tstates = Set.add s rep.states;\r\n\t\t\tacceptStates = Set.add s rep.acceptStates;\r\n\t\t\tcriteria = true }\r\n\r\n\tlet removeState s rep =\r\n\t\tif s = rep.initialState then\r\n\t\t\trep\r\n\t\telse\r\n\t\t{ rep with\r\n\t\t\tstates = Set.remove s rep.states;\r\n\t\t\ttransitions = Set.filter (fun (a,_,c,_,_) ->\r\n\t\t\t\t\t\t\ta <> s || c <> s) rep.transitions;\r\n\t\t\tacceptStates = Set.remove s rep.acceptStates }\r\n\r\n\tlet changeStateToInitial s rep =\r\n\t\t{ rep with\r\n\t\t\tinitialState = s }\r\n\r\n\tlet changeStateFromFinal s rep =\r\n\t\tlet newAcceptSts = Set.remove s rep.acceptStates in\r\n\t\t{ rep with\r\n\t\t\tacceptStates = newAcceptSts;\r\n\t\t\tcriteria = Set.size newAcceptSts <> 0 }\r\n\r\n\tlet changeStateToFinal s rep =\r\n\t\t{ rep with\r\n\t\t\tacceptStates = Set.add s rep.acceptStates;\r\n\t\t\tcriteria = true }\r\n\r\n\tlet renameState st name rep =\r\n\t\tlet initial = if st = rep.initialState then name else rep.initialState in\r\n\t\tlet newStates = Set.remove st (Set.add name rep.states) in\r\n\t\tlet newTransitions = Set.map\r\n\t\t\t\t\t(fun (s,a,t,b,c) -> \r\n\t\t\t\t\t\tif s = st && t = st then (name,a,name,b,c)\r\n\t\t\t\t\t\telse if s = st then (name,a,t,b,c)\r\n\t\t\t\t\t\telse if t = st then (s,a,name,b,c)\r\n\t\t\t\t\t\telse (s,a,t,b,c)\r\n\t\t\t\t\t) rep.transitions in\r\n\t\tlet newAcceptStates =\r\n\t\t\tSet.map (fun s -> if s = st then name else s) rep.acceptStates in\r\n\t\t\t\t{ rep with\r\n\t\t\t\t\tstates = newStates;\r\n\t\t\t\t\tinitialState = initial;\r\n\t\t\t\t\ttransitions = newTransitions;\r\n\t\t\t\t\tacceptStates = newAcceptStates;\r\n\t\t\t\t\tcriteria = true }\r\n\r\n\tlet addTransition trs rep =\r\n\t\t{ rep with\r\n\t\t\ttransitions = Set.add trs rep.transitions }\r\n\r\n\tlet removeTransition trs rep =\r\n\t\t{ rep with\r\n\t\t\ttransitions = Set.remove trs rep.transitions }\r\nend\r\n\r\nmodule TuringMachine =\r\nstruct\r\n\tinclude TuringMachineSupport\r\n\topen TuringMachineAcceptPrivate\r\n\topen TuringMachineGeneratePrivate\r\n\topen TuringMachineLBPrivate\r\n\topen TuringMachinePrivate\r\n\r\n\t(* Make *)\r\n\tlet make2 (arg: t Arg.alternatives): Entity.t * t = make2 arg validate\r\n\tlet make (arg: t Arg.alternatives): t = make arg validate\r\n\r\n\t(* Exercices support *)\r\n\tlet checkProperty (tm: t) (prop: string) =\r\n\t\tmatch prop with\r\n\t\t\t| \"turing machine\" -> true\r\n\t\t\t| _ -> Model.checkProperty prop\t\t\r\n\tlet checkExercise ex (tm: t) = Model.checkExercise ex (accept tm) (checkProperty tm)\r\n\tlet checkExerciseFailures ex (tm: t) = Model.checkExerciseFailures ex (accept tm) (checkProperty tm)\r\n\r\n\t(* Ops *)\r\n\tlet stats = Model.stats\r\n\tlet accept = accept\r\n\tlet acceptFull = acceptFull\r\n\tlet generate = generate\r\n\tlet isLB = isLB\r\n\tlet initialConfigs = initialConfigs\r\n\r\n\t(* Class *)\r\n\tclass model (arg: t Arg.alternatives) =\r\n\t\tobject(self) inherit Model.model (make2 arg) as super\r\n\t\t(* Representation *)\r\n\t\t\tmethod representation: t = representation\r\n\t\t(* Kind *)\r\n\t\t\tmethod isTuringMachine : bool = true\r\n\t\t(* Show *)\t\t\t\r\n\t\t\tmethod toJSon: JSon.t = toJSon representation\r\n\t\t\tmethod toJSon2: JSon.t = toJSon2 id representation\r\n\t\t\tmethod show: unit = show representation\r\n\t\t\tmethod show2: unit = show2 id representation\r\n\t\t(* Ops *)\t\t\t\t\r\n\t\t\tmethod accept (w: word): bool =\r\n\t\t\t\taccept representation w\r\n\r\n\t\t\tmethod acceptFull (w:word): bool * 'c list * 'c set list =\r\n\t\t\t\tacceptFull representation w\r\n\r\n\t\t\tmethod generate (length: int): words =\r\n\t\t\t\tgenerate representation length\r\n\r\n\t\t\tmethod reachable (s:state): states =\r\n\t\t\t\treachable s representation\r\n\r\n\t\t\tmethod productive : states =\r\n\t\t\t\tproductive representation\r\n\t\t\t\t\r\n\t\t\tmethod getUsefulStates: states =\r\n\t\t\t\tgetUsefulStates representation\r\n\r\n\t\t\tmethod getUselessStates: states =\r\n\t\t\t\tgetUselessStates representation\r\n\r\n\t\t\tmethod isDeterministic: bool =\r\n\t\t\t\tisDeterministic representation\r\n\r\n\t\t\tmethod cleanUselessStates: t =\r\n\t\t\t\tcleanUselessStates representation\r\n\r\n\t\t\tmethod areAllStatesUseful: bool =\r\n\t\t\t\tareAllStatesUseful representation\r\n\r\n\t\t\tmethod acceptLB (w: word) : bool =\r\n\t\t\t\tacceptLB w representation\r\n\r\n\t\t\tmethod acceptFullLB (w: word) : bool * 'c list * 'c set list =\r\n\t\t\t\tacceptFullLB w representation\r\n\r\n\t\t\tmethod isLB : bool = \t\r\n\t\t\t\tisLB representation\r\n\r\n\t\t\tmethod convertToStopCriteria: model =\r\n\t\t\t\tlet tm = convertToStopCriteria representation in\r\n\t\t\t\t\tnew model (Arg.Representation tm)\r\n\r\n\t\t\tmethod hasState(s: state): bool =\r\n\t\t\t\thasState s representation\r\n\r\n\t\t\tmethod hasTransition (trs: transition): bool =\r\n\t\t\t\thasTransition trs representation\r\n\r\n\t\t\tmethod isFinal (st: state): bool =\r\n\t\t\t\tisFinal st representation\r\n\r\n\t\t\tmethod isInitial (st: state): bool =\r\n\t\t\t\tisInitial st representation\r\n\r\n\t\t\tmethod addState (s: state) : t =\r\n\t\t\t\taddState s representation\r\n\r\n\t\t\tmethod addInitialState (s: state) : t =\r\n\t\t\t\taddInitialState s representation\r\n\r\n\t\t\tmethod addFinalState (s: state) : t =\r\n\t\t\t\taddFinalState s representation\r\n\t\t\r\n\t\t\tmethod removeState (s: state) : t =\r\n\t\t\t\tremoveState s representation\r\n\r\n\t\t\tmethod changeStateToInitial (s: state) : t =\r\n\t\t\t\tchangeStateToInitial s representation\r\n\r\n\t\t\tmethod changeStateToFinal (s: state) : t =\r\n\t\t\t\tchangeStateToFinal s representation\r\n\r\n\t\t\tmethod changeStateFromFinal (s: state) : t =\r\n\t\t\t\tchangeStateFromFinal s representation\r\n\t\t\t\r\n\t\t\tmethod renameState (s:state) (newS:state): t =\r\n\t\t\t\trenameState s newS representation\r\n\r\n\t\t\tmethod addTransition (trs:transition) : t =\r\n\t\t\t\taddTransition trs representation\r\n\r\n\t\t\tmethod removeTransition (trs:transition) : t =\r\n\t\t\t\tremoveTransition trs representation\r\n\r\n\t\t\tmethod downgradeModelToFiniteAutomaton: FiniteAutomaton.model =\r\n\t\t\t\tdowngradeModelToFiniteAutomaton representation\r\n\t\t\t\r\n\t\t\tmethod checkProperty prop =\r\n\t\t\t\tmatch prop with\r\n\t\t\t\t\t| \"deterministic\" -> self#isDeterministic\r\n\t\t\t\t\t| \"linear bounded\" -> self#isLB\r\n\t\t\t\t\t| \"acceptance by states\" -> representation.criteria\r\n\t\t\t\t\t| \"acceptance by stop\" -> not representation.criteria\r\n\t\t\t\t\t| \"turing machine\" -> true\r\n\t\t\t\t\t| _ -> super#checkProperty prop\r\n\t\t\r\n\t\t(* Learn-OCaml support *)\r\n\t\t(* incomplete *)\r\n\t\t\tmethod moduleName =\r\n\t\t\t\t\"TuringMachine\"\r\n\r\n\t\t\tmethod xTypeName =\r\n\t\t\t\t\"turingMachine\"\r\n\t\t\t\t\r\n\t\t\tmethod xTypeDeclString : string = \"todo\"\r\n\r\n\t\t\tmethod toDisplayString (name: string): string = \"todo\"\r\n\r\n\t\t\tmethod example : JSon.t =\r\n\t\t\t\tJSon.parse {|\r\n\t\t\t\t{\r\n\t\t\t\t\tkind : \"turing machine todo\"\r\n\t\t\t\t}\r\n\t\t\t|}\r\n\r\n\tend\r\n\r\nend\r\n\r\nmodule TuringMachineTop =\r\nstruct\r\n\topen TuringMachine\r\n\topen TuringMachineX\r\n\r\n\tlet tm_load file = tmX (make (Arg.File file))\r\n\tlet tm_text text = tmX (make (Arg.Text text))\r\n\tlet tm_json json = tmX (make (Arg.JSon json))\r\n\tlet tm_predef name = tm_text (Examples.example name)\r\n\r\n\tlet tm_ntapes tmx =\r\n\t\tnTapes (tmI tmx)\r\n\r\n\tlet tm_init tmx w =\r\n\t\tlet is = initialConfigs (tmI tmx) (wordI w) in\r\n\t\t\tconfsX is\r\n\r\n\tlet stats () = RuntimeControl.stats ()\r\n\r\n\tlet tm_accept tm w = accept (tmI tm) (wordI w)\r\n\r\n\tlet tm_path tm w =\r\n\t\tlet (r,p,t) = acceptFull (tmI tm) (wordI w) in\r\n\t\t\tpathX p\r\n\r\n\tlet tm_trail tm w =\r\n\t\tlet (r,p,t) = acceptFull (tmI tm) (wordI w) in\r\n\t\t\ttrailX t\r\n\r\n\tlet tm_generate tm len = wordsX (generate (tmI tm) len)\r\n\r\n\r\n\topen TuringMachineS\r\n\tlet tm_init tmx w =\r\n\t\tlet is = initialConfigs (tmI tmx) (wordI w) in\r\n\t\t\tconfsS is\r\n\r\nend\r\n\r\nopen TuringMachineTop\r\n\r\n(*\r\n\r\n--------------------\r\n\r\n#print_depth 10000;;\r\n#print_length 10000;;\r\n\r\nlet tm = tm_predef \"tm_translate\";;\r\nlet w = \"aba\";;\r\ntm_ntapes tm;;\r\ntm_init tm w;;\r\ntm_accept tm \"aba\";;\r\ntm_accept tm \"abac\";;\r\ntm_path tm \"aba\";;\r\ntm_trail tm \"aba\";;\r\n\r\n--------------------\r\nlet tm = tm_predef \"tm_astar2\";;\r\n\r\ntm_generate tm 4;;\r\n\r\ntm_accept tm \"abab\";;\r\ntm_accept tm \"abcab\";;\r\n\r\ntm_path tm \"abab\";;\r\ntm_path tm \"abcab\";;\r\n\r\ntm_trail tm \"abab\";;\r\n--------------------\r\n\r\n*)\r\n# 1 \"src/CompositionSupport.ml\"\r\n(*\r\n * CompositionSupport.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * dec/2023 (amd) - Initial version.\r\n *)\r\n\r\n(*\r\n * Description: Support types and functions for COMPs including a parser for COMPs.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule CompositionBasics =\r\nstruct\r\n\ttype tx = string\r\n\r\n\ttype t =\r\n\t\t| Plus of t * t\r\n\t\t| Seq of t * t\r\n\t\t| Intersect of t * t\r\n\t\t| Star of t\r\n\t\t| FA of FiniteAutomaton.t\r\n\t\t| RE of RegularExpression.t\r\n\t\t| CFG of ContextFreeGrammar.t\r\n\t\t| PDA of PushdownAutomaton.t\r\n\t\t| TM of TuringMachine.t\r\n\t\t| FAO of FiniteAutomaton.model\r\n\t\t| REO of RegularExpression.model\r\n\t\t| CFGO of ContextFreeGrammar.model\r\n\t\t| GR of Grammar.t\r\n\t\t| GRO of Grammar.model\r\n\t\t| PDAO of PushdownAutomaton.model\r\n\t\t| TMO of TuringMachine.model\r\n\t\t| Rep of string\r\n\t\t| Comp of t\r\n\t\t| Empty\r\n\t\t| Zero\r\n\r\n\tlet kind = \"composition\"\r\n\r\n\tlet comp_zero: t =\r\n\t\tZero\r\nend\r\n\r\nmodule type CompositionSyntaxSig =\r\nsig\r\n\topen CompositionBasics\r\n\t\r\n\tval parse : string -> t\r\n\tval toString : t -> string\r\n\tval show : t -> unit\r\nend\r\n\r\nmodule CompositionSyntax : CompositionSyntaxSig =\r\nstruct\r\n\topen Scanner\r\n\topen CompositionBasics\r\n\r\n\t(*\tGrammar:\r\n\t\t\tE -> E + E | E E | E* | c | (E) | ()\r\n\r\n\t\tGrammar with priorities:\r\n\t\t\tE -> I | I ^ E\r\n\t\t\tI -> T | T + I\r\n\t\t\tT -> F | F T\r\n\t\t\tF -> A | A*\r\n\t\t\tA -> P | c\r\n\t\t\tP -> (E) | ()\r\n\t*)\r\n\tlet rec parseExp () =\r\n\t\tlet i = parseInter () in\r\n\t\t\tmatch peek() with\r\n\t\t\t\t| '^' -> skip(); Intersect (i, parseExp ())\r\n\t\t\t\t| _ -> i\r\n\r\n\tand parseInter () =\r\n\t\tlet t = parseTerm () in\r\n\t\t\tmatch peek() with\r\n\t\t\t\t| '+' -> skip(); Plus (t, parseInter ())\r\n\t\t\t\t| _ -> t\r\n\r\n\tand parseTerm () =\r\n\t\tlet f = parseFactor () in\r\n\t\t\tmatch peek() with\r\n\t\t\t\t| '(' | '[' -> Seq (f, parseTerm ())\r\n\t\t\t\t| _ -> f\r\n\r\n\tand parseFactor () =\r\n\t\tlet a = parseAtom () in\r\n\t\t\tmatch peek() with\r\n\t\t\t\t| '*' -> skip(); (Star a)\r\n\t\t\t\t| _ -> a\r\n\r\n\tand parseAtom () =\r\n\t\tmatch peek() with\r\n\t\t\t| '~' -> skip(); Empty\r\n\t\t\t| '!' -> skip(); Zero\r\n\t\t\t| '(' -> skip(); parseParentheses ()\r\n\t\t\t| '^' | '+' | '*' -> invalid \"Invalid use of wildcard\\n\"\r\n\t\t\t| ' ' -> invalid \"Premature end of expression\\n\"\r\n\t\t\t| '[' -> skip(); parseId ()\r\n\t\t\t| _ -> invalid \"invalid expression\\n\"\r\n\r\n\tand parseParentheses () =\r\n\t\tlet e = parseExp () in begin\r\n\t\t\tmatch peek() with\r\n\t\t\t\t| ')' -> skip(); e\r\n\t\t\t\t| _ -> invalid \"Right-parenthesis expected\\n\"\r\n\t\tend\r\n\r\n\tand parseId () =\r\n\t\tlet e = Rep (getId ()) in begin\r\n\t\t\tmatch peek() with\r\n\t\t\t\t| ']' -> skip(); e\r\n\t\t\t\t| _ -> invalid \"Id close-parenthesis expected\\n\"\r\n\t\tend\r\n\r\n\tlet parse s =\r\n\t\tScanner.start \"CompositionSyntax\" s;\r\n\t\ttry\r\n\t\t\tparseExp ()\r\n\t\twith Not_found ->\r\n\t\t\tZero\r\n\r\n\tlet rec toStringN n comp =\r\n\t\tmatch comp with\r\n\t\t\t| Intersect(l, r) ->\r\n\t\t\t\t\t(if n > 0 then \"(\" else \"\") ^\r\n\t\t\t\t\ttoStringN 0 l ^ \"^\" ^ toStringN 0 r\r\n\t\t\t\t\t^ (if n > 0 then \")\" else \"\")\r\n\t\t\t| Plus(l, r) ->\r\n\t\t\t\t\t(if n > 1 then \"(\" else \"\") ^\r\n\t\t\t\t\ttoStringN 1 l ^ \"+\" ^ toStringN 1 r\r\n\t\t\t\t\t^ (if n > 1 then \")\" else \"\")\r\n\t\t\t| Seq(l, r) ->\r\n\t\t\t\t\t(if n > 2 then \"(\" else \"\") ^\r\n\t\t\t\t\ttoStringN 2 l ^ toStringN 2 r\r\n\t\t\t\t\t^ (if n > 2 then \")\" else \"\")\r\n\t\t\t| Star r ->\r\n\t\t\t\t\ttoStringN 3 r ^ \"*\"\r\n\t\t\t| Rep str -> \"[\" ^ str ^ \"]\"\r\n\t\t\t| Empty -> \"~\"\r\n\t\t\t| Zero -> \"!\"\r\n\t\t\t| _ -> \"?\"\r\n\r\n\tlet toString comp =\r\n\t\ttoStringN 0 comp\r\n\r\n\tlet show comp =\r\n\t\tUtil.println [toString comp]\r\nend\r\n\r\nmodule CompositionConversions =\r\nstruct\r\n\topen CompositionBasics\r\n\r\n\tlet internalize (comp: tx): t =\r\n\t\tCompositionSyntax.parse comp\r\n\r\n\tlet externalize (comp: t): tx =\r\n\t\tCompositionSyntax.toString comp\r\n\r\n\tlet fromJSon (j: JSon.t): t =\r\n\t\tif JSon.isNull j || not (JSon.hasField j \"kind\") then\r\n\t\t\tcomp_zero\r\n\t\telse\r\n\t\t\tlet comp = JSon.fieldString j \"comp\" in\r\n\t\t\t\tCompositionSyntax.parse comp\r\n\r\n\tlet toJSon0 (comp: t): JSon.t =\r\n\tJSon.makeAssoc [\r\n\t\t\t(\"comp\", JSon.makeString (CompositionSyntax.toString comp));\r\n\t\t]\r\n\r\n\tlet toJSon2 (id: Entity.t) (comp: t): JSon.t =\r\n\t\t JSon.append (Entity.toJSon id) (toJSon0 comp)\r\n\r\n\t\r\n\tlet toJSon (rep: t): JSon.t =\r\n\t\t toJSon2 (Entity.dummyId kind) rep\r\nend\r\n\r\n\r\nmodule CompositionBasicFunctions =\r\nstruct\r\n\topen CompositionBasics\r\n\topen CompositionConversions\r\n\t\r\n\tlet make2 (arg: t Arg.alternatives) validate: Entity.t * t =\r\n\t\tEntity.make2 arg fromJSon kind validate\r\n\r\n\tlet make (arg: t Arg.alternatives) validate: t =\r\n\t\tsnd (make2 arg validate)\r\n\r\n\tlet show (comp: t): unit =\r\n\t\tlet j = toJSon comp in\r\n\t\t\tJSon.show j\r\n\r\n\tlet show2 (id: Entity.t) (comp: t): unit =\r\n\t\tlet j = toJSon2 id comp in\r\n\t\t\tJSon.show j\r\nend\r\n\r\nmodule CompositionLearnOCaml =\r\nstruct\r\n\topen CompositionBasics\r\n\r\n\tlet moduleName =\r\n\t\t\"Composition\"\r\n\r\n\tlet xTypeName =\r\n\t\t\"composition\"\r\n\r\n\tlet solution (name: string) (compx: tx): string =\r\n\t\tPrintf.sprintf {zzz|\r\n\t\t%s\t%s\r\n\t\t|zzz}\t(* please, do not change this line *)\r\n\t\t\t(FiniteEnumerationLearnOCaml.displayHeader name xTypeName)\r\n\t\t\t(stateXD compx)\r\n\r\n\tlet prelude : string = {|\r\n\t\ttype composition = string\r\n\t\t|}\t(* please, do not change this line *)\r\n\r\n\tlet example : JSon.t =\r\n\t\tJSon.parse {| {\r\n\t\t\tkind : \"regular expression\",\r\n\t\t\tdescription : \"this is a simple example\",\r\n\t\t\tname : \"comp example\",\r\n\t\t\tcomp : \"w*+(w+yz)*\"\r\n\t\t}\r\n\t\t|}\t(* please, do not change this line *)\r\nend\r\n\r\nmodule CompositionSupport =\r\nstruct\r\n\tinclude CompositionBasics\r\n\tinclude CompositionSyntax\r\n\tinclude CompositionConversions\r\n\tinclude CompositionBasicFunctions\r\n\tinclude CompositionLearnOCaml\r\n\tlet makeCompositionRef : (t Arg.alternatives -> t) ref = ref (fun a -> Error.fatal \"\" )\r\nend\r\n\r\nmodule CompositionSyntaxTests : sig end =\r\nstruct\r\n\tlet active = false\r\n\r\n\tlet test00 () =\r\n\t\tlet comp = CompositionSyntax.parse \"[a]^[b]\" in\r\n\t\t\tCompositionSyntax.show comp\r\n\r\n\tlet test0 () =\r\n\t\tlet comp = CompositionSyntax.parse \"[az][b]+~*\" in\r\n\t\t\tCompositionSyntax.show comp\r\n\r\n\tlet test1 () =\r\n\t\tlet comp = CompositionSyntax.parse \"~(([a]^[b])*([c][d])*)*\" in\r\n\t\t\tCompositionSyntax.show comp\r\n\r\n\tlet runAll =\r\n\t\tif Util.testing active \"CompositionSyntax\" then begin\r\n\t\t\ttest00 ();\r\n\t\t\ttest0 ();\r\n\t\t\ttest1 ();\r\n\t\tend\r\nend\r\n# 1 \"src/PolyModel.ml\"\r\n(*\r\n * PolyModel.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Various\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * apr/2021 (amd) - Several new build functions.\r\n * jan/2021 (amd) - Created this module, collecting all the operation.\r\n                    involving two or more kinds of models.\r\n                    This allows to got rid of the mutual recursion between\r\n                    modules, allowing storing each module in a different file.\r\n * dec/2019 (jg) - Initial code, across several modules in file \"OCamlFlat.ml\".\r\n *)\r\n\r\n(*\r\n * Description: Poly-model operations.\r\n *\r\n * TODO: Cleanup.\r\n *)\r\n \r\nopen BasicTypes\r\n\r\n(********************************************************************)\r\nmodule RE2FA =\r\nstruct\r\n\topen RegularExpression\r\n\topen FiniteAutomaton\r\n\r\n\t(*auxiliary var for genName function*)\r\n\tlet k = ref 0\r\n\r\n\t(*for each new state, generates a name that will distinguish it from all the other generated states *)\r\n\tlet genName () =\r\n\t\tlet n = !k in\r\n\t\tlet () = k:= n + 1 in\r\n\t\t\t(*easy way of having all single digit state names have a zero before their actual number*)\r\n\t\t\tlet name = if n > 9 then \"new_St\" ^ (string_of_int n)\r\n\t\t\t\t\t\telse \"new_St0\" ^ (string_of_int n) in\r\n\t\t\t\tstr2state name\r\n\r\n\tlet rec compile (re: RegularExpression.t) : FiniteAutomaton.t =\r\n\t\tmatch re with\r\n\t\t\t| Plus(l, r) ->\r\n\t\t\t\t\tlet fa1 = compile l in\r\n\t\t\t\t\tlet fa2 = compile r in\r\n\t\t\t\t\tlet newStart = genName () in\r\n\t\t\t\t\tlet newSts = Set.add newStart (Set.union fa1.states fa2.states) in\r\n\t\t\t\t\tlet newAccSts = Set.union fa1.acceptStates fa2.acceptStates in\r\n\t\t\t\t\tlet newTran1 = (newStart, epsilon, fa1.initialState) in\r\n\t\t\t\t\tlet newTran2 = (newStart, epsilon, fa2.initialState) in\r\n\t\t\t\t\tlet newTrans = Set.add newTran1 (Set.add newTran2\r\n\t\t\t\t\t\t(Set.union fa1.transitions fa2.transitions)) in\r\n\t\t\t\t\tlet newAlf = Set.union fa1.alphabet fa2.alphabet in\r\n\t\t\t\t\t\t{alphabet = newAlf; states = newSts; initialState = newStart;\r\n\t\t\t\t\t\t\ttransitions = newTrans; acceptStates = newAccSts}\r\n\t\t\t| Seq(l, r) ->\r\n\t\t\t\t\tlet fa1 = compile l in\r\n\t\t\t\t\tlet fa2 = compile r in\r\n\t\t\t\t\tlet ist = fa1.initialState in\r\n\t\t\t\t\tlet sts = Set.union fa1.states fa2.states in\r\n\t\t\t\t\tlet asts = fa2.acceptStates in\r\n\t\t\t\t\tlet newTrns = Set.map (fun x -> (x, epsilon, fa2.initialState) ) fa1.acceptStates in\r\n\t\t\t\t\tlet trns = Set.union newTrns (Set.union fa1.transitions fa2.transitions) in\r\n\t\t\t\t\tlet alf = Set.union fa1.alphabet fa2.alphabet in\r\n\t\t\t\t\t\t{alphabet = alf; states = sts; initialState = ist;\r\n\t\t\t\t\t\t\ttransitions = trns; acceptStates = asts}\r\n\t\t\t| Star(r) ->\r\n\t\t\t\t\tlet fa = compile r in\r\n\t\t\t\t\tlet newStart = genName () in\r\n\t\t\t\t\tlet newSts = Set.add newStart fa.states in\r\n\t\t\t\t\tlet newTrns = Set.map (fun st -> (st, epsilon, newStart)) fa.acceptStates in\r\n\t\t\t\t\tlet allNewTrns = Set.add (newStart, epsilon, fa.initialState) (Set.union newTrns fa.transitions) in\r\n\t\t\t\t\t\t{alphabet = fa.alphabet; states = newSts; initialState = newStart;\r\n\t\t\t\t\t\t\ttransitions = allNewTrns; acceptStates = Set.make [newStart]}\r\n\t\t\t| Symb(c) ->\r\n\t\t\t\t\tlet newStart = genName () in\r\n\t\t\t\t\tlet newAcc = genName () in\r\n\t\t\t\t\tlet newSts = Set.make [newStart; newAcc] in\r\n\t\t\t\t\tlet newTrn = Set.make [(newStart, c, newAcc)] in\r\n\t\t\t\t\t\t{alphabet = Set.make [c]; states = newSts; initialState = newStart;\r\n\t\t\t\t\t\t\ttransitions = newTrn; acceptStates = Set.make [newAcc]}\r\n\t\t\t| Empty ->\r\n\t\t\t\t\tlet newStart = genName () in\r\n\t\t\t\t\t\t\t{alphabet = Set.empty; states = Set.make [newStart]; initialState = newStart;\r\n\t\t\t\t\t\t\t\ttransitions = Set.empty; acceptStates = Set.make [newStart]}\r\n\t\t\t| Zero ->\r\n\t\t\t\t\tlet newStart = genName () in\r\n\t\t\t\t\t\t{alphabet = Set.empty; states = Set.make [newStart]; initialState = newStart;\r\n\t\t\t\t\t\t\t\ttransitions = Set.empty; acceptStates = Set.empty}\r\n\t\r\n\tlet re2fa (re: RegularExpression.t): FiniteAutomaton.t =\r\n\t\tcompile re\r\nend\r\n\r\n(********************************************************************)\r\nmodule FA2RE =\r\nstruct\r\n\topen FiniteAutomaton\r\n\topen RegularExpression\r\n\r\n\t(* transforms the set of expressions into the regex: plus of all expressions of the set *)\r\n\tlet plusSet reSet =\r\n\t\tlet rec pls l =\r\n\t\t\tmatch l with\r\n\t\t\t\t[] -> Zero\r\n\t\t\t\t| x::xs -> if xs = [] then x else Plus (x, pls xs)\r\n\t\tin\r\n\t\t\tpls (Set.toList reSet)\r\n\r\n\t(* For the given i and j, returns the value of R when k is zero.\r\n\t\tNote that k will always be 0 when called inside this method *)\r\n\tlet calczerok k i j trns =\r\n\t\tlet ts = Set.filter (fun (a,_,b) -> i = a && j = b) trns in\r\n\t\tif ts <> Set.empty then\r\n\t\t\tif i <> j then\r\n\t\t\t\tlet res = Set.map (fun (_,c,_) -> Symb c) ts in\r\n\t\t\t\t\t(k,i,j,plusSet res)\r\n\t\t\telse\r\n\t\t\t\tlet res = Set.map (fun (_,c,_) -> Symb c) ts in\r\n\t\t\t\tlet re = Plus(Empty, (plusSet res)) in\r\n\t\t\t\t\t(k,i,j,re)\r\n\r\n\t\telse (k,i,j,Zero)\r\n\t\t\r\n\tlet getRij i j prvK =\r\n\t\tlet r = Set.nth (Set.filter (fun (_,x,y,_) -> x = i && y = j) prvK) 0 in\r\n\t\t\t(fun (_,_,_,re) -> re) r\r\n\r\n\tlet assembleRe st i j prvK =\r\n\t\tlet rik = getRij i st prvK in\r\n\t\tlet rkk = Star (getRij st st prvK) in\r\n\t\tlet rkj = getRij st j prvK in\r\n\t\t\tSeq(rik, Seq(rkk,rkj))\r\n\t\t\t\t\r\n\t(* For the given i and j, returns the value of R when k is not zero. *)\r\n\tlet calck k i j prvK sts =\r\n\t\tlet rij = getRij i j prvK in\r\n\t\tlet rikjs = Set.map (fun st -> assembleRe st i j prvK) sts in\r\n\t\tlet rikj = plusSet rikjs in\r\n\t\t\t(k,i,j,Plus(rij,rikj))\r\n\r\n\t(* Main function that applies previous 2 functions to all possible i and j pairs *)\r\n\tlet rec rkij k trns sts =\r\n\t\tif k < 1 then\r\n\t\t\tSet.map (fun (i,j) -> calczerok k i j trns) (Set.product sts sts)\r\n\t\telse\r\n\t\t\tlet prvK = rkij (k-1) trns sts in\r\n\t\t\t\tSet.map (fun(i,j) -> calck k i j prvK sts) (Set.product sts sts)\r\n\r\n\tlet fa2re (fa: FiniteAutomaton.t): RegularExpression.t =\r\n\t\t(* Since the algorithm only works for deterministic automaton, we first convert it\r\n\t\t\tto its deterministic equivalent *)\r\n\t\tlet fa = FiniteAutomaton.toDeterministic fa in\r\n\t\tlet sts = fa.states in\r\n\t\tlet trns = fa.transitions in\r\n\t\tlet allRks = rkij (Set.size sts) trns sts in\r\n\t\tlet result = Set.filter (fun (_,i,j,_) -> i = fa.initialState && Set.belongs j fa.acceptStates ) allRks in\r\n\t\tlet res = Set.map (fun (_,_,_,re) -> re) result in\t\t\r\n\t\t\tplusSet res\r\n\t\t(*\tsimplify (plusSet res) *)\r\nend\r\n\r\n(********************************************************************)\r\nmodule RE2CFG =\r\nstruct\r\n\topen RegularExpression\r\n\topen ContextFreeGrammarBasic\r\n\t\r\n\t(*auxiliary var for genVar function*)\r\n\tlet k = ref 0\r\n\r\n\t(* generates new unused variable name for the cfg *)\r\n\tlet genVar () =\r\n\t\tlet n = !k in\r\n\t\tlet () = k:= n + 1 in\r\n\t\tlet ascii = 65 + n in\r\n\t\tif ascii < 65 || ascii > 90\r\n\t\tthen char2symb 'A'\r\n\t\telse char2symb (Char.chr ascii)\r\n\r\n\t(*\r\n\tlet convertPlsRules rl i1 i2 newInit =\r\n\t\t(* swaps the initial variables of both old cfgs for the new initial var *)\r\n\t\tlet swapInits c = if c = i1 || c = i2 then newInit else c in\r\n\r\n\t\tlet newBody b = List.map (fun c -> swapInits c) b in\r\n\t\tlet newRule r = {head = swapInits r.head; body = newBody r.body} in\r\n\r\n\t\t\tSet.map (fun r -> newRule r) rl\r\n\r\n\tin\r\n\t*)\r\n\t(* create gcf rules for plus expression *)\r\n\tlet convertPlsRules rl i1 i2 newInit =\r\n\t\tlet newRule1 = {head = newInit; body = [i1]} in\r\n\t\tlet newRule2 = {head = newInit; body = [i2]} in\r\n\t\t\tSet.add newRule1 (Set.add newRule2 rl)\r\n\r\n\t(* create gcf rules for seq expression *)\r\n\tlet convertSeqRules lcfg rcfg =\r\n\t\tlet rl1 = lcfg.rules in\r\n\t\tlet rl2 = rcfg.rules in\r\n\t\tlet alp1 = lcfg.alphabet in\r\n\t\tlet rl = Set.union rl1 rl2 in\r\n\t\tlet newBody r =\r\n\t\t\tlet b = r.body in\r\n\t\t\t\tmatch b with\r\n\t\t\t\t\t| [c] when Set.belongs r rl1 && not (Set.belongs c alp1) && c <> epsilon -> b\r\n\t\t\t\t\t| [c] when Set.belongs r rl1 && Set.belongs c alp1 -> [c; rcfg.initial]\r\n\t\t\t\t\t| [epsilon] when Set.belongs r rl1 -> [epsilon; rcfg.initial]\r\n\t\t\t\t\t| b when Set.belongs r rl2 -> b\r\n\t\t\t\t\t| _ -> b\r\n\t\tin\r\n\t\tlet newRule r = {head = r.head; body = newBody r} in\r\n\t\t\tSet.map (fun r -> newRule r) rl\r\n\r\n\t(* create gcf rules for star expression *)\r\n\tlet convertStrRules cfg =\r\n\t\tlet newBody b =\r\n\t\t\tmatch b with\r\n\t\t\t\t| [c] when Set.belongs c cfg.alphabet -> [c; cfg.initial]\r\n\t\t\t\t| _ -> b\r\n\t\tin\r\n\t\tlet r0 = {head = cfg.initial; body = [epsilon]} in\r\n\r\n\t\tlet newRule r = {head = r.head; body = newBody r.body} in\r\n\t\tlet newRules = Set.map (fun r -> newRule r) cfg.rules in\r\n\t\t\tSet.add r0 newRules\r\n\r\n\tlet rec compile re =\r\n\t\tmatch re with\r\n\t\t\t| Plus(l, r) ->\r\n\t\t\t\t\tlet cl = compile l in\r\n\t\t\t\t\tlet cr = compile r in\r\n\t\t\t\t\tlet alp = Set.union cl.alphabet cr.alphabet in\r\n\t\t\t\t\tlet init = genVar () in\r\n\t\t\t\t\tlet vs = Set.add init (Set.union cl.variables cr.variables) in\r\n\t\t\t\t\tlet rl = Set.union cl.rules cr.rules in\r\n\t\t\t\t\tlet rl = convertPlsRules rl cl.initial cr.initial init in\r\n\t\t\t\t\t\t{alphabet = alp; variables = vs;\r\n\t\t\t\t\t\t\tinitial = init; rules = rl}\r\n\t\t\t| Seq(l, r) ->\r\n\t\t\t\t\tlet cl = compile l in\r\n\t\t\t\t\tlet cr = compile r in\r\n\t\t\t\t\tlet alp = Set.union cl.alphabet cr.alphabet in\r\n\t\t\t\t\tlet init = cl.initial in\r\n\t\t\t\t\tlet vs = Set.union cl.variables cr.variables in\r\n\t\t\t\t\tlet rl = convertSeqRules cl cr in\r\n\t\t\t\t\t\t{alphabet = alp; variables = vs;\r\n\t\t\t\t\t\t\tinitial = init; rules = rl}\r\n\t\t\t| Star(re) ->\r\n\t\t\t\t\tlet cre = compile re in\r\n\t\t\t\t\tlet alp = cre.alphabet in\r\n\t\t\t\t\tlet init = cre.initial in\r\n\t\t\t\t\tlet vs = cre.variables in\r\n\t\t\t\t\tlet rl = convertStrRules cre in\r\n\t\t\t\t\t\t{alphabet = alp; variables = vs;\r\n\t\t\t\t\t\t\tinitial = init; rules = rl}\r\n\t\t\t| Symb(c) ->\r\n\t\t\t\t\tlet alp = Set.make [c] in\r\n\t\t\t\t\tlet init = genVar () in\r\n\t\t\t\t\tlet vars = Set.make [init] in\r\n\t\t\t\t\tlet rules = Set.make [{head = init; body = [c]}] in\r\n\t\t\t\t\t\t{alphabet = alp; variables = vars;\r\n\t\t\t\t\t\t\tinitial = init; rules = rules}\r\n\t\t\t| Empty ->\r\n\t\t\t\t\tlet alp = Set.empty in\r\n\t\t\t\t\tlet init = genVar () in\r\n\t\t\t\t\tlet vars = Set.make [init] in\r\n\t\t\t\t\tlet rules = Set.make [{head = init; body = [epsilon]}] in\r\n\t\t\t\t\t\t{alphabet = alp; variables = vars;\r\n\t\t\t\t\t\t\tinitial = init; rules = rules}\r\n\t\t\t| Zero ->\r\n\t\t\t\t\tlet alp = Set.empty in\r\n\t\t\t\t\tlet init = genVar () in\r\n\t\t\t\t\tlet var2 = genVar () in\r\n\t\t\t\t\tlet vars = Set.make [init; var2] in\r\n\t\t\t\t\tlet r1 = {head = init; body = [var2]} in\r\n\t\t\t\t\tlet r2 = {head = var2; body = [init]} in\r\n\t\t\t\t\tlet rules = Set.make [r1; r2] in\r\n\t\t\t\t\t\t{alphabet = alp; variables = vars;\r\n\t\t\t\t\t\t\t\tinitial = init; rules = rules}\r\n\r\n\tlet re2cfg (re: RegularExpression.t): ContextFreeGrammarBasic.t =\r\n\t\tcompile re\r\nend\r\n\r\n(********************************************************************)\r\nmodule FA2CFG =\r\nstruct\r\n\tlet fa2cfg fa =\r\n\t\tlet re = FA2RE.fa2re fa in\r\n\t\t\tRE2CFG.re2cfg re\r\nend\r\n\r\n(********************************************************************)\r\nmodule CFG2FA = (* right-linear CFG *)\r\nstruct\r\n\topen ContextFreeGrammarBasic\r\n\topen FiniteAutomaton\r\n\t\r\n\tlet toState sy = state (symb2str sy)\r\n\r\n\tlet toStates ssy = Set.map toState ssy\r\n\r\n\t(* This name will always be unique in the generated automaton *)\r\n\tlet accSt = state \"AccSt\"\r\n\r\n\tlet ruleToTrans (cfg: ContextFreeGrammarBasic.t) rh rb =\r\n\t\tlet alp = cfg.alphabet in\r\n\t\tlet vrs = cfg.variables in\r\n\t\tmatch rb with\r\n\t\t\t| [s;v] when Set.belongs s alp && Set.belongs v vrs\t-> Set.make [(toState rh, s, toState v)]\r\n\t\t\t| [v] when Set.belongs v vrs -> Set.make [(toState rh, epsilon, toState v)]\r\n\t\t\t| [s] when Set.belongs s alp -> Set.make [(toState rh, s, accSt)]\r\n\t\t\t| [e] when e = epsilon -> Set.make [(toState rh, epsilon, accSt)]\r\n\t\t\t| _ -> Set.empty\r\n\r\n\tlet cfg2fa (cfg: ContextFreeGrammarBasic.t): FiniteAutomaton.t =\r\n\t{\talphabet = cfg.alphabet;\r\n\t\tstates = Set.add accSt (toStates cfg.variables);\r\n\t\tinitialState = toState cfg.initial;\r\n\t\ttransitions = Set.flatMap (fun r -> ruleToTrans cfg r.head r.body) cfg.rules;\r\n\t\tacceptStates = Set.make [accSt]\r\n\t}\r\nend\r\n\r\n(********************************************************************)\r\nmodule CFG2RE = (* right-linear CFG *)\r\nstruct\r\n\tlet cfg2re (cfg: ContextFreeGrammarBasic.t): RegularExpression.t =\r\n\t\tlet fa = CFG2FA.cfg2fa cfg in\r\n\t\t\tFA2RE.fa2re fa\r\nend\r\n\r\n(********************************************************************)\r\nmodule PDA2FA =\r\nstruct\r\n\tlet transitionsFa trns = Set.map ( fun (s1,_,a,s2,_) -> (s1,a,s2) ) trns\r\n\t\r\n\tlet pda2fa (pda: PushdownAutomaton.t): FiniteAutomaton.t  =\r\n\t{\talphabet = pda.inputAlphabet;\r\n\t\tstates = pda.states;\r\n\t\tinitialState = pda.initialState;\r\n\t\ttransitions = transitionsFa pda.transitions;\r\n\t\tacceptStates = pda.acceptStates\r\n\t}\r\nend\r\n\r\n(********************************************************************)\r\nmodule FA2PDA =\r\nstruct\r\n\tlet upgradeTransition (s1,symb,s2) =\r\n\t\t\t(s1,PushdownAutomaton.stackSpecialSymb,symb,s2,[PushdownAutomaton.stackSpecialSymb])\r\n\t\t\t\r\n\tlet upgradeTransitions trns =\r\n\t\tSet.map upgradeTransition trns\r\n\t\t\r\n\tlet fa2pda (fa: FiniteAutomaton.t): PushdownAutomaton.t =\r\n\t{\tinputAlphabet = fa.alphabet;\r\n\t\tstackAlphabet = Set.make [PushdownAutomaton.stackSpecialSymb];\r\n\t\tstates = fa.states;\r\n\t\tinitialState = fa.initialState;\r\n\t\tinitialStackSymbol = PushdownAutomaton.stackSpecialSymb;\r\n\t\ttransitions = upgradeTransitions fa.transitions;\r\n\t\tacceptStates = fa.acceptStates;\r\n\t\tcriteria = true\r\n\t}\r\nend\r\n\r\n(********************************************************************)\r\nmodule RE2PDA =\r\nstruct\r\n\tlet re2pda (re: RegularExpression.t): PushdownAutomaton.t =\r\n\t\tlet fa = RE2FA.re2fa re in\r\n\t\t\tFA2PDA.fa2pda fa\r\nend\r\n\r\n(********************************************************************)\r\nmodule PDA2RE =\r\nstruct\r\n\tlet pda2re (pda: PushdownAutomaton.t): RegularExpression.t =\r\n\t\tlet fa = PDA2FA.pda2fa pda in\r\n\t\t\tFA2RE.fa2re fa\r\nend\r\n\r\n(********************************************************************)\r\n(*FIX BY PEDRO CARLOS 11/11 -> handle r.body = [epsilon] differently VER!*)\r\nmodule CFG2PDA =\r\nstruct\r\n\topen ContextFreeGrammarBasic\r\n\topen PushdownAutomaton\r\n\r\n\tlet computeState = state \"q\"\r\n\t\r\n\tlet makeNewTransition symbToConsume topStackSymbol toPutInStack: transition =\r\n\t\t(computeState, topStackSymbol, symbToConsume, computeState, toPutInStack)\r\n\r\n\tlet make_new_transition_for_rule r = (*PEDRO CARLOS*)\r\n\t\tif r.body = [epsilon] then\r\n\t\t\tmakeNewTransition epsilon r.head []  (*NOVO PC*)\r\n\t\telse\r\n\t\t\tmakeNewTransition epsilon r.head r.body\r\n\r\n\tlet buildTransitions(cfg: ContextFreeGrammarBasic.t): transitions =\r\n\t  let transitionsRules = Set.map make_new_transition_for_rule cfg.rules in\r\n\t  let transitionsFinalSymb = Set.map (fun alph -> makeNewTransition alph alph []) cfg.alphabet in\r\n\t  Set.union transitionsRules transitionsFinalSymb\r\n\r\n\tlet cfg2pda (cfg: ContextFreeGrammarBasic.t): PushdownAutomaton.t = \r\n\t{\tinputAlphabet = cfg.alphabet;\r\n\t\tstackAlphabet = Set.union cfg.alphabet cfg.variables;\r\n\t\tstates = Set.make [computeState];\r\n\t\tinitialState = computeState;\r\n\t\tinitialStackSymbol = cfg.initial;\r\n\t\ttransitions = buildTransitions cfg;\r\n\t\tacceptStates = Set.empty;\r\n\t\tcriteria = false\r\n\t}\r\nend\r\n\r\n(********************************************************************)\r\nmodule PDA2CFG = (*PEDRO CARLOS!!!*)\r\nstruct\r\n  open PushdownAutomaton\r\n  open ContextFreeGrammarBasic\r\n  \t\r\n  \t(* 2. Empties stack before accepting *)\r\n\tlet checkEmptyStackOnAccept (pda: PushdownAutomaton.t): bool =\r\n\t\tSet.exists (fun (curr_state, curr_symb, input, n_state, top_stack) -> \r\n\t\t\tSet.belongs n_state pda.acceptStates && (top_stack = [pda.initialStackSymbol] || top_stack = [])\r\n\t\t) pda.transitions\r\n\r\n\t(* 3. Each transition either pushes one symbol to the stack, or pops one symbol off the stack, but\r\n\tnot both or none.  *)\r\n\tlet check_pda_transitions (pda: PushdownAutomaton.t) : bool =\r\n\t\tSet.for_all (fun (_, _, _, _, stack_to_push) ->\r\n\t\t\tmatch stack_to_push with\r\n\t\t\t| [] -> true  (* Pop operation *)\r\n\t\t\t| [a; b] -> true  (* Push one symbol, symbol to push and previous top are the new top *)\r\n\t\t\t| _ -> false    (* Invalid: pushes multiple symbols *)\r\n\t\t) pda.transitions\r\n\r\n\tlet newEpsilonRules states = \r\n\t\tlet epsilonRules = Set.map (fun st -> {head = str2symb (\"<\" ^ st ^ st ^ \">\"); body = [epsilon]}) states in\r\n\t\tepsilonRules\r\n\r\n\tlet newRulesCombinatory q_states =\r\n\t\tSet.fold_right (fun p acc ->\r\n\t\t\tSet.fold_right (fun q acc_q ->\r\n\t\t\t\tSet.fold_right (fun r acc_r ->\r\n\t\t\t\t\tSet.add { head = str2symb (\"<\"  ^ p ^ q ^ \">\"); body = [str2symb (\"<\" ^ p ^ r ^ \">\"); str2symb  (\"<\" ^ r ^ q ^ \">\")] } acc_r\r\n\t\t\t\t) q_states acc_q\r\n\t\t\t) q_states acc\r\n\t\t) q_states Set.empty\t\r\n\t\t\r\n\t\t(* \r\n\t\ttype transition =\r\n\t\t\tstate\t\t\t(* state *)\r\n\t\t  * symbol\t\t(* current symbol on top of the stack *)\r\n\t\t  * symbol\t\t(* consumed input symbol *)\r\n\t\t  * state\t\t\t(* next state *)\r\n\t\t  * symbol list\t(* new top of stack*)\r\n\t\t*)\r\n\r\n\tlet matchingTransitions stateP stateQ stateR stateS pda =\r\n\t\tlet transitions = pda.transitions in\r\n\r\n\t\tlet filtered_transitions = Set.filter (fun (p, e, a, r, u) -> \r\n\t\t\tp = stateP && r = stateR &&\r\n\t\t\tList.mem e u && List.mem a u\r\n\t\t) transitions in\r\n\r\n\t\tlet filtered_transitions2 = Set.filter (fun (p, e, a, r, u) -> \r\n\t\t\tList.length u = 0 (*&& e <> pda.initialStackSymbol check if condition e <> pda.initialStackSymbol applyes to other grammars *)\r\n\t\t) transitions in\r\n\r\n\r\n\t\tlet result =\r\n\t\t  Set.fold_right (fun (p, e, a, r, u) acc ->\r\n\t\t\tlet transitions = Set.filter (fun (s, u', b, q, v) ->\r\n\t\t\t  s = stateS && q = stateQ && e = u'\r\n\t\t\t) filtered_transitions2 in\r\n\t\t\tif not (Set.isEmpty transitions) then\r\n\t\t\t  Set.union acc (Set.add (p, e, a, r, u) transitions)\r\n\t\t\telse\r\n\t\t\t  acc\r\n\t\t  ) filtered_transitions Set.empty in\r\n\r\n\t\tlet limited =\r\n\t\t\tresult\r\n\t\t\t|> Set.toList\r\n\t\t\t|> (function\r\n\t\t\t\t| a :: b :: _ -> [a; b]\r\n\t\t\t\t| [a] -> [a]\r\n\t\t\t\t| [] -> [])\r\n\t\tin\r\n\t\tlimited\r\n\t\t  \r\n\tlet newRules3 pda q_states =\r\n\t\tSet.fold_right (fun p acc ->\r\n\t\t\tSet.fold_right (fun q acc_q ->\r\n\t\t\t\tSet.fold_right (fun r acc_r ->\r\n\t\t\t\t\tSet.fold_right (fun s acc_s ->\r\n\t\t\t\t\tlet t =  matchingTransitions p q r s pda in\r\n\t\t\t\t\tif List.length t <> 2 then\r\n\t\t\t\t\t\tacc_s\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tlet (r', _, a, s', u') = List.hd t in\r\n\t\t\t\t\t\tlet (r'', _, b, s'', v') = List.hd (List.tl t) in\r\n\t\t\t\t\t\tSet.add { \t\r\n\t\t\t\t\t\t\thead = str2symb (\"<\" ^ p ^ q ^ \">\"); \r\n\t\t\t\t\t\t\tbody = \r\n\t\t\t\t\t\t\t\tif a <> epsilon && b <> epsilon (*must check this condition in other pdas *)\r\n\t\t\t\t\t\t\t\t\tthen [b; str2symb (\"<\" ^ r ^ s ^ \">\"); a] \r\n\t\t\t\t\t\t\t\telse [str2symb (\"<\" ^ r ^ s ^ \">\")] \r\n\t\t\t\t\t\t} acc_s\r\n\t\t\t\t\t) q_states acc_r\r\n\t\t\t\t) q_states acc_q\r\n\t\t\t) q_states acc\r\n\t\t) q_states Set.empty\r\n\r\n\tlet pda2cfg (pda: PushdownAutomaton.t): ContextFreeGrammarBasic.t =\r\n\t\t(*For the conversion to be possible pda must respect prerequisites:\r\n\t\t\t1. Single accept state\r\n\t\t\t2. Empties stack before accepting\r\n\t\t\t3. Each transition either pushes one symbol to the stack, or pops one symbol off the stack, but\r\n\t\t\tnot both or none. \r\n\t\t*)\r\n\t\tif Set.size pda.acceptStates <> 1 then\r\n\t\t\tfailwith \"PDA to CFG conversion: PDA must have exactly one accept state\"\r\n\t\telse if not (checkEmptyStackOnAccept pda) then\r\n\t\t\tfailwith \"PDA to CFG conversion: Stack must be empty before accepting\" \r\n\t\telse if not (check_pda_transitions pda)  then\r\n\t\t\tfailwith \"PDA to CFG conversion: Each transition either pushes one symbol to the stack, or pops one symbol off the stack, but not both or none\" \r\n\t\telse\r\n\t\tlet rules = Set.union (newRulesCombinatory pda.states) (Set.union (newRules3 pda pda.states)(newEpsilonRules pda.states)) in\r\n\t\t(* Set.iter (fun rule -> print_endline (rule2str rule)) rules; *)\r\n\t\tlet initial = str2symb (\"<\" ^ state2str pda.initialState ^ state2str (Set.hd pda.acceptStates) ^ \">\") in\r\n\t\t{\r\n\t\t\talphabet = pda.inputAlphabet;\r\n\t\t\tvariables = Set.union (Set.map (fun rule -> rule.head) rules) (Set.make [initial]);\r\n\t\t\tinitial = initial;\r\n\t\t\trules = rules\r\n\t\t}\r\nend\r\n\r\n(********************************************************************)\r\n(* PDA2TM module implementation PEDRO CARLOS UPDATES *)\r\nmodule PDA2TM =\r\nstruct\r\n  open PushdownAutomaton\r\n  open TuringMachineBasics\r\n\r\n\tlet counter = ref 0\r\n\tlet last_state = ref (str2state \"q_temp_init\")  \r\n\t\r\n\tlet fresh_state =\r\n\t\tfun () ->\r\n\t\t\tlet state = str2state (\"q_temp_\" ^ string_of_int !counter) in\r\n\t\t\tincr counter;\r\n\t\t\tlast_state := state; \r\n\t\t\tstate\r\n\t\r\n\tlet get_current_state () = !last_state\r\n\r\n  let pda2tm_2tapes (pda: PushdownAutomaton.t) : TuringMachine.t =\r\n\tlet new_initial_state = fresh_state () in\r\n\r\n\tlet initial_stack_check = \r\n\t\tif pda.initialStackSymbol = epsilon || String.length (symb2str pda.initialStackSymbol) = 0 then\r\n\t\t\tfalse\r\n\t\telse\r\n\t\t\ttrue\r\n\tin\r\n\r\n\tlet transiton_on_push (q, stack_top, input, q', symbol_to_push, input_dir, stack_dir) =\r\n\t\tif input = epsilon then\r\n\t\t\tSet.fold_right (fun symbol acc ->\r\n\t\t\t\tlet transition = (q, [symbol; stack_top], q', [symbol; symbol_to_push], [S; stack_dir]) in\r\n\t\t\t\ttransition :: acc\r\n\t\t\t) pda.inputAlphabet []\r\n\t\telse\r\n\t\t\t[ (q, [input; stack_top], q', [input; symbol_to_push], [input_dir; stack_dir]) ]\r\n\tin\r\n\r\n\r\n\t(*TODO REWRITE FUNCTIONAL *)\r\n  let convert_transition (q, stack_top, input, q', alpha) =\r\n\t\tlet reversed_alpha = List.rev alpha in\r\n\t\tlet n = List.length reversed_alpha in\r\n\t\tif n = 0 then\r\n\t\t\tlet input = if input = epsilon then empty else input in\r\n\t\t\tlet stack_top = if Set.belongs stack_top pda.inputAlphabet then stack_top else empty in\r\n\t\t\t[ (q, [input; stack_top], q', [input; empty], [R; L]) ]\r\n\t\telse\r\n\t\t\tlet rec build_transitions i current_state transitions =\r\n\t\t\t\tif i >= n then transitions\r\n\t\t\t\telse\r\n\t\t\t\t\tlet s = List.nth reversed_alpha i in (* symbol to push *)\r\n\t\t\t\t\tlet new_top = if i = 0 then stack_top else empty in\r\n\t\t\t\t\tlet is_last = i = n - 1 in\t\t (* is this the last symbol to push? *)\r\n\t\t\t\t\tlet next_state = if is_last then q' else fresh_state () in\r\n\t\t\t\t\tlet input_dir = if is_last then R else S in\r\n\t\t\t\t\tlet stack_dir = if is_last then S else R in\r\n\t\t\t\t\tlet transitions_on_push = transiton_on_push (current_state, new_top, input, next_state, s, input_dir, stack_dir) in\r\n\t\t\t\t\tbuild_transitions (i + 1) next_state (transitions_on_push @ transitions)\r\n\t\t\tin\r\n\t\t\tbuild_transitions 0 q []\r\n\tin\r\n\r\n\tlet make_initial_state =\r\n\t\tif not initial_stack_check then\r\n\t\t\t[]\r\n\t\telse\r\n\t\t\tSet.fold_right (fun symbol acc ->\r\n\t\t\t\tlet transition = (new_initial_state, [symbol; empty], pda.initialState, [symbol; pda.initialStackSymbol], [S; S]) in\r\n\t\t\t\ttransition :: acc\r\n\t\t\t) pda.inputAlphabet []\r\n\tin\r\n\r\n\tlet transitions =\r\n\t\tSet.fold_right (fun trans acc ->\r\n\t\t\tlet converted = convert_transition trans in\r\n\t\t\tList.fold_left (fun acc' t -> Set.add t acc') acc converted\r\n\t\t) pda.transitions (Set.make make_initial_state)\r\n    in\r\n\r\n    (* Add accept state and transitions *)\r\n    let accept_state = fresh_state () in\r\n    let accept_transitions =\r\n\t\tif Set.isEmpty pda.acceptStates then\r\n\t\t\tSet.fold_right (fun q acc ->\r\n\t\t\t\tlet transition = (q, [empty; empty], accept_state, [empty; empty], [S; S]) in\r\n\t\t\t\tSet.add transition acc\r\n\t\t\t) pda.states Set.empty\r\n\t\telse\r\n\t\t\tSet.fold_right (fun q acc ->\r\n\t\t\t\tlet transition = (q, [empty; pda.initialStackSymbol\t], accept_state, [empty; empty], [S; S]) in\r\n\t\t\t\tSet.add transition acc\r\n\t\t\t) pda.states Set.empty\r\n    in\r\n\r\n\r\n\r\n\tlet all_transitions = Set.union transitions accept_transitions in\r\n\r\n    (* Collect all states involved *)\r\n    let states =\r\n      Set.fold_right (fun (q,_,q',_,_) acc ->\r\n        Set.add q (Set.add q' acc)\r\n      ) all_transitions (Set.add accept_state pda.states)\r\n    in\r\n\r\n\tlet init_state = \r\n\t\tif initial_stack_check then\r\n\t\t\tnew_initial_state\r\n\t\telse\r\n\t\t\tpda.initialState\r\n\tin\r\n\tlet accept_states = \r\n\t\tif Set.belongs pda.initialState pda.acceptStates then\r\n\t\t\t[accept_state; init_state]\r\n\t\telse\r\n\t\t\t[accept_state]\r\n\tin\r\n\r\n\t\r\n\t{ \r\n\t  entryAlphabet = pda.inputAlphabet;\r\n\t  tapeAlphabet = Set.union pda.stackAlphabet (Set.add empty pda.inputAlphabet);\r\n\t  empty = empty;\r\n\t  states = states;\r\n\t  initialState = init_state;\r\n\t  transitions = all_transitions;\r\n\t  acceptStates = Set.make accept_states;\r\n\t  criteria = true;\r\n\t  lbMarkers = [];\r\n\t  _nTapes = 2;\r\n\t}\r\n\r\n \r\n  let pda2tm (pda: PushdownAutomaton.t) : TuringMachine.t =\r\n\t\tlet new_initial_state = fresh_state () in\r\n\r\n\r\n\t\t(*limiter between stack and input*)\r\n\t\tlet stack_limiter = symb \"$\" in \r\n\t\t(*marks the current input being read when checking stack (changes on epsilon input to \"<\" ^ (symb2str symbol) ^ \"|\" ^ \">\" to track current symbol)*)\r\n\t\tlet head_pointer = symb \"|\" in \r\n\t\t(*stack end, marks the top of the stack*)\r\n\t\tlet stack_end = symb \"#\" in \r\n\r\n\t\tlet pda_alpha = Set.union pda.stackAlphabet pda.inputAlphabet in\r\n\t\tlet alphabet_movement = Set.union (Set.make [stack_limiter; empty]) pda_alpha in\r\n\r\n\t\t(* Collect all states involved in transitions*)\r\n\t\tlet state_collector transitions =\r\n\t\t\tSet.fold_right (fun (q,_,q',_,_) acc ->\r\n\t\t\t\tSet.add q (Set.add q' acc)\r\n\t\t\t) transitions Set.empty\r\n\t\tin\r\n\r\n\t\t(*input to stack*)\r\n\t\tlet go_to_stack alphabet state nextState =\r\n\t\t\tSet.fold_right (fun symbol acc ->\r\n\t\t\t\tlet transition = (state, [symbol], nextState, [symbol], [L]) in\r\n\t\t\t\ttransition :: acc\r\n\t\t\t) alphabet [] \r\n\t\tin\r\n\r\n\t\t(*stack to input*)\r\n\t\tlet return_from_stack alphabet state nextState =\r\n\t\t\tSet.fold_right (fun symbol acc ->\r\n\t\t\t\tlet transition = (state, [symbol], nextState, [symbol], [R]) in\r\n\t\t\t\ttransition :: acc\r\n\t\t\t) alphabet []\r\n\t\tin\r\n\r\n\t\t(*add transitions to handle initialStackSymbol*)\r\n\t\tlet make_initial_transitions =\r\n\t\t\tlet new_state = fresh_state () in\r\n\t\t\tlet to_stack = go_to_stack pda.inputAlphabet new_initial_state new_state in\r\n\r\n\t\t\tlet new_state2 = fresh_state () in\r\n\t\t\tlet put_delimiter = (new_state, [empty], new_state2, [stack_limiter], [L]) in\r\n\r\n\t\t\tlet new_state3 = fresh_state () in\r\n\t\t\tlet put_initial = (new_state2, [empty], new_state3, [pda.initialStackSymbol], [L]) in\r\n\r\n\t\t\tlet new_state4 = fresh_state () in\r\n\t\t\tlet put_stack_end = (new_state3, [empty], new_state4, [stack_end], [R]) in\r\n\r\n\t\t\tlet new_state5 = fresh_state () in\r\n\t\t\tlet put_initial_2 = (new_state4, [pda.initialStackSymbol], new_state5, [pda.initialStackSymbol], [R]) in\r\n\r\n\t\t\tlet start = (new_state5, [stack_limiter], pda.initialState, [stack_limiter], [R]) in\r\n\r\n\t\t\tSet.make (to_stack @ [put_delimiter; put_initial; start; put_initial_2; put_stack_end])\r\n\t\tin\r\n\r\n\t\tlet extract_original_symbol modified_symbol =\r\n\t\t\tlet str = symb2str modified_symbol in\r\n\t\t\tlet bar_pos = String.index str '|' in\r\n\t\t\tlet original_str = String.sub str 1 (bar_pos - 1) in\r\n\t\t\tstr2symb original_str\r\n\t\tin\r\n\r\n\t\tlet convert_transition (q, stack_top, input, q', alpha) =\r\n\t\t\tlet n = List.length alpha in\r\n\t\t\tlet input_empty_alphabet = Set.toList (Set.add empty pda.inputAlphabet) in\r\n\t\t\t(* let input_empty_alphabet = Set.toList pda.inputAlphabet in *)\r\n\t\t\tif n = 0 then\r\n\t\t\t\tlet new_state = fresh_state () in\r\n\r\n\t\t\t\tlet read_input = \r\n\t\t\t\t\tif input = epsilon then\r\n\t\t\t\t\t\tList.fold_right (fun symbol acc ->\r\n\t\t\t\t\t\t\tlet special_symb = str2symb (\"<\" ^ (symb2str symbol) ^ \"|\" ^ \">\") in\r\n\t\t\t\t\t\t\tlet transition = (q, [symbol], new_state, [special_symb], [L]) in\r\n\t\t\t\t\t\t\ttransition :: acc\r\n\t\t\t\t\t\t) input_empty_alphabet []\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t[(q, [input], new_state, [head_pointer], [L])]\r\n\t\t\t\tin\r\n\r\n\t\t\t\tlet to_stack = go_to_stack alphabet_movement new_state new_state in\r\n\r\n\t\t\t\tlet new_state2 = fresh_state () in\r\n\t\t\t\tlet read_stack_end = (new_state, [stack_end], new_state2, [stack_end], [R]) in\r\n\r\n\t\t\t\tlet new_state3 = fresh_state () in\r\n\t\t\t\tlet new_end = (new_state2, [stack_top], new_state3, [stack_end], [R]) in\r\n\r\n\t\t\t\tlet return_stack = return_from_stack alphabet_movement new_state3 new_state3 in\r\n\t\t\t\tlet move_head = \r\n\t\t\t\t\tif input = epsilon then\r\n\t\t\t\t\t\tlet specials = List.map (fun symbol -> str2symb (\"<\" ^ (symb2str symbol) ^ \"|\" ^ \">\")) input_empty_alphabet in\r\n\t\t\t\t\t\tList.fold_right (fun special acc ->\r\n\t\t\t\t\t\t\tlet original = extract_original_symbol special in\r\n\t\t\t\t\t\t\tlet transition = (new_state3, [special], q', [original], [S]) in\r\n\t\t\t\t\t\t\ttransition :: acc\r\n\t\t\t\t\t\t) specials []\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t[(new_state3, [head_pointer], q', [input], [R])]\r\n\t\t\t\tin\r\n\r\n\t\t\t\t[read_stack_end; new_end] @ to_stack @ return_stack @ read_input @ move_head\r\n\t\t\telse\r\n\t\t\t\tlet new_state = fresh_state () in\r\n\r\n\t\t\t\tlet read_input = \r\n\t\t\t\t\tif input = epsilon then\r\n\t\t\t\t\t\tList.fold_right (fun symbol acc ->\r\n\t\t\t\t\t\t\tlet special_symb = str2symb (\"<\" ^ (symb2str symbol) ^ \"|\" ^ \">\") in\r\n\t\t\t\t\t\t\tlet transition = (q, [symbol], new_state, [special_symb], [L]) in\r\n\t\t\t\t\t\t\ttransition :: acc\r\n\t\t\t\t\t\t) input_empty_alphabet []\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t[(q, [input], new_state, [head_pointer], [L])]\r\n\t\t\t\tin\r\n\r\n\t\t\t\tlet to_stack = go_to_stack alphabet_movement new_state new_state in\r\n\r\n\t\t\t\tlet new_state2 = fresh_state () in\r\n\t\t\t\tlet read_stack_end = (new_state, [stack_end], new_state2, [empty], [R]) in\r\n\r\n\t\t\t\tlet new_state3 = fresh_state () in\r\n\t\t\t\tlet empty_top = (new_state2, [stack_top], new_state3, [empty], [S]) in\r\n\r\n\t\t\t\t\r\n\t\t\t\tlet reversed = stack_end :: alpha in\r\n\t\t\t\tlet new_stack_top = \r\n\t\t\t\t\tList.fold_right (fun symbol acc ->\r\n\t\t\t\t\t\tlet current_state = get_current_state () in\r\n\t\t\t\t\t\tlet write_state = fresh_state () in\r\n\t\t\t\t\t\tlet transitions = [(current_state, [stack_end], write_state, [symbol], [L]); (current_state, [empty], write_state, [symbol], [L])] in\r\n\t\t\t\t\t\ttransitions @ acc\r\n\t\t\t\t\t) reversed []\r\n\t\t\t\tin\r\n\r\n\t\t\t\tlet current_state = get_current_state () in\r\n\t\t\t\tlet return_stack = return_from_stack (Set.add stack_end alphabet_movement) current_state current_state in\r\n\t\t\t\tlet move_head = \r\n\t\t\t\t\tif input = epsilon then\r\n\t\t\t\t\t\tlet specials = List.map (fun symbol -> str2symb (\"<\" ^ (symb2str symbol) ^ \"|\" ^ \">\")) input_empty_alphabet in\r\n\t\t\t\t\t\tList.fold_right (fun special acc ->\r\n\t\t\t\t\t\t\tlet original = extract_original_symbol special in\r\n\t\t\t\t\t\t\tlet transition = (current_state, [special], q', [original], [S]) in\r\n\t\t\t\t\t\t\ttransition :: acc\r\n\t\t\t\t\t\t) specials []\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t[(current_state, [head_pointer], q', [input], [R])]\r\n\t\t\t\tin\r\n\t\t\t\t\r\n\t\t\t\t[read_stack_end; empty_top] @ to_stack @ new_stack_top @ return_stack @ read_input @ move_head\r\n\t\tin \r\n\r\n\t\tlet transitions =\r\n\t\t\tSet.fold_right (fun trans acc ->\r\n\t\t\t\tlet converted = convert_transition trans in\r\n\t\t\t\tList.fold_left (fun acc' t -> Set.add t acc') acc converted\r\n\t\t\t) pda.transitions make_initial_transitions\r\n\t\tin\r\n\r\n\r\n\t\tlet accept_state = fresh_state () in\r\n\r\n\t\tlet accept_transitions =\r\n\t\t\tif not (Set.isEmpty pda.acceptStates) then\r\n\t\t\t\tSet.fold_right (fun q acc ->\r\n\t\t\t\t\tlet new_state = fresh_state () in\r\n\r\n\t\t\t\t\tlet read_input = (q, [empty], new_state, [head_pointer], [L]) in\r\n\r\n\t\t\t\t\tlet to_stack = go_to_stack alphabet_movement new_state new_state in\r\n\r\n\t\t\t\t\tlet new_state2 = fresh_state () in\r\n\t\t\t\t\tlet read_stack_end = (new_state, [stack_end], new_state2, [stack_end], [R]) in\r\n\r\n\t\t\t\t\t(* let new_state3 = fresh_state () in *)\r\n\t\t\t\t\tlet new_end = (new_state2, [pda.initialStackSymbol], accept_state, [empty], [R]) in \r\n\t\t\t\t\t(* let move_head = (new_state3, [head_pointer], accept_state, [empty], [R]) in *)\r\n\r\n\t\t\t\t\tlet transSet = Set.make ([read_stack_end; read_input; new_end] @ to_stack) in\r\n\t\t\t\t\tSet.union transSet acc\r\n\t\t\t\t) pda.states transitions\r\n\t\t\telse\r\n\t\t\t\tlet current_states = state_collector transitions in\r\n\t\t\t\tSet.fold_right (fun q acc ->\r\n\t\t\t\t\tlet new_state = fresh_state () in\r\n\r\n\t\t\t\t\tlet read_input = (q, [empty], new_state, [head_pointer], [L]) in\r\n\r\n\t\t\t\t\tlet to_stack = go_to_stack (Set.add stack_limiter pda_alpha) new_state new_state in\r\n\r\n\t\t\t\t\tlet new_state2 = fresh_state () in\r\n\t\t\t\t\tlet read_stack_end = (new_state, [stack_end], new_state2, [stack_end], [R]) in\r\n\r\n\t\t\t\t\t(* let new_state3 = fresh_state () in *)\r\n\t\t\t\t\tlet new_end = (new_state2, [stack_limiter], accept_state, [empty], [R]) in \r\n\t\t\t\t\t(* let move_head = (new_state3, [head_pointer], accept_state, [empty], [R]) in *)\r\n\r\n\t\t\t\t\tlet transSet = Set.make ([read_stack_end; read_input; new_end] @ to_stack) in\r\n\r\n\t\t\t\t\tSet.union transSet acc\r\n\t\t\t\t) current_states transitions\r\n\t\tin\r\n\t\t\t\r\n\r\n\r\n\t\tlet all_states = state_collector accept_transitions in\r\n\r\n\t\tlet accept_states = \r\n\t\t\tif Set.belongs pda.initialState pda.acceptStates then\r\n\t\t\t\t[accept_state; new_initial_state]\r\n\t\t\telse\r\n\t\t\t\t[accept_state]\r\n\t\tin\r\n\r\n\t\tlet getTransSymbolMs transitions =\r\n\t\t\tlet trns2 = Set.map (fun (_,b,_,_,_) -> b) transitions in\r\n\t\t\tlet trns4 = Set.map (fun (_,_,_,d,_) -> d) transitions in\r\n\t\t\t\tSet.union trns2 trns4\r\n\t\tin\r\n\t\r\n\t\tlet getTransSymbols transitions =\r\n\t\t\tSet.flatten (Set.map Set.make (getTransSymbolMs transitions))\r\n\t\tin\r\n\r\n\t\t{\tentryAlphabet = pda.inputAlphabet;\r\n\t\t\ttapeAlphabet = (getTransSymbols accept_transitions);\r\n\t\t\tempty = empty;\r\n\t\t\tstates = Set.union all_states (Set.make accept_states);\r\n\t\t\tinitialState = new_initial_state;\r\n\t\t\ttransitions = accept_transitions;\r\n\t\t\tacceptStates = Set.make accept_states;\r\n\t\t\tcriteria = true;\r\n\t\t\tlbMarkers = [];\r\n\t\t\t_nTapes = 1\r\n\t\t} \r\nend\r\n\r\n(********************************************************************)\r\nmodule FA2TM = (* Carolina *)\r\nstruct\r\n\tlet fa2tm (fa : FiniteAutomaton.t): TuringMachine.t = \r\n\t{\tentryAlphabet = Set.remove empty fa.alphabet;  (*PEDRO CARLOS *)\r\n\t\ttapeAlphabet = Set.add empty fa.alphabet ;  (*PEDRO CARLOS *)\r\n\t(* {\tentryAlphabet = fa.alphabet;\r\n\t\ttapeAlphabet = fa.alphabet; VER!!!   MUDOU PORQUE? empty não pertence a nenhum alfabeto!*)\r\n\t\tempty = empty;\r\n\t\tstates = fa.states;\r\n\t\tinitialState = fa.initialState;\r\n\t\ttransitions = Set.map (fun (a,b,c) -> (a,[b],c,[b],[R])) fa.transitions;\r\n\t\tacceptStates = fa.acceptStates;\r\n\t\tcriteria = true;\r\n\t\tlbMarkers = [];\r\n\t\t_nTapes = 1\r\n\t}\r\nend\r\n\r\n(********************************************************************)\r\nmodule RE2TM =\r\nstruct\r\n\tlet re2tm (re: RegularExpression.t): TuringMachine.t =\r\n\t\tlet re = RE2FA.re2fa re in\r\n\t\t\tFA2TM.fa2tm re\r\nend\r\n\r\n(********************************************************************)\r\nmodule CFG2TM = (* PEDRO CARLOS VER!!! *)\r\nstruct\r\n\tlet cfg2tm (cfg: ContextFreeGrammarBasic.t): TuringMachine.t =\r\n\t\tlet pda = CFG2PDA.cfg2pda cfg in\r\n\t\t\tPDA2TM.pda2tm pda (* uma fita *)\r\n\r\n\tlet cfg2tm_2tapes (cfg: ContextFreeGrammarBasic.t): TuringMachine.t =\r\n\t\tlet pda = CFG2PDA.cfg2pda cfg in\r\n\t\t\tPDA2TM.pda2tm_2tapes pda \r\n(* \t\r\n\tlet cfg2tm (cfg: ContextFreeGrammarBasic.t): TuringMachine.t =\r\n\t\tlet pda = CFG2PDA.cfg2pda cfg in\r\n\t\t\tPDA2TM.pda2tm_2tapes pda  *)\r\n\t(* let cfg2tm (cfg: ContextFreeGrammarBasic.t): TurMachMultiTypes.t =\r\n\t\tlet pda = CFG2PDA.cfg2pda cfg in\r\n\t\t\tPDA2TM.pda2tm pda *)\r\nend\r\n\r\n(********************************************************************)\r\n(*PEDRO CARLOS VER!!! *)\r\n(********************************************************************)\r\n  (* GRAMMAR *)\r\n\tmodule CFG2GR =\r\n\tstruct\r\n\t\topen ContextFreeGrammarBasic\r\n\t\topen Grammar\r\n\r\n    let cfg2gr (cfg: ContextFreeGrammarBasic.t): Grammar.t =\r\n\t\t\tlet rules = \r\n\t\t\t\t\tSet.map (fun (rule: ContextFreeGrammarBasic.rule) : Grammar.rule ->\r\n\t\t\t\t\t\t\t{head = [rule.head]; body = rule.body}) cfg.rules\r\n\t\t\tin\r\n\t\t\t{\r\n\t\t\t\t\talphabet = cfg.alphabet;\r\n\t\t\t\t\tvariables = cfg.variables;\r\n\t\t\t\t\tinitial = cfg.initial;\r\n\t\t\t\t\trules = rules;\r\n\t\t\t}\r\n\tend\r\n\r\n\r\n\t(********************************************************************)\r\n\tmodule RE2GR =\r\n\tstruct\r\n\t\tlet re2gr re =\r\n\t\t\tlet cfg = RE2CFG.re2cfg re in\r\n\t\t\t\tCFG2GR.cfg2gr cfg\r\n\tend\r\n\r\n(********************************************************************)\r\n\r\n\t(********************************************************************)\r\n\tmodule FA2GR =\r\n\tstruct\r\n\t\tlet fa2gr (fa: FiniteAutomaton.t): Grammar.t =\r\n\t\t\tlet cfg = FA2CFG.fa2cfg fa in\r\n\t\t\t\tCFG2GR.cfg2gr cfg\r\n\tend\r\n\r\n(********************************************************************)\r\n\r\n\tmodule GR2CFG = \r\n\tstruct\r\n\t\topen ContextFreeGrammarBasic\r\n\t\topen Grammar\r\n\r\n\t(* pre: gram is context free *)\r\n\tlet gr2cfg (gram: Grammar.t): ContextFreeGrammarBasic.t =\r\n\t\t{\r\n\t\t\talphabet = gram.alphabet;\r\n\t\t\tvariables = gram.variables;\r\n\t\t\tinitial = gram.initial;\r\n\t\t\trules = Set.map (fun (rule: Grammar.rule) : ContextFreeGrammarBasic.rule -> \r\n\t\t\t\t{head = List.hd rule.head; body = rule.body}) gram.rules;\r\n\t\t}\r\n\tend\r\n\r\n\tmodule GR2PDA = (* ??? *)\r\n\t\tstruct\r\n\t\t\tlet gr2pda (gr: Grammar.t): PushdownAutomaton.t =\r\n\t\t\t\tlet cfg = GR2CFG.gr2cfg gr in\r\n\t\t\t\t\tCFG2PDA.cfg2pda cfg \r\n\r\n\t\t\t(* let cfg2tm (cfg: ContextFreeGrammarBasic.t): TurMachMultiTypes.t =\r\n\t\t\t\tlet pda = CFG2PDA.cfg2pda cfg in\r\n\t\t\t\t\tPDA2TM.pda2tm pda *)\r\nend\r\n\t\r\n\tmodule GR2TM =\r\n\tstruct\r\n\t\t open Grammar\r\n\t\t open TuringMachine\r\n\r\n\tlet gr2tm (gram: Grammar.t): TuringMachine.t =\r\n\t\t(* Not implemented *)\r\n\t\t\t\t{\r\n\t\t\t\t\tentryAlphabet = Set.make [];\r\n\t\t\t\t\ttapeAlphabet = Set.make [];\r\n\t\t\t\t\tempty = empty;\r\n\t\t\t\t\tstates = Set.make [];\r\n\t\t\t\t\tinitialState = \"q0\";\r\n\t\t\t\t\ttransitions = Set.make [];\r\n\t\t\t\t\tacceptStates = Set.make [\"q_accept\"];\r\n\t\t\t\t\tcriteria = true;\r\n\t\t\t\t\tlbMarkers = [];\r\n\t\t\t\t\t_nTapes = 1;\r\n\t\t\t\t}\r\n\r\n\tend\r\n\r\n\tmodule TM2GR = (* Linz *)\r\n\tstruct\r\n\t\t open Grammar\r\n\t\t open TuringMachine\r\n\r\n\t\t \tlet tm2gr (tm: TuringMachine.t): Grammar.t =\r\n\t\t\t\t(* Check if the Turing Machine is deterministic *)\r\n\t\t\t\tif tm._nTapes <> 1 then\r\n\t\t\t\t\tfailwith \"The Turing Machine must have exactly one tape\"\r\n\t\t\t\telse if not (TuringMachinePrivate.isDeterministic tm) then\r\n\t\t\t\t\tfailwith \"The Turing Machine is not deterministic\"\r\n\t\t\t\telse\r\n\t\t\t\t\tlet ini_symb = str2symb \"S\" in\r\n\t\t\t\t\tlet t_symb = str2symb \"T\" in\r\n\t\t\t\t\tlet aSet = Set.add tm.empty tm.entryAlphabet in\r\n\t\t\t\t\tlet bSet = tm.tapeAlphabet in\r\n\t\t\t\t\tlet newAB_Vars =\r\n\t\t\t\t\t\tSet.fold_right (fun a acc ->\r\n\t\t\t\t\t\t\tSet.fold_right (fun b acc_inner ->\r\n\t\t\t\t\t\t\t\tlet new_var = Printf.sprintf \"<V%s%s>\" (symb2str a) (symb2str b) in\r\n\t\t\t\t\t\t\t\tSet.add (str2symb new_var) acc_inner\r\n\t\t\t\t\t\t\t) bSet acc\r\n\t\t\t\t\t\t) aSet Set.empty\r\n\t\t\t\t\tin\r\n\t\t\t\t\tlet states = tm.states in\r\n\t\t\t\t\tlet newAIB_Vars =\r\n\t\t\t\t\t\tSet.fold_right (fun a acc ->\r\n\t\t\t\t\t\t\tSet.fold_right (fun i acc_inner ->\r\n\t\t\t\t\t\t\t\tSet.fold_right (fun b acc_innermost ->\r\n\t\t\t\t\t\t\t\t\tlet new_var = Printf.sprintf \"<V%s%s%s>\" (symb2str a) (state2str i) (symb2str b) in\r\n\t\t\t\t\t\t\t\t\tSet.add (str2symb new_var) acc_innermost\r\n\t\t\t\t\t\t\t\t) bSet acc_inner\r\n\t\t\t\t\t\t\t) states acc\r\n\t\t\t\t\t\t) aSet Set.empty\r\n\t\t\t\t\tin\r\n\t\t\t\r\n\t\t\t\t\tlet firstRules = \r\n\t\t\t\t\t\tlet empty = tm.empty in\r\n\t\t\t\t\t\tlet v_empty_empty = str2symb (Printf.sprintf \"<V%s%s>\" (symb2str empty) (symb2str empty)) in\r\n\t\t\t\t\t\tSet.make [\r\n\t\t\t\t\t\t\t{head = [ini_symb]; body = [v_empty_empty; ini_symb]};\r\n\t\t\t\t\t\t\t{head = [ini_symb]; body = [ini_symb; v_empty_empty]};\r\n\t\t\t\t\t\t\t{head = [ini_symb]; body = [t_symb]};\r\n\t\t\t\t\t\t]\r\n\t\t\t\t\tin\r\n\t\t\t\r\n\t\t\t\t\tlet secondRules =\r\n\t\t\t\t\t\tSet.fold_right (fun a acc ->\r\n\t\t\t\t\t\t\tlet new_var = str2symb (Printf.sprintf \"<V%s%s>\" (symb2str a) (symb2str a)) in\r\n\t\t\t\t\t\t\tlet new_var_2 = str2symb (Printf.sprintf \"<V%s%s%s>\" (symb2str a) (state2str tm.initialState) (symb2str a)) in\r\n\t\t\t\t\t\t\tlet new_rule = {head = [t_symb]; body = [t_symb; new_var]} in\r\n\t\t\t\t\t\t\tlet new_rule_2 = {head = [t_symb]; body = [new_var_2]} in\r\n\t\t\t\t\t\t\tlet new_rules = Set.make [new_rule; new_rule_2] in\r\n\t\t\t\t\t\t\tSet.union new_rules acc\r\n\t\t\t\t\t\t) tm.entryAlphabet Set.empty\r\n\t\t\t\t\tin\r\n\t\t\t\r\n\t\t\t\t\tlet transition_rules =\r\n\t\t\t\t\t\tSet.flatMap (fun (curr_state, input, next_state, tape_symb, dir) ->\r\n\t\t\t\t\t\t\tmatch dir with\r\n\t\t\t\t\t\t\t| [L] -> \r\n\t\t\t\t\t\t\t\tSet.fold_right (fun a acc ->\r\n\t\t\t\t\t\t\t\t\tSet.fold_right (fun p acc_inner ->\r\n\t\t\t\t\t\t\t\t\t\tSet.fold_right (fun q acc_innermost ->\r\n\t\t\t\t\t\t\t\t\t\t\tlet v_pq = str2symb (Printf.sprintf \"<V%s%s>\" (symb2str p) (symb2str q)) in\r\n\t\t\t\t\t\t\t\t\t\t\tlet v_aic = str2symb (Printf.sprintf \"<V%s%s%s>\" (symb2str a) (state2str curr_state) (symb2str (List.hd input))) in\r\n\t\t\t\t\t\t\t\t\t\t\tlet v_pjq = str2symb (Printf.sprintf \"<V%s%s%s>\" (symb2str p) (state2str next_state) (symb2str q)) in\r\n\t\t\t\t\t\t\t\t\t\t\tlet v_ad = str2symb (Printf.sprintf \"<V%s%s>\" (symb2str a) (symb2str (List.hd tape_symb))) in\r\n\t\t\t\t\t\t\t\t\t\t\tlet new_rule = {head = [v_pq; v_aic]; body = [v_pjq; v_ad]} in\r\n\t\t\t\t\t\t\t\t\t\t\tSet.add new_rule acc_innermost\r\n\t\t\t\t\t\t\t\t\t\t) bSet acc_inner\r\n\t\t\t\t\t\t\t\t\t) aSet acc\r\n\t\t\t\t\t\t\t\t) aSet Set.empty\r\n\t\t\t\t\t\t\t| [R] -> \r\n\t\t\t\t\t\t\t\tSet.fold_right (fun a acc ->\r\n\t\t\t\t\t\t\t\t\tSet.fold_right (fun p acc_inner ->\r\n\t\t\t\t\t\t\t\t\t\tSet.fold_right (fun q acc_innermost ->\r\n\t\t\t\t\t\t\t\t\t\t\tlet v_pq = str2symb (Printf.sprintf \"<V%s%s>\" (symb2str p) (symb2str q)) in\r\n\t\t\t\t\t\t\t\t\t\t\tlet v_aic = str2symb (Printf.sprintf \"<V%s%s%s>\" (symb2str a) (state2str curr_state) (symb2str (List.hd input))) in\r\n\t\t\t\t\t\t\t\t\t\t\tlet v_pjq = str2symb (Printf.sprintf \"<V%s%s%s>\" (symb2str p) (state2str next_state) (symb2str q)) in\r\n\t\t\t\t\t\t\t\t\t\t\tlet v_ad = str2symb (Printf.sprintf \"<V%s%s>\" (symb2str a) (symb2str (List.hd tape_symb))) in\r\n\t\t\t\t\t\t\t\t\t\t\tlet new_rule = {head = [v_aic; v_pq]; body = [v_ad; v_pjq]} in\r\n\t\t\t\t\t\t\t\t\t\t\tSet.add new_rule acc_innermost\r\n\t\t\t\t\t\t\t\t\t\t) bSet acc_inner\r\n\t\t\t\t\t\t\t\t\t) aSet acc\r\n\t\t\t\t\t\t\t\t) aSet Set.empty\r\n\t\t\t\t\t\t\t| _ -> Set.empty\r\n\t\t\t\t\t\t) tm.transitions\r\n\t\t\t\t\tin\r\n\t\t\t\r\n\t\t\t\t\tlet accept_state_rules = \r\n\t\t\t\t\t\tSet.fold_right (fun a acc ->\r\n\t\t\t\t\t\t\tSet.fold_right (fun i acc_inner ->\r\n\t\t\t\t\t\t\t\tSet.fold_right (fun b acc_innermost ->\r\n\t\t\t\t\t\t\t\t\tlet new_var = str2symb (Printf.sprintf \"<V%s%s%s>\" (symb2str a) (state2str i) (symb2str b)) in\r\n\t\t\t\t\t\t\t\t\tlet new_rule = {head = [new_var]; body = [a]} in\r\n\t\t\t\t\t\t\t\t\tSet.add new_rule acc_innermost\r\n\t\t\t\t\t\t\t\t) bSet acc_inner\r\n\t\t\t\t\t\t\t) tm.acceptStates acc\r\n\t\t\t\t\t\t) aSet Set.empty\r\n\t\t\t\t\tin\r\n\t\t\t\r\n\t\t\t\t\tlet handle_terminals_rules = \r\n\t\t\t\t\t\tSet.fold_right (fun a acc ->\r\n\t\t\t\t\t\t\tSet.fold_right (fun c acc_inner ->\r\n\t\t\t\t\t\t\t\tSet.fold_right (fun b acc_innermost ->\r\n\t\t\t\t\t\t\t\t\tlet new_var = str2symb (Printf.sprintf \"<V%s%s>\" (symb2str a) (symb2str b)) in\r\n\t\t\t\t\t\t\t\t\tlet new_rule = {head = [c; new_var]; body = [c; a]} in\r\n\t\t\t\t\t\t\t\t\tlet new_rule2 = {head = [new_var; c]; body = [a; c]} in\r\n\t\t\t\t\t\t\t\t\tlet new_rules = Set.make [new_rule; new_rule2] in\r\n\t\t\t\t\t\t\t\t\tSet.union new_rules acc_innermost\r\n\t\t\t\t\t\t\t\t) bSet acc_inner\r\n\t\t\t\t\t\t\t) aSet acc\r\n\t\t\t\t\t\t) aSet Set.empty\r\n\t\t\t\t\tin\r\n\t\t\t\r\n\t\t\t\t\tlet empty_epsilon_rule =\r\n\t\t\t\t\t\tlet new_rule = {head = [tm.empty]; body = [epsilon]} in\r\n\t\t\t\t\t\tSet.make [new_rule]\r\n\t\t\t\t\tin\r\n\t\t\t\r\n\t\t\t\t\tlet rules = \r\n\t\t\t\t\t\tlet first = Set.union firstRules secondRules in\r\n\t\t\t\t\t\tlet second = Set.union transition_rules accept_state_rules in\r\n\t\t\t\t\t\tlet third = Set.union handle_terminals_rules empty_epsilon_rule in\r\n\t\t\t\t\t\tSet.union first (Set.union second third)\r\n\t\t\t\t\tin\r\n\t\t\t\r\n\t\t\t\t\tlet vars = \r\n\t\t\t\t\t\tlet symbs = Set.make [ini_symb; t_symb; tm.empty] in\r\n\t\t\t\t\t\tSet.union (Set.union newAB_Vars newAIB_Vars) symbs\r\n\t\t\t\t\tin\r\n\t\t\t\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\talphabet = tm.entryAlphabet;\r\n\t\t\t\t\t\tvariables = vars;\r\n\t\t\t\t\t\tinitial = ini_symb;\r\n\t\t\t\t\t\trules = rules\r\n\t\t\t\t\t}\r\n\r\n\r\n\tend\r\n\t\r\n(********************************************************************)\r\n(*PEDRO CARLOS *)\r\n(********************************************************************)\r\n\r\nmodule PolyBasic =\r\nstruct\r\n\tlet re2fa = RE2FA.re2fa\r\n\tlet pda2fa = PDA2FA.pda2fa\r\n\tlet cfg2fa = CFG2FA.cfg2fa\r\n\t\r\n\tlet fa2re = FA2RE.fa2re\r\n\tlet pda2re = PDA2RE.pda2re\r\n\tlet cfg2re = CFG2RE.cfg2re\r\n\r\n\tlet fa2pda = FA2PDA.fa2pda\r\n\tlet re2pda = RE2PDA.re2pda\r\n\tlet cfg2pda = CFG2PDA.cfg2pda\r\n\r\n\tlet gr2pda = GR2PDA.gr2pda (* PEDRO CARLOS VER!!! impossivel  está expplicado....*)\r\n\t\r\n\tlet fa2cfg = FA2CFG.fa2cfg\r\n\tlet re2cfg = RE2CFG.re2cfg\r\n\tlet re2gr = RE2GR.re2gr (* PEDRO CARLOS *)\r\n\tlet pda2cfg = PDA2CFG.pda2cfg\r\n\t\r\n\tlet fa2tm = FA2TM.fa2tm\r\n\tlet fa2gr = FA2GR.fa2gr (* PEDRO CARLOS *)\r\n\tlet re2tm = RE2TM.re2tm\r\n\tlet pda2tm = PDA2TM.pda2tm\r\n\tlet pda2tm_2tapes = PDA2TM.pda2tm_2tapes (* PEDRO CARLOS *)\r\n\tlet cfg2tm = CFG2TM.cfg2tm\r\n\tlet cfg2tm_2tapes = CFG2TM.cfg2tm_2tapes (* PEDRO CARLOS *)\r\n\r\n\t(* GRAMMAR *)\r\n\t(********************************************************************)\r\n\t(*PEDRO CARLOS *)\r\n\t(********************************************************************)\r\n\tlet gr2cfg = GR2CFG.gr2cfg\r\n\tlet gr2tm = GR2TM.gr2tm \r\n\tlet cfg2gr = CFG2GR.cfg2gr\r\n\tlet tm2gr = TM2GR.tm2gr\r\n\r\n\r\n\t(********************************************************************)\r\n\t(*PEDRO CARLOS *)\r\n\t(********************************************************************)\r\n\r\nend\r\n\r\n(********************************************************************)\r\nmodule PolyModel =\r\nstruct\r\n\topen PolyBasic\r\n\r\n\tlet json2model (j: JSon.t): Model.model =\r\n\t\tlet kind = JSon.fieldString j \"kind\" in\r\n\t\t\t(********************************************************************)\r\n\t\t\t(*PEDRO CARLOS *)\r\n\t\t\t(********************************************************************)\r\n\t\t\tif Grammar.kind = kind then\r\n\t\t\t\t(new Grammar.model (Arg.JSon j) :> Model.model)\r\n\t\t\t(********************************************************************)\r\n\t\t\t(*PEDRO CARLOS *)\r\n\t\t\t(********************************************************************)\r\n\t\t\telse if FiniteAutomaton.kind = kind then\r\n\t\t\t\t(new FiniteAutomaton.model (Arg.JSon j) :> Model.model)\r\n\t\t\telse if RegularExpression.kind = kind then\r\n\t\t\t\t(new RegularExpression.model (Arg.JSon j) :> Model.model)\r\n\t\t\telse if PushdownAutomaton.kind = kind then\r\n\t\t\t\t(new PushdownAutomaton.model (Arg.JSon j) :> Model.model)\r\n\t\t\telse if ContextFreeGrammarBasic.kind = kind then\r\n\t\t\t\t(new ContextFreeGrammarBasic.model (Arg.JSon j) :> Model.model)\r\n\t\t\telse if TuringMachine.kind = kind then\r\n\t\t\t\t(new TuringMachine.model (Arg.JSon j) :> Model.model)\r\n\t\t\telse if FiniteEnumeration.kind = kind then\r\n\t\t\t\t(new FiniteEnumeration.model (Arg.JSon j) :> Model.model)\r\n\t\t\telse if Exercise.kind = kind then (\r\n\t\t\t\tignore (new Exercise.exercise (Arg.JSon j));\t\t\t\r\n\t\t\t\t(new FiniteAutomaton.model (Arg.JSon FiniteAutomaton.example) :> Model.model)\r\n\t\t\t)\r\n\t\t\telse (* need to ignore Composition.kind *)\r\n\t\t\t\t(new FiniteAutomaton.model (Arg.JSon FiniteAutomaton.example) :> Model.model)\r\n\t\t\t\t\r\n\tlet text2model (text: string): Model.model = json2model (JSon.parse text)\r\n\t\r\n\tlet file2model (filename: string): Model.model = json2model (JSon.fromFile filename)\r\n\t\r\n\tlet example2model (name: string): Model.model = text2model (Examples.example name)\r\n\r\n\t(********************************************************************)\r\n\t(*PEDRO CARLOS *)\r\n\t(********************************************************************)\r\n\tlet gr2model (g: Grammar.t): Grammar.model =\r\n\t\tnew Grammar.model (Arg.Representation g)\r\n\t(********************************************************************)\r\n\t(*PEDRO CARLOS *)\r\n\t(********************************************************************)\r\n\r\n\tlet fa2model (fa: FiniteAutomaton.t): FiniteAutomaton.model =\r\n\t\tnew FiniteAutomaton.model (Arg.Representation fa)\r\n\r\n\tlet re2model (re: RegularExpression.t): RegularExpression.model =\r\n\t\tnew RegularExpression.model (Arg.Representation re)\r\n\r\n\tlet pda2model (pda: PushdownAutomaton.t): PushdownAutomaton.model =\r\n\t\tnew PushdownAutomaton.model (Arg.Representation pda)\r\n\r\n\tlet cfg2model (cfg: ContextFreeGrammarBasic.t): ContextFreeGrammarBasic.model =\r\n\t\tnew ContextFreeGrammarBasic.model (Arg.Representation cfg)\r\n\r\n\tlet tm2model (tm: TuringMachine.t): TuringMachine.model =\r\n\t\tnew TuringMachine.model (Arg.Representation tm)\r\n\r\n\t(* let tmMulti2model (tm: TurMachMultiTypes.t): TurMachMultiTypes.model =\r\n\t\tnew TurMachMultiTypes.model (Arg.Representation tm) *)\r\n\r\n\t(* GRAMMAR *)\r\n\t(********************************************************************)\r\n\t(*PEDRO CARLOS *)\r\n\t(********************************************************************)\r\n\tlet model2gr (model: Model.model): Grammar.t =\r\n\t\tif model#isGrammar then Grammar.make (Arg.JSon (model#toJSon))\r\n\t\telse Error.fatal \"model2gr\"\r\n\t(********************************************************************)\r\n\t(*PEDRO CARLOS *)\r\n\t(********************************************************************)\r\n\r\n\tlet model2fa (model: Model.model): FiniteAutomaton.t =\r\n\t\tif model#isFiniteAutomaton then FiniteAutomaton.make (Arg.JSon (model#toJSon))\r\n\t\telse Error.fatal \"model2fa\"\r\n\t\t\r\n\tlet model2re (model: Model.model): RegularExpression.t =\r\n\t\tif model#isRegularExpression then RegularExpression.make (Arg.JSon (model#toJSon))\r\n\t\telse Error.fatal \"model2re\"\r\n\t\t\r\n\tlet model2cfg (model: Model.model): ContextFreeGrammarBasic.t =\r\n\t\tif model#isContextFreeGrammar then ContextFreeGrammarBasic.make (Arg.JSon (model#toJSon))\r\n\t\telse Error.fatal \"model2cfg\"\r\n\t\t\r\n\tlet model2pda (model: Model.model): PushdownAutomaton.t =\r\n\t\tif model#isPushdownAutomaton then PushdownAutomaton.make (Arg.JSon (model#toJSon))\r\n\t\telse Error.fatal \"model2pda\"\r\n\t\t\r\n\tlet model2tm (model: Model.model): TuringMachine.t =\r\n\t\tif model#isTuringMachine then TuringMachine.make (Arg.JSon (model#toJSon))\r\n\t\telse Error.fatal \"model2tm\"\r\n\r\n\t(* Carolina *)\r\n\tlet model2comp (model: Model.model): CompositionSupport.t =\r\n\t\tif model#isFiniteAutomaton then FA (model2fa model)\r\n\t\telse if model#isRegularExpression then RE (model2re model)\r\n\t\telse if model#isPushdownAutomaton then PDA (model2pda model)\r\n\t\telse if model#isContextFreeGrammar then CFG (model2cfg model)\r\n\t\telse if model#isTuringMachine then TM (model2tm model)\r\n\t\t(********************************************************************)\r\n\t\t(*PEDRO CARLOS *)\r\n\t\t(********************************************************************)\r\n\t\telse if model#isGrammar then GR (model2gr model)\r\n\t\t(********************************************************************)\r\n\t\t(*PEDRO CARLOS *)\r\n\t\t(********************************************************************)\r\n\t\telse if model#isComposition then \r\n\t\t\t!CompositionSupport.makeCompositionRef (Arg.JSon (model#toJSon))\r\n\t\telse Error.fatal \"model2comp\"\r\n\r\n\tlet re2fa m = fa2model (re2fa m#representation)\r\n\tlet pda2fa m = fa2model (pda2fa m#representation)\r\n\tlet cfg2fa m = fa2model (cfg2fa m#representation)\r\n\r\n\tlet fa2re m = re2model (fa2re m#representation)\r\n\tlet pda2re m = re2model (pda2re m#representation)\r\n\tlet cfg2re m = re2model (cfg2re m#representation)\r\n\r\n\tlet fa2pda m = pda2model (fa2pda m#representation)\r\n\tlet re2pda m = pda2model (re2pda m#representation)\r\n\tlet cfg2pda m = pda2model (cfg2pda m#representation)\r\n\r\n\tlet fa2cfg m = cfg2model (fa2cfg m#representation)\r\n\tlet re2cfg m = cfg2model (re2cfg m#representation)\r\n\tlet re2gr m = gr2model (re2gr m#representation) (*PEDRO CARLOS *)\r\n\tlet pda2cfg m = cfg2model (pda2cfg m#representation)\r\n\t\r\n\tlet fa2tm m = tm2model (fa2tm m#representation)\r\n\tlet re2tm m = tm2model (re2tm m#representation)\r\n\r\n\tlet cfg2tm m = tm2model (cfg2tm m#representation)\r\n\tlet cfg2tm_2tapes m = tm2model (cfg2tm_2tapes m#representation) (*PEDRO CARLOS *)\r\n\r\n\t(********************************************************************)\r\n\t(*PEDRO CARLOS *)\r\n\t(********************************************************************)\r\n\tlet pda2tm m = tm2model (pda2tm m#representation)\r\n\tlet pda2tm_2tapes m = tm2model (pda2tm_2tapes m#representation)\r\n\r\n\tlet fa2gr m = gr2model (fa2gr m#representation)\r\n\t(********************************************************************)\r\n\t(*PEDRO CARLOS *)\r\n\t(********************************************************************)\t\r\n\r\n\tlet gr2pda m = pda2model (gr2pda m#representation)\r\n\t(* let pda2tmMulti m = tmMulti2model (pda2tm m#representation)\t *)\r\n\r\n\tlet gr2cfg m = cfg2model (gr2cfg m#representation)\r\n\tlet gr2tm m = tm2model (gr2tm m#representation) \r\n\tlet tm2gr m = gr2model (tm2gr m#representation)\r\n\tlet cfg2gr m = gr2model (cfg2gr m#representation)\r\n\r\n\t(********************************************************************)\r\n\t(*PEDRO CARLOS *)\r\n\t(********************************************************************)\r\nend\r\n\r\nmodule PolyCheckExamples: sig end =\r\nstruct\r\n\topen Examples\r\n\topen PolyModel\r\n\r\n\tlet checkExamples = (* run immediately *)\r\n\t\tList.iter\r\n\t\t\t(fun name -> ignore (text2model (example name))) examples\r\nend\r\n\r\n(********************************************************************)\r\nmodule PolyBasicTests: sig end = (*PEDRO CARLOS VER!!! *)\r\nstruct\r\n\topen PolyBasic\r\n\r\n\tlet active = false\r\n\r\n\tlet cfg_g = {| \t\t{\r\n\t\tkind : \"grammar\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"cfg_simple\",\r\n\t\talphabet : [\"0\", \"1\"],\r\n\t\tvariables : [\"S\", \"P\"],\r\n\t\tinitial : \"S\",\r\n\t\trules : [\t\r\n\t\t\"S -> 1S0\",\r\n\t\t\"S -> P\",\r\n\t\t\"P -> 0P1\", \"P -> ~\" ]\r\n\t\t}|}\r\n\r\n\r\n\tlet cfg = {| \t\t{\r\n\t\tkind : \"context free grammar\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"cfg_simple\",\r\n\t\talphabet : [\"0\", \"1\"],\r\n\t\tvariables : [\"S\", \"P\"],\r\n\t\tinitial : \"S\",\r\n\t\trules : [\t\r\n\t\t\"S -> 1S0\",\r\n\t\t\"S -> P\",\r\n\t\t\"P -> 0P1\", \"P -> ~\" ]\r\n\t}|}\r\n\r\n\tlet cfg2 = {| \t\t{\r\n\t\tkind : \"context free grammar\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"cfg_simple\",\r\n\t\talphabet : [\"a\", \"b\"],\r\n\t\tvariables : [\"S\"],\r\n\t\tinitial : \"S\",\r\n\t\trules : [\t\r\n\t\t\"S -> aSb\",\r\n\t\t\"S -> ab\" ]\r\n\t}|}\r\n (*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ *)\r\n\tlet pda_AABB = {| {\r\n\t\tkind: \"pushdown automaton\",\r\n\t\tdescription: \"this is an example\",\r\n\t\tname: \"pda_AABB\",\r\n\t\tinputAlphabet: [\"a\", \"b\"],\r\n\t\tstackAlphabet: [\"a\", \"z\"],\r\n\t\tstates: [\"S1\", \"S2\", \"S3\"],\r\n\t\tinitialState: \"S1\",\r\n\t\tinitialStackSymbol: \"z\",\r\n\t\ttransitions: [\r\n\t\t\t[\"S1\", \"z\", \"a\", \"S1\", \"az\"],   \r\n\t\t\t[\"S1\", \"a\", \"a\", \"S1\", \"aa\"],   \r\n\t\t\t[\"S1\", \"a\", \"b\", \"S2\", \"\"],           \r\n\t\t\t[\"S2\", \"a\", \"b\", \"S2\", \"\"],          \r\n\t\t\t[\"S2\", \"z\", \"~\", \"S3\", \"\"]\r\n\t\t],\r\n\t\tacceptStates: [\"S3\"],\r\n\t\tcriteria: \"true\"\r\n\t} |}\r\n\r\n\r\n\tlet pda_AABB2 = {| {\r\n\t\tkind: \"pushdown automaton\",\r\n\t\tdescription: \"this is an example\",\r\n\t\tname: \"pda_AABB\",\r\n\t\tinputAlphabet: [\"a\", \"b\"],\r\n\t\tstackAlphabet: [\"a\", \"S\", \"b\"],\r\n\t\tstates: [\"q\"],\r\n\t\tinitialState: \"q\",\r\n\t\tinitialStackSymbol: \"z\",\r\n\t\ttransitions: [\r\n\t\t\t[\"q\", \"S\", \"~\", \"q\", \"bSa\"],   \r\n\t\t\t[\"q\", \"S\", \"~\", \"q\", \"ab\"],   \r\n\t\t\t[\"q\", \"a\", \"a\", \"q\", \"\"],           \r\n\t\t\t[\"q\", \"b\", \"b\", \"q\", \"\"],          \r\n\t\t],\r\n\t\tacceptStates: [\"S3\"],\r\n\t\tcriteria: \"true\"\r\n\t} |}\r\n\r\n\r\n\r\n\r\nlet tm_astar3 = {| {\r\n\tkind: \"turing machine\",\r\n\tdescription: \"Accepts words of the form a^nb^n (equal number of a's followed by b's)\",\r\n\tname: \"tm_astar3\",\r\n\tentryAlphabet: [\"a\", \"b\"],\r\n\ttapeAlphabet: [\"a\", \"b\", \"z\", \"B\"],\r\n\tempty: \"B\",\r\n\tstates: [\"S1\",\"S1_push1\",\"S1_push2\", \"S2\", \"S3\"],\r\n\tinitialState: \"S1\",\r\n\ttransitions: [\r\n    [\"S1\", \"z\", \"S1_push1\", \"z\", \"R\"],\r\n    [\"S1_push1\", \"B\", \"S1\", \"a\", \"L\"],\r\n    [\"S1\", \"a\", \"S1_push2\", \"a\", \"R\"],\r\n    [\"S1_push2\", \"B\", \"S1\", \"a\", \"L\"],\r\n    [\"S1\", \"b\", \"S2\", \"B\", \"L\"],\r\n    [\"S2\", \"b\", \"S2\", \"B\", \"L\"],\r\n    [\"S2\", \"z\", \"S3\", \"B\", \"L\"],\r\n\t\t[\"S1\", \"a\", \"S1\", \"z\", \"R\"],\r\n\t\t[\"S1\", \"a\", \"S1\", \"a\", \"R\"]\r\n],\r\n\tacceptStates: [\"S3\"],\r\n\tcriteria: \"true\",\r\n\tmarkers: []\r\n} |} \r\n (*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ *)\r\n\tlet fa_toRe = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"fa_toRe\",\r\n\t\talphabet : [\"a\",\"b\"],\r\n\t\tstates : [\"1\", \"2\"],\r\n\t\tinitialState : \"1\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"1\",\"a\",\"2\"],[\"2\",\"b\",\"2\"]\r\n\t\t\t],\r\n\t\tacceptStates : [\"2\"]\r\n\t} |}\r\n\r\n\tlet csg = {| {\r\n\t\tkind: \"grammar\",\r\n\t\tdescription: \"a^nb^nc^n\",\r\n\t\tname: \"custom_csg\",\r\n\t\talphabet: [\"a\", \"b\", \"c\"],\r\n\t\tvariables: [\"S\", \"B\", \"C\", \"Z\", \"W\"],\r\n\t\tinitial: \"S\",\r\n\t\trules: [\r\n\t\t\"S -> aBC\",\r\n\t\t\"S -> aSBC\",\r\n\t\t\"CB -> CZ\",\r\n\t\t\"CZ -> WZ\",\r\n\t\t\"WZ -> WC\",\r\n\t\t\"WC -> BC\",\r\n\t\t\"aB -> ab\",\r\n\t\t\"bB -> bb\",\r\n\t\t\"bC -> bc\",\r\n\t\t\"cC -> cc\"]\r\n\t} |}\r\n\r\n\t (*\r\n\t Terceiro exemplo dos slides do stor - Aceita a palavra (a + b)*aa(a + b)*\r\n\t Este exemplo e:\r\n\t\t - determinista\r\n\t\t - nao entra em loop de configuracao\r\n\t\t - nao corre infinitamente sem repetir configuracao\r\n\t\t - nao tem estados useless\r\n\t\t - termina por estados de aceitacao\r\n *)\r\n let tm_astar3 = {| {\r\n\t\t kind: \"turing machine\",\r\n\t\t description: \"this is an example changed\",\r\n\t\t name: \"tm_astar3\",\r\n\t\t entryAlphabet: [\"a\", \"b\"],\r\n\t\t tapeAlphabet: [\"a\", \"b\",\"B\"],\r\n\t\t empty: \"B\",\r\n\t\t states: [\"q1\", \"q2\", \"q3\"],\r\n\t\t initialState: \"q1\",\r\n\t\t transitions: [\r\n\t\t\t [\"q1\", \"a\", \"q2\", \"a\", \"R\"],\r\n\t\t\t [\"q1\", \"b\", \"q1\", \"b\", \"R\"],\r\n\t\t\t [\"q2\", \"a\", \"q3\", \"a\", \"R\"],\r\n\t\t\t [\"q2\", \"b\", \"q1\", \"b\", \"R\"]\r\n\t\t ],\r\n\t\t acceptStates: [\"q3\"],\r\n\t\t criteria: \"true\",\r\n\t\t markers: []\r\n\t\t } |}\r\n\r\n\r\n\t\t let tm_astar4 = {| {\r\n\t\t\tkind: \"turing machine\",\r\n\t\t\tdescription: \"Turing machine for language a^n b^n c^n\",\r\n\t\t\tname: \"tm_astar4\",\r\n\t\t\tentryAlphabet: [\"a\", \"b\", \"c\"],\r\n\t\t\ttapeAlphabet: [\"a\", \"b\", \"c\", \"X\", \"Y\", \"Z\", \"B\"],\r\n\t\t\tempty: \"B\",\r\n\t\t\tstates: [\"q0\",\"q1\", \"q2\", \"q3\", \"q4\", \"qf\"],\r\n\t\t\tinitialState: \"q0\",\r\n\t\t\ttransitions: [\r\n\t\t\t\t[\"q0\", \"a\", \"q1\", \"X\", \"R\"],\r\n\t\t\t\t[\"q0\", \"Y\", \"q4\", \"Y\", \"R\"],\r\n\t\t\r\n\t\t\t\t[\"q1\", \"a\", \"q1\", \"a\", \"R\"],\r\n\t\t\t\t[\"q1\", \"Y\", \"q1\", \"Y\", \"R\"],\r\n\t\t\t\t[\"q1\", \"b\", \"q2\", \"Y\", \"R\"],\r\n\t\t\r\n\t\t\t\t[\"q2\", \"b\", \"q2\", \"b\", \"R\"],\r\n\t\t\t\t[\"q2\", \"Z\", \"q2\", \"Z\", \"R\"],\r\n\t\t\t\t[\"q2\", \"c\", \"q3\", \"Z\", \"L\"],\r\n\t\t\r\n\t\t\t\t[\"q3\", \"a\", \"q3\", \"a\", \"L\"],\r\n\t\t\t\t[\"q3\", \"Y\", \"q3\", \"Y\", \"L\"],\r\n\t\t\t\t[\"q3\", \"b\", \"q3\", \"b\", \"L\"],\r\n\t\t\t\t[\"q3\", \"Z\", \"q3\", \"Z\", \"L\"],\r\n\t\t\t\t[\"q3\", \"X\", \"q0\", \"X\", \"R\"],\r\n\t\t\r\n\t\t\t\t[\"q4\", \"Y\", \"q4\", \"Y\", \"R\"],\r\n\t\t\t\t[\"q4\", \"Z\", \"q4\", \"Z\", \"R\"],\r\n\t\t\t\t[\"q4\", \"B\", \"qf\", \"B\", \"L\"]\r\n\t\t\t],\r\n\t\t\tacceptStates: [\"qf\"],\r\n\t\t\tcriteria: \"true\",\r\n\t\t\tmarkers: []\r\n\t\t} |}\r\n\r\n\tlet clean = {| {\r\n\t\tkind : \"context free grammar\", \r\n\t\tdescription : \"Clean example from https://www.cs.scranton.edu/~mccloske/courses/cmps260/cfg_remove_useless.html\",\r\n\t\tname : \"Clean1\",\r\n\t\talphabet : [\"a\", \"b\", \"c\", \"d\"],\r\n\t\tvariables : [\"S\", \"A\", \"B\", \"C\", \"D\"],\r\n\t\tinitial : \"S\",\r\n\t\trules : [\"S -> aSa | bB | bAA\", \"A -> a | SbA | aB\", \"B -> AB | CaB\", \"C -> cC | Sa | bD\", \"D -> dD | ~\"]\r\n\t} |}\r\n\r\n\tlet cleang = {| {\r\n\t\tkind : \"grammar\", \r\n\t\tdescription : \"Clean example from https://www.cs.scranton.edu/~mccloske/courses/cmps260/cfg_remove_useless.html\",\r\n\t\tname : \"Clean1\",\r\n\t\talphabet : [\"a\", \"b\", \"c\", \"d\"],\r\n\t\tvariables : [\"S\", \"A\", \"B\", \"C\", \"D\"],\r\n\t\tinitial : \"S\",\r\n\t\trules : [\"S -> aSa | bB | bAA\", \"A -> a | SbA | aB\", \"B -> AB | CaB\", \"C -> cC | Sa | bD\", \"D -> dD | ~\"]\r\n\t} |}\r\n\r\n\r\n\tlet pda_WW_1 = {| {\r\n\t\tkind: \"pushdown automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"pda_WW-1\",\r\n\t\tinputAlphabet : [\"a\",\"b\"],\r\n\t\tstackAlphabet: [\"z\",\"a\",\"b\"],\r\n\t\tstates : [\"S1\",\"S2\",\"S3\",\"S4\"],\r\n\t\tinitialState : \"S1\",\r\n\t\tinitialStackSymbol: \"z\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"S1\",\"z\",\"a\",\"S2\",\"az\"], \r\n\t\t\t\t[\"S1\",\"z\",\"b\",\"S2\",\"bz\"],\r\n\t\t\t\t[\"S2\",\"a\",\"a\",\"S2\",\"aa\"],\r\n\t\t\t\t[\"S2\",\"a\",\"a\",\"S3\",\"\"],\r\n\t\t\t\t[\"S2\",\"a\",\"b\",\"S2\",\"ba\"],\r\n\t\t\t\t[\"S2\",\"b\",\"a\",\"S2\",\"ab\"],\r\n\t\t\t\t[\"S2\",\"b\",\"b\",\"S2\",\"bb\"],\r\n\t\t\t\t[\"S2\",\"b\",\"b\",\"S3\",\"\"],\r\n\t\t\t\t[\"S3\",\"a\",\"a\",\"S3\",\"\"],\r\n\t\t\t\t[\"S3\",\"b\",\"b\",\"S3\",\"\"],\r\n\t\t\t\t[\"S3\",\"z\",\"~\",\"S4\",\"z\"]\r\n\t\t\t],\r\n\t\tacceptStates : [\"S1\",\"S4\"],\r\n\t\tcriteria: \"true\"\r\n\t} |}\r\n\r\n\t(* == Finite Automaton (FA) Tests == *)\r\n\t\r\n\tlet testSimplify () = (* FA -> RE simplify *)\r\n\t\tlet fa = FiniteAutomaton.make (Arg.Text fa_toRe) in\r\n\t\tlet re = fa2re fa in\r\n\t\t\tRegularExpression.show re;\r\n\t\t\tlet rs =  RegularExpression.simplify re in\r\n\t\t\t\tRegularExpression.show rs\r\n\r\n\tlet testFAToRe () = (* FA -> RE *)\r\n\t\tlet fa = FiniteAutomaton.make (Arg.Text fa_toRe) in\r\n\t\tlet re = fa2re fa in\r\n\t\t\tRegularExpression.show re\r\n\r\n\t(* == Regular Expression (RE) Tests == *)\r\n\t\r\n\tlet testREToFA () = (* RE -> FA *)\r\n\t\tlet re = RegularExpression.make (Arg.Predef \"re_abc\") in\r\n\t\tlet fa = re2fa re in\r\n\t\t\tJSon.show (FiniteAutomaton.toJSon fa)\r\n\r\n\tlet testREToFA2 () = (* RE -> FA *)\r\n\t\tlet re = RegularExpression.make (Arg.Predef \"re_simple\") in\r\n\t\tlet fa = re2fa re in\r\n\t\t\tJSon.show (FiniteAutomaton.toJSon fa)\r\n\r\n\tlet testREToFA3 () = (* RE -> FA *)\r\n\t\tlet re = RegularExpression.make (Arg.Predef \"re_complex\") in\r\n\t\tlet fa = re2fa re in\r\n\t\t\tJSon.show (FiniteAutomaton.toJSon fa)\r\n\r\n\tlet testREToFA4 () = (* RE -> FA *)\r\n\t\tlet re = RegularExpression.make (Arg.Predef \"re_convoluted\") in\r\n\t\tlet fa = re2fa re in\r\n\t\t\tJSon.show (FiniteAutomaton.toJSon fa)\r\n\r\n\tlet testREToCFG () = (* RE -> CFG *)\r\n\t\tlet re = RegularExpression.make (Arg.Predef \"re_simple\") in\r\n\t\tlet cfg = re2cfg re in\r\n\t\t\tContextFreeGrammarBasic.show cfg\r\n\r\n\t(* == Context-Free Grammar (CFG) Tests == *)\r\n\t\r\n\tlet testCFGToFA () = (* CFG -> FA *)\r\n\t\tlet cfg = ContextFreeGrammarBasic.make (Arg.Predef \"cfg_abc\") in\r\n\t\tlet fa = cfg2fa cfg in\r\n\t\t\tFiniteAutomaton.show fa\r\n\r\n\tlet testCFGToRe () = (* CFG -> RE *)\r\n\t\tlet cfg = ContextFreeGrammarBasic.make (Arg.Predef \"cfg_abc\") in\r\n\t\tlet re = cfg2re cfg in\r\n\t\t\tRegularExpression.show re\r\n\r\n\t(* == Grammar (GR) / CFG Inter-conversion Tests == *)\r\n\t\r\n\tlet testGrToCfg () = (* GR -> CFG *)\r\n\t\tlet g_cfg = Grammar.make (Arg.Text cfg) in\r\n\t\tlet cfg_res = gr2cfg g_cfg in (*two must be equal*)\r\n\t\t\tContextFreeGrammarBasic.show cfg_res;\r\n\t\t\tGrammar.show g_cfg;\r\n\t\tprint_endline \"-------------------\";\r\n\t\tlet g_csg = Grammar.make (Arg.Text csg) in\r\n\t\tlet cfgFromCsg = gr2cfg g_csg in (*FAIL show returns two different grammars, supposed to fail*)\r\n\t\t\tContextFreeGrammarBasic.show cfgFromCsg;\r\n\t\t\tGrammar.show g_csg\r\n\r\n\tlet testCFGToGR () = (* CFG -> GR *)\r\n\t\tlet g_cfg = ContextFreeGrammarBasic.make (Arg.Text clean) in\r\n\t\tlet gr_res = cfg2gr g_cfg in (*two must be equal*)\r\n\t\tGrammar.show gr_res;\r\n\t\tContextFreeGrammarBasic.show g_cfg\r\n\r\n\tlet testCleanCfgToGr () = (* CFG -> GR (with cleaning) *)\r\n\t\tlet cfg = ContextFreeGrammarBasic.make (Arg.Text clean) in\r\n\t\tlet g_cfg = Grammar.make (Arg.Text cleang) in\r\n\t\tlet cleanedCFG = ContextFreeGrammarLL1.clean cfg in\r\n\t\tList.iter (fun t -> ignore (ContextFreeGrammarLL1.transformationToString t)) cleanedCFG;\r\n\t\tlet cleanedGCFG = Grammar.clean g_cfg in\r\n\t\tGrammar.show cleanedGCFG\r\n\r\n\t(* == Pushdown Automaton (PDA) / CFG/GR Inter-conversion Tests == *)\r\n\t\r\n\tlet testPDA2CFG () = (* PDA -> CFG -> GR -> Clean GR *)\r\n\t\tprint_endline \"testPDA2CFG\";\r\n\t\tlet pda = PushdownAutomaton.make (Arg.Text pda_AABB) in\r\n\t\tprint_endline \"Original PDA\";\r\n\t\tPushdownAutomaton.show pda;\r\n\t\tprint_endline \"\";\r\n\t\tlet cfg = pda2cfg pda in\r\n\t\tprint_endline \"Converted CFG\";\r\n\t\tContextFreeGrammarBasic.show cfg;\r\n\t\tprint_endline \"\"; \r\n\t\tlet g_cfg = cfg2gr cfg in (*Convert to grammar to test with clean*)\r\n\t\tprint_endline \"Converted CFG Grammar\";\r\n\t\tGrammar.show g_cfg;\r\n\t\tprint_endline \"\"; \r\n\t\tlet cleaned_g_cfg = Grammar.clean g_cfg in\r\n\t\tprint_endline \"Cleaned gr converted\";\r\n\t\tGrammar.show cleaned_g_cfg;\r\n\t\tassert (Grammar.accept cleaned_g_cfg (word \"ab\"));\r\n\t\tassert (Grammar.accept cleaned_g_cfg (word \"aabb\"));\r\n\t\tassert (Grammar.accept cleaned_g_cfg (word \"aaabbb\"));\r\n\t\tprint_endline \"testPDA2CFG done\"\r\n\r\n\tlet testGRToPDA () = (* GR -> CFG -> PDA *)\r\n\t\tlet gr_cfg = Grammar.make (Arg.Text cfg_g) in\r\n\t\tlet cfg_cfg = ContextFreeGrammarBasic.make (Arg.Text cfg) in\r\n\t\t(*Grammars*)\r\n\t\tlet cfg_converted = gr2cfg gr_cfg in\r\n\t\tprint_endline \"Converted CFG\";\r\n\t\tContextFreeGrammarBasic.show cfg_converted;\r\n\t\tprint_endline \"Original CFG\";\r\n\t\tContextFreeGrammarBasic.show cfg_cfg;\r\n\t\t(*PDAs*)\r\n\t\tlet pda_gr = cfg2pda cfg_converted in\r\n\t\tlet pda_cfg = cfg2pda cfg_cfg in\r\n\t\tprint_endline \"PDA_CFG\";\r\n\t\tPushdownAutomaton.show pda_cfg;\r\n\t\tprint_endline \"PDA\";\r\n\t\tPushdownAutomaton.show pda_gr;\r\n\t\tlet wordsToAccept = [\"\"; \"01\"; \"10\"; \"0011\"; \"1010\"; \"1100\"; \"000111\"; \"100110\"; \"110100\"; \"111000\"] in\r\n\t\tList.iter (fun w ->\r\n\t\t\t\tlet result = PushdownAutomaton.accept pda_gr (word w) in\r\n\t\t\t\tPrintf.printf \"Word %s accepted: %b\\\\n\" w result\r\n\t\t) wordsToAccept\r\n\r\n\t(* == Pushdown Automaton (PDA) / Turing Machine (TM) Tests == *)\r\n\t\r\n\tlet testPDA2TM () = (* PDA -> TM (1 tape) *)\r\n\t\tlet pda = PushdownAutomaton.make (Arg.Text pda_AABB) in  \r\n\t\tlet pda2 = PushdownAutomaton.make (Arg.Text pda_WW_1) in \r\n\r\n\t\tprint_endline \"Original PDA 1 (AABB)\";\r\n\t\t(* PushdownAutomaton.show pda; *)\r\n\t\tlet wordsToAccept1 = [\"\";\"a\"; \"b\"; \"aab\"; \"abb\"; \"aaaaaaabbbb\"; \"bbbbbaaaaa\"  ; \"aa\" ;\"aaaa\"; \"ab\"; \"aaaaabbbbb\"; \"aabb\"] in\r\n\t\tList.iter (fun w ->\r\n\t\t\t\tlet result = PushdownAutomaton.accept pda (word w) in\r\n\t\t\t\tPrintf.printf \"Word '%s' accepted by PDA1: %b\\\\n\" w result\r\n\t\t) wordsToAccept1; \r\n\t\t\r\n\t\tlet tm = pda2tm pda in\r\n\t\tTuringMachinePrivate.validate \"pda2tm\" tm;\r\n\t\tprint_endline \"Converted TM 1\";\r\n(* \t\tTuringMachine.show tm;\r\n *)\t\tList.iter (fun w ->\r\n\t\t\t\tlet result = TuringMachine.accept tm (word w) in\r\n\t\t\t\tPrintf.printf \"Word '%s' accepted by TM1: %b\\\\n\" w result\r\n\t\t) wordsToAccept1;  \r\n\t\tprint_endline \"\";\r\n\t\t\r\n\t\tprint_endline \"Original PDA 2 (WW_1)\";\r\n\t\t(* PushdownAutomaton.show pda2; *)\r\n\t\tlet wordsToAccept2 = [\"\"; \"a\"; \"b\"; \"aa\"; \"bb\"; \"aba\"; \"bab\"; \"abba\"; \"baab\"] in\r\n\t\tList.iter (fun w ->\r\n\t\t\t\tlet result = PushdownAutomaton.accept pda2 (word w) in\r\n\t\t\t\tPrintf.printf \"Word '%s' accepted by PDA2: %b\\\\n\" w result\r\n\t\t) wordsToAccept2; \r\n\t\tprint_endline \"\";\r\n\t\t\r\n\t\tlet tm2 = pda2tm pda2 in\r\n\t\tprint_endline \"Converted TM 2\";\r\n\t\t(* TuringMachine.show tm2;  *)\r\n\t\tList.iter (fun w ->\r\n\t\t\t\tlet result = TuringMachine.accept tm2 (word w) in\r\n\t\t\t\tPrintf.printf \"Word '%s' accepted by TM2: %b\\\\n\" w result\r\n\t\t) wordsToAccept2; \r\n\t\tprint_endline \"\"\r\n\r\n\tlet testPDA2TM_MULTI () = (* PDA -> TM (2 tapes) *)\r\n\t\tlet pda = PushdownAutomaton.make (Arg.Text pda_AABB) in  \r\n\t\tlet pda2 = PushdownAutomaton.make (Arg.Text pda_WW_1) in \r\n\t\tprint_endline \"Original PDA 1 (AABB)\";\r\n\t\tPushdownAutomaton.show pda;\r\n\t\tprint_endline \"\";\r\n\t\tlet wordsToAccept1 = [\"aabb\"; \"ab\"; \"a\"; \"b\"] in\r\n\t\tList.iter (fun w ->\r\n\t\t\t\tlet result = PushdownAutomaton.accept pda (word w) in\r\n\t\t\t\tPrintf.printf \"Word '%s' accepted by PDA1: %b\\\\n\" w result\r\n\t\t) wordsToAccept1; \r\n\t\t\r\n\t\tlet tm = pda2tm_2tapes pda in\r\n\t\tprint_endline \"Converted TM 1 (2 tapes)\";\r\n\t\tTuringMachine.show tm;\r\n\t\tprint_endline \"\";\r\n\t\tlet wordsToAccept1_tm = [\"aabb\"; \"ab\"; \"b\"; \"aaabbb\"; \"abbb\"] in\r\n\t\tList.iter (fun w ->\r\n\t\t\t\tlet result = TuringMachine.accept tm (word w) in\r\n\t\t\t\tPrintf.printf \"Word '%s' accepted by TM1: %b\\\\n\" w result\r\n\t\t) wordsToAccept1_tm; \r\n\t\tprint_endline \"\";\r\n\t\t\r\n\t\tprint_endline \"Original PDA 2 (WW_1)\";\r\n\t\tPushdownAutomaton.show pda2;\r\n\t\tprint_endline \"\";\r\n\t\tlet wordsToAccept2 = [\"\"; \"aa\"; \"bb\"; \"abba\"; \"aabb\"; \"aba\"; \"b\"; \"aaabbb\"] in\r\n\t\tList.iter (fun w ->\r\n\t\t\t\tlet result = PushdownAutomaton.accept pda2 (word w) in\r\n\t\t\t\tPrintf.printf \"Word '%s' accepted by PDA2: %b\\\\n\" w result\r\n\t\t) wordsToAccept2; \r\n\t\tprint_endline \"\";\r\n\t\t\r\n\t\tlet tm2 = pda2tm_2tapes pda2 in\r\n\t\tprint_endline \"Converted TM 2 (2 tapes)\";\r\n\t\tTuringMachine.show tm2;\r\n\t\tList.iter (fun w ->\r\n\t\t\t\tlet result = TuringMachine.accept tm2 (word w) in\r\n\t\t\t\tPrintf.printf \"Word '%s' accepted by TM2: %b\\\\n\" w result\r\n\t\t) wordsToAccept2; \r\n\t\tprint_endline \"\"\r\n\r\n\tlet testCFGToTM () = (* CFG -> PDA -> TM (1 tape) *)\r\n\t\tlet g_cfg = ContextFreeGrammarBasic.make(Arg.Text cfg2) in\r\n\t\tprint_endline \"CFG (ab)\";\r\n\t\tContextFreeGrammarBasic.show g_cfg;\r\n\t\tlet pda = cfg2pda g_cfg in \r\n\t\tprint_endline \"Intermediate PDA\";\r\n\t\tPushdownAutomaton.show pda;\r\n\t\tlet wordsToAccept = [\"a\"; \"b\"; \"aab\"; \"abb\"; \"aaaaaaabbbb\"; \"bbbbbaaaaa\"  ; \"aa\" ;\"aaaa\"; \"ab\"; \"aaaaabbbbb\"; \"aabb\"] in\r\n\t\tList.iter (fun w ->\r\n\t\t\t\tlet result = PushdownAutomaton.accept pda (word w) in\r\n\t\t\t\tPrintf.printf \"Word '%s' accepted by PDA: %b\\\\n\" w result\r\n\t\t) wordsToAccept;\r\n\t\t\r\n\t\tlet tm = pda2tm pda in\r\n\t\tprint_endline \"Converted TM (1 tape)\";\r\n\t\tTuringMachine.show tm;\r\n\t\tList.iter (fun w ->\r\n\t\t\tlet result = TuringMachine.accept tm (word w) in\r\n\t\t\tPrintf.printf \"Word '%s' accepted by TM: %b\\\\n\" w result\r\n\t\t) wordsToAccept\r\n\r\n\tlet testCFGToTM_MULTI () = (* CFG -> PDA -> TM (2 tapes) *)\r\n\t\tlet g_cfg = ContextFreeGrammarBasic.make(Arg.Text cfg2) in\r\n\t\tprint_endline \"CFG (ab)\";\r\n\t\tContextFreeGrammarBasic.show g_cfg;\r\n\t\tlet pda = cfg2pda g_cfg in \r\n\t\tprint_endline \"Intermediate PDA\";\r\n\t\tPushdownAutomaton.show pda; \r\n\t\tlet wordsToAccept = [\"a\"; \"b\"; \"aab\"; \"abb\"; \"aaaaaaabbbb\"; \"bbbbbaaaaa\"  ; \"aa\" ;\"aaaa\"; \"ab\"; \"aaaaabbbbb\"; \"aabb\"] in\r\n\t\tList.iter (fun w ->\r\n\t\t\t\tlet result = PushdownAutomaton.accept pda (word w) in\r\n\t\t\t\tPrintf.printf \"Word '%s' accepted by PDA: %b\\\\n\" w result\r\n\t\t) wordsToAccept;\r\n\t\t\r\n\t\tlet tm = pda2tm_2tapes pda in\r\n\t\tprint_endline \"Converted TM (2 tapes)\";\r\n\t\tTuringMachine.show tm;\r\n\t\tList.iter (fun w ->\r\n\t\t\t\tlet result = TuringMachine.accept tm (word w) in\r\n\t\t\t\tPrintf.printf \"Word '%s' accepted by TM: %b\\\\n\" w result\r\n\t\t) wordsToAccept\r\n\r\n\t(* == Turing Machine (TM) / Grammar (GR) Tests == *)\r\n\t\r\n\t(* \r\n\tlet testGrToTM () =\r\n\t\tlet g_cfg = Grammar.make (Arg.Text cfg_g) in\r\n\t\tlet tm = gr2tm g_cfg in\r\n\t\tTuringMachine.show tm;\r\n\t\tlet wordsToAccept = [\"\"; \"01\"; \"10\"; \"0011\"; \"1010\"; \"1100\"; \"000111\"; \"100110\"; \"110100\"; \"111000\"] in\r\n\t\tList.iter (fun w ->\r\n\t\t\t\tlet result = TuringMachine.accept tm (word w) in\r\n\t\t\t\tPrintf.printf \"Word %s accepted: %b\\\\n\" w result\r\n\t\t) wordsToAccept\r\n\t*)\r\n\t\r\n\t(* let testTmToGr () =\r\n\t\tlet tm = TuringMachine.make (Arg.Text tm_astar4) in\r\n\t\tlet wordsToAccept = [\"abc\"; \"aabbcc\"] in\r\n\t\tList.iter (fun w ->\r\n\t\t\t\tlet result = TuringMachine.accept tm (word w) in\r\n\t\t\t\tPrintf.printf \"Word %s accepted by tm: %b\\\\n\" w result\r\n\t\t) wordsToAccept;\r\n\t\tlet gr = tm2gr tm in\r\n\t\tGrammar.show gr; \r\n\t\tprint_endline \"\";\r\n\t\tlet cleaned_gr = Grammar.clean gr in\r\n\t\tprint_endline \"Cleaned Grammar\";\r\n\t\tGrammar.show cleaned_gr; \r\n\t\tlet wordsToAccept = [\"abc\"] in\r\n\t\tList.iter (fun w ->\r\n\t\t\t\tlet result = Grammar.accept gr (str2word w) in\r\n\t\t\t\tPrintf.printf \"Word %s accepted: %b\\\\n\" w result\r\n\t\t) wordsToAccept  *)\r\n\r\n\r\n\t(* == Test Runner == *)\r\n\t\r\n\tlet runAll =\r\n\t\tif Util.testing active \"PolyModel\" then begin\r\n\t\t\t(* FA Tests *)\r\n(* \t\t\tUtil.sep(); testSimplify ();\r\n\t\t\tUtil.sep(); testFAToRe ();\r\n\t\t\t(* RE Tests *)\r\n\t\t\tUtil.sep(); testREToFA ();\r\n\t\t\tUtil.sep(); testREToFA2 ();\r\n\t\t\tUtil.sep(); testREToFA3 ();\r\n\t\t\tUtil.sep(); testREToFA4 ();\r\n\t\t\tUtil.sep(); testREToCFG ();\r\n\t\t\t(* CFG Tests *)\r\n\t\t\tUtil.sep(); testCFGToFA ();\r\n\t\t\tUtil.sep(); testCFGToRe ();\r\n\t\t\t(* GR/CFG Tests *)\r\n\t\t\tUtil.sep (); testGrToCfg (); \r\n\t\t\tUtil.sep (); testCFGToGR ();\r\n\t\t\tUtil.sep (); testCleanCfgToGr (); *)\r\n\t\t\t(* PDA/CFG/GR Tests *)\r\n(* \t\t\tUtil.sep (); testPDA2CFG ();  *)\r\n(* \t\t\tUtil.sep (); testGRToPDA ();   *)\r\n\t\t\t(* PDA/TM Tests *)\r\n\t\tUtil.sep (); testPDA2TM (); \r\n(* \t\t\tUtil.sep (); testPDA2TM_MULTI (); \r\n\t\t\tUtil.sep (); testCFGToTM (); \r\n\t\t\tUtil.sep (); testCFGToTM_MULTI ();  *)\r\n\t\t\t(* TM/GR Tests (Commented out) *)\r\n\t\t\t(* Util.sep (); testGrToTM (); *)    \r\n\t\t\t(* Util.sep (); testTmToGr (); *)    \r\n\t\tend\r\nend\r\n\r\n(* OLD original, mudado pelo Pedro Carlos VER!!!\r\n(********************************************************************)\r\nmodule PolyBasicTests: sig end =\r\nstruct\r\n\topen PolyBasic\r\n\r\n\tlet active = false\r\n\r\n\tlet testToFA () =\r\n\t\tlet re = RegularExpression.make (Arg.Predef \"re_abc\") in\r\n\t\tlet fa = re2fa re in\r\n\t\t\tJSon.show (FiniteAutomaton.toJSon fa)\r\n\r\n\tlet testToFA2 () =\r\n\t\tlet re = RegularExpression.make (Arg.Predef \"re_simple\") in\r\n\t\tlet fa = re2fa re in\r\n\t\t\tJSon.show (FiniteAutomaton.toJSon fa)\r\n\r\n\tlet testToFA3 () =\r\n\t\tlet re = RegularExpression.make (Arg.Predef \"re_complex\") in\r\n\t\tlet fa = re2fa re in\r\n\t\t\tJSon.show (FiniteAutomaton.toJSon fa)\r\n\r\n\tlet testToFA4 () =\r\n\t\tlet re = RegularExpression.make (Arg.Predef \"re_convoluted\") in\r\n\t\tlet fa = re2fa re in\r\n\t\t\tJSon.show (FiniteAutomaton.toJSon fa)\r\n\r\n\tlet fa_toRe = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"fa_toRe\",\r\n\t\talphabet : [\"a\",\"b\"],\r\n\t\tstates : [\"1\", \"2\"],\r\n\t\tinitialState : \"1\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"1\",\"a\",\"2\"],[\"2\",\"b\",\"2\"]\r\n\t\t\t],\r\n\t\tacceptStates : [\"2\"]\r\n\t} |}\r\n\r\n\tlet testSimplify () =\r\n\t\tlet fa = FiniteAutomaton.make (Arg.Text fa_toRe) in\r\n\t\tlet re = fa2re fa in\r\n\t\t\tRegularExpression.show re;\r\n\t\t\tlet rs =  RegularExpression.simplify re in\r\n\t\t\t\tRegularExpression.show rs\r\n\r\n\tlet testToRe () =\r\n\t\tlet fa = FiniteAutomaton.make (Arg.Text fa_toRe) in\r\n\t\tlet re = fa2re fa in\r\n\t\t\tRegularExpression.show re\r\n\r\n\tlet testToGrammar () =\r\n\t\tlet re = RegularExpression.make (Arg.Predef \"re_simple\") in\r\n\t\tlet cfg = re2cfg re in\r\n\t\t\tContextFreeGrammarBasic.show cfg\r\n\r\n\tlet testToAutomaton () =\r\n\t\tlet cfg = ContextFreeGrammarBasic.make (Arg.Predef \"cfg_abc\") in\r\n\t\tlet fa = cfg2fa cfg in\r\n\t\t\tFiniteAutomaton.show fa\r\n\r\n\tlet testToRe () =\r\n\t\tlet cfg = ContextFreeGrammarBasic.make (Arg.Predef \"cfg_abc\") in\r\n\t\tlet re = cfg2re cfg in\r\n\t\t\tRegularExpression.show re\r\n\r\n\tlet runAll =\r\n\t\tif Util.testing active \"PolyModel\" then begin\r\n\t\t\ttestSimplify ()\r\n\t\tend\r\nend\r\n*)\r\n\r\n\r\n\r\n\r\n(* OLD original, mudado pelo Pedro Carlos VER!!!\r\n(********************************************************************)\r\nmodule PDA2TM =\r\nstruct\r\n\tlet generateTransitionsToPD st alphEntr alphPD: TuringMachine.transitions =\r\n\t\tlet allAlph = Set.add dollar (Set.union alphEntr alphPD) in\r\n\t\t\tSet.map (fun symb -> (st,[symb],st,[symb],[R])) allAlph \r\n\r\n\tlet generateTransitionsFromPD st alphEntr alphPD: TuringMachine.transitions =\r\n\t\tlet allAlph = Set.add dollar (Set.union alphEntr alphPD) in\r\n\t\t\tSet.map (fun symb -> (st,[symb],st,[symb],[L])) allAlph \r\n\r\n\tlet insertSymbolsPD alphEntr (pda: PushdownAutomaton.t): states * TuringMachine.transitions =\r\n\t\tlet alphPD = pda.stackAlphabet in\r\n\t\tlet st1 = state (IdGenerator.gen(\"q\")) in\r\n\t\tlet st2 = state (IdGenerator.gen(\"q\")) in\r\n\t\tlet st3 = state (IdGenerator.gen(\"q\")) in\r\n\t\tlet newSts = Set.add st1 ( Set.add st2 ( Set.add st3 Set.empty)) in\r\n\t\tlet newTrs1 = Set.union (generateTransitionsToPD st1 alphEntr alphPD) (generateTransitionsFromPD st3 alphEntr alphPD) in\r\n\t\tlet newTrs2 = Set.add (st1,[empty],st2,[symb \"$\"],[R]) (Set.add (st2,[empty],st3,[pda.initialStackSymbol],[R]) ( Set.add (st3,[empty],pda.initialState,[empty],[R])  newTrs1 )) in\r\n\t\t\t(Set.union pda.states newSts) , newTrs2\r\n\r\n\tlet rec fillStackTransition lastSt prevSt (trs: TuringMachine.transitions) wordL: TuringMachine.transitions =\r\n\t\tmatch wordL with\r\n\t\t| [] -> trs\r\n\t\t| x::y ->\tlet newState = if (Set.isEmpty (Set.make y)) then lastSt else IdGenerator.gen(\"q\") in\r\n\t\t\t\t\t\t\tlet dir = if (Set.isEmpty (Set.make y)) then L else R in\r\n\t\t\t\t\t\t\t\tfillStackTransition lastSt newState (Set.add (prevSt,[empty], newState, [x], [dir]) trs) y \r\n\r\n\tlet convertNormalTransition (tr: PushdownAutomaton.transition) alphEntr alphPD: states * TuringMachine.transitions =\r\n\t\tlet (startState,unstackedSymbol,readSymbol,nextState,writeSymbolL) = tr in\r\n\t\tlet st1 = state (IdGenerator.gen(\"q\")) in\r\n\t\tlet st2 = state (IdGenerator.gen(\"q\")) in\r\n\t\tlet st3 = state (IdGenerator.gen(\"q\")) in\r\n\t\tlet ftrs = (startState,[readSymbol],st1,[empty],[R]) in\r\n\t\tlet trsTPD = Set.add ftrs (generateTransitionsToPD st1 alphEntr alphPD) in\r\n\t\tlet trsRTOP = Set.add (st1,[empty],st2,[empty],[L]) trsTPD in\r\n\t\tlet firstDirection = if ((List.length writeSymbolL) = 1) then L else R in\r\n\t\tlet lastSt = if ((List.length writeSymbolL) = 1) then st3 else state (IdGenerator.gen(\"q\")) in\r\n\t\tlet replaceTop = Set.add (st2,[unstackedSymbol],st3, [List.hd writeSymbolL], [firstDirection]) trsRTOP in\r\n\t\tlet additionalSymbolTrs = Set.union replaceTop (fillStackTransition lastSt st3 Set.empty (List.tl writeSymbolL)) in\r\n\t\tlet trsFPD = Set.union additionalSymbolTrs (generateTransitionsFromPD lastSt alphEntr alphPD) in\r\n\t\tlet trsLast = Set.add (lastSt,[empty],nextState,[empty],[R]) trsFPD in\r\n\t\t\tSet.add lastSt (Set.add st3 (Set.add st2 (Set.add st1 Set.empty))), trsLast\r\n\r\n\tlet convertAcceptTransition (tr: PushdownAutomaton.transition) alphEntr alphPD initialStackSymb: states * TuringMachine.transitions =\r\n\t\tlet (startState,unstackedSymbol,readSymbol,nextState,writeSymbolL) = tr in\r\n\t\tlet st1 = state (IdGenerator.gen(\"q\")) in\r\n\t\tlet st2 = state (IdGenerator.gen(\"q\")) in\r\n\t\tlet st3 = state (IdGenerator.gen(\"q\")) in\r\n\t\tlet ftrs = Set.add (startState,[dollar],st1,[dollar],[R]) Set.empty in\r\n\t\tlet checkInitSS = Set.add (st1,[initialStackSymb],st2,[empty],[R]) ftrs in\r\n\t\tlet lastCheck = Set.add (st2,[empty],st3,[empty],[R]) checkInitSS in\r\n\t\t\tSet.add st3 (Set.add st2 (Set.add st1 Set.empty)), lastCheck\r\n\r\n\tlet convertTransitionX (tr: PushdownAutomaton.transition) alphEntr alphPD initialStackSymb: states * TuringMachine.transitions = \r\n\t\tlet (_,_,readSymbol,_,_) = tr in\r\n\t\t\tif readSymbol == draftVar then convertAcceptTransition tr alphEntr alphPD initialStackSymb\r\n\t\t\telse convertNormalTransition tr alphEntr alphPD\r\n\r\n\tlet rec convertTransitions newSts newTrs alphEntr (pda: PushdownAutomaton.t) (trs: PushdownAutomaton.transitions): states * TuringMachine.transitions = \r\n\t\tlet alphPD = pda.stackAlphabet in\r\n\t\tlet initialStackSymb = pda.initialStackSymbol in\r\n\t\tif (Set.size trs) = 0 then newSts, newTrs\r\n\t\telse \r\n\t\t\tlet (nSts,nTrs) = convertTransitionX (Set.hd trs) alphEntr alphPD initialStackSymb in\r\n\t\t\t\tconvertTransitions (Set.union nSts newSts) (Set.union nTrs newTrs) alphEntr pda (Set.tl trs)\r\n\r\n\t(*Se parar por pilha vazia 'e ncess'ario criar um estado final*)\r\n\tlet getFinalStates trs: states =\r\n\t\tSet.map (fun (_,_,_,d,_) -> d) (Set.filter (fun (_,_,c,_,_) -> c = dollar) trs)\r\n\r\n\tlet pda2tm (pda: PushdownAutomaton.t): TuringMachine.t =\r\n\t\tlet pdaAlphabet = Set.remove draftVar pda.inputAlphabet in\r\n\t\tlet (initialStates, initialTransitions) = insertSymbolsPD pdaAlphabet pda in\r\n\t\tlet (convertedTransitionStates,convertedTransitions) =\r\n\t\t\tconvertTransitions Set.empty Set.empty pdaAlphabet pda pda.transitions in\r\n\t\tlet allAlphabet = Set.add dollar ( Set.union pdaAlphabet pda.stackAlphabet) in\r\n\t\tlet allStates = Set.union initialStates convertedTransitionStates in\r\n\t\tlet allTransitions = Set.union initialTransitions convertedTransitions in\r\n\t\tlet allAcceptStates = Set.union pda.acceptStates (getFinalStates pda.transitions) in\r\n\t\t\t{ TuringMachine.tm_zero with\r\n\t\t\t\tentryAlphabet = pda.inputAlphabet;\r\n\t\t\t\ttapeAlphabet = allAlphabet;\r\n\t\t\t\tstates = allStates;\r\n\t\t\t\tinitialState = state \"q00\";\r\n\t\t\t\ttransitions = allTransitions;\r\n\t\t\t\tacceptStates = allAcceptStates;\r\n\t\t\t\tcriteria = true }\r\nend\r\n*)\r\n# 1 \"src/Composition.ml\"\r\n(*\r\n * Composition.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Carolina Duarte (cd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n *)\r\n\r\n(*\r\n * Description: Composition of models.\r\n *\r\n *)\r\n\r\n open BasicTypes\r\n\r\n module Repository = struct \r\n   type t = CompositionSupport.t\r\n \r\n   let data : (string * t) list ref = ref []\r\n   \r\n   let exists (name:string) : bool =\r\n     List.mem_assoc name !data \r\n   \r\n \r\n   let delete (name:string) : unit =\r\n     data := List.remove_assoc name !data\r\n   \r\n   \r\n   let update (name:string) (model: t) : unit =\r\n     delete name;\r\n     data := (name,model)::!data\r\n \r\n\r\n        \r\n   let updateModel (name:string) (model: Model.model) : unit =\r\n    delete name;\r\n    let m = PolyModel.model2comp model in\r\n      data := (name,m)::!data\r\n    \r\n\r\n   let getExample (name:string) : t  =  \r\n       let j = Examples.jsonExample name in\r\n       let kind = JSon.fieldString j \"kind\" in\r\n        if FiniteAutomaton.kind = kind then\r\n          (FA (FiniteAutomaton.make (Arg.JSon j)))\r\n        else if RegularExpression.kind = kind then\r\n          (RE (RegularExpression.make (Arg.JSon j)))\r\n        else if ContextFreeGrammar.kind = kind then\r\n          (CFG (ContextFreeGrammarBasic.make (Arg.JSon j)))\r\n        else if PushdownAutomaton.kind = kind then\r\n          (PDA (PushdownAutomaton.make (Arg.JSon j)))\r\n        else if TuringMachine.kind = kind then\r\n          (TM (TuringMachine.make (Arg.JSon j)))\r\n        else if Grammar.kind = kind then     (*PEDRO CARLOS *)\r\n          (GR (Grammar.make (Arg.JSon j)))  (*PEDRO CARLOS *)\r\n        else if CompositionSupport.kind = kind then\r\n          (!CompositionSupport.makeCompositionRef (Arg.JSon j))\r\n        else Error.fatal \"getExample\"\r\n       \r\n \r\n   let get (name:string) : t  =\r\n     try\r\n       List.assoc name !data \r\n     with Not_found -> getExample name\r\n\r\n   let getText (name:string) : string =\r\n    try\r\n      let m = List.assoc name !data in\r\n      match m with\r\n      | Plus (a,b) ->\r\n        JSon.toString (CompositionSupport.toJSon m)\r\n      |Intersect (a,b) ->\r\n        JSon.toString (CompositionSupport.toJSon m)\r\n      | Seq (a,b) ->\r\n        JSon.toString (CompositionSupport.toJSon m)\r\n      | Star t ->\r\n        JSon.toString (CompositionSupport.toJSon m)\r\n      | FA fa ->\r\n        JSon.toString (FiniteAutomaton.toJSon fa)\r\n      | RE re ->\r\n        JSon.toString (PolyModel.re2model re)#toJSon\r\n      | CFG cfg ->\r\n        JSon.toString (PolyModel.cfg2model cfg)#toJSon\r\n      | PDA pda ->\r\n        JSon.toString (PolyModel.pda2model pda)#toJSon\r\n      | TM tm ->\r\n        JSon.toString (PolyModel.tm2model tm)#toJSon\r\n      | GR gr ->                                        (*PEDRO CARLOS *)\r\n        JSon.toString (PolyModel.gr2model gr)#toJSon    (*PEDRO CARLOS *)\r\n      | GRO gr ->                                       (*PEDRO CARLOS *)\r\n        JSon.toString gr#toJSon                         (*PEDRO CARLOS *)\r\n      | FAO fao ->\r\n        JSon.toString fao#toJSon \r\n      | REO reo ->\r\n        JSon.toString reo#toJSon \r\n      | CFGO cfgo ->\r\n        JSon.toString cfgo#toJSon \r\n      | PDAO pdao ->\r\n        JSon.toString pdao#toJSon \r\n      | TMO tmo ->\r\n        JSon.toString tmo#toJSon\r\n      | _ -> Error.fatal \"getText\"\r\n    with Not_found -> Examples.example name\r\n\r\n\r\n let getJSon (name:string) : JSon.t =\r\n  try\r\n    let m = List.assoc name !data in\r\n    match m with\r\n    | Plus (a,b) ->\r\n      CompositionSupport.toJSon2 (Entity.dummyId CompositionSupport.kind) m\r\n    |Intersect (a,b) ->\r\n      CompositionSupport.toJSon2 (Entity.dummyId CompositionSupport.kind) m\r\n    | Seq (a,b) ->\r\n      CompositionSupport.toJSon2 (Entity.dummyId CompositionSupport.kind) m\r\n    | Star t ->\r\n      CompositionSupport.toJSon2 (Entity.dummyId CompositionSupport.kind) m\r\n    | FA fa ->\r\n      FiniteAutomaton.toJSon2 (Entity.dummyId FiniteAutomaton.kind) fa\r\n    | RE re ->\r\n      RegularExpression.toJSon2 (Entity.dummyId RegularExpression.kind) re\r\n    | CFG cfg ->\r\n      ContextFreeGrammar.toJSon2 (Entity.dummyId ContextFreeGrammar.kind) cfg\r\n    | GR gr ->                                        (*PEDRO CARLOS *)\r\n      Grammar.toJSon2 (Entity.dummyId Grammar.kind) gr  (*PEDRO CARLOS *)\r\n    | GRO gro ->                                       (*PEDRO CARLOS *)\r\n      gro#toJSon2                                      (*PEDRO CARLOS *)\r\n    | PDA pda ->\r\n      PushdownAutomaton.toJSon2 (Entity.dummyId PushdownAutomaton.kind) pda\r\n    | TM tm ->\r\n      TuringMachine.toJSon2 (Entity.dummyId TuringMachine.kind) tm\r\n    | FAO fao ->\r\n      fao#toJSon2 \r\n    | REO reo ->\r\n      reo#toJSon2 \r\n    | CFGO cfgo ->\r\n      cfgo#toJSon2 \r\n    | PDAO pdao ->\r\n      pdao#toJSon2 \r\n    | TMO tmo ->\r\n      tmo#toJSon2\r\n    | _ -> Error.fatal \"getJSon\"\r\n  with Not_found -> Examples.jsonExample name\r\n\r\n  let getListLabels =\r\n    let e = Examples.examples in\r\n    let d = List.map fst !data in\r\n    List.append e d;\r\nend\r\n \r\n (*not use\r\n module Repository2 = struct \r\n \r\n   type 'a t = (string * 'a) list\r\n   let rep: 'a t = []\r\n \r\n   let r = ref rep\r\n \r\n   let f (x: 'a t) = x\r\n \r\n   let exists (name:string) : bool = \r\n     List.exists (fun (n,_) -> n=name) !r\r\n   \r\n   let get (name:string) =\r\n     let c = List.find_opt (fun (n,_) -> n = name) !r in\r\n     match c with\r\n       | None -> None\r\n       | Some (n,m) -> Some m\r\n \r\n   let delete (name:string) =\r\n     r := List.filter (fun (n,_) -> n != name) !r\r\n \r\n \r\n   let update (name:string) (model: 'a) =\r\n     delete (name);\r\n     r := (name,model)::!r\r\n   end*)\r\n \r\n \r\n module Composition =\r\n struct\r\n \r\n   include CompositionSupport\r\n \r\n \r\n \r\n (*let repository : t Repository.t ref = ref [] \r\n \r\n   let xx = \r\n     repository := Repository.update \"ola\" (Rep \"ole\")*)\r\n \r\n \r\n   (* example *)\r\n   (* AMD\r\n   let fa_empty = {| {\r\n       kind : \"finite automaton\",\r\n       description : \"empty finite automaton\",\r\n       name : \"fa_empty\",\r\n       alphabet: [\"a\"],\r\n       states : [\"START\"],\r\n       initialState : \"START\",\r\n       transitions : [\r\n         [\"START\", \"a\", \"START\"]\r\n       ],\r\n       acceptStates : []\r\n       } |}\r\n \r\n   let emptyFA =\r\n     FiniteAutomaton.make (Arg.Text fa_empty)\r\n\t*)\r\n \r\n \r\n \r\n   (** aux *)\r\n   let rec decompositions l =\r\n     match l with\r\n       [] -> [([], [])]\r\n       | x::xs -> let lp = decompositions xs in\r\n         ([], l) :: List.map (fun (a,b) -> (x::a,b)) lp\r\n   ;;\r\n \r\n \r\n   (* Try to recognize a word *)\r\n   let rec accept (c: t) (w: word) : bool =\r\n     match c with\r\n     | Plus (a,b) ->\r\n       accept a w || accept b w\r\n     | Intersect (a,b) ->\r\n       accept a w && accept b w\r\n     | Seq (a,b) ->\r\n       let list = Set.make(decompositions w) in\r\n       Set.exists (fun (p0,p1) -> (accept a p0) && (accept b p1)) list\r\n       (*false*)\r\n     | Star t ->\r\n       w = []\r\n       || (let list = Set.remove ([],w) (Set.make(decompositions w)) in\r\n           Set.exists (fun (p0,p1) -> (accept t p0) && (accept (Star t) p1)) list)\r\n       (*false*)\r\n     | FA fa ->\r\n       FiniteAutomaton.accept fa w\r\n     | RE re ->\r\n       RegularExpressionPrivate.accept re w\r\n     | CFG cfg ->\r\n       ContextFreeGrammarBasic.accept cfg w\r\n     | PDA pda ->\r\n       PushdownAutomaton.accept pda w\r\n     | TM tm ->\r\n       TuringMachine.accept tm w\r\n     | FAO fao ->\r\n         FiniteAutomaton.accept fao#representation w \r\n     | GR gr ->  (*PEDRO CARLOS *)\r\n        Grammar.accept gr w  (*PEDRO CARLOS *)   \r\n     | GRO gro ->  (*PEDRO CARLOS *)\r\n        Grammar.accept gro#representation w  (*PEDRO CARLOS *)\r\n     | REO reo ->\r\n         RegularExpressionPrivate.accept reo#representation w\r\n     | CFGO cfgo ->\r\n         ContextFreeGrammarBasic.accept cfgo#representation w\r\n     | PDAO pdao ->\r\n         PushdownAutomaton.accept pdao#representation w\r\n     | TMO tmo ->\r\n         TuringMachine.accept tmo#representation w\r\n     | Rep rep ->\r\n      (try\r\n        let m = Repository.get rep in\r\n          accept m w\r\n      with Not_found -> Error.fatal \"Composition with invalid repository name\")\r\n       \r\n     | _ -> Error.fatal \"accept\"\r\n       \r\n   (* Concat  *)\r\n   let concatAllS w s =\r\n     Set.map (fun l -> w@l) s\r\n \r\n \r\n   (* Generate all the accepted word with maximum length *)\r\n   let rec generate (c: t) (len: int) : words =\r\n     match c with\r\n     | Plus (a,b) ->\r\n       Set.union (generate a len)  (generate b len)\r\n     | Intersect (a,b) ->\r\n       Set.inter (generate a len) (generate b len)\r\n     | Seq (a,b) ->\r\n       let left = generate a len in\r\n       let rigth w = generate b (len - (List.length w)) in\r\n       let conc w = concatAllS w (rigth w) in\r\n         Set.flatMap (fun lw -> conc lw) left    \r\n     | Star t ->\r\n       let exp = generate t len in\r\n         Set.star exp len\r\n     | FA fa ->\r\n       FiniteAutomaton.generate fa len\r\n     | RE re ->\r\n       RegularExpressionPrivate.generate re len\r\n     | CFG cfg ->\r\n       ContextFreeGrammarBasic.generate cfg len\r\n     | PDA pda ->\r\n       PushdownAutomaton.generate len pda\r\n     | TM tm ->\r\n       TuringMachine.generate tm len\r\n     | FAO fao ->\r\n       FiniteAutomaton.generate fao#representation len \r\n     | GR gr ->  (*PEDRO CARLOS *)\r\n       Grammar.generate gr len  (*PEDRO CARLOS *)   \r\n     | GRO gro ->  (*PEDRO CARLOS *)\r\n       Grammar.generate gro#representation len  (*PEDRO CARLOS *)\r\n     | REO reo ->\r\n         RegularExpressionPrivate.generate reo#representation len\r\n     | CFGO cfgo ->\r\n         ContextFreeGrammarBasic.generate cfgo#representation len\r\n     | PDAO pdao ->\r\n         PushdownAutomaton.generate len pdao#representation\r\n     | TMO tmo ->\r\n         TuringMachine.generate tmo#representation len\r\n     | Rep rep ->\r\n      (try\r\n        let m = Repository.get rep in\r\n          generate m len\r\n      with Not_found -> Error.fatal \"Composition with invalid repository name\")\r\n     | _ -> Error.fatal \"generate\"\r\n \r\n     (* Adds a sufix to a state name *)\r\n     let addSufixFA (st: state)(sufix: string): state =\r\n       str2state ((state2str st)^\"_\"^sufix)  \r\n\r\n\tlet angular str = str2symb(\"<\"^str^\">\")   (* AMD *)\r\n\r\n     (* Adds a sufix to a variable name name *)\r\n     let addSufixCFG (v: symbol)(sufix: string): symbol =\r\n       angular ((symb2str v)^\"_\"^sufix) (*PEDRO CARLOS added prefix < and sufix >. Should not work whithout it VER@!!!*)\r\n     \r\n \r\n     (* Renames all the states in one automaton adding a sufix *)\t\r\n     let renameStatesFA(fa: FiniteAutomaton.t) (sufix: string): FiniteAutomaton.t =\r\n \r\n       {\r\n         alphabet = fa.alphabet; \r\n         states = Set.map (fun st -> addSufixFA st sufix) fa.states;\r\n         initialState = addSufixFA fa.initialState sufix;\r\n         transitions = Set.map (fun (s1,sy,s2) -> (addSufixFA s1 sufix,sy,addSufixFA s2 sufix)) fa.transitions;\r\n         acceptStates = Set.map (fun st -> addSufixFA st sufix) fa.acceptStates\r\n       }\r\n \r\n     let addSufixList body sufix =\r\n        List.map(fun s -> addSufixCFG  s sufix) body\r\n     \r\n     let addSufixListCFG body sufix alphabet =\r\n        List.map\r\n\t\t\t(fun s -> if Set.belongs s alphabet then s else addSufixCFG s sufix)\r\n\t\t\tbody\r\n     \r\n       (* Renames all the variables in one gramatic adding a sufix *)\t\r\n     let renameVariablesCFG (cfg: ContextFreeGrammarBasic.t) (sufix: string): ContextFreeGrammarBasic.t =\r\n       let open ContextFreeGrammarBasic in \r\n       {alphabet = cfg.alphabet;\r\n        variables =\tSet.map (fun v -> addSufixCFG v sufix) cfg.variables;\r\n        initial = addSufixCFG cfg.initial sufix;\r\n        rules = Set.map\r\n\t\t\t\t\t(fun {head= h;body = b} -> {head=(addSufixCFG h sufix); body=addSufixListCFG b sufix cfg.alphabet})\r\n\t\t\t\t\tcfg.rules\r\n       }\r\n      (*PEDRO CARLOS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*)\r\n              (* Renames all the variables in one gramatic adding a sufix *)\t\r\n     let renameVariablesGR (gr: Grammar.t) (sufix: string): Grammar.t =\r\n      let open Grammar in \r\n      let addSufixIfVariable symbol =\r\n        if Set.belongs symbol gr.variables then addSufixCFG symbol sufix else symbol\r\n      in\r\n      {alphabet = gr.alphabet;\r\n       variables =\tSet.map (fun v -> addSufixCFG v sufix) gr.variables;\r\n       initial = addSufixCFG gr.initial sufix;\r\n       rules = Set.map\r\n       (fun {head= h; body = b} -> \r\n         { head = List.map addSufixIfVariable h;\r\n           body = List.map addSufixIfVariable b })\r\n       gr.rules\r\n      }\r\n     (*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*)\r\n\r\n     let renameStatesPDA (pda: PushdownAutomaton.t) (sufix: string): PushdownAutomaton.t =\r\n       \r\n       {\r\n         inputAlphabet = pda.inputAlphabet;\r\n         stackAlphabet = Set.map (fun s -> addSufixCFG s sufix) pda.stackAlphabet;\r\n         states = Set.map (fun st -> addSufixFA st sufix) pda.states;\r\n         initialState = addSufixFA pda.initialState sufix;\r\n         initialStackSymbol = addSufixCFG pda.initialStackSymbol sufix;\r\n         transitions = Set.map (fun (q1,s1,sy,q2,s2) -> (addSufixFA q1 sufix,addSufixCFG s1 sufix,sy,addSufixFA q2 sufix,addSufixList s2 sufix )) pda.transitions;\r\n         acceptStates = Set.map (fun st -> addSufixFA st sufix) pda.acceptStates;\r\n         criteria = true\r\n       }\r\n \r\n     let renameStatesTM (tm: TuringMachine.t) (sufix: string): TuringMachine.t =\r\n\t\t{ tm with\r\n\t\t\tstates = Set.map (fun st -> addSufixFA st sufix) tm.states;\r\n\t\t\tinitialState = addSufixFA tm.initialState sufix;\r\n\t\t\ttransitions = Set.map (fun (s1,symb1,s2,symb2,d) ->\r\n\t\t\t\t\t\t(addSufixFA s1 sufix,symb1,addSufixFA s2 sufix,symb2,d ))\r\n\t\t\t\t\t\ttm.transitions;\r\n\t\t\tacceptStates = Set.map (fun st -> addSufixFA st sufix) tm.acceptStates;\r\n\t\t\tcriteria = true }\r\n   \r\n     let rec rename (c: t): t =\r\n     match c with\r\n     | Plus (a,b) ->\r\n         Plus(rename a,rename b)\r\n     | Seq (a,b) ->\r\n         Seq(rename a,rename b)\r\n     | Intersect (a,b) ->\r\n         Intersect(rename a,rename b)\r\n     | Star t ->\r\n         Star(rename t)\r\n     | FA fa ->\r\n         FA (renameStatesFA fa (IdGenerator.gen(\"\")))\r\n     | RE re ->\r\n       RE re\r\n     | CFG cfg ->\r\n       CFG (renameVariablesCFG cfg (IdGenerator.gen(\"\")))\r\n     | GR gr ->  (*PEDRO CARLOS *)\r\n       GR (renameVariablesGR gr (IdGenerator.gen(\"\")))  (*PEDRO CARLOS *) \r\n     | PDA pda ->\r\n       PDA (renameStatesPDA pda (IdGenerator.gen(\"\")))\r\n     | TM tm ->\r\n       TM (renameStatesTM tm (IdGenerator.gen(\"\")))\r\n     | _ -> Error.fatal \"rename\"\r\n     \r\n \r\n     (* calculate a composite finite automaton resulting from a plus operation *)\t\r\n     let evalPlusFA (fa: FiniteAutomaton.t) \r\n                   (fb: FiniteAutomaton.t): FiniteAutomaton.t = \r\n \r\n       let qI = str2state (IdGenerator.gen(\"q\")) in\r\n       let ta = (qI, epsilon,fa.initialState) in\r\n       let tb = (qI,epsilon,fb.initialState) in\r\n       {\r\n         alphabet = Set.union fa.alphabet fb.alphabet; \r\n         states = Set.add qI (Set.union fa.states fb.states);\r\n         initialState = qI;\r\n         transitions = Set.add tb (Set.add ta (Set.union fa.transitions fb.transitions));\r\n         acceptStates = Set.union fa.acceptStates fb.acceptStates\r\n       }\r\n \r\n     (* Creates a transition between two states in a Finite Automata*)\r\n     let createTransitionFA firstState secondState =\r\n       (firstState, epsilon,secondState) \r\n \r\n     (* calculate a composite finite automaton resulting from a sequence operation *)\t\r\n     let evalSeqFA (fa: FiniteAutomaton.t) (fb: FiniteAutomaton.t): FiniteAutomaton.t = \r\n         \r\n       let t = Set.map (fun st -> createTransitionFA st fb.initialState) fa.acceptStates in\r\n       {\r\n         alphabet = Set.union fa.alphabet fb.alphabet; \r\n         states = Set.union fa.states fb.states;\r\n         initialState = fa.initialState;\r\n         transitions = Set.union t (Set.union fa.transitions fb.transitions);\r\n         acceptStates = fb.acceptStates\r\n       }\r\n \r\n \r\n     (*Transforms 2 strings in one string *)\r\n     let makeName2 a b = a^\"_#_\"^b\r\n \r\n     (*finds the transions for the 2 states and symbol of the alphabet*)\r\n     let findTransitions a b s transA transB  : FiniteAutomaton.transition3 set = \r\n \r\n       let ab = makeName2 a b in\r\n \r\n       let at = Set.filter (fun (x,s1,y) -> x = a && s1 = s  ) transA in\r\n \r\n       let bt = Set.filter (fun (x,s1,y) -> x = b && s1 = s  ) transB in\r\n \r\n       let abt = Set.product at bt in\r\n \r\n       Set.map (fun ((x1,s1,y1),(x2,s2,y2)) -> (ab,s,makeName2 y1 y2)) abt\r\n \r\n     let createEmptyTransition a b transA transB  : FiniteAutomaton.transition3 set = \r\n \r\n       let ab = makeName2 a b in\r\n       let at = Set.filter (fun (x,s,y) -> x = a && s = epsilon ) transA in\r\n       let bt = Set.filter (fun (x,s,y) -> x = b && s = epsilon ) transB in\r\n       let abt = Set.product at bt in\r\n \r\n       let emptyAB = Set.map (fun ((x1,s1,y1),(x2,s2,y2)) -> (ab,epsilon,makeName2 y1 y2)) abt in\r\n       let emptyA = Set.map (fun (x,s,y) -> ab,epsilon,makeName2 y b) at in\r\n       let emptyB = Set.map (fun (x,s,y) -> ab,epsilon,makeName2 a y) bt in\r\n \r\n       Set.union emptyAB (Set.union emptyA emptyB)\r\n \r\n \r\n \r\n     (*performs findTransitions for every symbol of the alphabet*)\r\n     let findTransitions2 a b  transA transB alphabet  : FiniteAutomaton.transition3 set = \r\n \r\n       let t = Set.flat_map (fun s -> findTransitions a b s transA transB) alphabet in\r\n       let emptyt = createEmptyTransition a b transA transB in\r\n       Set.union t emptyt\r\n \r\n     (* calculate a composite finite automaton resulting from a intersection operation *)\t\r\n     let evalIntersectFA (fa: FiniteAutomaton.t) (fb: FiniteAutomaton.t): FiniteAutomaton.t =\r\n \r\n       let s = Set.product fa.states fb.states in\r\n       let newAlphabet = Set.inter fa.alphabet fb.alphabet in\r\n       let trans = Set.flat_map (fun (a,b) -> findTransitions2 a b fa.transitions fb.transitions newAlphabet ) s in\r\n       let newStates = Set.map (fun (a,b) -> makeName2 a b) s in\r\n       let s1 = Set.product fa.acceptStates fb.acceptStates in\r\n       let newAccept = Set.map (fun (a,b)  -> makeName2 a b) s1 in\r\n       {\r\n         alphabet = newAlphabet; \r\n         states =  newStates;\r\n         initialState = makeName2 fa.initialState fb.initialState;\r\n         transitions =  trans;\r\n         acceptStates = newAccept\r\n       }\r\n \r\n \r\n     (* calculate a composite finite automaton resulting from a star operation *)\t\r\n     let evalStarFA (ft: FiniteAutomaton.t) : FiniteAutomaton.t = \r\n         \r\n       let qI = str2state (IdGenerator.gen(\"q\")) in\r\n       let ta = (qI, epsilon,ft.initialState) in\r\n       let t = Set.map (fun st -> createTransitionFA st ft.initialState) ft.acceptStates in\r\n       {\r\n         alphabet = ft.alphabet; \r\n         states = Set.add qI ft.states;\r\n         initialState = qI;\r\n         transitions = Set.add ta (Set.union t ft.transitions);\r\n         acceptStates = Set.add qI ft.acceptStates\r\n       }\r\n \r\n \r\n     \r\n      \r\n   \r\n   (* calculate a composite finite automaton *)\r\n   (*Pre: c already renamed*)\r\n   let rec calcEvalFA (c: t): FiniteAutomaton.t =\r\n     match c with\r\n     | Plus (a,b) ->\r\n         let fa = calcEvalFA a in \r\n         let fb = calcEvalFA b in\r\n           evalPlusFA fa fb\r\n     | Seq (a,b) ->\r\n         let fa = calcEvalFA a in\r\n         let fb = calcEvalFA b in\r\n         evalSeqFA fa fb\t\r\n     | Intersect (a,b) ->\r\n       let fa = calcEvalFA a in\r\n       let fb = calcEvalFA b in\r\n       evalIntersectFA fa fb\r\n     | Star t ->\r\n         let ft = calcEvalFA t in\r\n         evalStarFA ft\r\n     | FA fa ->\r\n       fa\r\n     |  _ ->\r\n       Error.fatal \"calcEvalFA\"\r\n \r\n \r\n   (* calculate a composite regular expression resulting from a plus operation *)\t\r\n   let evalPlusRE (ra: RegularExpression.t) (rb: RegularExpression.t) : RegularExpression.t =\r\n     Plus(ra, rb)\r\n \r\n   \r\n \r\n   (* calculate a composite regular expression resulting from a sequence operation *)\t\r\n   let evalSeqRE (ra: RegularExpression.t) (rb: RegularExpression.t) : RegularExpression.t =\r\n     Seq(ra, rb)\r\n \r\n   \r\n   (* calculate a composite regular expression resulting from a intersection operation *)\t\r\n   let evalIntersectRE (ra: RegularExpression.t) (rb: RegularExpression.t) : RegularExpression.t =\r\n     let fa = PolyBasic.re2fa ra in\r\n     let fb = PolyBasic.re2fa rb in\r\n     let faComp = evalIntersectFA fa fb in\r\n      PolyBasic.fa2re faComp\r\n \r\n   (* calculate a composite regular expression resulting from a star operation *)\t\r\n   let evalStarRE (rt: RegularExpression.t) : RegularExpression.t =\r\n     Star rt\r\n \r\n   (* calculate a composite Regular Expression *)\r\n   let rec calcEvalRE (c: t): RegularExpression.t =\r\n     match c with\r\n     | Plus (a,b) ->\r\n         let ra = calcEvalRE a in \r\n         let rb = calcEvalRE b in\r\n           evalPlusRE ra rb\r\n     | Seq (a,b) ->\r\n         let ra = calcEvalRE a in\r\n         let rb = calcEvalRE b in\r\n         evalSeqRE ra rb\r\n     | Intersect (a,b) ->\r\n       let ra = calcEvalRE a in\r\n       let rb = calcEvalRE b in\r\n       evalIntersectRE  ra rb\r\n     | Star t ->\r\n         let rt = calcEvalRE t in\r\n         evalStarRE rt\r\n     | RE re ->\r\n       re\r\n     |  _ ->\r\n       Error.fatal \"calcEvalRE\"\r\n\r\n   (* calculate a composite context free grammar resulting from a plus operation *)\t\r\n   let evalPlusCFG (ca: ContextFreeGrammarBasic.t) (cb: ContextFreeGrammarBasic.t) : ContextFreeGrammarBasic.t =\r\n \r\n     let open ContextFreeGrammarBasic in \r\n     let s =  angular (IdGenerator.gen(\"S\")) in\r\n     let r1 = {head = s; body = [ca.initial]} in\r\n     let r2 = {head = s; body = [cb.initial]} in\r\n     {alphabet = Set.union ca.alphabet cb.alphabet;\r\n     variables =\tSet.add s (Set.union ca.variables cb.variables);\r\n     initial = s;\r\n     rules = Set.add r1 (Set.add r2 (Set.union ca.rules cb.rules))\r\n     }\r\n\r\n\r\n   (* calculate a composite context free grammar resulting from a sequence operation *)\t\r\n   let evalSeqCFG (ca: ContextFreeGrammarBasic.t) (cb: ContextFreeGrammarBasic.t) : ContextFreeGrammarBasic.t =\r\n \r\n     let open ContextFreeGrammarBasic in \r\n     let s = angular (IdGenerator.gen(\"S\")) in\r\n     let r1 = {head = s; body = [ca.initial; cb.initial]} in\r\n     {alphabet = Set.union ca.alphabet cb.alphabet;\r\n     variables =\tSet.add s (Set.union ca.variables cb.variables);\r\n     initial = s;\r\n     rules =Set.add r1 (Set.union ca.rules cb.rules)\r\n     }\r\n   \r\n \r\n   (* calculate a composite context free grammar resulting from a star operation *)\t\r\n   let evalStarCFG (ct: ContextFreeGrammarBasic.t)  : ContextFreeGrammarBasic.t =\r\n \r\n     let open ContextFreeGrammarBasic in \r\n     let s =  angular (IdGenerator.gen(\"S\")) in\r\n     let r1 = {head = s; body = [s;ct.initial]} in\r\n     let r2 = {head = s; body = [epsilon]} in\r\n     {alphabet = ct.alphabet;\r\n     variables =\tSet.add s ct.variables;\r\n     initial = s;\r\n     rules = Set.add r1 (Set.add r2 ct.rules)\r\n     }\t\t\r\n \r\n   (* calculate a composite Context Free Grammar *)\r\n   let rec calcEvalCFG (c: t): ContextFreeGrammarBasic.t =\r\n     match c with\r\n     | Plus (a,b) ->\r\n         let ca = calcEvalCFG a in \r\n         let cb = calcEvalCFG b in\r\n         evalPlusCFG ca cb\r\n     | Seq (a,b) ->\r\n         let ca = calcEvalCFG a in\r\n         let cb = calcEvalCFG b in\r\n         evalSeqCFG ca cb\t\r\n     | Star t ->\r\n         let ct = calcEvalCFG t in\r\n         evalStarCFG ct\r\n     | CFG cfg ->\r\n       cfg\r\n     |  _ ->\r\n       Error.fatal \"calcEvalCFG\"\r\n \r\n  (*PEDRO CARLOS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*)\r\n\r\n  let evalPlusGR (ca: Grammar.t) (cb: Grammar.t) : Grammar.t =\r\n \r\n    let open Grammar in \r\n    let s =  str2symb (\"<\" ^ IdGenerator.gen(\"S\") ^ \">\") in\r\n    let r1 = {head = [s]; body = [ca.initial]} in\r\n    let r2 = {head = [s]; body = [cb.initial]} in\r\n    {alphabet = Set.union ca.alphabet cb.alphabet;\r\n    variables =\tSet.add s (Set.union ca.variables cb.variables);\r\n    initial = s;\r\n    rules = Set.add r1 (Set.add r2 (Set.union ca.rules cb.rules))\r\n    }\r\n\r\n  let evalSeqGR (ca: Grammar.t) (cb: Grammar.t) : Grammar.t =\r\n\r\n    let open Grammar in \r\n    let s =  str2symb (\"<\" ^ IdGenerator.gen(\"S\") ^ \">\") in\r\n    let r1 = {head = [s]; body = [ca.initial; cb.initial]} in\r\n    {alphabet = Set.union ca.alphabet cb.alphabet;\r\n    variables =\tSet.add s (Set.union ca.variables cb.variables);\r\n    initial = s;\r\n    rules =Set.add r1 (Set.union ca.rules cb.rules)\r\n    }\r\n\r\n  let evalStarGR(ct: Grammar.t)  : Grammar.t =\r\n\r\n    let open Grammar in \r\n    let s =  str2symb (\"<\" ^ IdGenerator.gen(\"S\") ^ \">\") in\r\n    let r1 = {head = [s]; body = [s;ct.initial]} in\r\n    let r2 = {head = [s]; body = [epsilon]} in\r\n    {alphabet = ct.alphabet;\r\n    variables =\tSet.add s ct.variables;\r\n    initial = s;\r\n    rules = Set.add r1 (Set.add r2 ct.rules)\r\n    }\t\r\n  \r\n    \r\n    let rec calcEvalGR (c: t): Grammar.t =\r\n      match c with\r\n      | Plus (a,b) ->\r\n          let ca = calcEvalGR a in \r\n          let cb = calcEvalGR b in\r\n          evalPlusGR ca cb\r\n      | Seq (a,b) ->\r\n          let ca = calcEvalGR a in\r\n          let cb = calcEvalGR b in\r\n          evalSeqGR ca cb\t\r\n      | Star t ->\r\n          let ct = calcEvalGR t in\r\n          evalStarGR ct\r\n      | GR gr ->\r\n        gr\r\n      |  _ ->\r\n        Error.fatal \"calcEvalGR\"\r\n\r\n(*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*)\r\n\r\n   (* calculate a composite pushdown automata resulting from a plus operation *)\t\r\n   (* AMD *)\r\n   (* DOES NOT HANDLE LB-TMs *)\r\n   (* DOES NOT HANDLE DIRECTION S *)\r\n   (* DOES NOT HANDLE TWO MULTITAPE TMs *)\r\n   let evalPlusPDA (pa: PushdownAutomaton.t) (pb: PushdownAutomaton.t) : PushdownAutomaton.t =\r\n     \r\n     let qI = str2state (IdGenerator.gen(\"q\")) in\r\n     let sI = str2symb (IdGenerator.gen(\"s\")) in\r\n     let t1 = (qI,sI,epsilon,pa.initialState,[pa.initialStackSymbol]) in\r\n     let t2 = (qI,sI,epsilon,pb.initialState,[pb.initialStackSymbol]) in\r\n     {\r\n       inputAlphabet = Set.union pa.inputAlphabet pb.inputAlphabet;\r\n       stackAlphabet = Set.add sI (Set.union pa.stackAlphabet pb.stackAlphabet);\r\n       states = Set.add qI (Set.union pa.states pb.states);\r\n       initialState = qI;\r\n       initialStackSymbol = sI;\r\n       transitions = Set.add t2 (Set.add t1 (Set.union pa.transitions pb.transitions));\r\n       acceptStates = Set.union pa.acceptStates pb.acceptStates;\r\n       criteria = true\r\n     }\r\n \r\n   (* Creates a transition between two states in a pushdowm automata *)\r\n   let createTransitionPDA firstState secondState stackSymbol symbolstackAlphabet =\r\n       \r\n     Set.map(fun s -> (firstState,s,epsilon,secondState, [stackSymbol])) symbolstackAlphabet\r\n     \r\n   \r\n   (* calculate a composite pushdown automata resulting from a sequence operation *)\t\r\n   let evalSeqPDA (pa: PushdownAutomaton.t) (pb: PushdownAutomaton.t) : PushdownAutomaton.t =\r\n     \r\n     let t = Set.flatten (Set.map (fun st -> createTransitionPDA st pb.initialState pb.initialStackSymbol pa.stackAlphabet) pa.acceptStates) in\r\n     {\r\n       inputAlphabet = Set.union pa.inputAlphabet pb.inputAlphabet;\r\n       stackAlphabet = Set.union pa.stackAlphabet pb.stackAlphabet;\r\n       states = Set.union pa.states pb.states;\r\n       initialState = pa.initialState;\r\n       initialStackSymbol = pa.initialStackSymbol;\r\n       transitions = Set.union t (Set.union pa.transitions pb.transitions);\r\n       acceptStates = pb.acceptStates;\r\n       criteria = true\r\n     }\r\n \r\n \r\n   (* calculate a composite pushdown automata resulting from a star operation *)\t\r\n   let evalStarPDA (pt: PushdownAutomaton.t)  : PushdownAutomaton.t =\r\n     \r\n     let qI = str2state (IdGenerator.gen(\"q\")) in\r\n     let sI = str2symb (IdGenerator.gen(\"s\")) in\r\n     let t1 = (qI,sI,epsilon,pt.initialState,[pt.initialStackSymbol]) in\r\n     let t = Set.flatten (Set.map (fun st -> createTransitionPDA st pt.initialState pt.initialStackSymbol pt.stackAlphabet) pt.acceptStates) in\r\n     {\r\n       inputAlphabet = pt.inputAlphabet;\r\n       stackAlphabet = Set.add sI pt.stackAlphabet;\r\n       states = Set.add qI pt.states;\r\n       initialState = qI;\r\n       initialStackSymbol = sI;\r\n       transitions = Set.add t1 (Set.union t pt.transitions);\r\n       acceptStates = Set.add qI pt.acceptStates;\r\n       criteria = true\r\n     }\r\n \r\n \r\n \r\n   (* calculate a composite Pushdown Automata *)\r\n   let rec calcEvalPDA (c: t): PushdownAutomaton.t =\r\n     match c with\r\n     | Plus (a,b) ->\r\n         let pa = calcEvalPDA a in \r\n         let pb = calcEvalPDA b in\r\n         evalPlusPDA pa pb\r\n     | Seq (a,b) ->\r\n         let pa = calcEvalPDA a in\r\n         let pb = calcEvalPDA b in\r\n         evalSeqPDA pa pb\r\n     | Star t ->\r\n         let pt = calcEvalPDA t in\r\n         evalStarPDA pt\r\n     | PDA pda ->\r\n       pda\r\n     |  _ ->\r\n       Error.fatal \"calcEvalPDA\";;\r\n \r\n   (* calculate a composite turing machine resulting from a plus operation *)\t\r\n   let evalPlusTM (ta: TuringMachine.t) (tb: TuringMachine.t): TuringMachine.t =\r\n \r\n     let qI = str2state (IdGenerator.gen(\"q\")) in\r\n     let t1 = (qI,[empty],ta.initialState,[empty],[L]) in\r\n     let t2 = (ta.initialState,[empty],ta.initialState,[empty],[R]) in\r\n     let t3 = (qI,[empty],tb.initialState,[empty],[L]) in\r\n     let t4 = (tb.initialState,[empty],tb.initialState,[empty],[R]) in\r\n     let t = Set.make [t1;t2;t3;t4] in\r\n     {\r\n       entryAlphabet = Set.union ta.entryAlphabet tb.entryAlphabet;\r\n       tapeAlphabet = Set.add empty (Set.union ta.tapeAlphabet tb.tapeAlphabet);\r\n       empty = empty;\r\n       states = Set.add qI (Set.union ta.states tb.states);\r\n       initialState = qI;\r\n       transitions = Set.union t (Set.union ta.transitions tb.transitions);\r\n       acceptStates = Set.union ta.acceptStates tb.acceptStates;\r\n       criteria = true;\r\n       lbMarkers = ta.lbMarkers;\r\n       _nTapes = 1\r\n     }\r\n\r\n   \r\n \r\n   (* Creates a transition between two states in a Turing Machine*)\r\n   let createTransitionTM firstState secondState tapeAlphabetTA =\r\n       \r\n     Set.map(fun s -> (firstState,[s],secondState,[s],[R])) tapeAlphabetTA\r\n \r\n   (* calculate a composite turing machine resulting from a sequence operation *)\t\r\n   let evalSeqTM (ta: TuringMachine.t) (tb: TuringMachine.t): TuringMachine.t =\r\n \r\n     let t = Set.flatten (Set.map (fun st -> createTransitionTM st tb.initialState ta.tapeAlphabet) ta.acceptStates) in\r\n     \r\n     {\r\n       entryAlphabet = Set.union ta.entryAlphabet tb.entryAlphabet;\r\n       tapeAlphabet = Set.add empty (Set.union ta.tapeAlphabet tb.tapeAlphabet);\r\n       empty = empty;\r\n       states = Set.union ta.states tb.states;\r\n       initialState = ta.initialState;\r\n       transitions = Set.union t (Set.union ta.transitions tb.transitions);\r\n       acceptStates = tb.acceptStates;\r\n       criteria = true;\r\n       lbMarkers = ta.lbMarkers;\r\n       _nTapes = 1\r\n     }\r\n \r\n   (* calculate a composite turing machine resulting from a star operation *)\t\r\n   let evalStarTM (tt: TuringMachine.t) : TuringMachine.t =\r\n    let qI = str2state (IdGenerator.gen(\"q\")) in\r\n    let t1 = (qI,[empty],tt.initialState,[empty],[L]) in\r\n    let t2 = (tt.initialState,[empty],tt.initialState,[empty],[R]) in\r\n     let t = Set.flatten (Set.map (fun st -> createTransitionTM st tt.initialState tt.tapeAlphabet) tt.acceptStates) in\r\n     \r\n     {\r\n       entryAlphabet = tt.entryAlphabet;\r\n       tapeAlphabet = Set.add empty tt.tapeAlphabet;\r\n       empty = empty;\r\n       states = Set.add qI tt.states;\r\n       initialState = qI;\r\n       transitions = Set.add t2 (Set.add t1 (Set.union t tt.transitions));\r\n       acceptStates = Set.add qI tt.acceptStates;\r\n       criteria = true;\r\n       lbMarkers = tt.lbMarkers;\r\n       _nTapes = 1\r\n     }\r\n   \r\n   (* Auxiliar function *)\r\n   let direction2direction3 dir : direction = if dir = L then L else R\r\n   (*creates the transions for the 2 states *)\r\n   let createsTransitionsInter (a: state) (b: state) (transA: TuringMachine.transitions) (transB: TuringMachine.transitions)  : TuringMachine.transition set = \r\n \r\n     let ab = makeName2 a b in\r\n \r\n     let at = Set.filter (fun (sa,x,s,y,d) -> sa = a ) transA in\r\n \r\n     let bt = Set.filter (fun (sb,x,s,y,d) -> sb = b ) transB in\r\n \r\n     let abt = Set.product at bt in\r\n     \r\n\t let f (a, b) =\r\n\t\tmatch a, b with\r\n\t\t| (sa,[x1],s1,[y1],[d1]), (sb,[x2],s2,[y2],[d2]) ->\r\n\t\t\t(ab,[x1;x2], makeName2 s1 s2,[y1;y2],\r\n\t\t\t\t[direction2direction3 d1; direction2direction3 d2])\r\n\t\t| _, _ ->\r\n\t\t\tfailwith \"createsTransitionsInter\"\r\n\t in\r\n\t\tSet.map f abt\r\n   \r\n   let evalIntersectTM (ta: TuringMachine.t) (tb: TuringMachine.t): TuringMachine.t =\r\n \r\n     let s = Set.product ta.states tb.states in\r\n     let newEntryAlphabet = Set.inter ta.entryAlphabet tb.entryAlphabet in\r\n     let trans = Set.flat_map (fun (a,b) -> createsTransitionsInter a b ta.transitions tb.transitions ) s in\r\n     let newStates = Set.map (fun (a,b) -> makeName2 a b) s in\r\n     let acceptS = Set.product ta.acceptStates tb.acceptStates in\r\n     let newAccept = Set.map (fun (a,b)  -> makeName2 a b) acceptS in\r\n \r\n     {\r\n       entryAlphabet = newEntryAlphabet;\r\n       tapeAlphabet = Set.union ta.tapeAlphabet tb.tapeAlphabet;\r\n       empty = empty;\r\n       states = newStates;\r\n       initialState = makeName2 ta.initialState tb.initialState;\r\n       transitions = trans;\r\n       acceptStates = newAccept;\r\n       criteria = true; (* true = acceptStates | false = stop *)\r\n       lbMarkers = ta.lbMarkers;\r\n       _nTapes = 1\r\n     }\r\n \r\n   (* calculate a composite Turing Machine *)\r\n   let rec calcEvalTM (c: t): TuringMachine.t =\r\n     match c with\r\n     | Plus (a,b) ->\r\n         let ta = calcEvalTM a in \r\n         let tb = calcEvalTM b in\r\n         evalPlusTM ta tb\r\n     | Seq (a,b) ->\r\n         let ta = calcEvalTM a in\r\n         let tb = calcEvalTM b in\r\n         evalSeqTM ta tb\r\n    | Intersect (a,b)->\r\n         let ta = calcEvalTM a in\r\n         let tb = calcEvalTM b in\r\n         evalIntersectTM ta tb\r\n     | Star t ->\r\n         let tt = calcEvalTM t in\r\n         evalStarTM tt\r\n     | TM tm ->\r\n       tm\r\n     |  _ ->\r\n       Error.fatal \"calcEvalTM\"\r\n\r\n \r\n   (* tranforms a composition of elements to a composition of finite automaton *)\r\n   (*Pre: c isFAConvertivel*)\t\t\r\n   let rec comp2facomp (c: t): t =\r\n     match c with\r\n       | Plus (a,b) ->\r\n           Plus (comp2facomp a, comp2facomp b)\r\n       | Seq (a,b) ->\r\n           Seq (comp2facomp a, comp2facomp b)\r\n       | Intersect (a,b) ->\r\n           Intersect (comp2facomp a, comp2facomp b)\r\n       | Star t ->\r\n           Star (comp2facomp t)\r\n       | FA fa ->\r\n           FA fa\r\n       | RE re ->\r\n           FA (PolyBasic.re2fa re)\r\n       | CFG cfg ->\r\n         FA (PolyBasic.cfg2fa cfg)\r\n       | GR gr -> (*PEDRO CARLOS *)\r\n         let cfg = PolyBasic.gr2cfg gr in(*PEDRO CARLOS *)\r\n         FA (PolyBasic.cfg2fa cfg)\t(*PEDRO CARLOS *)\r\n       | PDA pda ->\r\n         FA (PolyBasic.pda2fa pda)\r\n       | TM tm ->\r\n         let tmobj = new TuringMachine.model (Representation tm) in\r\n         FA (tmobj#downgradeModelToFiniteAutomaton)#representation\t\r\n       | _ -> Error.fatal \"comp2facomp\"\r\n \r\n   \r\n \r\n   (* tranforms a composition of elements to a composition of regular expressions *)\r\n   (*Pre: c isREConvertivel*)\t\t\r\n   let rec comp2recomp (c: t): t =\r\n     match c with\r\n       | Plus (a,b) ->\r\n           Plus (comp2recomp a, comp2recomp b)\r\n       | Seq (a,b) ->\r\n           Seq (comp2recomp a, comp2recomp b)\r\n       | Intersect (a,b) ->\r\n           Intersect (comp2recomp a, comp2recomp b)\r\n       | Star t ->\r\n           Star (comp2recomp t)\r\n       | RE re ->\r\n           RE re\r\n       | FA fa ->\r\n           RE (PolyBasic.fa2re fa)\r\n       | CFG cfg ->\r\n           RE (PolyBasic.cfg2re cfg)\r\n       | GR gr ->        (*PEDRO CARLOS *)\r\n          let cfg = PolyBasic.gr2cfg gr in (*PEDRO CARLOS *)\r\n          RE (PolyBasic.cfg2re cfg) (*PEDRO CARLOS *)\r\n       | PDA pda ->\r\n           RE (PolyBasic.pda2re pda)\r\n       | TM tm ->\r\n         let tmobj = new TuringMachine.model (Representation tm) in\r\n         RE (PolyModel.fa2re (tmobj#downgradeModelToFiniteAutomaton))#representation\t\t\t\r\n       | _ -> Error.fatal \"comp2recomp\"\r\n\r\n   (* tranforms a composition of elements to a composition of Context Free Grammar *)\r\n   (*Pre: c isCFGConvertivel*)\t\t\r\n   let rec comp2CFGcomp (c: t): t =\r\n     match c with\r\n       | Plus (a,b) ->\r\n           Plus (comp2CFGcomp a, comp2CFGcomp b)\r\n       | Seq (a,b) ->\r\n           Seq (comp2CFGcomp a, comp2CFGcomp b)\r\n       | Intersect (a,b) ->\r\n           Intersect (comp2CFGcomp a, comp2CFGcomp b)\r\n       | Star t ->\r\n           Star (comp2CFGcomp t)\r\n       | CFG cfg ->\r\n           CFG cfg \r\n       | GR gr -> (*PEDRO CARLOS *)\r\n          CFG (PolyBasic.gr2cfg gr) (*PEDRO CARLOS *)\r\n       | PDA pda ->\r\n           CFG (PolyBasic.pda2cfg pda)\r\n       | FA fa ->\r\n           CFG (PolyBasic.fa2cfg fa)\r\n       | RE re ->\r\n           CFG (PolyBasic.re2cfg re)\r\n       | _ -> Error.fatal \"comp2CFGcomp\"\r\n(*PEDRO CARLOS+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ *)\r\n      let rec comp2GRcomp (c: t): t =\r\n      match c with\r\n        | Plus (a,b) ->\r\n            Plus (comp2GRcomp a, comp2GRcomp b)\r\n        | Seq (a,b) ->\r\n            Seq (comp2GRcomp a, comp2GRcomp b)\r\n        | Intersect (a,b) ->\r\n            Intersect (comp2GRcomp a, comp2GRcomp b)\r\n        | Star t ->\r\n            Star (comp2GRcomp t)\r\n        | CFG cfg ->\r\n            GR (PolyBasic.cfg2gr cfg) \r\n        | GR gr ->\r\n            GR gr\r\n        | TM tm ->\r\n            GR (PolyBasic.tm2gr tm)\r\n        | PDA pda ->\r\n            let cfg = PolyBasic.pda2cfg pda in\r\n            GR (PolyBasic.cfg2gr cfg)\r\n        | FA fa ->\r\n            let cfg = PolyBasic.fa2cfg fa in\r\n            GR (PolyBasic.cfg2gr cfg)\r\n        | RE re ->\r\n            let cfg = PolyBasic.re2cfg re in\r\n            GR (PolyBasic.cfg2gr cfg)\r\n        | _ -> Error.fatal \"comp2GRcomp\"\r\n (*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ *)\r\n   (* tranforms a composition of elements to a composition of Pushdown Automata *)\r\n   (*Pre: c isPDAConvertivel*)\t\t\r\n   let rec comp2PDAcomp (c: t): t =\r\n     match c with\r\n       | Plus (a,b) ->\r\n           Plus (comp2PDAcomp a, comp2PDAcomp b)\r\n       | Seq (a,b) ->\r\n           Seq (comp2PDAcomp a, comp2PDAcomp b)\r\n       | Intersect (a,b) ->\r\n           Intersect (comp2PDAcomp a, comp2PDAcomp b)\r\n       | Star t ->\r\n           Star (comp2PDAcomp t)\r\n       | CFG cfg ->\r\n           PDA (PolyBasic.cfg2pda cfg)\r\n      | GR gr -> (*PEDRO CARLOS *)\r\n          let cfg = PolyBasic.gr2cfg gr in (*PEDRO CARLOS *)\r\n          PDA (PolyBasic.cfg2pda cfg) (*PEDRO CARLOS *)\r\n       | PDA pda ->\r\n           PDA pda\r\n       | FA fa ->\r\n           PDA (PolyBasic.fa2pda fa)\t\t\r\n       | RE re ->\r\n           PDA (PolyBasic.re2pda re)\t\t\t\t\r\n       | _ -> Error.fatal \"comp2PDAcomp\"\r\n   \r\n   (* tranforms a composition of elements to a composition of Turing Machine*)\r\n   (*Pre: c isTMConvertivel*)\t\t\r\n   let rec comp2TMcomp (c: t): t =\r\n     match c with\r\n       | Plus (a,b) ->\r\n           Plus (comp2TMcomp a, comp2TMcomp b)\r\n       | Seq (a,b) ->\r\n           Seq (comp2TMcomp a, comp2TMcomp b)\r\n       | Intersect (a,b) ->\r\n           Intersect (comp2TMcomp a, comp2TMcomp b)\r\n       | Star t ->\r\n           Star (comp2TMcomp t)\r\n       | CFG cfg ->\r\n           TM (PolyBasic.cfg2tm cfg)\r\n       (* | GR gr -> (*PEDRO CARLOS *)\r\n          TM (PolyBasic.gr2tm gr) (*PEDRO CARLOS VER@!!!*)\t\t\t *)\r\n       | PDA pda ->\r\n           TM (PolyBasic.pda2tm pda)\t\r\n       | FA fa ->\r\n           TM (PolyBasic.fa2tm fa)\t\r\n       | RE re ->\r\n           TM (PolyBasic.re2tm re)\r\n       | TM tm ->\r\n         TM tm\t\t\t\r\n       | _ -> Error.fatal \"comp2PDAcomp\"\r\n\r\n\r\n   (* calculate a composition of elements into a finite automaton *)\r\n   let evalMixFA (c:t) : FiniteAutomaton.t = \r\n     let c1  = comp2facomp c in\r\n     let c2 = rename c1 in\r\n     calcEvalFA c2\r\n \r\n   (* calculate a composition of elements into a Regular Expression *)\r\n   let evalMixRE (c:t) : RegularExpression.t = \r\n     let c1  = comp2recomp c in\r\n     calcEvalRE c1\r\n \r\n   (* calculate a composition of elements into a Context Free Grammar *)\r\n   let evalMixCFG (c:t) : ContextFreeGrammarBasic.t = \r\n     let c1  = comp2CFGcomp c in\r\n     let c2 = rename c1 in\r\n     calcEvalCFG c2\r\n \r\n   (* calculate a composition of elements into a Pushdown Automata *)\r\n   let evalMixPDA (c:t) : PushdownAutomaton.t = \r\n     let c1  = comp2PDAcomp c in\r\n     let c2 = rename c1 in\r\n     calcEvalPDA c2\r\n \r\n   (* calculate a composition of elements into a Turing Machine *)\r\n   let evalMixTM (c:t) : TuringMachine.t = \r\n     let c1  = comp2TMcomp c in\r\n     let c2 = rename c1 in\r\n     calcEvalTM c2\r\n\r\n       (* calculate a composition of elements into a Grammar *)\r\n    (*PEDRO CARLOS+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ *)\r\n    let evalMixGR (c:t) : Grammar.t = \r\n      let c1  = comp2GRcomp c in\r\n      let c2 = rename c1 in\r\n      calcEvalGR c2\r\n    (*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ *)\r\n\r\n   (*auxiliar functions*)\r\n\tlet fx a =\t\r\n\t\tmatch a with\r\n\t\t| (s,[symb],nextS,[nextSymb],[dir]) -> symb == nextSymb && dir == R\r\n\t\t| _ -> failwith \"fx\"\r\n\tlet isTM2FA (tm : TuringMachine.t) : bool =\r\n\t\tSet.for_all fx tm.transitions\r\n \r\n   (* checks if a composition of elements is convertivel to Finite Automaton *)\r\n   let rec isFAConvertivel(c:t): bool =\r\n     match c with\r\n       | Plus (a,b) ->\r\n         isFAConvertivel a && isFAConvertivel b\r\n       | Seq (a,b) ->\r\n         isFAConvertivel a && isFAConvertivel b\r\n       | Intersect (a,b) ->\r\n         isFAConvertivel a && isFAConvertivel b\r\n       | Star t ->\r\n         isFAConvertivel t\r\n       | FA fa -> \r\n         true\r\n       | RE re ->\r\n         true\r\n       | CFG cfg ->\r\n         let cfgobj = new ContextFreeGrammarBasic.model (Representation cfg) in\r\n         cfgobj#isRegular\r\n        | GR gr -> (*PEDRO CARLOS*)\r\n          let cfg = PolyBasic.gr2cfg gr in(*PEDRO CARLOS*)\r\n          let cfgobj = new ContextFreeGrammarBasic.model (Representation cfg) in(*PEDRO CARLOS*)\r\n          Grammar.isContextFreeGrammar gr && cfgobj#isRegular(*PEDRO CARLOS*)\r\n       | PDA pda ->\r\n         let pdaobj = new PushdownAutomaton.model (Representation pda) in\r\n         pdaobj#isFiniteAutomaton\r\n       | TM tm ->\r\n         isTM2FA tm\r\n       | _ -> \r\n         false\r\n \r\n   (* checks if a composition of elements is convertivel to Regular Expression *)\t\t\t\r\n   let rec isREConvertivel(c:t): bool =\r\n     match c with\r\n       | Plus (a,b) ->\r\n         isREConvertivel a && isREConvertivel b\r\n       | Seq (a,b) ->\r\n         isREConvertivel a && isREConvertivel b\r\n       | Intersect (a,b) ->\r\n         isREConvertivel a && isREConvertivel b\r\n       | Star t ->\r\n         isFAConvertivel t\r\n       | FA fa -> \r\n         true\r\n       | RE re ->\r\n         true\r\n       | CFG cfg -> \r\n         let cfgobj = new ContextFreeGrammarBasic.model (Representation cfg) in\r\n         cfgobj#isRegular\r\n        | GR gr -> (*PEDRO CARLOS*)\r\n          let cfg = PolyBasic.gr2cfg gr in(*PEDRO CARLOS*)\r\n          let cfgobj = new ContextFreeGrammarBasic.model (Representation cfg) in(*PEDRO CARLOS*)\r\n          Grammar.isContextFreeGrammar gr && cfgobj#isRegular(*PEDRO CARLOS*)\r\n       | PDA pda ->\r\n         let pdaobj = new PushdownAutomaton.model (Representation pda) in\r\n         pdaobj#isFiniteAutomaton\r\n       | TM tm ->\r\n         isTM2FA tm\r\n       | _ -> \r\n         false\r\n \r\n   (* checks if a composition of elements is convertivel to Context free grammar *)\r\n   let rec isCFGConvertivel(c:t): bool =\r\n     match c with\r\n       | Plus (a,b) ->\r\n         isCFGConvertivel a && isCFGConvertivel b\r\n       | Seq (a,b) ->\r\n         isCFGConvertivel a && isCFGConvertivel b\r\n       | Intersect (a,b) ->\r\n         isCFGConvertivel a && isCFGConvertivel b\r\n       | Star t ->\r\n         isCFGConvertivel t\r\n       | GR gr -> (*PEDRO CARLOS*)\r\n         Grammar.isContextFreeGrammar gr(*PEDRO CARLOS*)\r\n       | CFG fa -> \r\n         true\r\n       | PDA re ->\r\n         true\r\n       | FA fa ->\r\n         true\r\n       | RE re ->\r\n         true\r\n       | _ -> \r\n         false\r\n \r\n   (* checks if a composition of elements is convertivel to pushdown automata *)\r\n   let rec isPDAConvertivel(c:t): bool =\r\n     match c with\r\n       | Plus (a,b) ->\r\n         isPDAConvertivel a && isPDAConvertivel b\r\n       | Seq (a,b) ->\r\n         isPDAConvertivel a && isPDAConvertivel b\r\n       | Intersect (a,b) ->\r\n         isPDAConvertivel a && isPDAConvertivel b\r\n       | Star t ->\r\n         isPDAConvertivel t\r\n       | CFG cfg -> \r\n         true\r\n       | GR gr -> (*PEDRO CARLOS*)\r\n         Grammar.isContextFreeGrammar gr(*PEDRO CARLOS*)\r\n       | PDA re ->\r\n         true\r\n       | FA fa ->\r\n         true\r\n       | RE re ->\r\n         true\r\n       | _ -> \r\n         false\r\n   \r\n   (* checks if a composition of elements is convertivel to turing machine *)\r\n   let rec isTMConvertivel(c:t): bool =\r\n     match c with\r\n       | Plus (a,b) ->\r\n         isTMConvertivel a && isTMConvertivel b\r\n       | Seq (a,b) ->\r\n         isTMConvertivel a && isTMConvertivel b\r\n       | Intersect (a,b) ->\r\n         isTMConvertivel a && isTMConvertivel b\r\n       | Star t ->\r\n         isTMConvertivel t\r\n       | CFG cfg -> \r\n         true\r\n        | GR gr -> (*PEDRO CARLOS*)\r\n          true(*PEDRO CARLOS*)\r\n       | PDA re ->\r\n         true\r\n       | FA fa ->\r\n         true\r\n       | RE re ->\r\n         true\r\n       | TM tm ->\r\n         true\r\n       | _ -> \r\n         false\r\n \r\n      (*PEDRO CARLOS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ *)\r\n    (* checks if a composition of elements is convertivel to grammar *)\r\n    let rec isGRConvertivel(c:t): bool =\r\n      match c with\r\n        | Plus (a,b) ->\r\n        isGRConvertivel a && isGRConvertivel b\r\n        | Seq (a,b) ->\r\n        isGRConvertivel a && isGRConvertivel b\r\n        | Intersect (a,b) ->\r\n        isGRConvertivel a && isGRConvertivel b\r\n        | Star t ->\r\n        isGRConvertivel t\r\n        | CFG cfg -> \r\n          true\r\n         | GR gr ->\r\n           true\r\n        | PDA re ->\r\n          true\r\n        | FA fa ->\r\n          true\r\n        | RE re ->\r\n          true\r\n        | TM tm ->\r\n          true\r\n        | _ -> \r\n          false\r\n       (*PEDRO CARLOS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ *)\r\n\r\n   let isFA (c:t) : bool =\r\n     match c with \r\n       | FA _ -> true\r\n       | _ -> false\r\n \r\n   (*transforms everything in type t *)\r\n   let rec transformt (c: t) : t =\r\n     match c with\r\n       | Plus (a,b) ->\r\n         Plus (transformt a, transformt b)\r\n       | Seq (a,b) ->\r\n         Seq (transformt a, transformt b)\r\n       | Intersect (a,b) ->\r\n         Intersect (transformt a, transformt b)\r\n       | Star t ->\r\n         Star (transformt t)\r\n       | FA fa -> \r\n         FA fa\r\n       | RE re ->\r\n         RE re\r\n       | CFG cfg -> \r\n         CFG cfg\r\n       | GR gr -> (*PEDRO CARLOS *)\r\n         GR gr(*PEDRO CARLOS *)\r\n       | GRO gro -> (*PEDRO CARLOS *)\r\n         GR gro#representation(*PEDRO CARLOS *)\r\n       | PDA pda ->\r\n         PDA pda\r\n       | FAO fao ->\r\n         FA fao#representation\r\n       | REO reo ->\r\n         RE reo#representation\r\n       | CFGO cfgo ->\r\n         CFG cfgo#representation\r\n       |\tPDAO pdao ->\r\n         PDA pdao#representation \r\n       | Rep str ->\r\n         (try\r\n           let m = Repository.get str in\r\n             transformt m\r\n         with Not_found -> Error.fatal \"Composition with invalid repository name\")\r\n       | _ -> \r\n         Error.fatal \"transformt\"\r\n \r\n \r\n   \r\n   (* calculate a composite finite automaton given a composition of elements *)\t\t\r\n   let evalFA (c: t) : FiniteAutomaton.t  =\r\n     let c1 = transformt c in\r\n     match isFAConvertivel c1 with\r\n       | true -> evalMixFA c1 \r\n       | false -> Error.fatal \"evalFA\"\r\n \r\n   (* calculate a composite regular expression given a composition of elements *)\t\t\r\n   let evalRE (c: t) : RegularExpression.t  =\r\n     let c1 = transformt c in\r\n     match isREConvertivel c1 with\r\n       | true -> evalMixRE c1\r\n       | false -> Error.fatal \"evalRE\"\r\n \r\n   (* calculate a composite context free grammar given a composition of elements *)\t\t\r\n   let evalCFG (c: t) : ContextFreeGrammarBasic.t  =\r\n     let c1 = transformt c in\r\n     match isCFGConvertivel c1 with\r\n       | true -> evalMixCFG c1\r\n       | false -> Error.fatal \"evalCFG\"\r\n\r\n  (*PEDRO CARLOS+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*)\r\n\r\n  let evalGR (c: t) : Grammar.t  =\r\n    let c1 = transformt c in\r\n    match isGRConvertivel c1 with\r\n      | true -> evalMixGR c1\r\n      | false -> Error.fatal \"evalGR\"\r\n\r\n\r\n (*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*)\r\n   (* calculate a composite pushdown automata given a composition of elements *)\t\t\r\n   let evalPDA (c: t) : PushdownAutomaton.t  =\r\n     let c1 = transformt c in\r\n     match isPDAConvertivel c1 with\r\n       | true -> evalMixPDA c1\t\t\t\t\t\t\t\t\t\t\t\r\n       | false -> Error.fatal \"evalPDA\"\r\n \r\n   (* calculate a composite turing machine given a composition of elements *)\r\n   let evalTM (c: t) : TuringMachine.t  =\r\n     let c1 = transformt c in\r\n     match isTMConvertivel c1 with\r\n       | true -> evalMixTM c1\t\t\t\t\t\t\t\t\t\t\t\r\n       | false -> Error.fatal \"evalTM\"\r\n \r\n   let setRep (c: t) (name: string) : unit  = \r\n     Repository.update name c\r\n   \r\n   let getRep (name: string) : t =\r\n     try\r\n       Repository.get name\r\n     with Not_found -> Error.fatal \"getRep\"\r\n \r\n         \r\n   let findRep (name: string ) : bool = \r\n     Repository.exists name\r\n \r\n   let validate (name: string) (comp: t) : unit = ()\r\n \r\n\r\n   \r\n  let make2 (arg: t Arg.alternatives): Entity.t * t = make2 arg validate\r\n\tlet make (arg: t Arg.alternatives): t = make arg validate\r\n\r\n\r\n   let _ = makeCompositionRef := make\r\n\t(* Exercices support *)\r\n  let checkProperty (comp: t) (prop: string) =\r\n\t\tmatch prop with\r\n\t\t\t| \"composition\" -> true\r\n\t\t\t| _ -> Model.checkProperty prop\r\n\r\n\tlet checkExercise ex comp = Model.checkExercise ex (accept comp) (checkProperty comp)\t\r\n\tlet checkExerciseFailures ex comp = Model.checkExerciseFailures ex (accept comp) (checkProperty comp)\r\n\r\n   (* Class *)\r\n   class model (arg: t Arg.alternatives) =\r\n     object(self) inherit Model.model (make2 arg) as super\t\r\n     (* Representation *)\r\n       method representation = representation\r\n     (* Kind *)\r\n\t\t\tmethod isComposition : bool = true\r\n     (* Show *)\t\t\t\r\n       method toJSon: JSon.t = toJSon representation \r\n       method toJSon2: JSon.t = toJSon2 id representation\r\n       method show: unit = show representation\r\n       method show2: unit = show2 id representation\r\n \r\n       method accept (w: word): bool = accept representation w\r\n \r\n       method generate (length: int): words = generate representation length\r\n    \r\n       method evalFA : FiniteAutomaton.t = evalFA representation\r\n\r\n       method evalPDA : PushdownAutomaton.t = evalPDA representation\r\n\r\n       method evalRE : RegularExpression.t = evalRE representation\r\n\r\n       method evalCFG : ContextFreeGrammarBasic.t = evalCFG representation\r\n       \r\n       method evalTM : TuringMachine.t = evalTM representation\r\n\r\n       method evalGR : Grammar.t = evalGR representation\r\n\r\n     (* Ops *)(*\r\n       method acceptBreadthFirst (w: word): bool = acceptBreadthFirst representation w\r\n       method accept (w: word): bool = accept representation w\r\n       method acceptFull (w: word) : bool * path * trail = acceptFull representation w\r\n \r\n       method acceptWithTracing (w:word): unit = acceptWithTracing representation w\r\n       method generate (length: int): words = generate representation length\r\n       method generateUntil (length: int): words = generateUntil representation length\r\n \r\n       method reachable (s:state): states = reachable representation s\r\n       method productive: states = productive representation\r\n       method getUsefulStates: states = getUsefulStates representation\r\n       method getUselessStates: states = getUselessStates representation\r\n       method cleanUselessStates: model =\r\n         let fa = cleanUselessStates representation in\r\n           new model (Arg.Representation fa)\r\n       method areAllStatesUseful: bool = areAllStatesUseful representation\r\n \r\n       method toDeterministic: model =\r\n         let fa = toDeterministic representation in\r\n           new model (Arg.Representation fa)\r\n       method isDeterministic: bool = isDeterministic representation\r\n \r\n       method equivalencePartition: states set = equivalencePartition representation\r\n       method minimize: model =\r\n         let fa = minimize representation in\r\n           new model (Arg.Representation fa)\r\n       method isMinimized: bool = isMinimized representation*)\r\n     (* Exercices support *)\r\n       method checkProperty (prop: string) =  checkProperty representation prop\r\n       \r\n     (* Learn-OCaml support *)\r\n       method moduleName = \"\"\r\n       method xTypeName = \"\"\r\n       method xTypeDeclString : string = \"\"\r\n       method toDisplayString (name: string): string = \"\"\r\n       method example : JSon.t = JNull\r\n       \r\n     end\r\n               \r\n    \r\n end\r\n \r\n \r\n\r\n\r\n# 3 \"src/TopLevel.ml\"\r\n(*\r\n * TopLevel.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by João Gonçalves (jg)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * feb/2021 (amd) - Added some missing functions.\r\n * feb/2020 (jg) - Initial version.\r\n *)\r\n\r\n(*\r\n * Description: Set of functions with simple signatures to the used in the\r\n * ocaml toplevel system. In a sense, this provides a command-line interface\r\n * to most of the functionalities of the OCamlFLAT library.\r\n *\r\n * TODO: Improve.\r\n *)\r\n\r\n(*\r\n\r\nlet f str =\r\n\tlet r = fa_accept fa str in\r\n\tlet q = stats() in\r\n\tlet t = fa_acceptTrail fa str in\r\n\tlet x = stats() in\r\n\tlet p = fa_acceptPath fa str in\r\n\tlet y = stats() in\r\n\tlet (_,p1,t1) = fa_acceptFull fa str in\r\n\tlet z = stats() in\r\n\tlet w =  if t = t1 && p = p1 then \"OK\" else \"BAD\" in\r\n\t\t(r,q,x,y,z,w)\r\n;;\r\n\r\n#print_depth 10000;;\r\n#print_length 10000;;\r\n\r\n\r\n*)\r\n\r\nopen FiniteAutomatonTop\r\n\r\n\r\n# 1 \"src/LearnOCaml.ml\"\r\n(*\r\n * LearnOCaml.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias, Rita Macedo (amd, rm)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * jul/2021 (amd) - Added semantic validation of the student's solution.\r\n * jun/2021 (amd) - Added support for typed student answers in the file\r\n *                  \"template.ml\". Many improvements in the implementation,\r\n *                  and managed to get rid of many technical\r\n *                  complexities in the file \"template.ml\".\r\n * mar/2021 (amd, rm) - Initial version\r\n *)\r\n\r\n(*\r\n * Description: This module helps in the use of the OCamlFLAT library\r\n * inside Learn-OCaml (the platform for learning the OCaml language). The goal\r\n * is to support FLAT related exercises inside Learn-OCaml. \r\n *  \r\n * As for FLAT exercises developed for current text-based interaction of\r\n * Learn-OCaml, our current approach is to avoid changing Learn-OCaml\r\n * itself.\r\n * \r\n * The current solution comprehends:\r\n *\r\n * - A technique that allows the OCamlFLAT library to be available inside the\r\n *   exercise environment of Learn-OCaml (via the file \"prepare.ml\").\r\n *   \r\n * - The idea of reducing FLAT model analysis to OCaml function analysis. This\r\n *   allows us to represent FLAT exercises using what is available in\r\n *   Learn-OCaml, without changing anything in Learn-OCaml.\r\n *   \r\n * - This module, which supplies some functions that helps in\r\n *   the creation by hand of FLAT exercises following the conventions\r\n *   of Learn-OCaml.\r\n *   \r\n * - A translator from the OCamlFLAT exercise format to the Learn-OCaml\r\n *   exercise format. The translator generates a directory containing all\r\n *   the usual files: \"template.ml\", \"solution.ml\", \"meta.json\", etc.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule type LearnOCamlSig =\r\nsig\r\n\tval setOCamlFlatDir : string -> unit\r\n\tval setExercicesDir : string -> unit\r\n\tval setExerciceName : string -> unit\r\n\tval processAnswer : Model.model\r\n\t\t\t\t\t-> Exercise.exercise -> (string * int) list\r\n\tval decl2json : string -> JSon.t\r\n\tval generateExerciseDir : JSon.t -> JSon.t -> bool -> unit\r\nend\r\n\r\nmodule LearnOCaml : LearnOCamlSig =\r\nstruct\r\n\t(* ----- Dir/File management ----- *)\r\n\tlet oCamlFlatDir = ref \"\"\r\n\tlet exercicesDir = ref \"\"\r\n\tlet exerciceName = ref \"\"\t\t\r\n\r\n\tlet setOCamlFlatDir dirname =\r\n\t\toCamlFlatDir := Util.handleHomeDir dirname\r\n\r\n\tlet setExercicesDir dirname =\r\n\t\texercicesDir := Util.handleHomeDir dirname\r\n\r\n\tlet setExerciceName filename =\r\n\t\texerciceName := filename\r\n\r\n\tlet initialize () =\r\n\t\tif !oCamlFlatDir = \"\" then\r\n\t\t\tbegin\r\n\t\t\t\tsetOCamlFlatDir\r\n\t\t\t\t\t\"~/work/OCamlFlat\";\r\n\t\t\t\tsetExercicesDir\r\n\t\t\t\t\t\"~/work/learn-test/my-learn-ocaml-repository/exercises\";\r\n\t\t\t\tsetExerciceName\r\n\t\t\t\t\t\"default\"\r\n\t\t\tend\r\n\r\n\tlet libFile () =\r\n\t\t!oCamlFlatDir ^ \"/lib/OCamlFlat.ml\"\r\n\r\n\tlet targetDir () =\r\n\t\t!exercicesDir ^ \"/\" ^ !exerciceName\r\n\t\r\n\tlet targetFile fileName =\r\n\t\ttargetDir () ^ \"/\" ^ fileName\r\n\t\r\n\tlet adjust txt =\r\n\t\tUtil.stripHead txt\r\n \r\n\tlet createTargetDir () =\r\n\t\tignore (Sys.command (\"mkdir -p \" ^ targetDir ()) )\r\n\r\n\tlet createTargetFile fileName text =\r\n\t\tlet co = open_out (targetFile fileName) in\r\n\t\tlet text = adjust text in\r\n\t\tbegin\r\n\t\t\toutput_string co text;\r\n\t\t\tclose_out co\r\n\t\tend\r\n\r\n\tlet getExerciceDirContents () =\r\n\t\tArray.to_list (Sys.readdir !exercicesDir)\r\n\t\r\n\t(* ----- Utility functions ----- *)\r\n\tlet processUnitTest m expected w =\r\n\t\t\t(word2str w, expected, m#accept w = expected)\r\n\r\n\tlet semanticValidation (m: Model.model) =\r\n\t\tm#errors\r\n\r\n\tlet convertSemanticValidationResult mesg =\r\n\t\t\t(mesg, 0)\r\n\r\n\tlet processUnitTests (m: Model.model) (e: Exercise.exercise) =\r\n\t\tlet open Exercise in\r\n\t\tlet rep = e#representation in\r\n\t\t\tList.map (processUnitTest m true) (Set.toList rep.inside)\r\n\t\t\t@\r\n\t\t\tList.map (processUnitTest m false) (Set.toList rep.outside)\r\n\t\t\t\r\n\tlet convertUnitTestResult (word, acceptance, passed) =\r\n\t\tlet ar = if acceptance then \"Acceptance\" else \"Rejection\" in\r\n\t\tlet pf = if passed then \"passed\" else \"failed\" in\r\n\t\tlet points = if passed then 1 else 0 in\r\n\t\t\t(ar ^ \" of word \\\"\" ^ word ^ \"\\\" \" ^ pf, points)\r\n\r\n\tlet processProperty m p =\r\n\t\t(p, m#checkProperty p)\r\n\t\r\n\tlet processProperties (m: Model.model) (e: Exercise.exercise) =\r\n\t\tlet open Exercise in\r\n\t\tlet rep = e#representation in\r\n\t\tlet props = Set.toList rep.properties in\r\n\t\t\tList.map (processProperty m) props\t\r\n\t\t\r\n\tlet convertPropertyResult (property, passed) =\r\n\t\tlet pf = if passed then \"passed\" else \"failed\" in\r\n\t\tlet points = if passed then 3 else 0 in\r\n\t\t\t(\"Property \\\"\" ^ property ^ \"\\\" \" ^ pf, points)\r\n\r\n\tlet finalResult0 res =\r\n\t\t[(\"###  Checking for static semantic errors...\", -999)]\r\n\t\t@ res\r\n\t\t@ [(\"### Errors found\", -999)]\r\n\r\n\tlet finalResult1 res1 res2 =\r\n\t\t[]\r\n\t\t@ [(\"###  Checking for static semantic errors...\", -999)]\r\n\t\t@ [(\"### Checking unit tests...\", -999)]\r\n\t\t@ res1\r\n\t\t@ [(\"### Checking properties...\", -999)]\r\n\t\t@ res2\r\n\t\t@ [(\"### Done\", -999)]\r\n\r\n\tlet processAnswer (m: Model.model) (e: Exercise.exercise) =\r\n\t\tlet semanticValidationResults = semanticValidation m in\r\n\t\tlet res0 = List.map convertSemanticValidationResult semanticValidationResults in\r\n\t\tif res0 <> [] then\r\n\t\t\tfinalResult0 res0\r\n\t\telse\r\n\t\t\tlet unitTestsResults = processUnitTests m e in\r\n\t\t\tlet res1 = List.map convertUnitTestResult unitTestsResults in\r\n\t\t\tlet propertyResults = processProperties m e in\r\n\t\t\tlet res2 = List.map convertPropertyResult propertyResults in\r\n\t\t\t\tfinalResult1 res1 res2\r\n\r\n\tlet stdKind kind =\r\n\t\tmatch kind with\r\n\t\t| \"finiteAutomaton\" | \"FiniteAutomaton.tx\" ->\r\n\t\t\tFiniteAutomaton.kind\r\n\t\t| \"regularExpression\" | \"RegularExpression.tx\" ->\r\n\t\t\tRegularExpression.kind\r\n\t\t| \"ContextFreeGrammarBasic\" | \"ContextFreeGrammarBasic.tx\" ->\r\n\t\t\tContextFreeGrammarBasic.kind\r\n\t\t| \"finiteEnumeration\" | \"FiniteEnumeration.tx\" ->\r\n\t\t\tFiniteEnumeration.kind\r\n\t\t| _ ->\r\n\t\t\t\"*** invalid ***\"\r\n\r\n\tlet completeJSon kind j  =\r\n\t\tmatch kind with\r\n\t\t| \"regularExpression\" | \"RegularExpression.tx\" ->\r\n\t\t\tJSon.makeAssoc [(\"re\", j)]\r\n\t\t| \"finiteEnumeration\" | \"FiniteEnumeration.tx\" ->\r\n\t\t\tJSon.makeAssoc [(\"words\", j)]\r\n\t\t| _ ->\r\n\t\t\tj\r\n\r\n\tlet decl2json s =\r\n\t\ttry\r\n\t\t\tlet a = String.index_from s 0 ':' in\r\n\t\t\tlet b = String.index_from s a '=' in\r\n\t\t\tlet kind = String.trim (String.sub s (a+1) (b-a-1)) in\r\n\t\t\tlet ocamlExp = String.sub s (b+1) (String.length s -b-1) in\r\n\t\t\tlet jExp = JSon.parseOon ocamlExp in\r\n\t\t\tlet mainJSon = completeJSon kind jExp in\r\n\t\t\tlet jHead = Entity.toJSon (Entity.dummyId (stdKind kind)) in\r\n\t\t\t\tJSon.append jHead mainJSon\r\n\t\twith _ ->\r\n\t\t\tJSon.JNull\r\n\t\r\n\t(* ----- FILE descr.html ----- *)\r\n\tlet fileName =\r\n\t\t\"descr.html\"\r\n\t\r\n\tlet contents (exercise: JSon.t) =\r\n\t\tPrintf.sprintf\r\n{ooo_descr_html_ooo|\r\n\t\t<h3> %s </h3>\r\n\t\t<p> %s </p>\r\n|ooo_descr_html_ooo}\r\n\t\t(JSon.fieldString exercise \"description\")\r\n\t\t(JSon.fieldString exercise \"problem\")\r\n\t\r\n\tlet generateFile_Descr (exercise: JSon.t) =\r\n\t\tlet text = contents exercise in\r\n\t\t\tcreateTargetFile fileName text\r\n\r\n\t(* ----- FILE meta.json ----- *)\r\n\tlet fileName =\r\n\t\t\"meta.json\"\r\n\t\t\r\n\tlet contents (exercise: JSon.t) =\r\n\t\tPrintf.sprintf\r\n\t{ooo_meta_json_ooo|\r\n\t\t{\r\n\t\t  \"learnocaml_version\" : \"1\",\r\n\t\t  \"kind\" : \"exercise\",\r\n\t\t  \"stars\" : 0,\r\n\t\t  \"title\" : \"%s\"\r\n\t\t}\r\n\t|ooo_meta_json_ooo}\r\n\t\t(JSon.fieldString exercise \"description\")\r\n\t\r\n\tlet generateFile_Meta (exercise: JSon.t) =\r\n\t\tlet text = contents exercise in\r\n\t\t\tcreateTargetFile fileName text\r\n\r\n\t(* ----- FILE prelude.ml ----- *)\r\n\tlet fileName =\r\n\t\t\"prelude.ml\"\r\n\r\n\tlet generateFile_Prelude (solution: Model.model) =\r\n\t\tlet text = solution#xTypeDeclString in\r\n\t\t\tcreateTargetFile fileName text\r\n\t\r\n\t(* ----- FILE prepare.ml ----- *)\r\n\tlet fileName =\r\n\t\t\"prepare.ml\"\r\n\r\n\tlet generateFile_Prepare () =\r\n\t\tlet cmd = \"cp -a \" ^ libFile () ^ \" \" ^ targetFile fileName in\r\n\t\t\tignore (Sys.command cmd)\r\n\r\n\t(* ----- FILE solution.ml ----- *)\r\n\tlet fileName =\r\n\t\t\"solution.ml\"\r\n\r\n\tlet contentsJSon (solution: Model.model) =\r\n\t\tPrintf.sprintf\r\n\t{ooo_solution_ml_ooo|\r\n\t\tlet solution = {| %s |}\r\n\t|ooo_solution_ml_ooo}\r\n\t\t(JSon.toStringN 2 solution#toJSon)\r\n\r\n\tlet contents (solution: Model.model) =\r\n\t\tlet signature = \"\\n\\t\\t(* OCamlFlat exercise *)\" in\r\n\t\tlet body = solution#toDisplayString \"solution\" in\r\n\t\t\tsignature ^ body\r\n\t\r\n\tlet generateFile_Solution (solution: Model.model) useJSon =\r\n\t\tlet text =\r\n\t\t\tif useJSon then contentsJSon solution\r\n\t\t\telse contents solution\r\n\t\tin\r\n\t\t\tcreateTargetFile fileName text\r\n\r\n\t(* ----- FILE template.ml ----- *)\r\n\tlet fileName =\r\n\t\t\"template.ml\"\r\n\r\n\tlet contentsJSon (solution: Model.model) =\r\n\t\tPrintf.sprintf\r\n\t{ooo_template_ml_json_ooo|\r\n\t\t(* Write your solution below, by using the provided example as a template *)\r\n\r\n\t\tlet solution = {| %s |}\r\n\t|ooo_template_ml_json_ooo}\r\n\t\t(JSon.toStringN 2 solution#example)\r\n\r\n\tlet contents (solution: Model.model) =\r\n\t\tPrintf.sprintf\r\n\t{ooo_template_ml_ooo|\r\n\t\t(* Write your solution below, by using the provided example as a template *)\r\n\t\t%s|ooo_template_ml_ooo}\t(* please, do not change this *)\r\n\t\t((PolyModel.json2model solution#example)#toDisplayString \"solution\")\r\n\r\n\tlet generateFile_Template (solution: Model.model) useJSon =\r\n\t\tlet text =\r\n\t\t\tif useJSon then contentsJSon solution\r\n\t\t\t\t\t\telse contents solution\r\n\t\tin\r\n\t\t\tcreateTargetFile fileName text\r\n\r\n\t(* ----- FILE test.ml ----- *)\r\n\tlet fileName =\r\n\t\t\"test.ml\"\r\n\t\r\n\tlet exercisePart (exercise: JSon.t) =\r\n\t\tPrintf.sprintf\r\n\t{ooo_exercise_ooo|\r\n\t\tlet exercise = {| %s |}\r\n\t|ooo_exercise_ooo}\r\n\t\t(JSon.toStringN 2 exercise)\r\n\r\n\tlet handleAnswerPartJSon =\r\n\t\tPrintf.sprintf\r\n\t{ooo_handle_answer_json_ooo|\r\n\t\tlet handleAnswer (): Learnocaml_report.t =\r\n\t\t\ttest_variable_property\r\n\t\t\t\t[%%ty: string]\r\n\t\t\t\t\"solution\"\r\n\t\t\t\t(fun solution ->\r\n\t\t\t\t\tcheckAnswer\r\n\t\t\t\t\t\t(PolyModel.text2model solution)\r\n\t\t\t\t\t\t(new Exercise.exercise (Arg.Text exercise))\r\n\t\t\t\t)\r\n\t|ooo_handle_answer_json_ooo}\r\n\t\r\n\tlet handleAnswerPart (solution: Model.model) =\r\n\t\tPrintf.sprintf\r\n\t{ooo_handle_answer_ooo|\r\n\t\tlet handleAnswer (): Learnocaml_report.t =\r\n\t\t\ttest_variable_property\r\n\t\t\t\t[%%ty: %s]\r\n\t\t\t\t\"solution\"\r\n\t\t\t\t(fun solution ->\r\n\t\t\t\t\tcheckAnswer\r\n\t\t\t\t\t\t((new %s.model (Arg.Representation (%s.internalize solution))):\r\n\t\t\t\t\t\t\t\t\t\t%s.model :> Model.model)\r\n\t\t\t\t\t\t(new Exercise.exercise (Arg.Text exercise))\r\n\t\t\t\t)\r\n\t|ooo_handle_answer_ooo}\r\n\tsolution#xTypeName\r\n\tsolution#moduleName\r\n\tsolution#moduleName\r\n\tsolution#moduleName\r\n\t\t\r\n\tlet contents exerciseText handleAnswerText =\r\n\t\tPrintf.sprintf\r\n\t{ooo_test_ml_ooo|\r\n\t\topen Test_lib\r\n\t\topen Report\r\n\t\t%s\r\n\t\tlet convertResult (diagnostic, points) =\r\n\t\t\tmatch points with\r\n\t\t\t| _ when points > 0 ->\r\n\t\t\t\tMessage ([Text diagnostic], Success points)\r\n\t\t\t| -999 ->\r\n\t\t\t\tMessage ([Break; Text diagnostic], Informative)\r\n\t\t\t| _ ->\r\n\t\t\t\tMessage ([Text diagnostic], Failure)\r\n\t\t\r\n\t\tlet checkAnswer (m: Model.model) (e: Exercise.exercise) =\r\n\t\t\tlet res = LearnOCaml.processAnswer m e in\r\n\t\t\t\tList.map convertResult res\r\n\t\t%s\r\n\t\tlet () =\r\n\t\t\tset_result @@\r\n\t\t\tast_sanity_check code_ast @@\r\n\t\t\thandleAnswer\r\n\t|ooo_test_ml_ooo}\r\n\t\texerciseText\r\n\t\thandleAnswerText\r\n\r\n\tlet generateFile_Test (exercise: JSon.t) (solution: Model.model) useJSon =\r\n\t\tlet ex = exercisePart exercise in\r\n\t\tlet hs =\r\n\t\t\tif useJSon then handleAnswerPartJSon\r\n\t\t\telse handleAnswerPart solution\r\n\t\tin\r\n\t\tlet text = contents ex hs\r\n\t\tin\r\n\t\t\tcreateTargetFile fileName text\t\r\n\r\n\t(* ----- FILE index.json ----- *)\r\n\tlet fileName =\r\n\t\t\"../index.json\"\r\n\t\t\r\n\tlet contents (l: string list) =\r\n\t\tPrintf.sprintf\r\n\t{ooo_index_json_ooo|\r\n\t\t{\r\n\t\t  \"learnocaml_version\" : \"1\",\r\n\t\t  \"groups\" : { \"OCamlFLAT\": {\r\n\t\t    \"title\": \"OCamlFLAT exercise pack for Learn-OCaml\",\r\n\t\t    \"exercises\": %s\r\n\t\t  } }\r\n\t\t}\r\n\t|ooo_index_json_ooo}\r\n\t\t(stringsD l)\r\n\t\r\n\tlet generateFile_Index () =\r\n\t\tlet l = getExerciceDirContents () in\r\n\t\tlet l = List.filter (fun x -> x <> \"index.json\") l in\r\n\t\tlet text = contents l in\r\n\t\tlet text = String.map (fun x -> if x = ';' then ',' else x) text in\r\n\t\t\tcreateTargetFile fileName text\r\n\r\n\t(* ----- generateExerciseDir ----- *)\r\n\t\r\n\tlet generateExerciseDir exercise solution useJSon =\r\n\t\tlet solution: Model.model = PolyModel.json2model solution in\r\n\t\t\tinitialize ();\r\n\t\t\tcreateTargetDir ();\r\n\t\t\tgenerateFile_Descr exercise;\r\n\t\t\tgenerateFile_Meta exercise;\r\n\t\t\tgenerateFile_Prelude solution;\r\n\t\t\tgenerateFile_Prepare ();\r\n\t\t\tgenerateFile_Solution solution useJSon;\r\n\t\t\tgenerateFile_Template solution useJSon;\r\n\t\t\tgenerateFile_Test exercise solution useJSon;\r\n\t\t\tgenerateFile_Index ()\r\nend\r\n\r\n(*\r\nLearnocaml_report.t:\r\n\r\n\ttype report = item list\r\n\r\n\tand item =\r\n\t  | Section of text * report\r\n\t  (** A titled block that groups subreports *)\r\n\t  | Message of text * status\r\n\t  (** Basic report block *)\r\n\r\n\tand status =\r\n\t  | Success of int (** With given points *)\r\n\t  | Failure (** With missed points *)\r\n\t  | Warning (** A student error without influence on the grade *)\r\n\t  | Informative (** A message for the student *)\r\n\t  | Important (** An important message *)\r\n\r\n\tand text = inline list\r\n\r\n\tand inline =\r\n\t  | Text of string (** A word *)\r\n\t  | Break (** Line separator *)\r\n\t  | Code of string (** For expressions *)\r\n\t  | Output of string (** For output *)\r\n*)\r\n# 1 \"src/PreOpen.ml\"\r\nopen Examples\r\n\r\n\r\n(*\r\ntype symbol = char\r\ntype finiteAutomaton = FiniteAutomatonX.tx\r\ntype regularExpression = RegularExpression.tx\r\ntype contextFreeGrammar = ContextFreeGrammarBasic.tx\r\ntype finiteEnumeration = FiniteEnumeration.tx\r\n*)\r\n\r\n(* CHECKING *)\r\n\r\n(*\r\n\r\nlet _: finiteAutomaton =\r\n{\r\n\talphabet = ['a'];\r\n\tstates = [\"START\"];\r\n\tinitialState = \"START\";\r\n\ttransitions = [(\"START\", 'a', \"START\")];\r\n\tacceptStates = [\"START\"]\r\n}\r\n\r\nlet _: contextFreeGrammar =\r\n{\r\n\talphabet = ['['; ']'];\r\n\tvariables = ['S'];\r\n\tinitial = 'S';\r\n\trules = [\"S -> [S]\"; \"S -> SS\"; \"S -> ~\"]\r\n}\r\n*)\r\n# 1 \"src/Tests.ml\"\r\n(*\r\n * Tests.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * jan/2021 (amd) - Initial version.\r\n *)\r\n\r\n(*\r\n * Description: Set of unit tests for checking the library from time to time.\r\n *\r\n * TODO: This is only a starting point. There are already many (disabled) unit\r\n * tests in several modules and this stuff needs to be reviewed.\r\n *)\r\n\r\nmodule Tests : sig end =\r\nstruct\r\n\topen Examples\r\n\r\n\tlet active = false\r\n\r\n(*\r\n\topen TopLevel\r\n\r\n\r\n\r\n\tlet test1 () =\r\n\t\tlet a = fa_predef \"dfa_1\" in\r\n\t\t\tUtil.println [if fa_accept a \"ab\" then \"OK\" else \"ERROR\"] *)\r\n\r\n\tlet runAll =\r\n\t\tif Util.testing active \"Tests\" then begin\r\n\r\n\t\tend\r\nend\r\n# 1 \"src/JSonTests.ml\"\r\n(*\r\n * JSonTests.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * apr/2023 (amd) - New file.\r\n *)\r\n\r\n(*\r\n * Description: JSon parser tests.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule JSonTests : sig end =\r\nstruct\r\n\tlet active = false\r\n\r\n\tlet jsonSample = {| {\r\n\t\tname: {\r\n\t\t\tfirst: \"aa\",\r\n\t\t\tlast: \"22\",\r\n\t\t\tfullname: \"33\"\r\n\t\t},\r\n\t\tage: \"33\",\r\n\t\thobbies: [ \"44\", \"55\" ]\r\n\t} |}\r\n\t\r\n\tlet jsonSample2 = {| \"aa\" |}\r\n\t\r\n\tlet test0 () =\r\n\t\tlet json = JSon.parse jsonSample in\r\n\t\tlet json2 = JSon.parse jsonSample2 in\r\n\t\t\tJSon.show json; JSon.show json2\r\n\t\r\n\tlet oonSample = {| {\r\n\t\talphabet = ['a';'b'];\r\n\t\tstates = [\"START\"; \"33\"];\r\n\t\tinitialState = \"START\";\r\n\t\ttransitions = [(\"START\", 'a', \"START\"); (\"START\", 'a', \"START\")];\r\n\t\tacceptStates = [\"START\"]\r\n\t} |}\r\n\t\r\n\tlet oonSample2 = {| \"z*\" |}\r\n\r\n\tlet oonSample3 = {| (\"START\", [\"ee\"], \"yu\") |}\r\n\r\n\tlet test1 () =\r\n\t\tlet oon = JSon.parseOon oonSample in\r\n\t\tlet oon2 = JSon.parseOon oonSample2 in\r\n\t\tlet oon3 = JSon.parseOon oonSample3 in\r\n\t\t\tJSon.show oon; JSon.show oon2; JSon.show oon3\r\n\r\n\tlet test () =\r\n\t\tlet oon2 = JSon.parseOon oonSample2 in\r\n\t\t\tJSon.show oon2\r\n\r\n\tlet runAll =\r\n\t\tif Util.testing active \"JSon\" then begin\r\n\t\t\ttest ()\r\n\t\tend\r\n\r\nend\r\n# 1 \"src/FiniteEnumerationTests.ml\"\r\n(*\r\n * FiniteEnumerationTests.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by João Gonçalves (jg)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * apr/2023 (amd) - New file.\r\n *)\r\n\r\n(*\r\n * Description: Finite enumeration testing.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule FiniteEnumerationTests : sig end =\r\nstruct\r\n\topen FiniteEnumeration\r\n\r\n\tlet active = false\r\n\t\r\n\tlet fe_colors = {| {\r\n\t\tkind : \"finite enumeration\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"colors\",\r\n\t\twords : [\"Red\", \"Yellow\", \"Blue\"]\r\n\t} |}\r\n\t\r\n\tlet exer_colors = {| {\r\n\t\tkind : \"exercise\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"exer_colors\",\r\n\t\tproblem : \"Colors of length 3\",\r\n\t\tinside : [\"Red\", \"\"],\r\n\t\toutside : [\"Yellow\",\"Blue\"],\r\n\t\tproperties : [\"fail\"]\r\n\t} |}\r\n\r\n\tlet test0 () =\r\n\t\tlet (id,fe) = FiniteEnumeration.make2 (Arg.Text fe_colors) in\r\n\t\t\tUtil.sep ();\r\n\t\t\tshow2 id fe\r\n\r\n\tlet test1 () =\r\n\t\tlet fe = FiniteEnumeration.make (Arg.Text fe_colors) in\r\n\t\tlet ex = Exercise.make (Arg.Text exer_colors) in\r\n\t\tlet (ins,outs,props) = FiniteEnumeration.checkExerciseFailures ex fe in\r\n\t\t\tUtil.sep ();\r\n\t\t\tFiniteEnumeration.show fe;\r\n\t\t\tExercise.show ex;\r\n\t\t\tExercise.showRes (ins,outs,props)\r\n\r\n\tlet test2 () =\r\n\t\tlet fe = new FiniteEnumeration.model (Arg.Text fe_colors) in\r\n\t\tlet e = new Exercise.exercise (Arg.Text exer_colors) in\r\n\t\tlet (ins,outs,props) = fe#checkExerciseFailures e in\t\r\n\t\t\tUtil.sep ();\r\n\t\t\tfe#show;\r\n\t\t\te#show;\r\n\t\t\tExercise.showRes (ins,outs,props)\r\n\t\t\r\n\tlet runAll =\r\n\t\tif Util.testing active \"FiniteEnumeration\" then begin\r\n\t\t\ttest0 ();\r\n\t\t\ttest1 ();\r\n\t\t\ttest2 ()\r\n\t\tend\r\nend\r\n\r\n# 1 \"src/FiniteAutomatonTests.ml\"\r\n(*\r\n * FiniteAutomatonTests.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by João Gonçalves (jg)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * apr/2023 (amd) - New file.\r\n *)\r\n\r\n(*\r\n * Description: Finite automata testing.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule FiniteAutomatonTests : sig end =\r\nstruct\r\n\topen FiniteAutomaton\r\n\r\n\tlet active = false\r\n\r\n\r\n\tlet test0 () =\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Predef \"fa_abc\") in\r\n\t\t\tlet j = fa#toJSon in\r\n\t\t\t\tJSon.show j\r\n\r\n\tlet testBug () =\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Predef \"fa_abc\") in\r\n\t\tlet fa2 = fa#toDeterministic in\r\n\t\t\tlet j = fa2#toJSon in\r\n\t\t\t\tJSon.show j;\r\n\t\tlet fa3 = fa2#cleanUselessStates in\r\n\t\t\tlet j = fa3#toJSon in\r\n\t\t\t\tJSon.show j\r\n\r\n\tlet testBug2 () =\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Predef \"fa_abc\") in\r\n\t\tlet fa2 = fa#toDeterministic in\r\n\t\t\tUtil.println [\"productive states:\"];\r\n\t\t\tUtil.printStates fa2#productive;\r\n\t\t\tUtil.println []\r\n\r\n\tlet faAccept = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"ab123\",\r\n\t\talphabet : [\"a\", \"b\"],\r\n\t\tstates : [\"1\", \"2\", \"3\"],\r\n\t\tinitialState : \"1\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"1\",\"a\",\"2\"], [\"1\",\"b\",\"3\"],\r\n\t\t\t\t[\"2\",\"b\",\"2\"],\r\n\t\t\t\t[\"3\",\"a\",\"3\"]\r\n\t\t\t],\r\n\t\tacceptStates : [\"2\", \"3\"]\r\n\t} |}\r\n\r\n\tlet faAccept2 = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"abc\",\r\n\t\talphabet : [\"a\", \"b\", \"c\", \"d\"],\r\n\t\tstates : [\"START\", \"A\", \"AB\", \"C\", \"SUCCESS\", \"D\"],\r\n\t\tinitialState : \"START\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"START\",\"a\",\"A\"], [\"START\",\"~\",\"AB\"],\r\n\t\t\t\t[\"A\",\"~\",\"C\"],\r\n\t\t\t\t[\"AB\",\"b\",\"SUCCESS\"], [\"AB\",\"~\",\"SUCCESS\"],\r\n\t\t\t\t[\"C\",\"~\",\"SUCCESS\"], [\"C\",\"d\",\"C\"],\r\n\t\t\t\t[\"SUCCESS\",\"~\",\"START\"]\r\n\t\t\t],\r\n\t\tacceptStates : [\"SUCCESS\"]\r\n\t} |}\r\n\r\n\tlet check f w =\r\n\t\tlet msg = \r\n\t\t\tif f w then \"word was accepted\" else \"word was not accepted\"\r\n\t\tin Util.println [msg]\r\n\r\n\tlet testAcceptBF () =\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Text faAccept) in\r\n\t\t\tcheck fa#acceptBreadthFirst [];\r\n\t\t\tcheck fa#acceptBreadthFirst (word \"a\");\r\n\t\t\tcheck fa#acceptBreadthFirst (word \"ab\");\r\n\t\t\tcheck fa#acceptBreadthFirst (word \"b\");\r\n\t\t\tcheck fa#acceptBreadthFirst (word \"ba\");\r\n\t\t\tcheck fa#acceptBreadthFirst (word \"abb\");\r\n\t\t\tcheck fa#acceptBreadthFirst (word \"aba\");\r\n\t\t\tcheck fa#acceptBreadthFirst (word \"baa\");\r\n\t\t\tcheck fa#acceptBreadthFirst (word \"bab\");\r\n\t\t\tUtil.println []\r\n\r\n\tlet testAcceptBF2 () =\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Text faAccept2) in\r\n\t\t\tcheck fa#acceptBreadthFirst [];\r\n\t\t\tcheck fa#acceptBreadthFirst (word \"a\");\r\n\t\t\tcheck fa#acceptBreadthFirst (word \"ad\");\r\n\t\t\tcheck fa#acceptBreadthFirst (word \"abad\");\r\n\t\t\tcheck fa#acceptBreadthFirst (word \"c\");\r\n\t\t\tUtil.println []\r\n\r\n\tlet testAccept () =\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Text faAccept) in\r\n\t\t\tcheck fa#accept [];\r\n\t\t\tcheck fa#accept (word \"a\");\r\n\t\t\tcheck fa#accept (word \"ab\");\r\n\t\t\tcheck fa#accept (word \"b\");\r\n\t\t\tcheck fa#accept (word \"ba\");\r\n\t\t\tcheck fa#accept (word \"abb\");\r\n\t\t\tcheck fa#accept (word \"aba\");\r\n\t\t\tcheck fa#accept (word \"baa\");\r\n\t\t\tcheck fa#accept (word \"bab\");\r\n\t\t\tUtil.println []\r\n\r\n\tlet testAccept2 () =\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Text faAccept2) in\r\n\t\t\tcheck fa#accept [];\r\n\t\t\tcheck fa#accept (word \"a\");\r\n\t\t\tcheck fa#accept (word \"ad\");\r\n\t\t\tcheck fa#accept (word \"abad\");\r\n\t\t\tcheck fa#accept (word \"c\");\r\n\t\t\tUtil.println []\r\n\r\n\tlet testAccTrace () =\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Predef \"fa_abc\") in\r\n\t\t\tfa#acceptWithTracing (word \"abe\")\r\n\r\n\tlet faGenerate = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"abc\",\r\n\t\talphabet : [\"a\", \"b\"],\r\n\t\tstates : [\"S1\", \"S2\", \"S3\", \"S4\", \"S5\"],\r\n\t\tinitialState : \"S1\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"S1\",\"b\",\"S2\"], [\"S1\",\"a\",\"S3\"], [\"S1\",\"~\",\"S3\"],\r\n\t\t\t\t[\"S2\",\"~\",\"S3\"],\r\n\t\t\t\t[\"S3\",\"~\",\"S3\"]\r\n\t\t\t],\r\n\t\tacceptStates : [\"S3\"]\r\n\t} |}\r\n\r\n\tlet faGenerate2 = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"abc\",\r\n\t\talphabet : [\"a\", \"b\"],\r\n\t\tstates : [\"S1\", \"S2\"],\r\n\t\tinitialState : \"S1\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"S1\",\"a\",\"S1\"], [\"S1\",\"b\",\"S2\"],\r\n\t\t\t\t[\"S2\",\"a\",\"S2\"], [\"S2\",\"b\",\"S1\"]\r\n\r\n\t\t\t],\r\n\t\tacceptStates : [\"S2\"]\r\n\t} |}\r\n\r\n\tlet faGenerate3 = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"abc\",\r\n\t\talphabet : [\"a\"],\r\n\t\tstates : [\"S1\"],\r\n\t\tinitialState : \"S1\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"S1\",\"a\",\"S1\"]\r\n\t\t\t],\r\n\t\tacceptStates : [\"S1\"]\r\n\t} |}\r\n\r\n\tlet faGenerate4 = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"abc\",\r\n\t\talphabet : [\"a\",\"b\"],\r\n\t\tstates : [\"S1\",\"S2\"],\r\n\t\tinitialState : \"S1\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"S1\",\"a\",\"S1\"], [\"S1\",\"b\",\"S2\"],\r\n\t\t\t\t[\"S2\",\"a\",\"S2\"]\r\n\t\t\t],\r\n\t\tacceptStates : [\"S1\"]\r\n\t} |}\r\n\r\n\tlet testGenerate () =\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Text faGenerate) in\r\n\t\t\tUtil.println [\"generated words size 0:\"]; Util.printWords (fa#generate 0);\r\n\t\t\tUtil.println [\"generated words size 1:\"]; Util.printWords (fa#generate 1);\r\n\t\t\tUtil.println [\"generated words size 2:\"]; Util.printWords (fa#generate 2);\r\n\t\t\tUtil.println [\"generated words size 100:\"]; Util.printWords (fa#generate 100);\r\n\t\t\tUtil.println []\r\n\r\n\tlet testGenerate2 () =\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Text faGenerate2) in\r\n\t\t\tUtil.println [\"generated words size 0:\"]; Util.printWords (fa#generate 0);\r\n\t\t\tUtil.println [\"generated words size 1:\"]; Util.printWords (fa#generate 1);\r\n\t\t\tUtil.println [\"generated words size 2:\"]; Util.printWords (fa#generate 2);\r\n\t\t\tUtil.println [\"generated words size 3:\"]; Util.printWords (fa#generate 3);\r\n\t\t\tUtil.println [\"generated words size 4:\"]; Util.printWords (fa#generate 4);\r\n\t\t\tUtil.println [\"generated words size 18:\"]; Util.printWords (fa#generate 18);\r\n\r\n\t\t\tUtil.println []\r\n\r\n\tlet testGenerate3 () =\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Text faGenerate3) in\r\n\t\t\tUtil.println [\"generated words size 0:\"]; Util.printWords (fa#generate 0);\r\n\t\t\tUtil.println [\"generated words size 1:\"]; Util.printWords (fa#generate 1);\r\n\t\t\tUtil.println [\"generated words size 10:\"]; Util.printWords (fa#generate 10);\r\n\t\t\tUtil.println [\"generated words size 50:\"]; Util.printWords (fa#generate 50);\r\n\t\t\tUtil.println [\"generated words size 100:\"]; Util.printWords (fa#generate 100);\r\n\t\t\tUtil.println [\"generated words size 1000:\"]; Util.printWords (fa#generate 1000);\r\n\t\t\tUtil.println []\r\n\r\n\tlet testGenerate4 () =\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Text faGenerate4) in\r\n\t\t\tUtil.println [\"generated words size 0:\"]; Util.printWords (fa#generate 0);\r\n\t\t\tUtil.println [\"generated words size 1:\"]; Util.printWords (fa#generate 1);\r\n\t\t\tUtil.println [\"generated words size 10:\"]; Util.printWords (fa#generate 10);\r\n\t\t\tUtil.println [\"generated words size 100:\"]; Util.printWords (fa#generate 100);\r\n\t\t\tUtil.println []\r\n\r\n\tlet testGenerateUntil () =\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Text faGenerate) in\r\n\t\t\tUtil.println [\"generated words size 5:\"]; Util.printWords (fa#generateUntil 5);\r\n\t\t\tUtil.println [];\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Text faGenerate2) in\r\n\t\t\tUtil.println [\"generated words size 5:\"]; Util.printWords (fa#generateUntil 5);\r\n\t\t\tUtil.println [];\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Text faGenerate3) in\r\n\t\t\tUtil.println [\"generated words size 5:\"]; Util.printWords (fa#generateUntil 5);\r\n\t\t\tUtil.println [];\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Text faGenerate4) in\r\n\t\t\tUtil.println [\"generated words size 5:\"]; Util.printWords (fa#generateUntil 5);\r\n\t\t\tUtil.println []\r\n\r\n\tlet faReach = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"abc\",\r\n\t\talphabet : [\"a\", \"b\"],\r\n\t\tstates : [\"S1\", \"S2\", \"S3\"],\r\n\t\tinitialState : \"S1\",\r\n\t\ttransitions : [\r\n\t\t\t],\r\n\t\tacceptStates : [\"S1\"]\r\n\t} |}\r\n\r\n\tlet faReach2 = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"abc\",\r\n\t\talphabet : [\"a\",\"b\"],\r\n\t\tstates : [\"S1\",\"S2\",\"S3\",\"S4\",\"S5\",\"S6\"],\r\n\t\tinitialState : \"S1\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"S1\",\"~\",\"S2\"], [\"S1\",\"a\",\"S3\"],\r\n\t\t\t\t[\"S2\",\"a\",\"S2\"],\r\n\t\t\t\t[\"S3\",\"~\",\"S4\"],\r\n\t\t\t\t[\"S4\",\"~\",\"S5\"],\r\n\t\t\t\t[\"S5\",\"~\",\"S3\"], [\"S5\",\"b\",\"S6\"], [\"S5\",\"~\",\"S5\"]\r\n\t\t\t],\r\n\t\tacceptStates : [\"S1\"]\r\n\t} |}\r\n\r\n\tlet testReachable () =\r\n\t\t\tlet open FiniteAutomaton in\r\n\t\t\tlet fa = new FiniteAutomaton.model (Arg.Text faReach) in\r\n\t\t\tlet fa2 = new FiniteAutomaton.model (Arg.Text faReach2) in\r\n\t\t\tlet start = fa#representation.initialState in\r\n\t\t\tlet start2 = fa2#representation.initialState in\r\n\t\t\t\tUtil.println [\"reachable states:\"]; Util.printStates (fa#reachable start); Util.println [];\r\n\t\t\t\tUtil.println [\"reachable states:\"]; Util.printStates (fa#reachable start2); Util.println []\r\n\r\n\tlet faProductive = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"abc\",\r\n\t\talphabet : [\"a\", \"b\"],\r\n\t\tstates : [\"S1\",\"S2\",\"S3\",\"S4\"],\r\n\t\tinitialState : \"S1\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"S1\",\"a\",\"S2\"], [\"S1\",\"b\",\"S3\"],\r\n\t\t\t\t[\"S4\",\"a\",\"S2\"], [\"S4\",\"b\",\"S3\"], [\"S3\",\"a\",\"S3\"]\r\n\t\t\t],\r\n\t\tacceptStates : [\"S4\"]\r\n\t} |}\r\n\r\n\tlet faProductive2 = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"abc\",\r\n\t\talphabet : [\"a\", \"b\"],\r\n\t\tstates : [\"S1\",\"S2\",\"S3\",\"S4\",\"S5\",\"S6\",\"S7\"],\r\n\t\tinitialState : \"S1\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"S1\",\"~\",\"S2\"], [\"S1\",\"a\",\"S2\"], [\"S1\",\"~\",\"S3\"], [\"S1\",\"a\",\"S3\"], [\"S1\",\"~\",\"S5\"], [\"S1\",\"a\",\"S5\"],\r\n\t\t\t\t[\"S2\",\"~\",\"S1\"], [\"S2\",\"a\",\"S1\"],\r\n\t\t\t\t[\"S4\",\"~\",\"S3\"], [\"S4\",\"a\",\"S3\"],[\"S4\",\"~\",\"S4\"], [\"S4\",\"a\",\"S4\"],\r\n\t\t\t\t[\"S5\",\"~\",\"S2\"], [\"S5\",\"a\",\"S2\"],[\"S5\",\"~\",\"S6\"], [\"S5\",\"a\",\"S6\"],\r\n\t\t\t\t[\"S6\",\"~\",\"S6\"], [\"S6\",\"a\",\"S6\"],[\"S6\",\"~\",\"S7\"], [\"S6\",\"a\",\"S7\"],\r\n\t\t\t\t[\"S7\",\"~\",\"S3\"], [\"S7\",\"a\",\"S3\"],[\"S7\",\"~\",\"S5\"], [\"S7\",\"a\",\"S5\"]\r\n\t\t\t],\r\n\t\tacceptStates : [\"S2\",\"S4\"]\r\n\t} |}\r\n\r\n\tlet testProductive () =\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Text faProductive) in\r\n\t\tlet fa2 = new FiniteAutomaton.model (Arg.Text faProductive2) in\r\n\t\t\tUtil.println [\"productive states:\"]; Util.printStates fa#productive; Util.println [];\r\n\t\t\tUtil.println [\"productive states:\"]; Util.printStates fa2#productive; Util.println []\r\n\r\n\r\n\tlet faClean = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"abc\",\r\n\t\talphabet : [\"a\", \"b\"],\r\n\t\tstates : [\"S1\",\"S2\",\"S3\",\"S4\"],\r\n\t\tinitialState : \"S1\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"S1\",\"a\",\"S2\"], [\"S1\",\"b\",\"S3\"],\r\n\t\t\t\t[\"S4\",\"a\",\"S2\"], [\"S4\",\"b\",\"S3\"], [\"S3\",\"a\",\"S3\"]\r\n\t\t\t],\r\n\t\tacceptStates : [\"S4\"]\r\n\t} |}\r\n\r\n\tlet faClean2 = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"abc\",\r\n\t\talphabet : [\"a\", \"b\"],\r\n\t\tstates : [\"S1\",\"S2\",\"S3\",\"S4\"],\r\n\t\tinitialState : \"S1\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"S1\",\"a\",\"S2\"], [\"S1\",\"~\",\"S3\"],\r\n\t\t\t\t[\"S3\",\"a\",\"S2\"], [\"S3\",\"~\",\"S1\"], [\"S3\",\"a\",\"S4\"]\r\n\t\t\t],\r\n\t\tacceptStates : [\"S2\"]\r\n\t} |}\r\n\r\n\tlet testClean () =\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Text faClean) in\r\n\t\tlet fa2 = new FiniteAutomaton.model (Arg.Text faClean2) in\r\n\t\tlet mfa = fa#cleanUselessStates in\r\n\t\tlet mfa2 = fa2#cleanUselessStates in\r\n\t\tlet j = mfa#toJSon in\r\n\t\tlet j2 = mfa2#toJSon in\r\n\t\t\tJSon.show j; Util.println [];\r\n\t\t\tJSon.show j2; Util.println []\r\n\r\n\tlet faIsDeter = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"isDeter\",\r\n\t\talphabet : [\"a\", \"b\"],\r\n\t\tstates : [\"S1\", \"S2\", \"S3\", \"S4\", \"S5\"],\r\n\t\tinitialState : \"S1\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"S1\",\"~\",\"S2\"], [\"S1\",\"a\",\"S3\"],\r\n\t\t\t\t[\"S2\",\"a\",\"S3\"], [\"S2\",\"b\",\"S2\"]\r\n\t\t\t],\r\n\t\tacceptStates : [\"S3\"]\r\n\t} |}\r\n\r\n\tlet faIsDeter2 = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"isDeter\",\r\n\t\talphabet : [\"a\", \"b\"],\r\n\t\tstates : [\"S1\", \"S2\", \"S3\", \"S4\", \"S5\"],\r\n\t\tinitialState : \"S1\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"S1\",\"~\",\"S2\"], [\"S1\",\"b\",\"S3\"],\r\n\t\t\t\t[\"S2\",\"a\",\"S4\"], [\"S4\",\"b\",\"S5\"],\r\n\t\t\t\t[\"S3\",\"b\",\"S5\"]\r\n\t\t\t],\r\n\t\tacceptStates : [\"S5\"]\r\n\t} |}\r\n\r\n\tlet faIsDeter3 = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"isDeter\",\r\n\t\talphabet : [\"a\", \"b\"],\r\n\t\tstates : [\"S1\", \"S2\", \"S3\", \"S4\", \"S5\"],\r\n\t\tinitialState : \"S1\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"S1\",\"a\",\"S2\"], [\"S1\",\"a\",\"S3\"],\r\n\t\t\t\t[\"S2\",\"b\",\"S4\"],\r\n\t\t\t\t[\"S3\",\"b\",\"S4\"]\r\n\t\t\t],\r\n\t\tacceptStates : [\"S4\"]\r\n\t} |}\r\n\r\n\tlet faToDeter = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"abc\",\r\n\t\talphabet : [\"0\", \"1\"],\r\n\t\tstates : [\"S1\", \"S2\", \"S3\", \"S4\", \"S5\"],\r\n\t\tinitialState : \"S1\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"S1\",\"1\",\"S2\"], [\"S1\",\"1\",\"S3\"] , [\"S1\",\"0\",\"S5\"],\r\n\t\t\t\t[\"S2\",\"~\",\"S4\"],\r\n\t\t\t\t[\"S4\",\"0\",\"S3\"],\r\n\t\t\t\t[\"S5\",\"1\",\"S2\"], [\"S5\",\"0\",\"S3\"], [\"S5\",\"0\",\"S4\"]\r\n\t\t\t],\r\n\t\tacceptStates : [\"S3\"]\r\n\t} |}\r\n\r\n\tlet testIsDeterministic () =\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Text faIsDeter) in\r\n\t\tlet fa2 = new FiniteAutomaton.model (Arg.Text faIsDeter2) in\r\n\t\tlet fa3 = new FiniteAutomaton.model (Arg.Text faIsDeter3) in\r\n\t\t\tif fa#isDeterministic then\r\n\t\t\t\tUtil.println [\"automata is deterministic\"] else Util.println [\"automata is non-deterministic\"];\r\n\t\tif fa2#isDeterministic then\r\n\t\t\t\tUtil.println [\"automata is deterministic\"] else Util.println [\"automata is non-deterministic\"];\r\n\t\t\tif fa3#isDeterministic then\r\n\t\t\t\tUtil.println [\"automata is deterministic\"] else Util.println [\"automata is non-deterministic\"]\r\n\r\n\r\n\r\n\tlet testToDeterministic () =\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Text faToDeter) in\r\n\t\tlet mfa = fa#toDeterministic in\r\n\t\tlet j = mfa#toJSon in\r\n\t\t\tJSon.show j;\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Text faIsDeter) in\r\n\t\tlet mfa = fa#toDeterministic in\r\n\t\tlet j = mfa#toJSon in\r\n\t\t\tJSon.show j\r\n\r\n\r\n\tlet testEquivalence () =\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Predef \"fa_abc\") in\r\n\t\tlet s = fa#equivalencePartition in\r\n\t\t\tSet.iter (fun s -> Util.print [\"set: \"]; Util.printStates s) s\r\n\r\n\r\n\tlet faMinimize = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"abc\",\r\n\t\talphabet : [\"a\", \"b\"],\r\n\t\tstates : [\"S1\", \"S2\", \"S3\", \"S4\", \"S5\"],\r\n\t\tinitialState : \"S1\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"S1\",\"a\",\"S2\"], [\"S1\",\"b\",\"S3\"],\r\n\t\t\t\t[\"S2\",\"b\",\"S4\"], [\"S2\",\"a\",\"S3\"],\r\n\t\t\t\t[\"S3\",\"a\",\"S2\"], [\"S3\",\"b\",\"S4\"],\r\n\t\t\t\t[\"S4\",\"b\",\"S3\"], [\"S4\",\"a\",\"S2\"],\r\n\t\t\t\t[\"S4\",\"a\",\"S5\"]\r\n\t\t\t],\r\n\t\tacceptStates : [\"S4\"]\r\n\t} |}\r\n\r\n\tlet faMinimize2 = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"min\",\r\n\t\talphabet : [\"i\", \"c\", \"1\", \"2\"],\r\n\t\tstates : [\"S01\", \"S02\", \"S03\", \"S04\", \"S05\",\r\n\t\t\t\t\"S06\", \"S07\", \"S08\", \"S09\", \"S10\"],\r\n\t\tinitialState : \"S01\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"S01\",\"i\",\"S02\"],\r\n\t\t\t\t[\"S02\",\"1\",\"S03\"], [\"S02\",\"i\",\"S02\"],\r\n\t\t\t\t[\"S03\",\"1\",\"S04\"], [\"S03\",\"i\",\"S04\"],\r\n\t\t\t\t[\"S04\",\"1\",\"S03\"], [\"S04\",\"2\",\"S05\"], [\"S04\",\"i\",\"S04\"],\r\n\t\t\t\t[\"S05\",\"i\",\"S06\"], [\"S05\",\"c\",\"S07\"],\r\n\t\t\t\t[\"S06\",\"i\",\"S06\"], [\"S06\",\"1\",\"S03\"],\r\n\t\t\t\t[\"S07\",\"1\",\"S04\"], [\"S07\",\"i\",\"S08\"],\r\n\t\t\t\t[\"S08\",\"i\",\"S08\"], [\"S08\",\"1\",\"S03\"], [\"S08\",\"2\",\"S09\"],\r\n\t\t\t\t[\"S09\",\"c\",\"S03\"], [\"S09\",\"i\",\"S10\"],\r\n\t\t\t\t[\"S10\",\"1\",\"S03\"], [\"S10\",\"i\",\"S10\"]\r\n\t\t\t],\r\n\t\tacceptStates : [\"S10\"]\r\n\t} |}\r\n\r\n\tlet faMinimize3 = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"abc\",\r\n\t\talphabet : [\"a\", \"b\",\"c\"],\r\n\t\tstates : [\"S0\",\"S1\", \"S2\", \"S3\", \"S4\", \"S5\"],\r\n\t\tinitialState : \"S0\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"S0\",\"a\",\"S1\"], [\"S0\",\"b\",\"S2\"],\r\n\t\t\t\t[\"S1\",\"b\",\"S0\"], [\"S1\",\"a\",\"S1\"], [\"S1\",\"c\",\"S4\"],\r\n\t\t\t\t[\"S2\",\"b\",\"S0\"], [\"S2\",\"a\",\"S2\"], [\"S2\",\"c\",\"S5\"],\r\n\t\t\t\t[\"S3\",\"b\",\"S1\"], [\"S3\",\"a\",\"S3\"], [\"S3\",\"c\",\"S4\"],\r\n\t\t\t\t[\"S4\",\"b\",\"S5\"],\r\n\t\t\t\t[\"S5\",\"b\",\"S4\"]\r\n\t\t\t],\r\n\t\tacceptStates : [\"S4\",\"S5\"]\r\n\t} |}\r\n\r\n\tlet faMinimize4 = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"abc\",\r\n\t\talphabet : [\"0\", \"1\"],\r\n\t\tstates : [\"00\",\"01\", \"10\", \"11\"],\r\n\t\tinitialState : \"00\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"00\",\"1\",\"01\"], [\"00\",\"0\",\"10\"],\r\n\t\t\t\t[\"01\",\"1\",\"00\"], [\"01\",\"0\",\"11\"],\r\n\t\t\t\t[\"10\",\"0\",\"00\"], [\"10\",\"1\",\"11\"],\r\n\t\t\t\t[\"11\",\"1\",\"10\"], [\"11\",\"0\",\"01\"]\r\n\t\t\t],\r\n\t\tacceptStates : [\"01\"]\r\n\t} |}\r\n\r\n\tlet testMinimize () =\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Text faMinimize) in\r\n\t\tlet mfa = fa#minimize in\r\n\t\tlet j = mfa#toJSon in\r\n\t\t\tJSon.show j\r\n\r\n\tlet testMinimize2 () =\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Text faMinimize2) in\r\n\t\tlet mfa = fa#minimize in\r\n\t\tlet j = mfa#toJSon in\r\n\t\t\tJSon.show j\r\n\r\n\tlet testMinimize3 () =\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Text faMinimize3) in\r\n\t\tlet mfa = fa#minimize in\r\n\t\tlet j = mfa#toJSon in\r\n\t\t\tJSon.show j\r\n\r\n\tlet testMinimize4 () =\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Text faMinimize4) in\r\n\t\tlet mfa = fa#minimize in\r\n\t\tlet j = mfa#toJSon in\r\n\t\t\tJSon.show j\r\n\t\t\t\r\n\tlet testExercice () =\r\n\t\tlet e = new Exercise.exercise (Arg.Predef \"exer_astar_fa\") in\r\n\t\tlet fa = new FiniteAutomaton.model (Arg.Predef \"dfa_astar\") in\r\n\t\tlet (ins,outs,props) = fa#checkExerciseFailures e in\r\n\t\t\te#show2;\r\n\t\t\tfa#show2;\r\n\t\t\tExercise.showRes (ins,outs,props)\r\n\r\n\tlet faMinimize4 = {| {\r\n\t\tkind : \"finite automaton\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"abc\",\r\n\t\talphabet : [\"0\", \"1\"],\r\n\t\tstates : [\"00\",\"01\", \"10\", \"11\"],\r\n\t\tinitialState : \"00\",\r\n\t\ttransitions : [\r\n\t\t\t\t[\"00\",\"1\",\"01\"], [\"00\",\"0\",\"10\"],\r\n\t\t\t\t[\"01\",\"1\",\"00\"], [\"01\",\"0\",\"11\"],\r\n\t\t\t\t[\"10\",\"0\",\"00\"], [\"10\",\"1\",\"11\"],\r\n\t\t\t\t[\"11\",\"1\",\"10\"], [\"11\",\"0\",\"01\"]\r\n\t\t\t],\r\n\t\tacceptStates : [\"01\"]\r\n\t} |}\r\n\r\n\tlet runAll =\r\n\t\tif Util.testing active \"FiniteAutomaton\" then begin\r\n\t\t\tUtil.sep (); test0 ();\r\n\r\n\r\n(*\r\n\t\t\t\r\n\t\t\tUtil.sep (); testExercice ();\r\n\t\t\tUtil.sep (); testBug ();\r\n\t\t\tUtil.sep (); testBug2 ();\r\n\t\t\tUtil.sep (); testAcceptBF ();\r\n\t\t\tUtil.sep (); testAcceptBF2 ();\r\n\t\t\tUtil.sep (); testAccept ();\r\n\t\t\tUtil.sep (); testAccept2 ();\r\n\t\t\tUtil.sep (); testAccTrace () *)\r\n\t\tend\r\nend\r\n\r\n# 1 \"src/RegularExpressionTests.ml\"\r\n(*\r\n * RegularExpressionTests.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by João Gonçalves (jg)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * apr/2023 (amd) - New file.\r\n *)\r\n\r\n(*\r\n * Description: Regular expressions testing.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule RegularExpressionTests: sig end =\r\nstruct\r\n\tlet active = false\r\n\r\n\tlet test0 () =\r\n\t\tlet m = new RegularExpression.model (Arg.Predef \"re_abc\") in\r\n\t\t\tlet j = m#toJSon in\r\n\t\t\t\tJSon.show j\r\n\r\n\tlet test1 () =\r\n\t\tlet re = new RegularExpression.model (Arg.Predef \"re_abc\") in\r\n\t\t\tlet j = re#toJSon in\r\n\t\t\t\tJSon.show j\r\n\r\n\tlet testAlphabet () =\r\n\t\tlet re = new RegularExpression.model (Arg.Predef \"re_abc\") in\r\n\t\t\tUtil.println [\"alphabet: \"]; Util.printAlphabet re#alphabet;\r\n\t\t\tUtil.println []\r\n\r\n\tlet testAlphabet2 () =\r\n\t\tlet re = new RegularExpression.model (Arg.Predef \"re_simple\") in\r\n\t\t\tUtil.println [\"alphabet: \"]; Util.printAlphabet re#alphabet;\r\n\t\t\tUtil.println []\r\n\r\n\tlet testAlphabet3 () =\r\n\t\tlet re = new RegularExpression.model (Arg.Predef \"re_complex\") in\r\n\t\t\tUtil.println [\"alphabet: \"]; Util.printAlphabet re#alphabet;\r\n\t\t\tUtil.println []\r\n\r\n\tlet testAlphabet4 () =\r\n\t\tlet re = new RegularExpression.model (Arg.Predef \"re_convoluted\") in\r\n\t\t\tUtil.println [\"alphabet: \"]; Util.printAlphabet re#alphabet;\r\n\t\t\tUtil.println []\r\n\r\n\tlet testQuasiLang () =\r\n\t\tlet re = new RegularExpression.model (Arg.Predef \"re_abc\") in\r\n\t\t\tlet ws = re#quasiLanguage in\r\n\t\t\tUtil.printWords ws\r\n\r\n\tlet testQuasiLang2 () =\r\n\t\tlet re = new RegularExpression.model (Arg.Predef \"re_simple\") in\r\n\t\t\tlet ws = re#quasiLanguage in\r\n\t\t\tUtil.printWords ws\r\n\r\n\tlet testQuasiLang3 () =\r\n\t\tlet re = new RegularExpression.model (Arg.Predef \"re_complex\") in\r\n\t\t\tlet ws = re#quasiLanguage in\r\n\t\t\tUtil.printWords ws\r\n\r\n\tlet testQuasiLang4 () =\r\n\t\tlet re = new RegularExpression.model (Arg.Predef \"re_convoluted\") in\r\n\t\t\tlet ws = re#quasiLanguage in\r\n\t\t\tUtil.printWords ws\r\n\r\n\tlet check f w =\r\n\t\tlet msg = \r\n\t\t\tif f w then \"word was accepted\" else \"word was not accepted\"\r\n\t\tin Util.println [msg]\r\n\r\n\tlet testAccept () =\r\n\t\tlet m = new RegularExpression.model (Arg.Predef \"re_abc\") in\r\n\t\t\tcheck m#accept (word \"aa\")\r\n\r\n\tlet testAccept2 () =\r\n\t\tlet m = new RegularExpression.model (Arg.Predef \"re_simple\") in\r\n\t\t\tcheck m#accept (word \"aa\")\r\n\r\n\tlet testAccept3 () =\r\n\t\tlet m = new RegularExpression.model (Arg.Predef \"re_complex\") in\r\n\t\t\tcheck m#accept (word \"aa\")\r\n\r\n\tlet testAccept4 () =\r\n\t\tlet m = new RegularExpression.model (Arg.Predef \"re_convoluted\") in\r\n\t\t\tcheck m#accept (word \"aa\")\r\n\r\n\tlet testGenerate () =\r\n\t\tlet re = new RegularExpression.model (Arg.Predef \"re_abc\") in\r\n\t\t\tUtil.println [\"generated words size 0:\"]; Util.printWords (re#generate 0);\r\n\t\t\tUtil.println [\"generated words size 1:\"]; Util.printWords (re#generate 1);\r\n\t\t\tUtil.println [\"generated words size 2:\"]; Util.printWords (re#generate 2);\r\n\t\t\tUtil.println [\"generated words size 3:\"]; Util.printWords (re#generate 3);\r\n\t\t\tUtil.println [\"generated words size 4:\"]; Util.printWords (re#generate 4);\r\n\t\t\tUtil.println []\r\n\r\n\tlet testGenerate2 () =\r\n\t\tlet re = new RegularExpression.model (Arg.Predef \"re_simple\") in\r\n\t\t\tUtil.println [\"generated words size 0:\"]; Util.printWords (re#generate 0);\r\n\t\t\tUtil.println [\"generated words size 1:\"]; Util.printWords (re#generate 1);\r\n\t\t\tUtil.println [\"generated words size 2:\"]; Util.printWords (re#generate 2);\r\n\t\t\tUtil.println [\"generated words size 3:\"]; Util.printWords (re#generate 3);\r\n\t\t\tUtil.println [\"generated words size 4:\"]; Util.printWords (re#generate 4);\r\n\t\t\tUtil.println []\r\n\r\n\tlet testGenerate3 () =\r\n\t\tlet re = new RegularExpression.model (Arg.Predef \"re_complex\") in\r\n\t\t\tUtil.println [\"generated words size 0:\"]; Util.printWords (re#generate 0);\r\n\t\t\tUtil.println [\"generated words size 1:\"]; Util.printWords (re#generate 1);\r\n\t\t\tUtil.println [\"generated words size 2:\"]; Util.printWords (re#generate 2);\r\n\t\t\tUtil.println [\"generated words size 3:\"]; Util.printWords (re#generate 3);\r\n\t\t\tUtil.println [\"generated words size 4:\"]; Util.printWords (re#generate 4);\r\n\t\t\tUtil.println []\r\n\r\n\tlet testGenerate4 () =\r\n\t\tlet re = new RegularExpression.model (Arg.Predef \"re_convoluted\") in\r\n\t\t\tUtil.println [\"generated words size 0:\"]; Util.printWords (re#generate 0);\r\n\t\t\tUtil.println [\"generated words size 1:\"]; Util.printWords (re#generate 1);\r\n\t\t\tUtil.println [\"generated words size 2:\"]; Util.printWords (re#generate 2);\r\n\t\t\tUtil.println [\"generated words size 3:\"]; Util.printWords (re#generate 3);\r\n\t\t\tUtil.println [\"generated words size 4:\"]; Util.printWords (re#generate 4);\r\n\t\t\tUtil.println []\r\n\r\n\tlet testSimplify2 () =\r\n\t\tlet re = new RegularExpression.model (Arg.Predef \"re_simple\") in\r\n\t\tlet res = re#simplify in\r\n\t\t\tJSon.show res#toJSon\r\n\r\n\tlet testEnum () =\r\n\t\tlet e = new Exercise.exercise (Arg.Predef \"exer_re2fa\") in\r\n\t\tlet re = new RegularExpression.model (Arg.Predef \"re_simple\") in\r\n\t\tlet result = re#checkExercise e in\r\n\t\t\tif result then Util.print [\"it works\"] else Util.print [\"it does not work\"]\r\n\r\n\tlet testTrace () =\r\n\t\tlet re = new RegularExpression.model (Arg.Predef \"re_simple\") in\r\n\t\t\tre#allTrees (word \"acbacb\")\r\n\t\r\n\tlet re_more = {| {\r\n\t\t\tkind : \"regular expression\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"re_more\",\r\n\t\t\tre : \"a*\"\r\n\t} |}\r\n\t\t\t\t\r\n\tlet testMore () =\r\n\t\tlet re = new RegularExpression.model (Arg.Text re_more) in\r\n\t\t\tre#allTrees (word \"aa\")\r\n\r\n\tlet runAll =\r\n\t\tif Util.testing active \"RegularExpression\" then begin\r\n\t\t\ttestMore ()\r\n\t\tend\r\nend\r\n# 1 \"src/TransducerTests.ml\"\r\n(*\r\n * TransducerTests.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by João Santos (js)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * jul/2025 (amd) - New file.\r\n *)\r\n\r\n(*\r\n * Description: Finite-state transducer testing.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule TransducerTests : sig end =\r\nstruct\r\n\topen Transducer\r\n\t\r\n\tlet active = true\r\n\t\r\n\tlet fstIdentity = {| {\r\n\t\tkind : \"transducer\",\r\n\t\tdescription : \"Identity transducer\",\r\n\t\tname : \"fstId\",\r\n\t\tinAlphabet : [\"a\", \"b\"],\r\n\t\toutAlphabet : [\"a\", \"b\"],\r\n\t\tstates : [\"S\"],\r\n\t\tinitialState : \"S\",\r\n\t\ttransitions : [[\"S\",\"a\",\"a\",\"S\"], [\"S\",\"b\",\"b\",\"S\"]],\r\n\t\tacceptStates : [\"S\"]\r\n\t} |}\r\n\r\n\tlet test0 () =\r\n\t\tlet fst: t = make (Arg.Text fstIdentity) in\r\n\t\t\tshow fst\r\n\r\n\tlet test1 () =\r\n\t\tlet fst: t = make (Arg.Text fstIdentity) in\r\n\t\tlet json: JSon.t = toJSon fst in\r\n\t\t\tJSon.show json\r\n\r\n\tlet test2 () =\r\n\t\tlet json: JSon.t = JSon.parse fstIdentity in\r\n\t\tlet fst: t = make (Arg.JSon json) in\r\n\t\tlet json: JSon.t = toJSon fst in\r\n\t\t\tJSon.show json\r\n\r\n\tlet test3 () =\r\n\t\tlet json: JSon.t = JSon.parse fstIdentity in\r\n\t\tlet fst: t = fromJSon json in\r\n\t\tlet json: JSon.t = toJSon fst in\r\n\t\t\tJSon.show json\r\n\r\n\tlet runAll =\r\n\t\tif Util.testing active \"Transducer\" then begin\r\n\t\t\tUtil.header \"test0\";\r\n\t\t\ttest0 ();\r\n\t\t\tUtil.header \"test1\";\r\n\t\t\ttest1 ();\r\n\t\t\tUtil.header \"test2\";\r\n\t\t\ttest2 ();\r\n\t\t\tUtil.header \"test3\";\r\n\t\t\ttest3 ();\r\n\t\t\tUtil.header \"\"\r\n\t\tend\r\nend\r\n# 1 \"src/ContextFreeGrammarBasicTests.ml\"\r\n(*\r\n * ContextFreeGrammarBasicTests.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by João Gonçalves (jg)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * apr/2023 (amd) - New file.\r\n *)\r\n\r\n(*\r\n * Description: Context-free grammar testing.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule ContextFreeGrammarBasicTests : sig end =\r\nstruct\r\n\topen ContextFreeGrammarBasic\r\n\r\n\tlet active = false\r\n\t\r\n\tlet test0 () =\r\n\t\tlet m = new model (Arg.Predef \"cfg_simple\") in\r\n\t\tlet j = m#toJSon in\r\n\t\t\tJSon.show j\r\n\r\n\tlet test1 () =\r\n\t\tlet m = new model (Arg.Predef \"cfg_balanced\") in\r\n\t\tlet e = new Exercise.exercise (Arg.Predef \"exer_balanced_cfg\") in\r\n\t\tlet result = m#checkExercise e in\r\n\t\t\tif result then Util.println [\"it works\"] else Util.println [\"it does not work\"]\r\n\r\n\tlet testRegular () =\r\n\t\tlet m = new model (Arg.Predef \"cfg_simple\") in\r\n\t\tlet ws = m#isRegular in\r\n\t\t\tif ws then Util.println [\"is regular\"] else Util.println [\"is not regular\"]\r\n\r\n\r\n\tlet testAcc () =\r\n\t\tlet m = new model (Arg.Predef \"cfg_simple\") in\r\n\t\tlet ws = m#accept [] in\r\n\t\t\tif ws then Util.println [\"Word was accepted\"]\r\n\t\t\telse Util.println [\"Word was not accepted\"]\r\n\r\n\r\n\tlet testTrace () =\r\n\t\tlet m = new model (Arg.Predef \"cfg_simple\") in\r\n\t\t\tm#acceptWithTracing (word \"01\")\r\n\r\n\tlet testGen () =\r\n\t\tlet m = new model (Arg.Predef \"cfg_simple\") in\r\n\t\tlet ws = m#generate 4 in\r\n\t\t\tUtil.printWords ws\r\n\r\n\tlet showM m =\r\n\t\tlet j = m#toJSon in\r\n\t\t\tJSon.show j\r\n\t\r\n\tlet showB b =\r\n\t\tif b then print_string \"YES\\n\"\r\n\t\telse print_string \"NO\\n\"\t\r\n\t\r\n\tlet testChomsky () =\r\n\t\tlet m = new model (Arg.Predef \"cfg_balanced\") in\r\n\t\t\tshowB (m#accept (word \"\"));\t\t\t\r\n\t\t\tshowB (m#accept (word \"[[[]]]\"));\t\t\t\r\n\t\t\tshowB (m#accept (word \"[[][][]][]\"));\t\t\r\n\t\t\tshowB (m#accept (word \"[[][]]][]\"))\t\t\t\r\n\r\n\tlet testExercice () =\r\n\t\tlet e = new Exercise.exercise (Arg.Predef \"exer_balanced_cfg\") in\r\n\t\tlet g = new model (Arg.Predef \"cfg_balanced\") in\r\n\t\tlet b = g#checkExercise e in\r\n\t\t\te#show2;\r\n\t\t\tg#show2;\r\n\t\t\tshowB b\r\n\r\n\tlet zzz = {| {\r\n\t\t\tkind : \"context free grammar\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"qq_simple\",\r\n\t\t\talphabet : [\"0\", \"2\"],\r\n\t\t\tvariables : [\"S\", \"P\"],\r\n\t\t\tinitial : \"S\",\r\n\t\t\trules : [\t\"S -> 2S0 | P\",\r\n\t\t\t\t\t\t\"2P0 -> 0P2 | ~\",\r\n\t\t\t\t\t\t\" -> A\",\r\n\t\t\t\t\t\t\" ~ -> B\" ]\r\n\t\t} |}\r\n\r\n\tlet testBadHeads () =\r\n\t\tlet g = make (Arg.Text zzz) in\r\n\t\t\tshow g\r\n\r\n\t(* exemplos que se seguem PEDRO CARLOS VER!!! *)\r\n\t\tlet gram_example3 = {| {\r\n\t\t\tkind: \"context free grammar\",\r\n\t\t\tdescription: \"example\",\r\n\t\t\tname: \"cfg_example3\",\r\n\t\t\talphabet: [\"b\", \"a\" ],\r\n\t\t\tvariables: [\"S\", \"A\", \"B\"],\r\n\t\t\tinitial: \"S\",\r\n\t\t\trules: [\r\n\t\t\t\t\"S -> ab | ASB\",\r\n\t\t\t\t\"A -> a\",\r\n\t\t\t\t\"B -> b\"\r\n\t\t\t\t]\r\n\t\t\t} |}\r\n\r\n\t\t\tlet gram_example4 = {| {\r\n\t\t\t\tkind: \"context free grammar\",\r\n\t\t\t\tdescription: \"example\",\r\n\t\t\t\tname: \"cfg_example3\",\r\n\t\t\t\talphabet: [\"[\", \"a\", \"]\" ],\r\n\t\t\t\tvariables: [\"S\", \"A\"],\r\n\t\t\t\tinitial: \"S\",\r\n\t\t\t\trules: [\r\n\t\t\t\t\t\"S -> [S] | A\",\r\n\t\t\t\t\t\"A -> a\"\t\t\t\t\t]\r\n\t\t\t\t} |}\r\n\t\t\r\n\r\n\r\n\tlet\ttest_find_applied_rules () =\r\n\t\tprint_endline \"Running test_find_applied_rules\";\r\n\t\tlet g = new model (Arg.Text gram_example4) in\r\n\t\tlet word = \"[[a]]\" in\r\n\t\tlet (accepted, path, trail) = g#acceptFull (str2word word) in\r\n\r\n\t\tprint_endline (\"Path: \" ^\r\n\t\t\t\t(String.concat \" -> \" (\r\n\t\t\t\t\t\tList.map (fun (syms, _) ->\r\n\t\t\t\t\t\t\t\tString.concat \"\" (List.map symb2str syms)\r\n\t\t\t\t\t\t) path\r\n\t\t\t\t))\r\n\t\t);\r\n\r\n\t\tprint_endline (\"Trail: \" ^\r\n\t\t\t\t(String.concat \", \" (\r\n\t\t\t\t\t\tList.map (fun config_set ->\r\n\t\t\t\t\t\t\t\t\"{\" ^\r\n\t\t\t\t\t\t\t\t\t\t(String.concat \"; \" (\r\n\t\t\t\t\t\t\t\t\t\t\t\tSet.toList config_set\r\n\t\t\t\t\t\t\t\t\t\t\t\t|> List.map (fun (syms, _) -> String.concat \"\" (List.map symb2str syms))\r\n\t\t\t\t\t\t\t\t\t\t)) ^\r\n\t\t\t\t\t\t\t\t\"}\"\r\n\t\t\t\t\t\t) trail\r\n\t\t\t\t))\r\n\t\t);\r\n\t\tlet applied_rules = g#find_applied_rules path in\r\n\r\n\t\t  (* Print the applied rules for each configuration in the path *)\r\n\t\t\tList.iteri (fun i (sf, rules, positions) ->\r\n\t\t\tprint_endline (\"\\nStep \" ^ string_of_int i ^ \":\");\r\n\t\t\tprint_endline (\"Configuration: \" ^ \r\n\t\t\t\t\t\t\t\t\t\tString.concat \"\" (List.map symb2str sf));\r\n\t\t\t\r\n\t\t\tif List.length rules > 0 then begin\r\n\t\t\t\tprint_endline \"Applicable rules:\";\r\n\t\t\t\tList.iter2 (fun rule pos ->\r\n\t\t\t\t\tprint_endline (\"  At position \" ^ string_of_int pos ^ \": \" ^ \r\n\t\t\t\t\t\t\t\t\t\t\t\tsymb2str rule.head ^ \" -> \" ^ \r\n\t\t\t\t\t\t\t\t\t\t\t\tString.concat \"\" (List.map symb2str rule.body))\r\n\t\t\t\t) rules positions;\r\n\t\t\tend else \r\n\t\t\t\tprint_endline \"  No applicable rules\";\r\n\t\t) applied_rules;\r\n\t\r\n\t\tprint_endline \"\\nPassed test_find_applied_rules\"\r\n\r\n\tlet runAll =\r\n\t\tif Util.testing active \"ContextFreeGrammarBasic\" then begin\r\n\t\t\t(* Util.sep (); test0 ();\r\n\t\t\tUtil.sep (); test1 ();\r\n\t\t\tUtil.sep (); testRegular ();\r\n\t\t\tUtil.sep (); testAcc ();\r\n\t\t\tUtil.sep (); testTrace ();\r\n\t\t\tUtil.sep (); testGen ();\r\n\t\t\tUtil.sep (); testExercice();\r\n\t\t\tUtil.sep (); testBadHeads(); *)\r\n\t\t\tUtil.sep (); test_find_applied_rules()\r\n\t\tend\r\nend\r\n\r\n\r\n# 3 \"src/ContextFreeGrammarLL1Tests.ml\"\r\nopen BasicTypes\r\nopen ContextFreeGrammarBasic  \r\n\r\nmodule ContextFreeGrammarLL1Tests : sig end =\r\nstruct\r\n\tlet active = false\r\n\r\n  let example1 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Exemple 1\",\r\n\t  name : \"G1\",\r\n\t  alphabet : [\"a\", \"b\", \"c\", \"d\", \"e\"],\r\n\t  variables : [\"S\", \"A\", \"B\", \"C\", \"D\", \"E\"],\r\n\t  initial : \"S\",\r\n    rules : [\"S -> ABCDE\", \"A -> a | \", \"B -> b | \", \"C -> c\", \"D -> d | \", \"E -> e | \"]\r\n  } |}\r\n\r\n  let example2 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Exemple 2\",\r\n\t  name : \"G2\",\r\n\t  alphabet : [\"a\", \"b\", \"c\", \"d\"],\r\n\t  variables : [\"S\", \"B\", \"C\"],\r\n\t  initial : \"S\",\r\n    rules : [\"S -> Bb | Cd\", \"B -> aB | \", \"C -> cC | \"]\r\n  } |}\r\n  \r\n  let example3 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Exemple 3\",\r\n\t  name : \"G3\",\r\n\t  alphabet : [\"+\", \"*\", \"(\", \")\", \"i\"],\r\n\t  variables : [\"E\", \"D\", \"T\", \"U\", \"F\"],\r\n\t  initial : \"E\",\r\n    rules : [\"E -> TD\", \"D -> +TD | \", \"T -> FU\", \"U -> *FU | \", \"F -> i | (E)\"]\r\n  } |}\r\n  \r\n  let example4 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Exemple 4\",\r\n\t  name : \"G4\",\r\n\t  alphabet : [\"a\", \"b\", \"c\", \"f\", \"g\", \"h\"],\r\n\t  variables : [\"S\", \"B\", \"C\", \"D\", \"E\", \"F\"],\r\n\t  initial : \"S\",\r\n    rules : [\"S -> aBDh\", \"B -> cC\", \"C -> bC | \", \"D -> EF\", \"E -> g | \", \"F -> f | \"]\r\n  } |}\r\n\r\n  let example5 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Exemple 5\",\r\n\t  name : \"G5\",\r\n\t  alphabet : [\"n\", \"+\", \"*\"],\r\n\t  variables : [\"E\", \"A\", \"B\"],\r\n\t  initial : \"E\",\r\n    rules : [\"E -> nA\", \"A -> EB | \", \"B -> +A | *A\"]\r\n  } |}\r\n  \r\n  let example6 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Exemple 6\",\r\n\t  name : \"G6\",\r\n\t  alphabet : [\"a\", \"b\"],\r\n\t  variables : [\"N\", \"A\", \"B\", \"C\"],\r\n\t  initial : \"N\",\r\n    rules : [\"N -> AB | BA\", \"A -> a | CAC\", \"B -> b | CBC\", \"C -> a | b\"]\r\n  } |}\r\n  \r\n  let cfg_dissertation = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"dissertation example\",\r\n\t  name : \"G2\",\r\n\t  alphabet : [\"a\", \"b\", \"c\"],\r\n\t  variables : [\"S\", \"A\", \"B\", \"C\", \"D\", \"E\"],\r\n\t  initial : \"S\",\r\n    rules : [\"S -> ABC\", \"A -> aD\", \"B -> CE\", \"C -> c\", \"D -> AB | \", \"E -> bE | \"]\r\n  } |}\r\n\r\n  let non_deterministic_grammar = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Non deterministic grammar\",\r\n\t  name : \"N\",\r\n\t  alphabet : [\"a\", \"b\", \"d\", \"g\", \"h\"],\r\n\t  variables : [\"S\", \"A\", \"B\", \"C\"],\r\n\t  initial : \"S\",\r\n    rules : [\"S -> ACB | CbB | Ba\", \"A -> da | BC\", \"B -> g | \", \"C -> h | \"]\r\n  } |}\r\n\r\n  let accessible_symbols1 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Accessible symbols example\",\r\n\t  name : \"AS1\",\r\n\t  alphabet : [\"a\", \"b\"],\r\n\t  variables : [\"A\", \"B\", \"C\", \"D\", \"E\"],\r\n\t  initial : \"A\",\r\n    rules : [\"A -> aBb | bBa\", \"B -> Cb | bC\", \"C -> a | aC\", \"D -> E | Db\", \"E -> aE | Da\"]\r\n  } |}\r\n  \r\n  let accessible_symbols2 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Accessible symbols example\",\r\n\t  name : \"AS2\",\r\n\t  alphabet : [\"a\", \"b\"],\r\n\t  variables : [\"S\", \"B\"],\r\n\t  initial : \"S\",\r\n    rules : [\"S -> a\", \"B -> b\"]\r\n  } |}\r\n  \r\n  let productive_symbols1 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Productive symbols example\",\r\n\t  name : \"PS1\",\r\n\t  alphabet : [\"a\", \"b\"],\r\n\t  variables : [\"A\", \"B\", \"C\", \"D\", \"E\"],\r\n\t  initial : \"A\",\r\n    rules : [\"A -> aBb | bBa\", \"B -> CD | aC | Ab\", \"C -> a | aC\", \"D -> E | DA\", \"E -> aE | Da\"]\r\n  } |}\r\n\r\n  let productive_symbols2 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Productive symbols example\",\r\n\t  name : \"PS2\",\r\n\t  alphabet : [\"a\", \"b\"],\r\n\t  variables : [\"S\", \"A\", \"B\"],\r\n\t  initial : \"S\",\r\n    rules : [\"S -> a | A\", \"A -> AB\", \"B -> b\"]\r\n  } |}\r\n  \r\n  let clean_grammar1 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Clean example from https://www.cs.scranton.edu/~mccloske/courses/cmps260/cfg_remove_useless.html\",\r\n\t  name : \"Clean1\",\r\n\t  alphabet : [\"a\", \"b\", \"c\", \"d\"],\r\n\t  variables : [\"S\", \"A\", \"B\", \"C\", \"D\"],\r\n\t  initial : \"S\",\r\n    rules : [\"S -> aSa | bB | bAA\", \"A -> a | SbA | aB\", \"B -> AB | CaB\", \"C -> cC | Sa | bD\", \"D -> dD | \"]\r\n  } |}\r\n\r\n  let direct_left_recursion_grammar1 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Direct Left-recursion example 1\",\r\n\t  name : \"DR1\",\r\n\t  alphabet : [\"a\", \"b\"],\r\n\t  variables : [\"A\"],\r\n\t  initial : \"A\",\r\n    rules : [\"A -> Aa | b\"]\r\n  }  |}\r\n  \r\n  let direct_left_recursion_grammar2 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Direct Left-recursion example 2\",\r\n\t  name : \"DR2\",\r\n\t  alphabet : [\"a\", \"b\"],\r\n\t  variables : [\"B\"],\r\n\t  initial : \"B\",\r\n    rules : [\"B -> a | Bb\"]\r\n  } |}\r\n  \r\n  let indirect_left_recursion_grammar1 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Indirect Left-recursion example 1\",\r\n\t  name : \"IR1\",\r\n\t  alphabet : [\"a\"],\r\n\t  variables : [\"S\", \"A\"],\r\n\t  initial : \"S\",\r\n    rules : [\"S -> A | a\", \"A -> S\"]\r\n  }  |}\r\n\r\n  let indirect_left_recursion_grammar2 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Indirect Left-recursion example 2\",\r\n\t  name : \"IR2\",\r\n\t  alphabet : [\"a\"],\r\n\t  variables : [\"S\", \"A\", \"B\"],\r\n\t  initial : \"S\",\r\n    rules : [\"S -> A | B\", \"A -> a\", \"B -> S\"]\r\n  }  |}\r\n  \r\n  let indirect_left_recursion_grammar3 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Indirect Left-recursion example 2\",\r\n\t  name : \"IR3\",\r\n\t  alphabet : [\"a\", \"b\", \"c\"],\r\n\t  variables : [\"S\", \"A\", \"B\", \"C\"],\r\n\t  initial : \"S\",\r\n    rules : [\"S -> ABCS\", \"A -> a | \", \"B -> b | \", \"C -> c | \"]\r\n  }  |} \r\n  \r\n  let indirect_left_recursion_grammar4 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Indirect Left-recursion example\",\r\n\t  name : \"IR4\",\r\n\t  alphabet : [\"a\", \"b\", \"d\", \"e\", \"f\", \"g\"],\r\n\t  variables : [\"A\", \"B\", \"C\", \"D\"],\r\n\t  initial : \"A\",\r\n    rules : [\"A -> Ba | b\", \"B -> Cd | e\", \"C-> Df | g\", \"D -> Df | Aa | Cg\"]\r\n  }  |}\r\n\r\n  let indirect_left_recursion_grammar5 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Indirect Left-recursion example 2\",\r\n\t  name : \"IR3\",\r\n\t  alphabet : [\"a\"],\r\n\t  variables : [\"S\", \"A\"],\r\n\t  initial : \"S\",\r\n    rules : [\"S -> AS\", \"A -> a | \"]\r\n  }  |}\r\n\r\n  let left_factoring_example = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Left Factoring example\",\r\n\t  name : \"LF1\",\r\n\t  alphabet : [\"a\", \"b\", \"e\", \"i\", \"t\"],\r\n\t  variables : [\"S\", \"E\"],\r\n\t  initial : \"S\",\r\n    rules : [\"S -> iEtS | iEtSeS | a\", \"E -> b\"]\r\n  } |}\r\n\r\n  let left_factoring_example2 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Left Factoring example\",\r\n\t  name : \"LF2\",\r\n\t  alphabet : [\"a\", \"c\"],\r\n\t  variables : [\"A\", \"B\"],\r\n\t  initial : \"A\",\r\n    rules : [\"A -> aAB | aBc | aAc\", \"B ->\"]\r\n  } |}\r\n\r\n  let left_factoring_example3 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Left Factoring example\",\r\n\t  name : \"LF3\",\r\n\t  alphabet : [\"a\", \"b\"],\r\n\t  variables : [\"S\"],\r\n\t  initial : \"S\",\r\n    rules : [\"S -> bSSaaS | bSSaSb | bSb | a\"]\r\n  } |}\r\n\r\n  let left_factoring_example4 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Left Factoring example\",\r\n\t  name : \"LF4\",\r\n\t  alphabet : [\"a\", \"b\"],\r\n\t  variables : [\"S\"],\r\n\t  initial : \"S\",\r\n    rules : [\"S -> aSSbS | aSaSb | abb | b\"]\r\n  } |}\r\n  \r\n  let left_factoring_example5 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Left Factoring example\",\r\n\t  name : \"LF5\",\r\n\t  alphabet : [\"a\", \"b\", \"c\", \"d\"],\r\n\t  variables : [\"S\"],\r\n\t  initial : \"S\",\r\n    rules : [\"S -> a | ab | abc | abcd\"]\r\n  } |}\r\n  \r\n  let left_factoring_example6 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"Left Factoring example\",\r\n\t  name : \"LF6\",\r\n\t  alphabet : [\"a\", \"b\", \"c\", \"d\"],\r\n\t  variables : [\"S\", \"A\", \"B\"],\r\n\t  initial : \"S\",\r\n    rules : [\"S -> aAd | aB\", \"A -> a | ab\", \"B -> ccd | ddc\"]\r\n  } |}\r\n  \r\n  let unit_removal_example1 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"unit removal example\",\r\n\t  name : \"UR1\",\r\n\t  alphabet : [\"a\", \"b\"],\r\n\t  variables : [\"E\", \"T\", \"F\", \"I\"],\r\n\t  initial : \"E\",\r\n    rules : [\"E -> T\", \"T -> F\", \"F -> I\", \"I -> a | b | Ia | Ib\"]\r\n  } |}\r\n\r\n  let unit_removal_example2 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"unit removal example 2\",\r\n\t  name : \"UR2\",\r\n\t  alphabet : [\"a\", \"b\", \"c\"],\r\n\t  variables : [\"A\", \"B\", \"C\"],\r\n\t  initial : \"A\",\r\n    rules : [\"A -> B | a\", \"B -> C | b\", \"C -> A | c\"]\r\n  } |}\r\n  \r\n  let unit_removal_example3 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"unit removal example 3\",\r\n\t  name : \"UR3\",\r\n\t  alphabet : [\"a\", \"b\", \"c\"],\r\n\t  variables : [\"S\", \"A\", \"B\"],\r\n\t  initial : \"S\",\r\n    rules : [\"S -> Aa | B | c\", \"A -> a | bc | B\", \"B -> A | bb\"]\r\n  } |}\r\n  \r\n  let unit_removal_example4 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"unit removal example 4\",\r\n\t  name : \"UR4\",\r\n\t  alphabet : [\"a\", \"b\", \"d\"],\r\n\t  variables : [\"S\", \"A\", \"B\", \"C\", \"D\", \"E\"],\r\n\t  initial : \"S\",\r\n    rules : [\"S -> AC\", \"A -> a\", \"B -> D\", \"C -> B | d\", \"D -> E\", \"E -> b\"]\r\n  } |}\r\n  \r\n  let unit_removal_example5 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"unit removal example 5\",\r\n\t  name : \"UR5\",\r\n\t  alphabet : [\"a\", \"b\", \"0\", \"1\", \"(\", \")\", \"+\", \"*\"],\r\n\t  variables : [\"I\", \"F\", \"T\", \"E\"],\r\n\t  initial : \"E\",\r\n    rules : [\"E -> T | E+T\", \"T -> F | T*F\", \"F -> I | (E)\", \"I -> a | b | Ia | Ib | I0 | I1\"]\r\n  } |}\r\n\r\n  let epsilon_removal_example1 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"epsilon removal example\",\r\n\t  name : \"ER1\",\r\n\t  alphabet : [\"a\", \"b\", \"d\"],\r\n\t  variables : [\"S\", \"A\", \"B\", \"C\", \"D\"],\r\n\t  initial : \"S\",\r\n    rules : [\"S -> ABaC\", \"A -> BC\", \"B -> b | \", \"C -> D | \", \"D -> d\"]\r\n  } |}\r\n  \r\n  let epsilon_removal_example2 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"epsilon removal example 2\",\r\n\t  name : \"ER2\",\r\n\t  alphabet : [\"a\", \"b\"],\r\n\t  variables : [\"S\", \"A\", \"B\"],\r\n\t  initial : \"S\",\r\n    rules : [\"S -> AB\", \"A -> AaA | \", \"B -> BbB | \"]\r\n  } |}\r\n  \r\n  let epsilon_removal_example3 = {| {\r\n\t  kind : \"context free grammar\", \r\n\t  description : \"epsilon removal example 3\",\r\n\t  name : \"ER3\",\r\n\t  alphabet : [\"a\", \"b\"],\r\n\t  variables : [\"S\", \"A\", \"B\"],\r\n\t  initial : \"S\",\r\n    rules : [\"S -> AB\", \"A -> aAA | \", \"B -> bBB | \"]\r\n  } |}\r\n\r\n  let firstPairConversion_old l = Set.make (List.map (fun (a,b) -> (a, Set.make b)) l)\r\n  let followPairConversion_old l = Set.make (List.map (fun (a,b) -> (a, Set.make b)) l)\r\n  let lookaheadPairConversion_old l = Set.make (List.map (fun (a,b) -> ContextFreeGrammarBasic.parseLine a, Set.make b) l)\r\n\r\n  let firstPairConversion l = Set.make (List.map (fun (a,b) -> (symb a, Set.make (List.map char2symb b))) l)\r\n  let followPairConversion l = Set.make (List.map (fun (a,b) -> (char2symb a, Set.make (List.map char2symb b))) l)\r\n  let lookaheadPairConversion l = Set.make (List.map (fun (a,b) -> (Set.nth (ContextFreeGrammarBasic.parseLine a) 0), Set.make (List.map char2symb b)) l)\r\n\r\n  let printRepresentation (rep: t) =\r\n    Printf.printf \"Alphabet = \"; Util.printAlphabet rep.alphabet;\r\n    Printf.printf \"Variables = \"; Util.printAlphabet rep.variables;\r\n    Printf.printf \"Initial = %s\\n\" (symb2str rep.initial);\r\n    Printf.printf \"Rules {\\n\"; Set.iter (fun {head=h; body=b} -> Printf.printf \"\\t%s -> %s\\n\" (symb2str h) (word2str b)) rep.rules;\r\n    Printf.printf \"}\\n\\n\"\r\n\r\n  let rec testFunction2 f l c =\r\n    if l = Set.empty then ()\r\n    else let ((t,r),xs) = Set.cut l in\r\n      if (f t = r) then () else Printf.printf \"\\t\\tTest %i fails!\\n\" c;\r\n      testFunction2 f xs (c+1)\r\n\r\n\r\n\tlet colorRed = \"\\027[31m\"\r\n\tlet colorGreen = \"\\027[32m\"\r\n\tlet colorOff = \"\\027[0m\"\r\n\r\n(*\tlet colorRed = \"\"*)\r\n(*\tlet colorGreen = \"\"*)\r\n(*\tlet colorOff = \"\"*)\r\n\r\n  let failPrint str =\r\n    Printf.printf \"%s\" (colorRed ^ str ^ colorOff)\r\n    \r\n  let okPrint str =\r\n    Printf.printf \"%s\" (colorGreen ^ str ^ colorOff)\r\n\r\n  let printResult r =\r\n    if r\r\n    then okPrint \"O\"\r\n    else failPrint \"X\"\r\n  \r\n  let printFirstTest t =\r\n    Set.iter (fun (v,s) -> \r\n      Printf.printf \"(%s, [\" v;\r\n      Set.iter (fun v -> Printf.printf \"%c \" v) s;\r\n      Printf.printf \"%s\" \"]) \"\r\n    ) t\r\n    \r\n  let compareTheseSets s1 s2 =\r\n    Set.for_all (fun (h1,r1) ->\r\n      Set.exists (fun (h2,r2) -> h1 = h2 && Set.equals r1 r2) s2\r\n    ) s1 && Set.size s1 = Set.size s2\r\n\r\n  let testFirst g r =\r\n    let allResults = Set.map (fun v -> (v, g#first [v])) (g#representation : t).variables in\r\n(*    Printf.printf \"\\n\\tComparing:\";*)\r\n(*    Set.iter (fun (v,b) -> Printf.printf \"\\n\\t\\t%s->\\t\" (symb2str v); Set.iter (fun s ->  Printf.printf \" %s \" (symb2str s)) b) r;*)\r\n(*    Printf.printf \"\\n\\twith:\";*)\r\n(*    Set.iter (fun (v,b) -> Printf.printf \"\\n\\t\\t%s->\\t\" (symb2str v); Set.iter (fun s ->  Printf.printf \" %s \" (symb2str s)) b) allResults;*)\r\n(*    Printf.printf \"\\n\";*)\r\n(*    r = allResults*)\r\n    compareTheseSets r allResults\r\n\r\n  let testFollow g r =\r\n    let allResults = Set.map (fun v -> (v, g#follow v)) (g#representation : t).variables in\r\n(*    Printf.printf \"\\n\\tComparing:\";*)\r\n(*    Set.iter (fun (v,b) -> Printf.printf \"\\n\\t\\t%s->\\t\" (symb2str v); Set.iter (fun s ->  Printf.printf \" %s \" (symb2str s)) b) r;*)\r\n(*    Printf.printf \"\\n\\twith:\";*)\r\n(*    Set.iter (fun (v,b) -> Printf.printf \"\\n\\t\\t%s->\\t\" (symb2str v); Set.iter (fun s ->  Printf.printf \" %s \" (symb2str s)) b) allResults;*)\r\n(*    Printf.printf \"\\n\";*)\r\n(*    r = allResults*)\r\n    compareTheseSets r allResults\r\n    \r\n  let testLookahead g r =\r\n    let rep = (g#representation : t) in\r\n    let allResults = \r\n      Set.flatMap (fun v -> \r\n        let rules = Set.filter (fun {head=h; _} -> h = v ) rep.rules in\r\n        Set.map (fun r -> \r\n          (r, g#lookahead r)\r\n        ) rules\r\n      ) rep.variables \r\n    in\r\n(*    Printf.printf \"\\n\\tComparing:\";*)\r\n(*    Set.iter (fun ({head=h;body=b},r) -> Printf.printf \"\\n\\t\\t%s->%s\\t\" (symb2str h) (word2str b); Set.iter (fun s ->  Printf.printf \" %s \" (symb2str s)) r) r;*)\r\n(*    Printf.printf \"\\n\\twith:\";*)\r\n(*    Set.iter (fun ({head=h;body=b},r) -> Printf.printf \"\\n\\t\\t%s->%s\\t\" (symb2str h) (word2str b); Set.iter (fun s ->  Printf.printf \" %s \" (symb2str s)) r) allResults;*)\r\n(*    Printf.printf \"\\n\";*)\r\n(*    r = allResults*)\r\n    compareTheseSets r allResults\r\n\r\n  let testFunction1 f r =\r\n    f = r\r\n\r\n\r\n\r\n(*\tlet test0 () =*)\r\n(*\t\tlet m = new ContextFreeGrammarLL1.model (Arg.Text cfg_simple) in*)\r\n(*\t\tlet j = m#toJSon in*)\r\n(*\t\t\tJSon.show j*)\r\n\r\n\tlet dollar = '$'\r\n\tlet epsilon = '~'\r\n\r\n  let testExample1 () =\r\n    Printf.printf \"Example1 test: [\";\r\n    let first = [ (\"S\", ['a'; 'b'; 'c']); (\"A\", ['a'; '~']); (\"B\", ['b'; '~']); (\"C\", ['c']); (\"D\", ['d'; '~']); (\"E\", ['e'; '~']) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('S', ['$']); ('A', ['b'; 'c']); ('B', ['c']); ('C', ['d'; 'e'; '$']); ('D', ['e'; '$']); ('E', ['$']) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"S->ABCDE\", ['a'; 'b'; 'c']); \r\n                      (\"A->a\", ['a']); (\"A->\", ['b'; 'c']);\r\n                      (\"B->b\", ['b']); (\"B->\", ['c']); \r\n                      (\"C->c\", ['c']); \r\n                      (\"D->d\", ['d']); (\"D->\", ['e'; dollar]); \r\n                      (\"E->e\", ['e']); (\"E->\", [dollar]) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text example1) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n\t  printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#isLL1 true);\r\n      printResult (testFunction1 m#isLeftRecursive false);\r\n    Printf.printf \"]\\n\"\r\n    \r\n  let testExample2 () =\r\n    Printf.printf \"Example2 test: [\";\r\n    let first = [ (\"S\", ['a'; 'b'; 'c'; 'd']); (\"B\", ['a'; epsilon]); (\"C\", ['c'; epsilon]) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('S', [dollar]); ('B', ['b']); ('C', ['d']) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"S->Bb\", ['a'; 'b']); (\"S->Cd\", ['c'; 'd']);\r\n                      (\"B->aB\", ['a']); (\"B->\", ['b']);\r\n                      (\"C->cC\", ['c']); (\"C->\", ['d']) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text example2) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#isLL1 true);\r\n      printResult (testFunction1 m#isLeftRecursive false);\r\n    Printf.printf \"]\\n\"\r\n    \r\n  let testExample3 () =\r\n    Printf.printf \"Example3 test: [\";\r\n    let first = [ (\"U\", ['*'; epsilon]); (\"D\", ['+'; epsilon]); (\"E\", ['('; 'i']); (\"F\", ['('; 'i']); (\"T\", ['('; 'i']) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('U', [')'; '+'; dollar]); ('D', [')'; dollar]); ('E', [')'; dollar]); ('F', [')'; '*'; '+'; dollar]); ('T', [')'; '+'; dollar]) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"U->*FU\", ['*']); (\"U->\", [')'; '+'; dollar]); \r\n                      (\"D->+TD\", ['+']); (\"D->\", [')'; dollar]); \r\n                      (\"E->TD\", ['('; 'i']); \r\n                      (\"F->i\", ['i']); (\"F->(E)\", ['(']);\r\n                      (\"T->FU\", ['('; 'i']) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text example3) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#isLL1 true);\r\n      printResult (testFunction1 m#isLeftRecursive false);\r\n    Printf.printf \"]\\n\"\r\n    \r\n  let testExample4 () =\r\n    Printf.printf \"Example4 test: [\";\r\n    let first = [ (\"S\", ['a']); (\"B\", ['c']); (\"C\", ['b'; epsilon]); (\"D\", ['f'; 'g'; epsilon]); (\"E\", ['g'; epsilon]); (\"F\", ['f'; epsilon]) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('S', [dollar]); ('B', ['f'; 'g'; 'h']); ('C', ['f'; 'g'; 'h']); ('D', ['h']); ('E', ['f'; 'h']); ('F', ['h']) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"S->aBDh\", ['a']);\r\n                      (\"B->cC\", ['c']);\r\n                      (\"C->bC\", ['b']); (\"C->\", ['f'; 'g'; 'h']); \r\n                      (\"D->EF\", ['f'; 'g'; 'h']);\r\n                      (\"E->g\", ['g']); (\"E->\", ['f'; 'h']);\r\n                      (\"F->f\", ['f']); (\"F->\", ['h']) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text example4) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#isLL1 true);\r\n      printResult (testFunction1 m#isLeftRecursive false);\r\n    Printf.printf \"]\\n\"\r\n    \r\n  let testExample5 () =\r\n    Printf.printf \"Example5 test: [\";\r\n    let first = [ (\"E\", ['n']); (\"A\", ['n'; epsilon]); (\"B\", ['*'; '+']) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('E', ['*'; '+'; dollar]); ('A', ['*'; '+'; dollar]); ('B', ['*'; '+'; dollar]) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"E->nA\", ['n']);\r\n                      (\"A->EB\", ['n']); (\"A->\", ['*'; '+'; dollar]);\r\n                      (\"B->+A\", ['+']); (\"B->*A\", ['*']) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text example5) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#isLL1 true);\r\n      printResult (testFunction1 m#isLeftRecursive false);\r\n    Printf.printf \"]\\n\"\r\n    \r\n  let testExample6 () =\r\n    Printf.printf \"Example6 test: [\";\r\n    let first = [ (\"N\", ['a'; 'b']); (\"A\", ['a'; 'b']); (\"B\", ['a'; 'b']); (\"C\", ['a'; 'b']) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('N', [dollar]); ('A', ['a'; 'b'; dollar]); ('B', ['a'; 'b'; dollar]); ('C', ['a'; 'b'; dollar]) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"N->AB\", ['a'; 'b']); (\"N->BA\", ['a'; 'b']);\r\n                      (\"A->a\", ['a']); (\"A->CAC\", ['a'; 'b']);\r\n                      (\"B->b\", ['b']); (\"B->CBC\", ['a'; 'b']); \r\n                      (\"C->a\", ['a']); (\"C->b\", ['b']) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text example6) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#isLL1 false);\r\n      printResult (testFunction1 m#isLeftRecursive false);\r\n    Printf.printf \"]\\n\"\r\n\r\n  let testDissertation () =\r\n    Printf.printf \"%s\" (Printf.sprintf \"Dissertation test: [\");\r\n    let first = [ (\"S\", ['a']); (\"A\", ['a']); (\"B\", ['c']); (\"C\", ['c']); (\"D\", ['a'; epsilon]); (\"E\", ['b'; epsilon]) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('S', [dollar]); ('A', ['c']); ('B', ['c']); ('C', ['b'; 'c'; dollar]); ('D', ['c']); ('E', ['c']) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"S->ABC\", ['a']); \r\n                      (\"A->aD\", ['a']); \r\n                      (\"B->CE\", ['c']);\r\n                      (\"C->c\", ['c']); \r\n                      (\"D->AB\", ['a']); (\"D->\", ['c']);\r\n                      (\"E->bE\", ['b']); (\"E->\", ['c']) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text cfg_dissertation) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#isLL1 true);\r\n      printResult (testFunction1 m#isLeftRecursive false);\r\n    Printf.printf \"]\\n\"\r\n    \r\n  let testNFGrammar () =\r\n    Printf.printf \"Non deterministic grammar test: [\";\r\n    let first = [ (\"S\", ['a'; 'b'; 'd'; 'g'; 'h'; epsilon]); (\"A\", ['d'; 'g'; 'h'; epsilon]); (\"B\", ['g'; epsilon]); (\"C\", ['h'; epsilon]) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('S', [dollar]); ('A', ['g'; 'h'; dollar]); ('B', ['a'; 'g'; 'h'; dollar]); ('C', ['b'; 'g'; 'h'; dollar]) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"S->ACB\", ['d'; 'g'; 'h'; dollar]); (\"S->CbB\", ['b'; 'h']); (\"S->Ba\", ['a'; 'g']);\r\n                      (\"A->da\", ['d']); (\"A->BC\", ['g'; 'h'; dollar]); \r\n                      (\"B->g\", ['g']); (\"B->\", ['a'; 'g'; 'h'; dollar]); \r\n                      (\"C->h\", ['h']); (\"C->\", ['b'; 'g'; 'h'; dollar]); ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text non_deterministic_grammar) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#isLL1 false);\r\n      printResult (testFunction1 m#isLeftRecursive false);\r\n    Printf.printf \"]\\n\"\r\n\r\n  let testAccessible1 () =\r\n    Printf.printf \"%s\" (Printf.sprintf \"Remove inaccessible symbols test 1: [\");\r\n    let first = [ (\"A\", ['a'; 'b']); (\"B\", ['a'; 'b']); (\"C\", ['a']); (\"D\", ['a']); (\"E\", ['a']) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('A', [dollar]); ('B', ['a'; 'b']); ('C', ['a'; 'b']); ('D', ['a'; 'b']); ('E', ['a'; 'b']) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"A->aBb\", ['a']); (\"A->bBa\", ['b']); \r\n                      (\"B->Cb\", ['a']); (\"B->bC\", ['b']);\r\n                      (\"C->a\", ['a']); (\"C->aC\", ['a']); \r\n                      (\"D->E\", ['a']); (\"D->Db\", ['a']);\r\n                      (\"E->aE\", ['a']); (\"E->Da\", ['a']) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text accessible_symbols1) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#isLeftRecursive true);\r\n      printResult (testFunction1 m#isLL1 false);\r\n      printResult (testFunction1 m#isFullyAccessible false);\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation m#accessibleRewrite#representation) in\r\n(*      printRepresentation m#representation;*)\r\n(*      printRepresentation transformed#representation;*)\r\n      printResult (testFunction1 transformed#isFullyAccessible true);\r\n    Printf.printf \"]\\n\"\r\n    \r\n  let testAccessible2 () =\r\n    Printf.printf \"%s\" (Printf.sprintf \"Remove inaccessible symbols test 2: [\");\r\n    let first = [ (\"S\", ['a']); (\"B\", ['b']) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('S', [dollar]); ('B', []) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"S->a\", ['a']); \r\n                      (\"B->b\", ['b']) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text accessible_symbols2) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#isLeftRecursive false);\r\n      printResult (testFunction1 m#isLeftFactoring false);\r\n      printResult (testFunction1 m#isLL1 true);\r\n      printResult (testFunction1 m#isFullyAccessible false);\r\n      printResult (testFunction1 m#isFullyProductive true);\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation m#accessibleRewrite#representation) in\r\n      printResult (testFunction1 transformed#isFullyAccessible true);\r\n      printResult (testFunction1 transformed#isFullyProductive true);\r\n    Printf.printf \"]\\n\"\r\n\r\n  let testProductive1 () =\r\n    Printf.printf \"%s\" (Printf.sprintf \"Remove unproductive symbols test 1: [\");\r\n    let first = [ (\"A\", ['a'; 'b']); (\"B\", ['a'; 'b']); (\"C\", ['a']); (\"D\", ['a']); (\"E\", ['a']) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('A', ['a'; 'b'; dollar]); ('B', ['a'; 'b']); ('C', ['a'; 'b']); ('D', ['a'; 'b']); ('E', ['a'; 'b']) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"A->aBb\", ['a']); (\"A->bBa\", ['b']); \r\n                      (\"B->CD\", ['a']); (\"B->aC\", ['a']); (\"B->Ab\", ['a'; 'b']);\r\n                      (\"C->a\", ['a']); (\"C->aC\", ['a']); \r\n                      (\"D->E\", ['a']); (\"D->DA\", ['a']);\r\n                      (\"E->aE\", ['a']); (\"E->Da\", ['a']) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text productive_symbols1) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#isLeftRecursive true);\r\n      printResult (testFunction1 m#isLeftFactoring true);\r\n      printResult (testFunction1 m#isLL1 false);\r\n      printResult (testFunction1 m#isFullyProductive false);\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation m#productiveRewrite#representation) in\r\n      printResult (testFunction1 transformed#isFullyProductive true);\r\n    Printf.printf \"]\\n\"\r\n\r\n  let testProductive2 () =\r\n    Printf.printf \"%s\" (Printf.sprintf \"Remove unproductive symbols test 2: [\");\r\n    let first = [ (\"S\", ['a']); (\"A\", []); (\"B\", ['b']) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('S', [dollar]); ('A', ['b'; dollar]); ('B', ['b'; dollar]) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"S->a\", ['a']); (\"S->A\", []); \r\n                      (\"A->AB\", []);\r\n                      (\"B->b\", ['b']) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text productive_symbols2) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#isLeftRecursive true);\r\n      printResult (testFunction1 m#isLeftFactoring false);\r\n      printResult (testFunction1 m#isLL1 true);\r\n      printResult (testFunction1 m#isFullyAccessible true);\r\n      printResult (testFunction1 m#isFullyProductive false);\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation m#productiveRewrite#representation) in\r\n      printResult (testFunction1 transformed#isFullyAccessible false);\r\n      printResult (testFunction1 transformed#isFullyProductive true);\r\n    let fullyTransformed =  new ContextFreeGrammarLL1.model (Arg.Representation (List.nth m#clean 1).grammar#representation) in\r\n      printResult (testFunction1 fullyTransformed#isFullyAccessible true);\r\n      printResult (testFunction1 fullyTransformed#isFullyProductive true);\r\n    Printf.printf \"]\\n\"\r\n\r\n  let cleanGrammar1 () = \r\n    Printf.printf \"%s\" (Printf.sprintf \"Clean grammar test 1: [\");\r\n    let first = [ (\"S\", ['a'; 'b']); (\"A\", ['a'; 'b']); (\"B\", ['a'; 'b'; 'c']); (\"C\", ['a'; 'b'; 'c']); (\"D\", ['d'; epsilon]) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('S', ['a'; 'b'; dollar]); ('A', ['a'; 'b'; 'c'; dollar]); ('B', ['a'; 'b'; 'c'; dollar]); ('C', ['a']); ('D', ['a']) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"S->aSa\", ['a']); (\"S->bB\", ['b']); (\"S->bAA\", ['b']);\r\n                      (\"A->a\", ['a']); (\"A->SbA\", ['a'; 'b']); (\"A->aB\", ['a']);\r\n                      (\"B->AB\", ['a'; 'b']); (\"B->CaB\", ['a'; 'b'; 'c']);\r\n                      (\"C->cC\", ['c']); (\"C->Sa\", ['a'; 'b']); (\"C->bD\", ['b']);\r\n                      (\"D->dD\", ['d']); (\"D->\", ['a']) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text clean_grammar1) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#isLeftRecursive false);\r\n      printResult (testFunction1 m#isLeftFactoring true);\r\n      printResult (testFunction1 m#isLL1 false);\r\n      printResult (testFunction1 m#isFullyAccessible true);\r\n      printResult (testFunction1 m#isFullyProductive false);\r\n    let fullyTransformed =  new ContextFreeGrammarLL1.model (Arg.Representation (List.nth m#clean 1).grammar#representation) in\r\n      printResult (testFunction1 fullyTransformed#isFullyAccessible true);\r\n      printResult (testFunction1 fullyTransformed#isFullyProductive true);\r\n    Printf.printf \"]\\n\"\r\n    \r\n  let testDirectRecursion1 () =\r\n    Printf.printf \"Direct recursion test 1: [\";\r\n    let first = [ (\"A\", ['b']) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('A', ['a'; dollar]) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"A->Aa\", ['b']); (\"A->b\", ['b']) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text direct_left_recursion_grammar1) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#isLeftRecursive true);\r\n      printResult (testFunction1 m#isLeftFactoring false);\r\n      printResult (testFunction1 m#isLL1 false);\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation m#removeLeftRecursion.grammar#representation) in\r\n      printResult (testFunction1 transformed#isLeftRecursive false);\r\n      printResult (testFunction1 transformed#isLeftFactoring false);\r\n      printResult (testFunction1 transformed#isLL1 true);\r\n    Printf.printf \"]\\n\"\r\n\r\n  let testDirectRecursion2 () =\r\n    Printf.printf \"Direct recursion test 2: [\";\r\n    let first = [ (\"B\", ['a']) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('B', ['b'; dollar]) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"B->a\", ['a']); (\"B->Bb\", ['a']) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text direct_left_recursion_grammar2) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#isLeftRecursive true);\r\n      printResult (testFunction1 m#isLeftFactoring false);\r\n      printResult (testFunction1 m#isLL1 false);\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation m#removeLeftRecursion.grammar#representation) in\r\n      printResult (testFunction1 transformed#isLeftRecursive false);\r\n      printResult (testFunction1 transformed#isLeftFactoring false);\r\n      printResult (testFunction1 transformed#isLL1 true);\r\n    Printf.printf \"]\\n\"\r\n\r\n  let testIndirectRecursion1 () =\r\n    Printf.printf \"Indirect recursion test 1: [\";\r\n    let first = [ (\"A\", ['a']); (\"S\", ['a']) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('A', [dollar]); ('S', [dollar]) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"S->A\", ['a']); (\"S->a\", ['a']); (\"A->S\", ['a']) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text indirect_left_recursion_grammar1) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#isLeftRecursive true);\r\n      printResult (testFunction1 m#isLeftFactoring false);\r\n      printResult (testFunction1 m#isLL1 false);\r\n    (*Left recursion cannot be solved with #removeLeftRecursion. There are unit productions that need to be removed first.*)\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation m#removeUnitProductions.grammar#representation) in\r\n      printResult (testFunction1 transformed#isLeftRecursive false);\r\n      printResult (testFunction1 transformed#isLeftFactoring false);\r\n      printResult (testFunction1 transformed#isLL1 true);\r\n      printResult (testFunction1 transformed#isClean false);\r\n    (*Grammar can be cleaned yet.*)\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation (List.nth transformed#clean 1).grammar#representation) in\r\n      printResult (testFunction1 transformed#isLeftRecursive false);\r\n      printResult (testFunction1 transformed#isLeftFactoring false);\r\n      printResult (testFunction1 transformed#isLL1 true);\r\n      printResult (testFunction1 transformed#isClean true);\r\n    Printf.printf \"]\\n\"\r\n    \r\n  let testIndirectRecursion2 () = (*FIXME Trying to clean grammar right away fails*)\r\n    Printf.printf \"Indirect recursion test 2: [\";\r\n    let first = [ (\"S\", ['a']); (\"A\", ['a']); (\"B\", ['a']) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('S', [dollar]); ('A', [dollar]); ('B', [dollar]) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"S->A\", ['a']); (\"S->B\", ['a']);\r\n                      (\"A->a\", ['a']);\r\n                      (\"B->S\", ['a']) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text indirect_left_recursion_grammar2) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#isLeftRecursive true);\r\n      printResult (testFunction1 m#isLeftFactoring false);\r\n      printResult (testFunction1 m#isLL1 false);\r\n    (*Left recursion cannot be solved with #removeLeftRecursion. There are epsilon productions that need to be removed first.*)\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation m#removeEmptyProductions.grammar#representation) in\r\n      printResult (testFunction1 transformed#isLeftRecursive true);\r\n      printResult (testFunction1 transformed#isLeftFactoring false);\r\n      printResult (testFunction1 transformed#isLL1 false);\r\n    (*Left recursion cannot be solved with #removeLeftRecursion. There are unit productions that need to be removed first.*)\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation transformed#removeUnitProductions.grammar#representation) in\r\n      printResult (testFunction1 transformed#isLeftRecursive false);\r\n      printResult (testFunction1 transformed#isLeftFactoring false);\r\n      printResult (testFunction1 transformed#isLL1 true);\r\n    (*Grammar can be cleaned yet.*)\r\n      printResult (testFunction1 transformed#isClean false);\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation (List.nth transformed#clean 1).grammar#representation) in\r\n      printResult (testFunction1 transformed#isLeftRecursive false);\r\n      printResult (testFunction1 transformed#isLeftFactoring false);\r\n      printResult (testFunction1 transformed#isLL1 true);\r\n      printResult (testFunction1 transformed#isClean true);\r\n    Printf.printf \"]\\n\"\r\n\r\n  let testIndirectRecursion3 () =\r\n    Printf.printf \"Indirect recursion test 3: [\";\r\n    let first = [ (\"S\", ['a'; 'b'; 'c']); (\"A\", ['a'; epsilon]); (\"B\", ['b'; epsilon]); (\"C\", ['c'; epsilon]) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('S', [dollar]); ('A', ['a'; 'b'; 'c']); ('B', ['a'; 'b'; 'c']); ('C', ['a'; 'b'; 'c']) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"S->ABCS\", ['a'; 'b'; 'c']);\r\n                      (\"A->a\", ['a']); (\"A->\", ['a'; 'b'; 'c']); \r\n                      (\"B->b\", ['b']); (\"B->\", ['a'; 'b'; 'c']); \r\n                      (\"C->c\", ['c']); (\"C->\", ['a'; 'b'; 'c']) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text indirect_left_recursion_grammar3) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#isLeftRecursive true);\r\n      printResult (testFunction1 m#isLeftFactoring false);\r\n      printResult (testFunction1 m#isLL1 false);\r\n    (*Left recursion cannot be solved with #removeLeftRecursion. There are epsilon productions that need to be removed first.*)\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation m#removeEmptyProductions.grammar#representation) in\r\n      printResult (testFunction1 transformed#isLeftRecursive true);\r\n      printResult (testFunction1 transformed#isLeftFactoring true);\r\n      printResult (testFunction1 transformed#isLL1 false);\r\n    (*Left recursion cannot be solved with #removeLeftRecursion. There are unit productions that need to be removed first.*)\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation transformed#removeUnitProductions.grammar#representation) in\r\n      printResult (testFunction1 transformed#isLeftRecursive false);\r\n      printResult (testFunction1 transformed#isLeftFactoring true);\r\n      printResult (testFunction1 transformed#isLL1 false);\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation transformed#leftFactoring.grammar#representation) in\r\n      printResult (testFunction1 transformed#isLeftRecursive false);\r\n      printResult (testFunction1 transformed#isLeftFactoring false);\r\n      printResult (testFunction1 transformed#isLL1 false); (*This grammar is not LL(1)*)\r\n    Printf.printf \"]\\n\"\r\n    \r\n  let testIndirectRecursion4 () =\r\n    Printf.printf \"Indirect recursion test 4: [\";\r\n    let first = [ (\"A\", ['b'; 'e'; 'g']); (\"B\", ['b'; 'e'; 'g']); (\"C\", ['b'; 'e'; 'g']); (\"D\", ['b'; 'e'; 'g']) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('A', ['a'; dollar]); ('B', ['a']); ('C', ['d'; 'g']); ('D', ['f']) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"A->Ba\", ['b'; 'e'; 'g']); (\"A->b\", ['b']);\r\n                      (\"B->Cd\", ['b'; 'e'; 'g']); (\"B->e\", ['e']);\r\n                      (\"C->Df\", ['b'; 'e'; 'g']); (\"C->g\", ['g']);\r\n                      (\"D->Df\", ['b'; 'e'; 'g']); (\"D->Aa\", ['b'; 'e'; 'g']); (\"D->Cg\", ['b'; 'e'; 'g']) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text indirect_left_recursion_grammar4) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#isLeftRecursive true);\r\n      printResult (testFunction1 m#isLeftFactoring false);\r\n      printResult (testFunction1 m#isLL1 false);\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation m#removeLeftRecursion.grammar#representation) in\r\n      printResult (testFunction1 transformed#isLeftRecursive false);\r\n      printResult (testFunction1 transformed#isLeftFactoring true);\r\n      printResult (testFunction1 transformed#isLL1 false);\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation transformed#leftFactoring.grammar#representation) in\r\n      printResult (testFunction1 transformed#isLeftRecursive false);\r\n      printResult (testFunction1 transformed#isLeftFactoring false);\r\n      printResult (testFunction1 transformed#isLL1 false);\r\n    Printf.printf \"]\\n\"\r\n\r\n  let testIndirectRecursion5 () =\r\n    Printf.printf \"Indirect recursion test 5: [\";\r\n    let first = [ (\"S\", ['a']); (\"A\", ['a'; epsilon]) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('S', [dollar]); ('A', ['a']) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"S->AS\", ['a']);\r\n                      (\"A->a\", ['a']); (\"A->\", ['a']) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text indirect_left_recursion_grammar5) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#isLeftRecursive true);\r\n      printResult (testFunction1 m#isLeftFactoring false);\r\n      printResult (testFunction1 m#isLL1 false);\r\n    (*Left recursion cannot be solved with #removeLeftRecursion. There are epsilon productions that need to be removed first.*)\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation m#removeEmptyProductions.grammar#representation) in\r\n      printResult (testFunction1 transformed#isLeftRecursive true);\r\n      printResult (testFunction1 transformed#isLeftFactoring false);\r\n      printResult (testFunction1 transformed#isLL1 false);\r\n    (*Left recursion cannot be solved with #removeLeftRecursion. There are unit productions that need to be removed first.*)\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation transformed#removeUnitProductions.grammar#representation) in\r\n      printResult (testFunction1 transformed#isLeftRecursive false);\r\n      printResult (testFunction1 transformed#isLeftFactoring false);\r\n      printResult (testFunction1 transformed#isLL1 true);\r\n    Printf.printf \"]\\n\"\r\n\r\n  let testLeftFactoring1 () =\r\n    Printf.printf \"Left factoring test 1: [\";\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text left_factoring_example) in\r\n    let transformedM = new ContextFreeGrammarLL1.model (Arg.Representation m#leftFactoring.grammar#representation) in\r\n      printResult (testFunction1 m#isLL1 false);\r\n      printResult (testFunction1 transformedM#isLeftFactoring false);\r\n      printResult (testFunction1 transformedM#isLL1 false);\r\n    Printf.printf \"]\\n\"\r\n    \r\n  let testLeftFactoring2 () =\r\n    Printf.printf \"Left factoring test 2: [\";\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text left_factoring_example2) in\r\n    let transformedM = new ContextFreeGrammarLL1.model (Arg.Representation m#leftFactoring.grammar#representation) in\r\n      printResult (testFunction1 m#isLL1 false);\r\n      printResult (testFunction1 transformedM#isLeftFactoring false);\r\n      printResult (testFunction1 transformedM#isLL1 false);\r\n    Printf.printf \"]\\n\"\r\n    \r\n  let testLeftFactoring3 () =\r\n    Printf.printf \"Left factoring test 3: [\";\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text left_factoring_example3) in\r\n    let transformedM = new ContextFreeGrammarLL1.model (Arg.Representation m#leftFactoring.grammar#representation) in\r\n      printResult (testFunction1 m#isLL1 false);\r\n      printResult (testFunction1 transformedM#isLeftFactoring false);\r\n      printResult (testFunction1 transformedM#isLL1 false);\r\n    Printf.printf \"]\\n\"\r\n    \r\n  let testLeftFactoring4 () =\r\n    Printf.printf \"Left factoring test 4: [\";\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text left_factoring_example4) in\r\n    let transformedM = new ContextFreeGrammarLL1.model (Arg.Representation m#leftFactoring.grammar#representation) in\r\n      printResult (testFunction1 m#isLL1 false);\r\n      printResult (testFunction1 transformedM#isLeftFactoring false);\r\n      printResult (testFunction1 transformedM#isLL1 false);\r\n    Printf.printf \"]\\n\"\r\n    \r\n  let testLeftFactoring5 () =\r\n    Printf.printf \"Left factoring test 5: [\";\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text left_factoring_example5) in\r\n    let transformedM = new ContextFreeGrammarLL1.model (Arg.Representation m#leftFactoring.grammar#representation) in\r\n      printResult (testFunction1 m#isLL1 false);\r\n      printResult (testFunction1 transformedM#isLeftFactoring false);\r\n      printResult (testFunction1 transformedM#isLL1 true);\r\n    Printf.printf \"]\\n\"\r\n    \r\n  let testLeftFactoring6 () =\r\n    Printf.printf \"Left factoring test 6: [\";\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text left_factoring_example6) in\r\n    let transformedM = new ContextFreeGrammarLL1.model (Arg.Representation m#leftFactoring.grammar#representation) in\r\n      printResult (testFunction1 m#isLL1 false);\r\n      printResult (testFunction1 transformedM#isLeftFactoring false);\r\n      printResult (testFunction1 transformedM#isLL1 true);\r\n    Printf.printf \"]\\n\"\r\n\r\n  let testUnitRemoval1 () =\r\n    Printf.printf \"Unit production removal test 1: [\";\r\n    let first = [ (\"E\", ['a'; 'b']); (\"T\", ['a'; 'b']); (\"F\", ['a'; 'b']); (\"I\", ['a'; 'b']) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('E', [dollar]); ('T', [dollar]); ('F', [dollar]); ('I', ['a'; 'b'; dollar]) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"E->T\", ['a'; 'b']);\r\n                      (\"T->F\", ['a'; 'b']); \r\n                      (\"F->I\", ['a'; 'b']);\r\n                      (\"I->a\", ['a']); (\"I->b\", ['b']); (\"I->Ia\", ['a'; 'b']); (\"I->Ib\", ['a'; 'b'])] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text unit_removal_example1) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#hasUnitProductions true);\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation m#removeUnitProductions.grammar#representation) in\r\n      printResult (testFunction1 transformed#hasUnitProductions false);\r\n    Printf.printf \"]\\n\"\r\n\r\n  let testUnitRemoval2 () =\r\n    Printf.printf \"Unit production removal test 2: [\";\r\n    let first = [ (\"A\", ['a'; 'b'; 'c']); (\"B\", ['a'; 'b'; 'c']); (\"C\", ['a'; 'b'; 'c']) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('A', [dollar]); ('B', [dollar]); ('C', [dollar]) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"A->B\", ['a'; 'b'; 'c']); (\"A->a\", ['a']);\r\n                      (\"B->C\", ['a'; 'b'; 'c']); (\"B->b\", ['b']);\r\n                      (\"C->A\", ['a'; 'b'; 'c']); (\"C->c\", ['c'])] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text unit_removal_example2) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#hasUnitProductions true);\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation m#removeUnitProductions.grammar#representation) in\r\n      printResult (testFunction1 transformed#hasUnitProductions false);\r\n    Printf.printf \"]\\n\"\r\n\r\n  let testUnitRemoval3 () =\r\n    Printf.printf \"Unit production removal test 3: [\";\r\n    let first = [ (\"S\", ['a'; 'b'; 'c']); (\"A\", ['a'; 'b']); (\"B\", ['a'; 'b']) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('S', [dollar]); ('A', ['a'; dollar]); ('B', ['a'; dollar]) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"S->Aa\", ['a'; 'b']); (\"S->B\", ['a'; 'b']); (\"S->c\", ['c']);\r\n                      (\"A->a\", ['a']); (\"A->bc\", ['b']); (\"A->B\", ['a'; 'b']); \r\n                      (\"B->A\", ['a'; 'b';]); (\"B->bb\", ['b']) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text unit_removal_example3) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#hasUnitProductions true);\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation m#removeUnitProductions.grammar#representation) in\r\n      printResult (testFunction1 transformed#hasUnitProductions false);\r\n    Printf.printf \"]\\n\"\r\n\r\n  let testUnitRemoval4 () =\r\n    Printf.printf \"Unit production removal test 4: [\";\r\n    let first = [ (\"S\", ['a']); (\"A\", ['a']); (\"B\", ['b']); (\"C\", ['b'; 'd']); (\"D\", ['b']); (\"E\", ['b']) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('S', [dollar]); ('A', ['b'; 'd']); ('B', [dollar]); ('C', [dollar]); ('D', [dollar]); ('E', [dollar]) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"S->AC\", ['a']);\r\n                      (\"A->a\", ['a']); \r\n                      (\"B->D\", ['b']);\r\n                      (\"C->B\", ['b']); (\"C->d\", ['d']);\r\n                      (\"D->E\", ['b']);\r\n                      (\"E->b\", ['b'])] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text unit_removal_example4) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#hasUnitProductions true);\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation m#removeUnitProductions.grammar#representation) in\r\n      printResult (testFunction1 transformed#hasUnitProductions false);\r\n    Printf.printf \"]\\n\"\r\n    \r\n  let testUnitRemoval5 () =\r\n    Printf.printf \"Unit production removal test 5: [\";\r\n    let first = [ (\"E\", ['a'; 'b'; '(']); (\"T\", ['a'; 'b'; '(']); (\"F\", ['a'; 'b'; '(']); (\"I\", ['a'; 'b']) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('E', [')'; '+'; dollar]); ('T', [')'; '*'; '+'; dollar]); ('F', [')'; '*'; '+'; dollar]); ('I', ['0'; 'a'; '1'; 'b'; ')'; '*'; '+'; dollar]) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"E->T\", ['a'; 'b'; '(']); (\"E->E+T\", ['a'; 'b'; '(']);\r\n                      (\"T->F\", ['a'; 'b'; '(']); (\"T->T*F\", ['a'; 'b'; '(']); \r\n                      (\"F->I\", ['a'; 'b']); (\"F->(E)\", ['(']);\r\n                      (\"I->a\", ['a']); (\"I->b\", ['b']); (\"I->Ia\", ['a'; 'b']); (\"I->Ib\", ['a'; 'b']); (\"I->I0\", ['a'; 'b']); (\"I->I1\", ['a'; 'b']) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text unit_removal_example5) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#hasUnitProductions true);\r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation m#removeUnitProductions.grammar#representation) in\r\n      printResult (testFunction1 transformed#hasUnitProductions false);\r\n    Printf.printf \"]\\n\"\r\n\r\n  let testEmptyRemoval1 () =\r\n    Printf.printf \"Empty production removal test 1: [\";\r\n    let first = [ (\"S\", ['a'; 'b'; 'd']); (\"A\", ['b'; 'd'; epsilon]); (\"B\", ['b'; epsilon]); (\"C\", ['d'; epsilon]); (\"D\", ['d']) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('S', [dollar]); ('A', ['a'; 'b']); ('B', ['a'; 'b'; 'd']); ('C', ['a'; 'b'; dollar]); ('D', ['a'; 'b'; dollar]) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"S->ABaC\", ['a'; 'b'; 'd']);\r\n                      (\"A->BC\", ['a'; 'b'; 'd']); \r\n                      (\"B->b\", ['b']); (\"B->\", ['a'; 'b'; 'd']);\r\n                      (\"C->D\", ['d']); (\"C->\", ['a'; 'b'; dollar]); \r\n                      (\"D->d\", ['d']) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text epsilon_removal_example1) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#hasEmptyProductions true); \r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation m#removeEmptyProductions.grammar#representation) in\r\n      printResult (testFunction1 transformed#hasEmptyProductions false); \r\n    Printf.printf \"]\\n\"\r\n    \r\n  let testEmptyRemoval2 () =\r\n    Printf.printf \"Empty production removal test 2: [\";\r\n    let first = [ (\"S\", ['a'; 'b'; epsilon]); (\"A\", ['a'; epsilon]); (\"B\", ['b'; epsilon]) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('S', [dollar]); ('A', ['a'; 'b'; dollar]); ('B', ['b'; dollar]) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"S->AB\", ['a'; 'b'; dollar]);\r\n                      (\"A->AaA\", ['a']); (\"A->\", ['a'; 'b'; dollar]); \r\n                      (\"B->BbB\", ['b']); (\"B->\", ['b'; dollar]) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text epsilon_removal_example2) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#hasEmptyProductions true); \r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation m#removeEmptyProductions.grammar#representation) in\r\n      printResult (testFunction1 transformed#hasEmptyProductions false); \r\n    Printf.printf \"]\\n\"\r\n    \r\n  let testEmptyRemoval3 () =\r\n    Printf.printf \"Empty production removal test 3: [\";\r\n    let first = [ (\"S\", ['a'; 'b'; epsilon]); (\"A\", ['a'; epsilon]); (\"B\", ['b'; epsilon]) ] in\r\n    let first2 = firstPairConversion first in\r\n    let follow = [ ('S', [dollar]); ('A', ['a'; 'b'; dollar]); ('B', ['b'; dollar]) ] in\r\n    let follow2 = followPairConversion follow in\r\n    let lookahead = [ (\"S->AB\", ['a'; 'b'; dollar]);\r\n                      (\"A->aAA\", ['a']); (\"A->\", ['a'; 'b'; dollar]); \r\n                      (\"B->bBB\", ['b']); (\"B->\", ['b'; dollar]) ] in\r\n    let lookahead2 = lookaheadPairConversion lookahead in\r\n    let m = new ContextFreeGrammarLL1.model (Arg.Text epsilon_removal_example3) in\r\n      printResult (testFirst m first2);\r\n      printResult (testFollow m follow2);\r\n      printResult (testLookahead m lookahead2);\r\n      printResult (testFunction1 m#hasEmptyProductions true); \r\n    let transformed = new ContextFreeGrammarLL1.model (Arg.Representation m#removeEmptyProductions.grammar#representation) in\r\n      printResult (testFunction1 transformed#hasEmptyProductions false);\r\n    Printf.printf \"]\\n\"\r\n    ;;\r\n    \r\n\tlet runAll =\r\n\t\tif Util.testing active \"ContextFreeGrammarLL1\" then begin\r\n\t\t\ttestExample1 ();\r\n\t\t\ttestExample2 ();\r\n\t\t\ttestExample3 ();\r\n\t\t\ttestExample4 ();\r\n\t\t\ttestExample5 ();\r\n\t\t\ttestExample6 ();\r\n\t\t\ttestDissertation ();\r\n\t\t\ttestNFGrammar ();\r\n\t\t\ttestAccessible1 ();\r\n\t\t\ttestAccessible2 ();\r\n\t\t\ttestProductive1 ();\r\n\t\t\ttestProductive2 ();\r\n\t\t\tcleanGrammar1 ();\r\n\t\t\ttestDirectRecursion1 ();\r\n\t\t\ttestDirectRecursion2 ();\r\n\t\t\ttestIndirectRecursion1 ();\r\n\t\t\ttestIndirectRecursion2 ();\r\n\t\t\ttestIndirectRecursion3 ();\r\n\t\t\ttestIndirectRecursion4 ();\r\n\t\t\ttestIndirectRecursion5 ();\r\n\t\t\ttestLeftFactoring1 ();\r\n\t\t\ttestLeftFactoring2 ();\r\n\t\t\ttestLeftFactoring3 ();\r\n\t\t\ttestLeftFactoring4 ();\r\n\t\t\ttestLeftFactoring5 ();\r\n\t\t\ttestLeftFactoring6 ();\r\n\t\t\ttestUnitRemoval1 ();\r\n\t\t\ttestUnitRemoval2 ();\r\n\t\t\ttestUnitRemoval3 ();\r\n\t\t\ttestUnitRemoval4 ();\r\n\t\t\ttestUnitRemoval5 ();\r\n\t\t\ttestEmptyRemoval1 ();\r\n\t\t\ttestEmptyRemoval2 ();\r\n\t\t\ttestEmptyRemoval3 ()\r\n\t\tend\r\nend\r\n\r\n\r\n# 3 \"src/ContextFreeGrammarLRTests.ml\"\r\n(*\r\n * ContextFreeGrammarLRTests.ml\r\n *\r\n * This file is part of the OCamlFlat library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Bernardo Sousa (br)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * apr/2023 (amd) - New file.\r\n *)\r\n\r\n(*\r\n * Description: Context-free grammar testing.\r\n *)\r\n \r\nopen BasicTypes\r\nopen ContextFreeGrammarBasic  \r\n\r\nmodule ContextFreeGrammarLRTests : sig end =\r\nstruct\r\n\tlet active = false\r\n\r\n\topen LR0Grammar\r\n\topen SLR1Grammar\r\n\topen LR1Grammar\r\n\topen LALR1Grammar\r\n\r\n\tlet (lr1grammar:t) = (* basic LR1 with no First usage *)\r\n\t{alphabet = symbols \"01\";\r\n\tvariables = symbols \"SXA\" ;\r\n\tinitial = symb \"S\";\r\n\trules = ContextFreeGrammarBasic.parse (Set.make [\"S -> X\"; \"X -> A\"; \"A -> 0\" ; \"A -> 1\"])\r\n\t} ;;\r\n\r\n\tlet (lr1grammar2:t) = (* basic LR1 with basic First usage *)\r\n\t{alphabet = symbols \"01\";\r\n\tvariables = symbols \"SXA\" ;\r\n\tinitial = symb \"S\";\r\n\trules = ContextFreeGrammarBasic.parse (Set.make [\"S -> X\"; \"X -> A01\"; \"A -> 0\" ; \"A -> 1\"])\r\n\t} ;;\r\n\r\n\tlet ttLR1 () = (* Full grammar *)\r\n\t\tmakeLR1Diagram lr1grammar;;\r\n\r\n\tlet (lr1grammarX:t) = (* exemplo do professor Luis Monteiro *) \r\n\t{alphabet = symbols \"ab\";\r\n\tvariables = symbols \"SAB\";\r\n\tinitial = symb \"S\";\r\n\trules = ContextFreeGrammarBasic.parse (Set.make [\"S -> A\"; \"A -> BA\"; \"A -> ~\" ; \"B -> aB\"; \"B -> b\"; ])\r\n\t} ;; (* Resumindo esta gramatica: (B)^n, onde B = (a)^m b *)\r\n\t(* (a*b)* *)\r\n\r\n\tlet (lr0htmlgrammar:t) = (* teste de html *) \r\n\t{alphabet = symbols \"abcde\";\r\n\tvariables = symbols \"SABCDE\";\r\n\tinitial = symb \"S\";\r\n\trules = ContextFreeGrammarBasic.parse (Set.make [\"S -> ABCDE\"; \"A -> a | \"; \"B -> b | \"; \"C -> c\"; \"D -> d | \"; \"E -> e | \"])\r\n\t} \r\n\r\n\tlet ttisLR0 () =\r\n\t\tisLR0 lr0htmlgrammar;;\r\n\r\n\tlet ttLR1X () = (* Full grammar *)\r\n\t\tmakeLR1Diagram lr1grammarX;;\r\n\t\t\r\n\tlet ttLR1Id () = \r\n\t\tmakeLR1DiagramId (makeLR1Diagram lr1grammarX) ;;\r\n\t\t\r\n\tlet ttLR1Table () =\r\n\t\tmakeLR1Table (makeLR1DiagramId (makeLR1Diagram lr1grammarX)) lr1grammarX ;; \r\n\t\t\r\n\tlet ttLR1Word () = (* simple test *)\r\n\t\tacceptWordLR1 (word \"ab\") lr1grammarX ;;\r\n\t\t\r\n\t\t\r\n\t\t\r\n\tlet ttLR1Word2 () = (* long simple test *)\r\n\t\tacceptWordLR1 (word \"bbbbbbbb\") lr1grammarX ;;\r\n\t\t\r\n\tlet ttLR1Word3 () = (* long complex test *)\r\n\t\tacceptWordLR1 (word \"aaaaaaaaabbbbbbbb\") lr1grammarX ;;\r\n\t\t\r\n\tlet ttLR1Word4 () = (* empty test *)\r\n\t\tacceptWordLR1 [] lr1grammarX ;;\r\n\t\t\r\n\tlet ttLR1Word5 () = (* combination test *)\r\n\t\tacceptWordLR1 (word \"ababababababababaaaaaaaaabbbbbbbb\") lr1grammarX ;;\r\n\t\t\r\n\tlet ttLR1WordFail () = (* falha mas da erro em vez de false *)\r\n\t\tacceptWordLR1 (word \"bbbbbbbba\") lr1grammarX ;;\r\n\t\t\r\n\t\t\r\n\t(*----- Test functions LALR1-----*)\r\n\r\n\r\n\tlet (lalr1grammar:t) = (* basic SLR1 with Follow usage *)\r\n\t\t{alphabet = symbols \"cd\";\r\n\t\tvariables = symbols \"SXC\";\r\n\t\tinitial = symb \"S\";\r\n\t\trules = ContextFreeGrammarBasic.parse (Set.make [\"S -> X\"; \"X -> CC\"; \"X -> ~\"; \"C -> cC\" ; \"C -> d\"])\r\n\t} ;;\r\n\r\n\tlet ttLALR1 () = (* Full grammar *)\r\n\t\tmakeLALR1FromLR1 (makeLR1Diagram lalr1grammar);;\t\r\n\t\t\r\n\tlet ttLR1Table () =\r\n\t\tmakeLR1Table (makeLR1DiagramId (makeLR1Diagram lalr1grammar)) lalr1grammar ;; \r\n\t\t\r\n\tlet ttLALR1Table () =\r\n\t\tmakeLR1Table (makeLR1DiagramId (makeLALR1FromLR1 (makeLR1Diagram lalr1grammar))) lalr1grammar ;; \t\r\n\r\n\tlet ttLALR1Word () = (* simple test *)\r\n\t\tacceptWordLALR1 [] lalr1grammar ;;\r\n\t\t\r\n\tlet ttLALR1Word2 () = (* simple test *)\r\n\t\tacceptWordLALR1 (word \"dd\" ) lalr1grammar ;;\r\n\t\t\r\n\t\t\r\n\tlet ttLALR1WordFail () = (* simple test *)\r\n\t\tacceptWordLALR1 (word \"cd\" )  lalr1grammar ;;\r\n\t\t\r\n\tlet ttIsLALR1 () = isLALR1 lalr1grammar ;;\r\n\r\n\tlet ttIsLR1 () = isLR1 lalr1grammar ;;\r\n\r\n\t\t\r\n\t\t\r\n\t(*----- Test functions SLR1-----*)\r\n\r\n\tlet (slr1grammar:t) = (* basic SLR1 with Follow usage *)\r\n\t\t{alphabet = symbols \"acdz\";\r\n\t\tvariables = symbols \"SXAB\";\r\n\t\tinitial = symb \"S\";\r\n\t\trules = ContextFreeGrammarBasic.parse (Set.make [\"S -> X\"; \"X -> aAc\"; \"X -> aBd\"; \"A -> z\" ; \"B -> z\"])\r\n\t} ;;\r\n\r\n\r\n\tlet (slr1grammarFail:t) = (* basic SLR1 with Follow usage *)\r\n\t\t{alphabet = symbols \"acdz\";\r\n\t\tvariables = symbols \"SXAB\";\r\n\t\tinitial = symb \"S\";\r\n\t\trules = ContextFreeGrammarBasic.parse (Set.make [\"S -> X\"; \"X -> aAd\"; \"X -> aBd\"; \"A -> z\" ; \"B -> z\"])\r\n\t} ;;\r\n\r\n\tlet ttSLR1Table () =\r\n\t\tmakeSLR1Table (makeLR0DiagramId (makeLR0Diagram slr1grammar)) slr1grammar ;; \r\n\r\n\tlet ttSLR1Word() =\r\n\t\tacceptWordSLR1 (word \"azc\") slr1grammar ;;\r\n\t\t\r\n\tlet ttSLR1Word2() =\r\n\t\tacceptWordSLR1 (word \"azd\") slr1grammar ;;\r\n\t\t\r\n\tlet ttSLR1WordFail() =\r\n\t\tacceptWordSLR1 (word \"\") slr1grammar ;;\r\n\t\t\r\n\tlet ttSLR1WordFail2() =\r\n\t\tacceptWordSLR1 (word \"azcd\") slr1grammar ;;\r\n\t\t\r\n\tlet ttSLR1WordFail3() =\r\n\t\tacceptWordSLR1 (word \"az\") slr1grammar ;;\r\n\t\t\r\n\tlet ttSLR1WordFail4() =\r\n\t\tacceptWordSLR1 (word \"azc$\") slr1grammar ;;\r\n\t\t\r\n\tlet ttIsSLR1() = isSLR1 slr1grammar ;;\r\n\r\n\tlet ttIsSLR1Fail() = isSLR1 slr1grammarFail ;; (* é preciso alterar o follow para testar fails... dor *)\r\n\t\t\r\n\r\n\r\n\t(*----- Test functions LR0-----*)\r\n\r\n\tlet showLR0States (cfg:t) =\r\n\t\tlet diagram = makeLR0Diagram cfg in\r\n\t\tlet (states,transitions) : lr0Diagram = diagram in\r\n\t\tstates\r\n\t\t\r\n\tlet showLR0Transitions (cfg:t) =\r\n\t\tlet diagram = makeLR0Diagram cfg in\r\n\t\tlet (states,transitions) : lr0Diagram = diagram in\r\n\t\ttransitions\r\n\r\n\r\n\tlet (grammar:t) = \r\n\t{alphabet = symbols \"01\";\r\n\tvariables = symbols \"SX\";\r\n\tinitial = symb \"S\";\r\n\trules = ContextFreeGrammarBasic.parse (Set.make [\"S -> 1S0\"; \"S -> X\"; \"X -> 0X1\" ; \"X -> ~\"])\r\n\t} ;;\r\n\r\n\tlet tt () = (* Full grammar *)\r\n\t\tmakeLR0Diagram grammar;;\r\n\r\n\r\n\tlet (grammar2:t) = \r\n\t{alphabet = symbols \"1\";\r\n\tvariables = symbols \"S\";\r\n\tinitial = symb \"S\";\r\n\trules = ContextFreeGrammarBasic.parse (Set.make [\"S -> 1\"])\r\n\t} ;;\r\n\r\n\tlet tt2 () (* Single State Grammar *) =\r\n\t\tmakeLR0Diagram grammar2;;\r\n\t\t\r\n\r\n\tlet (grammar3:t)  = \r\n\t{alphabet = symbols \"01\";\r\n\tvariables = symbols \"S\";\r\n\tinitial = symb \"S\";\r\n\trules = ContextFreeGrammarBasic.parse (Set.make [\"S -> 111111\"])\r\n\t} ;;\r\n\r\n\tlet tt3 () (* Multiple State/Single Rule Grammar *)=\r\n\t\tmakeLR0Diagram grammar3;;\r\n\r\n\r\n\tlet (grammar4:t)  = \r\n\t{alphabet = symbols \"01\";\r\n\tvariables = symbols \"S\";\r\n\tinitial = symb \"S\";\r\n\trules = ContextFreeGrammarBasic.parse (Set.make [\"S -> 111111\"; \"S -> 000000\"])\r\n\t} ;;\r\n\r\n\tlet tt4 () (* Multiple State/Multiple Rule Grammar *) =\r\n\t\tmakeLR0Diagram grammar4;;\r\n\r\n\r\n\tlet (grammar5:t)  = \r\n\t{alphabet = symbols \"01\";\r\n\tvariables = symbols \"SA\";\r\n\tinitial = symb \"S\";\r\n\trules = ContextFreeGrammarBasic.parse (Set.make [\"S -> 111111\"; \"S -> 0X1\"; \"X -> 01\" ])\r\n\t} ;;\r\n\r\n\tlet (grammar5v2:t) (* Copy to test sorting in sets *) = \r\n\t{alphabet = symbols \"01\";\r\n\tvariables = symbols \"SA\";\r\n\tinitial = symb \"S\";\r\n\trules = ContextFreeGrammarBasic.parse (Set.make [\"S -> 111111\"; \"S -> 0A1\"; \"A -> 01\" ])\r\n\t} ;;\r\n\r\n\tlet tt5 () (* Multiple Variables/Multiple State/Multiple Rule Grammar *) =\r\n\t\tmakeLR0Diagram grammar5;;\r\n\r\n\r\n\tlet (grammar6:t) = \r\n\t{alphabet = symbols \"01\";\r\n\tvariables = symbols \"SXA\";\r\n\tinitial = symb \"S\";\r\n\trules = ContextFreeGrammarBasic.parse (Set.make [\"S -> 1X0\"; \"X -> A\"; \"A -> 0A1\"; \"A -> 01\"])\r\n\t} ;;\r\n\r\n\tlet tt6 () (* Almost Full Grammar\\No rule containing only epsilon *) =\r\n\t\tmakeLR0Diagram grammar6;;\r\n\r\n\tlet (grammar7:t) = \r\n\t{alphabet = symbols \"ab$\";\r\n\tvariables = symbols \"SXA\";\r\n\tinitial = symb \"S\";\r\n\trules = ContextFreeGrammarBasic.parse (Set.make [\"S -> X$\"; \"X -> XA\"; \"X -> A\"; \"A -> aXb\"; \"A -> ab\"])\r\n\t} ;;\r\n\r\n\tlet tt7 () (* Gramática LR0 do exemplo de Luis Monteiro *) =\r\n\t\tmakeLR0Diagram grammar7;;\r\n\r\n\t\t\r\n\tlet tt7Count () : bool (* Gramática LR0 do exemplo de Luis Monteiro *) =\r\n\t\tlet (a,b) :lr0Diagram = makeLR0Diagram grammar7 in\r\n\t\tif (Set.size a = 9 && Set.size b = 13) then true else false\r\n\t\t\r\n\t\t\r\n\tlet (grammar7f:t) = \r\n\t{alphabet = symbols \"abc$\";\r\n\tvariables = symbols \"SXA\";\r\n\tinitial = symb \"S\";\r\n\trules = ContextFreeGrammarBasic.parse (Set.make [\"S -> X$\"; \"X -> XA\"; \"X -> A\"; \"A -> aXb\"; \"A -> ab\";\"A -> abc\"])\r\n\t} ;;\r\n\r\n\tlet (grammar7alt:t) = \r\n\t{alphabet = symbols \"ab$\";\r\n\tvariables = symbols \"SXAF\";\r\n\tinitial = symb \"S\";\r\n\trules = ContextFreeGrammarBasic.parse (Set.make [\"S -> X$\"; \"X -> XA\"; \"X -> A\"; \"A -> aXb\"; \"A -> ab\";\"A -> abF\"; \"F -> FA\" ])\r\n\t} ;;\r\n\t\t\r\n\tlet tt7LR0 () (* Gramática LR0 do exemplo de Luis Monteiro *) =\r\n\t\tisLR0 grammar7;;\r\n\t\t\r\n\tlet ttLR0Fail () (* Deve dar falso devido a dois items completos *) =\r\n\t\tisLR0 grammar7f;;\r\n\t\t\r\n\tlet ttLR0Alt () (* Devia dar verdadeiro com um item completo e um item incompleto que espera uma variavel, mas na prática isto é impossivel, porque é preciso calcular o fecho para essa variavel, esse fecho novo causa um conflito, a menos que a variavel não tenha uma regra respectiva, sendo nesse caso uma variavel inutil *) =\r\n\t\tisLR0 grammar7alt;;\r\n\r\n\tlet ttIncon1 () = makeLR0Diagram grammar5;;\r\n\r\n\tlet ttIncon2 () = makeLR0Diagram grammar5v2;;\r\n\r\n\r\n\tlet ttId () = makeLR0DiagramId (makeLR0Diagram grammar7) ;;\r\n\t\t\t\r\n\tlet ttx () =\r\n\t\tmakeLR0Table (makeLR0DiagramId (makeLR0Diagram grammar7)) grammar7 ;; \r\n\t\t\r\n\tlet ttx2 () =\r\n\t\tmakeLR0Table (makeLR0DiagramId (makeLR0Diagram grammar5)) grammar5 ;; \r\n\r\n\r\n\tlet ttWord () = \r\n\t\tacceptWordLR0V2 (word \"1\") grammar2 ;;\r\n\t\t\r\n\tlet ttWordFail () = \r\n\t\tacceptWordLR0V2 (word \"10\") grammar2 ;;\r\n\t\t\r\n\tlet ttWord2 () = \r\n\t\tacceptWordLR0V2 (word \"111111\") grammar5 ;;\r\n\t\t\r\n\tlet ttWord2Fail () = \r\n\t\tacceptWordLR0V2 (word \"1111111\") grammar5 ;;\t\r\n\t\t\r\n\tlet ttWord3 () = \r\n\t\tacceptWordLR0V2 (word \"0011\") grammar5 ;;\r\n\t\t\r\n\tlet ttWord3Fail () = \r\n\t\tacceptWordLR0V2 (word \"00111\") grammar5 ;;\r\n\t\t\r\n\tlet ttWord4 () = \r\n\t\tacceptWordLR0V2 (word \"100110\") grammar6 ;;\r\n\t\t\r\n\tlet ttWord4Fail () = \r\n\t\tacceptWordLR0V2 (word \"10011\") grammar6 ;;\r\n\t\t\r\n\tlet ttWordX () =\r\n\t\tacceptWordLR0V2 (word \"aaabbb$\") grammar7 ;;\r\n\t\t\r\n\tlet ttWordXFail () =\r\n\t\tacceptWordLR0V2 (word \"aaabbb\") grammar7 ;;\r\n\t\t\r\n\tlet tt3LR0 () (* bug test *) =\r\n\t\tisLR0 grammar5;;\t\r\n\t\t\r\n\tlet lr0DiagnosticTest () =\r\n\t\tttWord() && ttWord2() && ttWord3() && ttWord4() && ttWordX()\r\n\t\t\r\n\tlet lr0DiagnosticFailTest () =\r\n\t\tttWordFail() && ttWord2Fail() && ttWord3Fail() && ttWord4Fail() && ttWordXFail()\t\r\n\r\n\tlet runAll =\r\n\t\tif Util.testing active \"ContextFreeGrammarLR\" then begin\r\n\t\t\tignore (tt3LR0 ())\r\n\t\tend\t\t\r\nend\t\r\n\r\n\r\n# 3 \"src/PushdownAutomatonTests.ml\"\r\n(*\r\n * PushdownAutomatonTests.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Carlos Freitas (cf)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * apr/2023 (amd) - New file.\r\n *)\r\n\r\n(*\r\n * Description: Pushdown automata testing.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule PushdownAutomatonTests : sig end =\r\nstruct\r\n\tlet active = false\r\n\r\n\tlet exer_abcd = {| {\r\n\t\t\tkind : \"exercise\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"exer_abcd\",\r\n\t\t\tproblem : \"Convert the regular expression (a+b)*(c+d) to finite automaton.\",\r\n\t\t\tinside : [\"abc\",\"c\",\"ab\",\"b\",\"abac\"],\r\n\t\t\toutside : [\"\",\"aba\",\"bab\",\"abba\",\"baab\",\"abcd\"],\r\n\t\t\tproperties : []\r\n\t\t} |}\r\n\r\n\tlet pda_astar = {| {\r\n\t\t\tkind: \"pushdown automaton\",\r\n\t\t\tdescription: \"this is an example\",\r\n\t\t\tname: \"pda_astar\",\r\n\t\t\tinputAlphabet: [\"a\"],\r\n\t\t\tstackAlphabet: [\"a\", \"$\"],\r\n\t\t\tstates: [\"START\"],\r\n\t\t\tinitialState: \"START\",\r\n\t\t\tinitialStackSymbol: \"$\",\r\n\t\t\ttransitions: [\r\n\t\t\t\t[\"START\", \"$\", \"a\", \"START\", \"$\"]\r\n\t\t\t],\r\n\t\t\tacceptStates: [\"START\"],\r\n\t\t\tcriteria: \"true\"\r\n\t\t\t} |}\r\n\r\n\tlet test0 () =\r\n\t\tlet pda = new PushdownAutomaton.model (Arg.Text pda_astar) in\r\n\t\t\tlet j = pda#toJSon in\r\n\t\t\t\tJSon.show j\r\n\r\n\r\n\tlet pdaReach = {| {\r\n\t\t\tkind: \"pushdown automaton\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"abc\",\r\n\t\t\tinputAlphabet : [\"a\",\"b\"],\r\n\t\t\tstackAlphabet: [\"$\"],\r\n\t\t\tstates : [\"S1\",\"S2\",\"S3\",\"S4\",\"S5\",\"S6\"],\r\n\t\t\tinitialState : \"S1\",\r\n\t\t\tinitialStackSymbol: \"$\",\r\n\t\t\ttransitions : [\r\n\t\t\t\t\t[\"S1\",\"$\",\"~\",\"S2\",\"$\"], [\"S1\",\"$\",\"a\",\"S3\",\"$\"],\r\n\t\t\t\t\t[\"S2\",\"$\",\"a\",\"S2\",\"$\"],\r\n\t\t\t\t\t[\"S3\",\"$\",\"~\",\"S4\",\"$\"],\r\n\t\t\t\t\t[\"S4\",\"$\",\"~\",\"S5\",\"$\"],\r\n\t\t\t\t\t[\"S5\",\"$\",\"~\",\"S3\",\"$\"], [\"S5\",\"$\",\"~\",\"S5\",\"$\"]\r\n\t\t\t\t],\r\n\t\t\tacceptStates : [\"S1\"],\r\n\t\t\tcriteria: \"true\"\r\n\t} |}\r\n\r\n\tlet testReachable () =\r\n\t\tlet pda = new PushdownAutomaton.model (Arg.Text pdaReach) in\r\n\t\tlet start = pda#representation.initialState in\r\n\t\tUtil.println [\"Reachable states:\"]; Util.printStates (pda#reachable start)\r\n\r\n\t\tlet pdaProductive = {| {\r\n\t\t\tkind: \"pushdown automaton\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"abc\",\r\n\t\t\tinputAlphabet : [\"a\",\"b\"],\r\n\t\t\tstackAlphabet: [\"$\"],\r\n\t\t\tstates : [\"S1\",\"S2\",\"S3\",\"S4\",\"S5\",\"S6\"],\r\n\t\t\tinitialState : \"S1\",\r\n\t\t\tinitialStackSymbol: \"$\",\r\n\t\t\ttransitions : [\r\n\t\t\t\t\t[\"S1\",\"$\",\"~\",\"S2\",\"$\"], [\"S1\",\"$\",\"a\",\"S3\",\"$\"],\r\n\t\t\t\t\t[\"S2\",\"$\",\"a\",\"S2\",\"$\"],\r\n\t\t\t\t\t[\"S3\",\"$\",\"~\",\"S4\",\"$\"],\r\n\t\t\t\t\t[\"S4\",\"$\",\"~\",\"S5\",\"$\"],\r\n\t\t\t\t\t[\"S5\",\"$\",\"~\",\"S3\",\"$\"], [\"S5\",\"$\",\"~\",\"S5\",\"$\"]\r\n\t\t\t\t],\r\n\t\t\tacceptStates : [\"S2\"],\r\n\t\t\tcriteria: \"true\"\r\n\t\t} |}\r\n\r\n\tlet testProductive () =\r\n\t\tlet pda = new PushdownAutomaton.model (Arg.Text pdaProductive) in\r\n\t\tUtil.println [\"Productive states:\"]; Util.printStates pda#productive\r\n\r\n\tlet testGetUsefulStates () =\r\n\t\tlet pda = new PushdownAutomaton.model (Arg.Text pdaProductive) in\r\n\t\tUtil.println [\"Useful states:\"]; Util.printStates pda#getUsefulStates\r\n\r\n\tlet testGetUselessStates () =\r\n\t\tlet pda = new PushdownAutomaton.model (Arg.Text pdaProductive) in\r\n\t\tUtil.println [\"Useless states:\"]; Util.printStates pda#getUselessStates\r\n\r\n\tlet pdaEmptyStackCriteria = {| {\r\n\t\tkind: \"pushdown automaton\",\r\n\t\tdescription: \"this is an example\",\r\n\t\tname: \"pda_astar\",\r\n\t\tinputAlphabet: [\"a\"],\r\n\t\tstackAlphabet: [\"a\", \"$\"],\r\n\t\tstates: [\"S2\"],\r\n\t\tinitialState: \"S2\",\r\n\t\tinitialStackSymbol: \"$\",\r\n\t\ttransitions: [\r\n\t\t\t[\"S2\", \"$\", \"a\", \"S2\", \"$\"]\r\n\t\t],\r\n\t\tacceptStates: [],\r\n\t\tcriteria: \"false\"\r\n\t\t} |}\r\n\r\n\tlet pdaEmptyAcceptStatesCriteria = {| {\r\n\t\tkind: \"pushdown automaton\",\r\n\t\tdescription: \"this is an example\",\r\n\t\tname: \"pda_astar\",\r\n\t\tinputAlphabet: [\"a\"],\r\n\t\tstackAlphabet: [\"a\", \"$\"],\r\n\t\tstates: [\"S2\"],\r\n\t\tinitialState: \"S2\",\r\n\t\tinitialStackSymbol: \"$\",\r\n\t\ttransitions: [\r\n\t\t\t[\"S2\", \"$\", \"a\", \"S2\", \"$\"]\r\n\t\t],\r\n\t\tacceptStates: [\"S2\"],\r\n\t\tcriteria: \"true\"\r\n\t\t} |}\r\n\r\n\tlet testTransformToAcceptCriteria () =\r\n\t\tlet pda = new PushdownAutomaton.model (Arg.Text pdaEmptyStackCriteria) in\r\n\t\tlet result: PushdownAutomaton.model = pda#transformPdaToAcceptStates in\r\n\t\tUtil.println [\"Initial PDA empty stack criteria:\"];JSon.show pda#toJSon;\r\n\t\tUtil.println [\"PDA transformed to accept states criteria:\"]; JSon.show (result#toJSon)\r\n\r\n\tlet testTransformToEmptyStackCriteria () =\r\n\t\tlet pda = new PushdownAutomaton.model (Arg.Text pdaEmptyAcceptStatesCriteria) in\r\n\t\tlet result: PushdownAutomaton.model = pda#transformPdaToAcceptEmptyStack in\r\n\t\tUtil.println [\"Initial PDA accept states criteria:\"];JSon.show pda#toJSon;\r\n\t\tUtil.println [\"PDA transformed to empty stack criteria:\"]; JSon.show (result#toJSon)\r\n\r\n\r\n\tlet pdaNonDeterministic = {| {\r\n\t\tkind: \"pushdown automaton\",\r\n\t\tdescription: \"this is an example\",\r\n\t\tname: \"pda_astar\",\r\n\t\tinputAlphabet: [\"a\"],\r\n\t\tstackAlphabet: [\"a\", \"$\"],\r\n\t\tstates: [\"S1\"],\r\n\t\tinitialState: \"S1\",\r\n\t\tinitialStackSymbol: \"$\",\r\n\t\ttransitions: [\r\n\t\t\t[\"S1\", \"$\", \"a\", \"S1\", \"$\"],\r\n\t\t\t[\"S1\", \"$\", \"~\", \"S1\", \"$\"]\r\n\t\t],\r\n\t\tacceptStates: [\"S1\"],\r\n\t\tcriteria: \"true\"\r\n\t\t} |}\r\n\r\n\tlet pdaDeterministic = {| {\r\n\t\tkind: \"pushdown automaton\",\r\n\t\tdescription: \"this is an example\",\r\n\t\tname: \"pda_astar\",\r\n\t\tinputAlphabet: [\"a\", \"b\"],\r\n\t\tstackAlphabet: [\"a\", \"$\"],\r\n\t\tstates: [\"S1\"],\r\n\t\tinitialState: \"S1\",\r\n\t\tinitialStackSymbol: \"$\",\r\n\t\ttransitions: [\r\n\t\t\t[\"S1\", \"$\", \"a\", \"S1\", \"$\"],\r\n\t\t\t[\"S1\", \"$\", \"b\", \"S1\", \"$\"],\r\n\t\t\t[\"S1\", \"a\", \"~\", \"S1\", \"$\"]\r\n\t\t],\r\n\t\tacceptStates: [\"S1\"],\r\n\t\tcriteria: \"true\"\r\n\t\t} |}\r\n\r\n\tlet testNotDeterministic () =\r\n\t\tlet pda = new PushdownAutomaton.model (Arg.Text pdaNonDeterministic) in\r\n\t\tlet deterministic = pda#isDeterministic in\r\n\t\tif deterministic then\r\n\t\t\tUtil.println [\"automata is deterministic\"] else Util.println [\"automata is non-deterministic\"];\r\n\t\tassert (not deterministic)\r\n\r\n\tlet testDeterministic () =\r\n\t\tlet pda = new PushdownAutomaton.model (Arg.Text pdaDeterministic) in\r\n\t\tlet deterministic = pda#isDeterministic in\r\n\t\tif deterministic then\r\n\t\t\tUtil.println [\"automata is deterministic\"] else Util.println [\"automata is non-deterministic\"];\r\n\t\tassert (deterministic)\r\n\r\n\tlet testIsFa () =\r\n\t\tlet pda = new PushdownAutomaton.model (Arg.Text pdaNonDeterministic) in\r\n\t\tlet isFa = pda#isFiniteAutomaton in\r\n\t\tif isFa then\r\n\t\t\tUtil.println [\"automata is equivalent to FA\"] else Util.println [\"automata is not equivalent to FA\"];\r\n\t\tassert (isFa)\r\n\r\n\tlet testIsNotFa () =\r\n\t\tlet pda = new PushdownAutomaton.model (Arg.Text pdaDeterministic) in\r\n\t\tlet isFa = pda#isFiniteAutomaton in\r\n\t\tif isFa then\r\n\t\t\tUtil.println [\"automata is equivalent to FA\"] else Util.println [\"automata is not equivalent to FA\"];\r\n\t\tassert (not isFa)\r\n\r\n\tlet pdaAccept = {| {\r\n\t\tkind: \"pushdown automaton\",\r\n\t\tdescription: \"this is an example\",\r\n\t\tname: \"pdaAccept\",\r\n\t\tinputAlphabet: [\"a\", \"b\"],\r\n\t\tstackAlphabet: [\"a\", \"$\"],\r\n\t\tstates: [\"S1\", \"S2\"],\r\n\t\tinitialState: \"S1\",\r\n\t\tinitialStackSymbol: \"$\",\r\n\t\ttransitions: [\r\n\t\t\t[\"S1\", \"$\", \"a\", \"S1\", \"a$\"],\r\n\t\t\t[\"S1\", \"a\", \"a\", \"S1\", \"aa\"],\r\n\t\t\t[\"S1\", \"a\", \"b\", \"S2\", \"a\"]\r\n\t\t],\r\n\t\tacceptStates: [\"S2\"],\r\n\t\tcriteria: \"true\"\r\n\t\t} |}\r\n\r\n\tlet pdaAccept2 = {| {\r\n\t\tkind: \"pushdown automaton\",\r\n\t\tdescription: \"this is an example\",\r\n\t\tname: \"pdaAccept2\",\r\n\t\tinputAlphabet: [\"a\", \"b\"],\r\n\t\tstackAlphabet: [\"a\", \"$\"],\r\n\t\tstates: [\"S1\", \"S2\", \"S3\"],\r\n\t\tinitialState: \"S1\",\r\n\t\tinitialStackSymbol: \"$\",\r\n\t\ttransitions: [\r\n\t\t\t[\"S1\", \"$\", \"a\", \"S1\", \"a$\"],\r\n\t\t\t[\"S1\", \"a\", \"a\", \"S1\", \"aa\"],\r\n\t\t\t[\"S1\", \"a\", \"~\", \"S2\", \"a\"],\r\n\t\t\t[\"S2\", \"a\", \"b\", \"S2\", \"\"],\r\n\t\t\t[\"S2\", \"$\", \"~\", \"S3\", \"$\"]\r\n\t\t],\r\n\t\tacceptStates: [\"S3\"],\r\n\t\tcriteria: \"true\"\r\n\t\t} |}\r\n\r\n\tlet pdaAccept3 = {| {\r\n\t\t\tkind: \"pushdown automaton\",\r\n\t\t\tdescription: \"this is an example\",\r\n\t\t\tname: \"pdaAccept2\",\r\n\t\t\tinputAlphabet: [\"a\", \"b\"],\r\n\t\t\tstackAlphabet: [\"a\", \"$\"],\r\n\t\t\tstates: [\"S1\", \"S2\", \"S3\"],\r\n\t\t\tinitialState: \"S1\",\r\n\t\t\tinitialStackSymbol: \"$\",\r\n\t\t\ttransitions: [\r\n\t\t\t\t[\"S1\", \"$\", \"a\", \"S1\", \"a$\"],\r\n\t\t\t\t[\"S1\", \"a\", \"a\", \"S1\", \"aa\"],\r\n\t\t\t\t[\"S1\", \"a\", \"~\", \"S2\", \"a\"],\r\n\t\t\t\t[\"S1\", \"a\", \"~\", \"S1\", \"aa\"],\r\n\t\t\t\t[\"S2\", \"a\", \"b\", \"S2\", \"\"],\r\n\t\t\t\t[\"S2\", \"$\", \"~\", \"S3\", \"$\"]\r\n\t\t\t],\r\n\t\t\tacceptStates: [\"S3\"],\r\n\t\t\tcriteria: \"true\"\r\n\t\t\t} |}\r\n\r\n\tlet testAccept() =\r\n\tlet pda = new PushdownAutomaton.model (Arg.Text pdaAccept) in\r\n\tlet accepted = pda#accept [symb \"a\"; symb \"a\"; symb \"b\"] in\r\n\t\tif accepted then\r\n\t\t\tUtil.println [\"Accepted word\"] else Util.println [\"Did not accept word\"];\r\n\t\t\tassert (accepted)\r\n\r\n\tlet testAccept2() =\r\n\t\tlet pda = new PushdownAutomaton.model (Arg.Text pdaAccept2) in\r\n\t\tlet accepted = pda#accept [symb \"a\"; symb \"a\"; symb \"b\"; symb \"b\"] in\r\n\t\t\tif accepted then\r\n\t\t\t\tUtil.println [\"Accepted word\"] else Util.println [\"Did not accept word\"];\r\n\t\t\t\tassert (accepted)\r\n\r\n\tlet testAccept3() =\r\n\t\tlet pda = new PushdownAutomaton.model (Arg.Text pdaAccept3) in\r\n\t\tlet accepted = pda#accept [symb \"a\"; symb \"a\"; symb \"b\"; symb \"b\"] in\r\n\t\t\tif accepted then\r\n\t\t\t\tUtil.println [\"Accepted word\"] else Util.println [\"Did not accept word\"];\r\n\t\t\t\tassert (accepted)\r\n\r\n\tlet testGenerate() =\r\n\t\tlet pda = new PushdownAutomaton.model (Arg.Text pdaAccept2) in\r\n\t\tlet words = pda#generate 6 in\r\n\t\t\tUtil.println [\"Generated words:\"];\r\n\t\t\tUtil.printWords words\r\n\r\n\tlet testSearchTree() =\r\n\t\tlet pda = new PushdownAutomaton.model (Arg.Text pdaAccept3) in\r\n\t\tlet searchTree = pda#getSearchTree [symb \"a\"; symb \"b\"] in\r\n\t\t\tPushdownAutomatonPrivate.printSearchTree searchTree\r\n\r\n\tlet runAll =\r\n\t\tif Util.testing active \"PushdownAutomaton\" then begin\r\n\t\t\tUtil.header \"PushdownAutomatonTests starting...\";\r\n\t\t\ttest0 ();\r\n\t\t\ttestReachable ();\r\n\t\t\ttestProductive ();\r\n\t\t\ttestGetUsefulStates ();\r\n\t\t\ttestGetUselessStates ();\r\n\t\t\ttestTransformToAcceptCriteria ();\r\n\t\t\ttestTransformToEmptyStackCriteria ();\r\n\t\t\ttestNotDeterministic ();\r\n\t\t\ttestDeterministic ();\r\n\t\t\ttestIsFa ();\r\n\t\t\ttestIsNotFa ();\r\n\t\t\ttestAccept ();\r\n\t\t\ttestAccept2 ();\r\n\t\t\ttestAccept3 ();\r\n\t\t\ttestGenerate ();\r\n\t\t\ttestSearchTree()\r\n\t\tend\r\nend\r\n\r\n\r\n# 3 \"src/TuringMachineTests.ml\"\r\n(*\r\n * TuringMachineTests.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias (amd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * jan/2025 (amd) - New file.\r\n *)\r\n\r\n(*\r\n * Description: Turing machine testing.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule TuringMachineTests : sig end =\r\nstruct\r\n\topen TuringMachine\r\n\topen TuringMachineX\r\n\t\r\n\tlet active = false\r\n\r\n\tlet test0 () =\r\n\t\tlet j = Examples.jsonExample \"tm_astar1\" in\r\n\t\tlet tm: t = make (Arg.JSon j) in\r\n\t\t\tif isLB tm then print_string \"LB\\n\" else print_string \"not LB\\n\";\r\n\t\t\tshow tm\r\n\r\n\tlet test1 () =\r\n\t\tlet tm = new TuringMachine.model (Arg.Predef \"tm_astar1\") in\r\n\t\t\ttm#show\r\n\r\n\tlet test2 () =\r\n\t\tlet j = Examples.jsonExample \"tm_translate\" in\r\n\t\tlet tm: t = make (Arg.JSon j) in\r\n\t\tlet tmx = tmX tm in\r\n\t\tlet tm = tmI tmx in\r\n\t\t\tshow tm\r\n\r\n\tlet test3 () =\r\n\t\tlet j = Examples.jsonExample \"tm_translate\" in\r\n\t\tlet tm: t = make (Arg.JSon j) in\r\n\t\tlet tm: t = { tm with initialState = \"q2\" } in\r\n\t\t\tshow tm\r\n\r\n\tlet runAll =\r\n\t\tif Util.testing active \"TuringMachineSupport\" then begin\r\n\t\t\tUtil.sep (); test3 ()\r\n\t\tend\r\n\r\nend\r\n\r\n# 1 \"src/CompositionTests.ml\"\r\n(*\r\n * Composition.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Carolina Duarte (cd)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n *)\r\n\r\n(*\r\n * Description: Model composition testing.\r\n *\r\n *)\r\n \r\nopen BasicTypes\r\n\r\nmodule CompositionTests : sig end =\r\nstruct\r\n\topen Composition\r\n\r\n\tlet active = false\r\n\r\n\tlet comp_abc = {| {\r\n\t\t\tkind : \"composition\",\r\n\t\t\tdescription : \"this is an example\",\r\n\t\t\tname : \"comp_abc\",\r\n\t\t\tcomp : \"[dfa_astar]^[dfa_astar]\"\r\n\t} |}\r\n\t\r\n\tlet test0 () =\r\n\t\tlet comp = new Composition.model (Arg.Text comp_abc) in\r\n\t\t\tcomp#show2\r\n\r\n\tlet checkWord comp s =\r\n\t\tif comp#accept (str2word s) then \"ACCEPT\" else \"REJECT\"\r\n\r\n\tlet checkWords comp l =\r\n\t\tList.iter (fun s -> Printf.printf \"\\\"%s\\\" %s\\n\" s (checkWord comp s)) l\r\n\r\n\tlet test1 () =\r\n\t\tlet comp = new Composition.model (Arg.Text comp_abc) in\r\n\t\t\tcheckWords comp [\"aa\"; \"bb\"]\r\n\r\n\tlet runAll =\r\n\t\tif Util.testing active \"Composition\" then begin\r\n\t\t\tUtil.sep (); test0();\r\n\t\t\tUtil.sep (); test1();\r\n\t\t\t\r\n\t\tend\r\nend\r\n\r\n\r\n\r\n# 1 \"src/LearnOCamlTests.ml\"\r\n(*\r\n * LearnOCamlTests.ml\r\n *\r\n * This file is part of the OCamlFLAT library\r\n *\r\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\r\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\r\n *\r\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\r\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\r\n *\r\n * This software is distributed under the terms of the GPLv3 license.\r\n * See the included LICENSE file for details.\r\n *\r\n *  Written by Artur Miguel Dias, Rita Macedo (amd, rm)\r\n *)\r\n\r\n(*\r\n * ChangeLog:\r\n *\r\n * apr/2023 (amd) - New file.\r\n *)\r\n\r\nopen BasicTypes\r\n\r\nmodule LearnOCamlTests : sig end =\r\nstruct\r\n\tlet active = false\r\n\r\n\tlet prepare target =\r\n\t\tprint_string (\"Generate: \" ^ target ^ \"\\n\");\r\n\t\tLearnOCaml.setOCamlFlatDir \"~/work/OCamlFlat\";\r\n\t\tLearnOCaml.setExercicesDir \"~/work/OCamlFlat/exercises\";\r\n\t\tLearnOCaml.setExerciceName target\r\n\r\n\tlet prepare0 () =\r\n\t\tLearnOCaml.setOCamlFlatDir \"~/work/OCamlFlat\";\r\n\t\tLearnOCaml.setExercicesDir \"~/work/learn/my-learn-ocaml-repository/exercises\";\r\n\t\tLearnOCaml.setExerciceName \"default\"\r\n\r\n\tlet make exercise model =\r\n\t\tprepare exercise;\r\n\t\tlet exercise = Examples.jsonExample exercise in\r\n\t\tlet solution = Examples.jsonExample model in\r\n\t\t\tLearnOCaml.generateExerciseDir exercise solution false\r\n\t\r\n\tlet test0 () =\r\n\t\tmake \"exer_astar_fa\" \"dfa_astar\"\r\n\t\t\t\r\n\tlet test1 () =\r\n\t\tmake \"exer_astar_re\" \"re_astar\"\r\n\t\t\t\r\n\tlet test2 () =\r\n\t\tmake \"exer_balanced_cfg\" \"cfg_balanced\"\r\n\t\r\n\tlet fe_colors = {| {\r\n\t\tkind : \"finite enumeration\",\r\n\t\tdescription : \"this is an example\",\r\n\t\tname : \"colors\",\r\n\t\twords : [\"Red\", \"Yellow\", \"Blue\"]\r\n\t} |}\r\n\t\t\t\r\n\tlet test3 () =\r\n\t\tprepare \"exer_astar\";\r\n\t\tlet exercise = Examples.jsonExample \"exer_astar\" in\r\n\t\tlet solution = JSon.parse fe_colors in\r\n\t\t\tLearnOCaml.generateExerciseDir exercise solution false\r\n\r\n\tlet decl1 = {|\r\n\t\tlet solution: finiteAutomaton =\r\n\t\t{\r\n\t\t\talphabet = ['a'];\r\n\t\t\tstates = [\"START\"];\r\n\t\t\tinitialState = \"START\";\r\n\t\t\ttransitions = [(\"START\", 'a', \"START\")];\r\n\t\t\tacceptStates = [\"START\"]\r\n\t\t} |}\r\n\t\t\r\n\tlet decl2 = {|\r\n\t\tlet solution: RegularExpression.tx =\r\n\t\t\t\"z*\"\r\n\t|}\r\n\t\t\r\n\tlet decl3 = {|\r\n\t\tlet solution: ContextFreeGrammarBasic.tx =\r\n\t\t{\r\n\t\t\talphabet = ['0'; '1'];\r\n\t\t\tvariables = ['S'; 'P'];\r\n\t\t\tinitial = 'S';\r\n\t\t\trules = [\t\"S -> 1S0 | P\";\r\n\t\t\t\t\t\t\"P -> 0P1 | ~\" ]\r\n\t\t}\r\n\t|}\r\n\t\t\r\n\tlet decl4 = {|\r\n\t\tlet solution: FiniteEnumeration.tx =\r\n\t\t\t[\"A\"; \"B\"; \"C\"; \"D\"; \"E\"]\r\n\t|}\r\n\r\n\tlet test4 () =\r\n\t\tlet j = LearnOCaml.decl2json decl1  in\r\n\t\t\tJSon.show j\r\n \r\n\tlet runAll =\r\n\t\tif Util.testing active \"LearnOCaml\" then begin\r\n\t\t\ttest0 ();\r\n\t\t\ttest1 ();\r\n\t\t\ttest2 ()\r\n\t\tend\r\nend\r\n","(*\n * Lang.ml\n *\n * This file is part of the OFLAT app\n *\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\n *\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\n *\n * This software is distributed under the terms of the GPLv3 license.\n * See the included LICENSE file for details.\n *\n *  Written by Rita Macedo\n *)\n\n(* \n * Description: support for internationalization.\n *)\n\nopen OCamlFlat\nopen Js_of_ocaml\nopen CSS\n\nmodule Lang =\n  struct\n\n    let default_language () =\n\t  (Js.Opt.get\n        Dom_html.window##.navigator##.language\n          (fun () ->\n            Js.Optdef.get Dom_html.window##.navigator##.userLanguage (fun () -> Js.string \"en\")))\n        ##substring\n        0\n        2\n  (* NOVO!\n    let default_language () =\n      (Js.Optdef.get\n        Dom_html.window##.navigator##.language\n          (fun () ->\n            Js.Optdef.get Dom_html.window##.navigator##.userLanguage (fun () -> Js.string \"en\")))\n        ##substring\n        0\n        2\n     *)\n      \n    let lang =\n      ref\n      (Js.to_string (Js.Optdef.case Dom_html.window##.localStorage default_language (fun st ->\n          Js.Opt.get (st##getItem (Js.string \"hyp_lang\")) default_language)))\n\n    let set_language language =\n        lang := Js.to_string (language)\n    \n    let i18nKey = \n      [\"en\"; \"pt\"; \"fr\"]\n    \n    let rec i18n sl =\n      let rec i18nX l sl =\n        match l, sl with\n          | [], _ -> Error.fatal \"i18nX\"\n          | _, [] -> Error.fatal \"i18nX\"\n          | x::_, y::_ when x = !lang -> y\n          | _::xs, _::ys -> i18nX xs ys\n      in\n        i18nX i18nKey sl\n  \n  (** ---------------- Barra lateral primeiro bloco ----------------- **)\n  let i18nTitle () = \n    i18n [\"OFLAT\"; \"OFLAT\"; \"OFLAT\"]\n\n  let i18nVersion () = \n    i18n [\"Version 4.1\"; \"Versão 4.1\"; \"Version 4.1\"]\n    \n  let i18nNewModel () =\n    i18n [\"New model\"; \"Novo modelo\"; \"Nouveau modèle\"]\n    \n  let i18nEditModel () =\n    i18n [\"Edit model\"; \"Editar modelo\"; \"Modifier le modèle\"] \n\n  let i18nFitGraph () = \n    i18n [\"Fit to box\"; \"Ajustar à caixa\"; \"Ajustement à la boîte\"]\n\n  let i18nToggleView () = \n    i18n [\"Toggle view\"; \"Alternar visualização\"; \"Basculer la vue\"]\n\n  let i18nGeneralRepresentation () = \n    i18n [\"General purpose representation of the derivation tree,\\n for context free grammars use context free model\";\n          \"Representação geral da árvore de derivação,\\n para gramáticas livres de contexto use o modelo de gramática livre de contexto\";\n          \"Représentation générale de l'arbre de dérivation,\\n pour les grammaires libres de contexte, utilisez le modèle de grammaire libre de contexte\"]\n\n(** ---------------- Barra lateral segundo bloco ----------------- **)\n  let i18nGenerate () = \n    i18n [\"Generate words with size X\"; \"Gerar palavras de tamanho X\"; \"Générer des mots de taille X\"]\n  \n  let i18nTesting () = \n    i18n [\"Test word\"; \"Testar palavra\"; \"Mot de test\"]\n\n  let i18nStep () = \n    i18n [\"Step-by-step word acceptance\"; \"Aceitação passo-a-passo da palavra\"; \"Acceptation des mots étape par étape\"]\n\n  let i18nStart () = \n    i18n [\"Start\"; \"Início\"; \"Début\"]\n\n  let i18nClearAuto () = \n    i18n [\"Clean Automaton\"; \"Limpar Autómato\"; \"Nettoyer l'automate\"]\n  \n  let i18nConvertToAcceptFinalState () = \n    i18n [\"Convert to acceptance by final states\"; \"Converter aceitação por estados finais\"; \"Convertisseur accepté par les états finaux\"]\n\n  let i18nConvertToAcceptEmptyStack () = \n    i18n [\"Convert to acceptance by empty stack\"; \"Converter aceitação por pilha vazia\"; \"Convertisseur pour pile vide accepter\"]\n\n(** ---------------- Barra lateral terceiro bloco ----------------- **)\n  let i18nSelectConv () = \n    i18n [\"Convert to\"; \"Converter em\"; \"Convertir en\"]\n\n  let i18nSelectRegex () = \n    i18n [\"Regular Expression\"; \"Expressão Regular\"; \"Expression régulière\"]\n\n  let i18nselectFA () = \n    i18n [\"Finite Automaton\"; \"Autómato Finito\"; \"Automate Fini\"]\n\n  let i18nselectPDA () = \n    i18n [\"Pushdown Automaton\"; \"Autómato de Pilha\"; \"Automate à Pile\"]\n\n  let i18nselectCFG () = \n    i18n [\"Context Free Grammar\"; \"Linguagem Livre de Contexto\"; \"Angages Hors-Contexte\"]\n\n\n  let i18nselectGR () = \n      i18n [\"Grammar\"; \"Gramática\"; \"Grammaire\"]\n\n  let i18nselectTM () = (* carolina *)\n    i18n [\"Turing Machine\"; \"Máquina de Turing\"; \"Machine de Turing\"]\n\n  let i18nselectTM2Tapes () =\n    i18n [\"Turing Machine 2 Tapes\"; \"Máquina de Turing 2 Fitas\"; \"Machine de Turing 2 Bandes\"]\n\n(** ---------------- Barra lateral quarto bloco ----------------- **)\n  \nlet i18nImportModel () = \n  i18n [\"Import model\"; \"Importar modelo\"; \"Modèle d'importation\"]\n  \nlet i18nExportModel () =\n  i18n [\"Export model\"; \"Exportar modelo\"; \"Modèle d'exportation\"]\n\nlet i18nServer () = \n  i18n [\"Predefined examples\"; \"Exemplos predefinidos\"; \"Exemples prédéfinis\"] \n\n(** ---------------- Barra lateral quinto bloco ----------------- **)\n\nlet i18nSelectedL () = \n  i18n [\"Language\"; \"Língua\"; \"Langue\"]\n\nlet i18nSelectPT () = \n  i18n [\"Portuguese\"; \"Português\"; \"Portugais\"]\n\nlet i18nSelectEN () = \n  i18n [\"English\"; \"Inglês\"; \"Anglaise\"]\n\nlet i18nSelectFR () = \n  i18n [\"French\"; \"Francês\"; \"Français\"]\n\nlet i18nAbout () = \n  i18n [\"About\"; \"Sobre\"; \"À propos\"]\n\nlet i18nFeedback () = \n  i18n [\"Feedback\"; \"Comentários\"; \"Commentaires\"]\n\n(** ---------------- Barra de topo ----------------- **)\n\nlet i18nMainTitle1 () = \n  i18n [\"Finite Automata\"; \"Autómatos Finitos\"; \"Automates Finis\"]\n\nlet i18nMainTitle2 () = \n  i18n [\"Regular Expressions\"; \"Expressões Regulares\"; \"Expressions Régulières\"]\n\nlet i18nMainTitle3 () = \n  i18n [\"Exercises\"; \"Exercícios\"; \"Des exercices\"]\n\nlet i18nMainTitle4 () =\n  i18n [\"Context Free Grammars\"; \"Gramáticas Independentes de Contexto\"; \"Grammaires Sans Contexte\"]\n\nlet i18nMainTitle5 () =\n  i18n [\"Grammars\"; \"Gramáticas Gerais\"; \"Grammaires Générales\"]\n\n\nlet i18nMainTitleTM () = (* carolina *)\n  i18n [\"Turing Machine\"; \"Máquina de Turing\"; \"Machine de Turing\"]\n\n\nlet i18nMainTitlePDA () = \n  i18n [\"Pushdown Automata\"; \"Autómatos de Pilha\"; \"Automate à Pile\"]\n\nlet i18nMainTitleComp () = (* carolina *)\n  i18n [\"Composition\"; \"Composição\"; \"Composition\"]\n\n(** ---------------- Footer ----------------- **)\n\nlet i18nDeveloped () = \n  i18n [\"Developed in \"; \"Desenvolvido em \"; \"Développé en\"]\n\nlet i18nNovaLincs () = \n    i18n [\"NOVA-LINCS\"; \"NOVA-LINCS\"; \"NOVA-LINCS\"]\n\nlet i18nProject () = \n  i18n [\" by the projects \"; \" pelos projectos \"; \"par les projets\"]\n\nlet i18nFactor () = \n  i18n [\"Factor\"; \"Factor\"; \"Factor\"] \n\nlet i18nAnd () = \n  i18n [\" and \"; \" e \"; \" et \"]\n  \nlet i18nLeafs () = \n  i18n [\" LEAFs\"; \" LEAFs\"; \" LEAFs\"]\n\nlet i18nFinancing () = \n  i18n [\" / Co-financed by \"; \" / Cofinanciado por \"; \"/ Cofinancé par\"]\n\nlet i18nFooter () = \n  i18n [\"Tezos Foundation\"; \"Fundação Tezos\"; \"Fondation Tezos\"]\n  \nlet i18nFooter1 () = \n  i18n [\"INRIA Foundation\"; \"Fundação INRIA\"; \"INRIA Foundation\"]\n\n(** ------------------ Modal ------------------- **)\n\nlet i18nNewModelSelectType() =\n  i18n [\"Select model type:\"; \"Selecionar o tipo de modelo:\"; \"Sélectionnez le type de modèle\"]\n\nlet i18nInstructionsAutomaton () =\n  i18n [\"Set the name of the initial state.\";\n        \"Defina o nome do estado inicial.\";\n        \"Définissez le nom de l'état initial.\"]\n\nlet i18nInstructionsCFG() =\n  i18n [\"The head of the rule of the first line is considered the initial variable of the grammar.\nThe empty symbol can be indicated with a blank space or with the character ~.\"; \n        \"A cabeça da regra da primeira linha é considerada a variável inicial da gramática.\nO símbolo vazio pode ser indicado com um espaço em branco ou com o caracter ~.\";\n        \"L'en-tête de la règle de la première ligne est considérée comme la variable initiale de la grammaire.\nLe symbole vide peut être indiqué par un espace blanc ou par le caractère ~.\"]\n\n\nlet i18nInstructionsGR() =\n  i18n [\"The head of the rule of the first line is considered the initial variable of the grammar.\nThe empty symbol can be indicated with a blank space or with the character ~.\"; \n        \"A cabeça da regra da primeira linha é considerada a variável inicial da gramática.\nO símbolo vazio pode ser indicado com um espaço em branco ou com o caracter ~.\";\n        \"L'en-tête de la règle de la première ligne est considérée comme la variable initiale de la grammaire.\nLe symbole vide peut être indiqué par un espace blanc ou par le caractère ~.\"]\n\n(** ---------------- Automatos ----------------- **)\n\nlet i18nFormatting () = \n  i18n [\"See model specification\"; \"Ver especificação do modelo\"; \"Voir les spécifications du modèle\"]\n\nlet i18nClean () = \n  i18n [\"Clean\"; \"Limpar\"; \"Nettoyer\"]\n\nlet i18nKuroda () = \n  i18n [\"Kuroda Normal Form\"; \"Forma normal de Kuroda\"; \"Forme normale de Kuroda\"]\n\nlet i18nPenttonen () = \n  i18n [\"Penttonen Normal Form\"; \"Forma normal de Penttonen\"; \"Forme normale de Penttonen\"]\n\nlet i18monoCSG () = \n  i18n [\"Monotonic to CSG\"; \"Monótona para GSC\"; \"Monotone vers GSC\"]\n\nlet i18nDeterministic () = \n  i18n [\"Make deterministic\"; \"Tornar determinista\"; \"Rendre déterministe\"]\n\nlet i18nMinimize () = \n  i18n [\"Minimize automaton\"; \"Minimizar autómato\"; \"Minimiser l'automate\"]\n\nlet i18nProductive () = \n  i18n [\"Productive states\"; \"Estados produtivos\"; \"États productifs\"]\n\nlet i18nAccessible () = \n  i18n [\"Accessible states\"; \"Estados acessiveis\"; \"États accessibles\"]\n\nlet i18nUseful () = \n  i18n [\"Useful states\"; \"Estados úteis\"; \"États utiles\"]\n\nlet i18nTogleAcceptCriteriaState () = \n  i18n [\"Acceptance Mode: Final states\"; \"Modo de Aceitação: Estados Finais\"; \"Mode d'acceptation : États finaux\"]\n\nlet i18nTogleAcceptCriteriaEmptyStack () = \n  i18n [\"Acceptance Mode: Empty Stack\"; \"Modo de Aceitação: Pilha Vazia\"; \"Mode d'acceptation : Pile Vide\"]\n\nlet i18nInitialStackSymbol () = \n  i18n [\"Initial stack symbol: \"; \"Símbolo inicial da pilha: \"; \"Symbole de pile initial: \"]\n\n(* let i18nInfoBox () = \n  i18n [\"Data about the Automaton\"; \"Dados sobre o Autómato\"] *) \n\nlet i18nIsDeterministic () = \n  i18n [\"The automaton is deterministic. \"; \"O autómato é determinista. \"; \"L'automate est déterministe. \"]\n\nlet i18nNotDeterministic () = \n  i18n [\"The Automaton is not deterministic. \"; \"O Autómato não é determinista. \"; \"L'automate n'est pas déterministe. \"]\n\nlet i18nIsMinimal () = \n  i18n [\"The Automaton is minimal. \"; \"O Autómato é mínimo. \"; \"L'automate est minimal. \"]\n\nlet i18nNotMinimal () = \n  i18n [\"The automaton is not minimal. \"; \"O autómato não é mínimo. \"; \"L'automate n'est pas minimal. \"]\n\nlet i18nNotUseless () = \n  i18n [\"The automaton has no useless states. \"; \"O autómato não tem estados inúteis. \"; \"L'automate n'a pas d'états inutiles. \"]\n\nlet i18nisEquivalentFA () =\n  i18n [\"The automaton can be transformed to a equivalent FA. \"; \"O autómato pode ser transformado em um AF equivalente. \"; \"L'automate peut être transformé en un AF équivalent. \"]\n\nlet i18nisNotEquivalentFA () =\n  i18n [\"The automaton can not be transformed to a equivalent FA. \"; \"O autómato não pode ser transformado em um AF equivalente. \"; \"L'automate ne peut être transformé en un AF équivalent. \"]\n\nlet i18nHas () = \n  i18n [\"The automaton has \"; \"O autómato tem \"; \"L'automate a \"]\n\nlet i18nUselessStates () = \n  i18n [\" useless states. \"; \" estados inúteis. \"; \" etats inutiles. \"] \n\nlet i18nNumberStates () = \n    i18n [\"Number of states: \"; \"Número de Estados: \"; \"Nombre d'états: \"] \n\nlet i18nNumberTransitions () = \n  i18n [\"Number of transitions: \"; \"Número de Transições: \"; \"Nombre de transitions: \"]\n\n(* ML *)\nlet i18nIsLinearBounded() = \n  i18n [\"The automaton is linear bounded \"; \"O autómato é linearmente limitado \"; \"L'automate est linéairement borné \"]\n\nlet i18nIsNotLinearBounded() = \n  i18n [\"The automaton is not linear bounded \"; \"O autómato não é linearmente limitado \"; \"L'automate n'est pas borné linéairement \"]\n\nlet i18nNoPathAvailablePDA () = \n  i18n [\n    \"(Word not accepted, there is no acceptance path available)\"; \n    \"(Palavra não aceite pelo Autómato, não existe nenhum caminho aceite pelo autómato)\"; \n    \"(Mot non accepté, il n'y a pas de chemin d'acceptation disponible)\"\n  ]\n\nlet i18nAlreadyInAcceptanceModeByStates () = \n  i18n [\"Automaton already in acceptance mode by final states\"; \n  \"O Autómato já está em modo de aceitação por estados finais\"; \n  \"Automate déjà en mode acceptation par états finaux\"]\n\nlet i18nAlreadyInAcceptanceModeByEmptyStack () = \n  i18n [\"Automaton already in acceptance mode by empty stack\"; \n  \"O Autómato já está em modo de aceitação por pilha vazia\"; \n  \"Automate déjà en mode acceptation par pile vide\"]\n\n(** ---------------- Regular Expressions ----------------- **)\n\nlet i18nDirection () = \n  i18n [\"Change tree direction\"; \"Mudar direção da árvore\"; \"Changer la direction de l'arbre\"]\n\n(** ---------------- Context Free Grammars ---------------- **)\n\nlet i18nCFGFirst () =\n  i18n [\"FIRST\";\n        \"PRIMEIROS\";\n        \"PREMIER\"]\n\nlet i18nCFGFollow () =\n  i18n [\"FOLLOW\";\n        \"SEGUINTES\";\n        \"SUIVANT\"]\n\nlet i18nRemoveLeftRecursion () =\n  i18n [\"Remove left recursion\"; \"Remover recursividade esquerda\"; \"Supprimer la récursivité gauche\"]\n  \nlet i18nRemoveUnproductive () =\n  i18n [\"Remove unproductive symbols\"; \"Remover símbolos não produtivos\"; \"Supprimer les symboles improductifs\"]\n\nlet i18nRemoveInaccessible () =\n  i18n [\"Remove inaccessible symbols\"; \"Remover símbolos inacessíveis\"; \"Supprimer les symboles inaccessibles\"]\n\nlet i18nLeftFactoring () =\n  i18n [\"Left factoring\"; \"Fatorizar à esquerda\"; \"Factorisation à gauche\"]\n\nlet i18nRemoveEpsilonProductions () =\n  i18n [\"Remove ε productions\"; \"Remover produções ε\"; \"Supprimer ε productions\"]\n\nlet i18nRemoveUnitProductions () =\n  i18n [\"Remove unit productions\"; \"Remover produções unitárias\"; \"Supprimer les productions unitaires\"]\n\nlet i18nTransformToLL1 () =\n  i18n [\"Transform to a LL1 Grammar\"; \"Transformar numa gramática LL1\"; \"Transformer en une grammaire LL1\"]\n\nlet i18nFirstAndFollow () =\n  i18n [\"First and follow set\"; \"Conjuntos dos primeiros e seguintes\"; \"Ensemble premier et suivi\"]\n  \nlet i18nParsingTable () =\n  i18n [\"Parsing table\";\n        \"Tabela de análise sintática\";\n        \"Table d'analyse\"]\n  \nlet i18nSetTables () =\n  i18n [\"First, Follow and Parsing tables\";\n        \"Tabelas dos primeiros, seguintes e análise sintática\";\n        \"Tout d'abord, suivre et analyser les tables\"]  \n\nlet i18nRDParser () =\n  i18n [\"Recursive descendent parser\";\n        \"Analisador descendente recursivo\";\n        \"Analyseur descendant récursif\"]  \n\nlet i18nToggle () =\n  i18n [\"Toggle mode\";\n        \"Alternar modo\";\n        \"Bascule entre les modes simple et traditionnel\"]\n\nlet i18nRDParserCopyButtonDefault () =\n  i18n [\"Copy to clipboard\";\n        \"Copiar\";\n        \"Copie\"]\n\nlet i18nRDParserCopyButtonClick () =\n  i18n [\"Copied\";\n        \"Copiado\";\n        \"Copié\"]\n\nlet i18nCFGLL1Accept () =\n  i18n [\"Test word acceptance\"; \"Testar aceitação de uma palavra\"; \"Tester l'acceptation des mots\"]\n\nlet i18nIsLL1 () =\n  i18n [\"The grammar is LL1. \"; \"A gramática é LL1. \"; \"La grammaire est LL1. \"]\n\nlet i18nIsNotLL1 () =\n  i18n [\"The grammar is not LL1. \"; \"A gramática não é LL1. \"; \"La grammaire n'est pas LL1. \"]\n  \nlet i18nIsLeftRecursive () =\n  i18n [\"The grammar is left recursive. \"; \"A gramática é recursiva à esquerda. \"; \"La grammaire est laissée récursive. \"]\n  \nlet i18nIsNotLeftRecursive () =\n  i18n [\"The grammar is not left recursive. \"; \"A gramática não é recursiva à esquerda. \"; \"La grammaire n'est pas laissée récursive. \"]\n  \nlet i18nIsLeftFactoring () =\n  i18n [\"The grammar can be left factored. \"; \"A gramática pode ser fatorizada à esquerda. \"; \"La grammaire peut être factorisée. \"]\n  \nlet i18nIsNotLeftFactoring () =\n  i18n [\"The grammar is already left factored. \"; \"A gramática é fatorizada à esquerda. \"; \"La grammaire est déjà factorisée à gauche. \"]\n\nlet i18nHasParsingTableConflict () =\n  i18n [\"There are conflicts on the parsing table. \";\n        \"Existem conflitos na tabela de análise sintática. \";\n        \"Il y a des conflits sur la table d'analyse. \"]\n\nlet i18nHasNotParsingTableConflict () =\n  i18n [\"There are no conflicts on the parsing table. \";\n        \"Não existem conflitos na tabela de análise sintática. \";\n        \"Il n'y a pas de conflits sur la table d'analyse. \"]\n\nlet i18nIsCFGClean () =\n  i18n [\"The grammar is clean. \"; \"A gramática é limpa. \"; \"La grammaire est propre. \"]\n\n  let i18nIsCFG () =\n      i18n [\"The grammar is context free. \"; \"A gramática é independente de contexto. \"; \"La grammaire est indépendante du contexte. \"]\n\n  let i18nIsCSG () =\n    i18n [\"The grammar is context sensitive. \"; \"A gramática é dependente de contexto. \"; \"La grammaire est dépendante du contexte. \"]\n  \n   let i18nIsMO () =\n    i18n [\"The grammar is monotonic. \"; \"A gramática é monotónica. \"; \"La grammaire est monotonique. \"]\n\n    let i18nIsUG () =\n      i18n [\"The grammar is unrestricted. \"; \"A gramática é irrestrita. \"; \"La grammaire est non restreinte. \"]\n\n      let i18nIsLG () =\n        i18n [\"The grammar is linear. \"; \"A gramática é linear. \"; \"La grammaire est linéaire. \"]\n\n        let i18nIsRLG () =\n            i18n [\"The grammar is right linear. \"; \"A gramática é linear direita. \"; \"La grammaire est linéaire droite. \"]\n        \n        let i18nIsLLG () =\n            i18n [\"The grammar is left linear. \"; \"A gramática é linear esquerda. \"; \"La grammaire est linéaire gauche. \"]\n\nlet i18nIsNotCFGClean () =\n  i18n [\"The grammar is not clean. \"; \"A gramática não é limpa. \"; \"La grammaire n'est pas propre. \"]\n  \nlet i18nNotProd () =\n  i18n [\"The grammar has unproductive symbols. \"; \"A gramática tem símbolos não produtivos. \"; \"La grammaire a des symboles improductifs. \"]\n  \nlet i18nNotAccess () =\n  i18n [\"The grammar has inaccessible symbols. \"; \"A gramática tem símbolos não acessíveis. \"; \"La grammaire a des symboles inaccessibles. \"]\n    \nlet i18nNewGrammar () =\n  i18n [\"New grammar\"; \"Nova gramática\"; \"Nouvelle grammaire\"]\n  \nlet i18nAcceptInput () =\n  i18n [\"Input\"; \"Entrada\"; \"Entrée\"]\n\nlet i18nAcceptRecognized () =\n  i18n [\"Recognized\"; \"Reconhecido\"; \"Reconnu\"]\n  \nlet i18nAcceptStack () =\n  i18n [\"Stack\"; \"Pilha\"; \"Empiler\"]\n  \nlet i18nAcceptProduction () =\n  i18n [\"Production\"; \"Produção\"; \"Production\"]\n\n(** ---------------- Exercises ----------------- **)\n\nlet i18nVerify () = \n  i18n [\"Verify\"; \"Verificar\"; \"Vérifier\"]\n\nlet i18nNonAccepted () = \n  i18n [\"Words to reject: \"; \"Palavras para rejeitar: \"; \"Mots à accepter: \"]\n\nlet i18nAcceptedWords () = \n  i18n [\"Words to accept: \"; \"Palavras para aceitar: \"; \"Des mots qui devraient être acceptés: \"]\n\nlet i18nProblem () = \n  i18n [\"Problem: \"; \"Problema: \"; \"Problème: \"] \n\nlet i18nEnumTitle () = \n  i18n [\"Exercise\"; \"Exercício\"; \"Exercice\"] \n\nlet i18nRight () = \n  i18n [\"Correct answer\"; \"Resposta correcta\"; \"Bonne réponse\"]\n\nlet i18nWrong () = \n  i18n [\"Wrong answer\"; \"Resposta errada\"; \"Mauvaise réponse\"]\n\n(** ---------------- Palavras Geradas ----------------- **)\n\nlet i18nGenerateWords () = \n  i18n [\"Generated Words:\"; \"Palavras Geradas:\"; \"Mots générés:\"]\n\n(** ---------------- Accept das Expressões Regulares ----------------- **)\n\nlet i18nWordAccepted () = \n  i18n [\"The word is accepted\"; \"A palavra é aceite\"; \"Le mot est accepté\"]\n\nlet i18nWordNotAccepted () = \n  i18n [\"The word is not accepted\"; \"A palavra não é aceite\"; \"Le mot n'est pas accept\"] \n\nlet i18nExists () = \n  i18n [\"There are \"; \"Existem \"; \"Il y a \"] \n\nlet i18nGoodDerivations () = \n  i18n [\" successful derivations: \"; \" derivações bem sucedidas: \"; \" dérivations réussies: \"]\n\nlet i18nBadDerivations () = \n  i18n [\" failed derivations: \"; \" derivações falhadas: \"; \" dérivations qui ont échoué: \"]\n\nlet i18nBy () = \n  i18n [\" by \"; \" por \"; \" par \"]\n\nlet i18nNext () = \n  i18n [\"Next\"; \"Próxima\"; \"Suivante\"]\n\nlet i18nPrevious () = \n  i18n [\"Previous\"; \"Anterior\"; \"Précédente\"]\n\n(** ---------------- Alertas ----------------- **)\n\nlet i18nAlertMinimum () = \n  i18n [\"The automaton is already minimal\"; \"O Autómato já é mínimo\"; \"L'automate est déjà minimal\"]\n\nlet i18nAlertNeedsDeterministic () = \n  i18n [\"The Automaton must be deterministic in order to be minimized\"; \n  \"O Autómato tem de ser determinista para poder ser minimizado\";\n  \"L'automate doit être déterministe pour être minimisé\"]\n\nlet i18nAlertDelete () = \n  i18n [\"It is not possible to delete the initial state, change the initial state to another one and then delete the desired one!\"; \n  \"Não é possível eliminar estado inicial, troque o estado inicial para outro e depois elimine o desejado!\";\n  \"Il n'est pas possible d'éliminer l'état initial, changer l'état initial en un autre et puis supprimez l'état souhaité\"] \n\nlet i18nAlertUnexistentState () = \n  i18n [\"The indicated state does not exist!\"; \"O estado indicado não existe!\"; \"L'état indiqué n'existe pas!\"]\n\n(* let i18nAlertInitialFirst () = \n  i18n [\"It is necessary to create an initial state first\"; \n  \"É necessário criar primeiro um estado inicial\"] *)\n\nlet i18nAlertTheTransition () = \n  i18n [\"The transition \"; \"A transição \"; \"La transition \"]\n\nlet i18nAlertAlreadyExists () = \n  i18n [\" already exists!\"; \" já existe!\"; \" existe déjà!\"] \n\nlet i18nAlertDoNotExists () = \n  i18n [\" doesn't exists!\"; \" não existe!\"; \" n'existe pas!\"] \n\nlet i18nAlertStartState () = \n  i18n [\"The starting state does not exist!\"; \"O estado de partida não existe!\"; \"L'état de départ n'existe pas!\"]\n\nlet i18nAlertArrivalState () = \n  i18n [\"The state of arrival does not exist!\"; \"O estado de chegada não existe!\"; \"L'état d'arrivée n'existe pas!\"]\n\nlet i18nAlertAlreadyFinal () = \n  i18n [\"The state is already final\"; \"O estado já é final\"; \"L'état est déjà définitif\"]\n\n(* TM *)\nlet i18nAlertAlreadyInitial () = \n  i18n [\"The state is already initial\"; \"O estado já é inicial\"; \"Le statut est déjà initial\"]\n\nlet i18nAlertNonFinal () = \n    i18n [\"The state is not final\"; \"O estado não é final\"; \"L'état n'est pas définitif\"]\n\nlet i18nAlertWorkingWithAutomata () = \n  i18n [\"You can't add state because you are not working with an automaton\"; \n  \"Não pode adicionar estado porque não está a trabalhar com um autómato\";\n  \"Vous ne pouvez pas ajouter d'état parce que vous ne travaillez pas avec un automate\"]\n\nlet i18nAlertDeterministic () = \n  i18n [\"The automaton is already deterministic\"; \n  \"O Autómato já é determinista\";\n  \"L'automate est déjà déterministe\"]\n\nlet i18nAlertClean () = \n  i18n [\"The automaton has no states to clean, there are no useless states!\"; \n  \"O Autómato não tem estados para limpar, não existem estados inúteis!\";\n  \"L'automate n'a pas d'états à nettoyer, il n'y a pas d'états inutiles!\"]\n\nlet i18nAlertRegex () = \n  i18n [\"You are already working with a regular expression\"; \n  \"Já está a trabalhar com uma expressão regular\";\n  \"Vous travaillez déjà avec une expression régulière\"]\n\nlet i18nAlertAutomaton () = \n  i18n [\"You are already working with a finite automaton\"; \n  \"Já está a trabalhar com um autómato finito\";\n  \"Vous travaillez déjà avec un automate fini\"]\n\nlet i18nAlertExists () = \n  i18n [\"The state already exists\"; \"O estado já existe\"; \"L'état existe déjà\"]\n\n(* ML *)\nlet i18nLeaveSimulationToEdit () = \n  i18n [\n        \"To edit the model, you need to exit stop the simulation. Are you sure you want to continue?\"; \n        \"Para editar o modelo, precisas de sair da simulação. Tens a certeze de que queres continuar\"; \n        \"Pour modifier le modèle, vous devez quitter et arrêter la simulation. Es-tu sur de vouloir continuer?\"\n      ]\n\n(* let i18nAlertAddStateTransitions () = \n  i18n [\"Add states and transitions in the text box\"; \n  \"Adicione os estados e transições na caixa de texto\"] *)\n\n(*  let defineAlertFormat lang =\n    match lang with \n    \"\" -> \"\"\n      | \"en\" -> \"The format of a transition is: State Transition State\"\n      | \"pt\" -> \"O formato de uma transição é: Estado Transição Estado\" *)\n\n (* let defineAlertName lang =\n    match lang with \n    \"\" -> \"\"\n      | \"en\" -> \"You must name the state in the text box\"\n      | \"pt\" -> \"Tem de dar um nome ao estado na caixa de texto\" *)\n\nlet i18nAlertNoTransitions () = \n  i18n [\"There is no transition with the symbol given!\"; \n  \"Não há transições com o símbolo indicado!\";\n  \"Il n'y a pas de transition avec le symbole donné!\"]\n\nlet i18nAlertNoMoreStates () = \n  i18n [\"The word is over. There are no more states to follow.\"; \n  \"A palavra terminou. Não existem mais estados seguintes.\";\n  \"Nous sommes en fin de mot. Il n'y a plus d'état à suivre.\"]\n\nlet i18nAlertEndTMSim () = (* ML *)\n  i18n [\n    \"The simulation is over. There are either no more transitions or the machine is in an accept state.\";\n    \"A simulação acabou. Não há mais transições ou a máquina está num estado de aceitação\";\n    \"La simulation est terminée. Il n'y a plus de transitions ou la machine est dans un état d'acceptation\"\n  ]\n  \nlet i18nAlertArrivedInitial () = \n  i18n [\"You are in the initial state. It is not possible to go backwards from this point\"; \n  \"Não é possível andar para trás do estado inicial\";\n  \"Vous êtes dans l'état initial. Il n'est pas possible de revenir en arrière à partir de ce point\"]\n\nlet i18nAlertNotLeftRecursive () =\n  i18n [\"Grammar is not left recursive\";\n  \"A gramática não é recursiva à esquerda\";\n  \"La grammaire n'est pas récursive\"]\n\nlet i18nAlertIsLL1 () = i18nIsLL1()\n\nlet i18nAlertNotLeftFactoring () =\n  i18n [\"Grammar does not need to be left factored\";\n  \"A gramática não precisa de ser fatorizada à esquerda\";\n  \"La grammaire n'a pas besoin d'être factorisée\"]\n\nlet i18nAlertIsClean () =\n  i18n [\"Grammar is already clean\";\n  \"A gramática já é limpa\";\n  \"La grammaire est déjà propre\"]\n\nlet i18nAlertIsNotMonotonic () =\n  i18n [\"Grammar is not monotonic\";\n  \"A gramática já não é monotónica\";\n  \"La grammaire n'a pas monotonique\"]\n  \n\nlet i18nAlertIsContextSensitive () =\n  i18n [\"Grammar is not context sensitive\";\n  \"A gramática não é dependente de contexto\";\n  \"La grammaire n'est pas sensible au contexte\"]\n\nlet i18nAlertNoEmptyProductions () =\n  i18n [\"Grammar does not have any epsilon productions\";\n  \"A gramática não tem produções epsilon\";\n  \"La grammaire n'a pas de productions epsilon\"]\n  \nlet i18nAlertNoUnitProductions () =\n  i18n [\"Grammar does not have any unit productions\";\n  \"A gramática não tem produções unitárias\";\n  \"La grammaire n'a pas de productions unitaires\"]\n\nlet i18nAlertCFGAcceptNoInput () =\n  i18n [\"Word not accepted because there are no more input symbols to analyze and the remaining stack symbols do not derive an empty word.\";\n  \"A palavra não é aceite porque não existem mais símbolos de entrada a analisar e os símbolos que sobram na pilha não derivam a palavra vazia.\";\n  \"Mot non accepté car il n'y a plus de symboles d'entrée à analyser et les symboles de pile restants ne dérivent pas un mot vide.\"]\n  \nlet i18nAlertCFGAcceptNoStack () =\n  i18n [\"Word not accepted because there are no more symbols on the stack but there are still symbols on the input to analyze.\";\n  \"A palavra não é aceite porque não existem mais símbolos na pilha mas existem ainda símbolos de entrada por analisar.\";\n  \"Mot non accepté car il n'y a plus de symboles sur la pile mais il y a encore des symboles sur l'entrée à analyser.\"]\n  \nlet i18nAlertCFGAcceptNoProduction () =\n  i18n [\"Word not accepted because there is no production found with the given variable and terminal symbols.\";\n  \"A palavra não é aceite porque não existe produção com os símbolos variável e terminal fornecidos.\";\n  \"Mot non accepté car aucune production n'a été trouvée avec la variable et les symboles terminaux donnés.\"]\n\nlet i18nAlertRETooBig () =\n  i18n [\"RE tree too big to display\";\n  \"Árvore ER muito grande para mostrar\";\n  \"Arborescence ER trop grande pour être affichée\"]\n\nlet i18nAlertDirectionWrong() =\n  i18n [\"The direction inserted is not correct, it must be either L or R\";\n    \"A direção inserida não está correta, deve ser L ou R\";\n    \"La direction insérée n'est pas correcte, elle doit être L ou R\"]\n\nlet i18nAlertExceededCharacters() =\n  i18n [\n    \"Expecting only 5 characters\";\n    \"São esperados apenas 5 caractéres\";\n    \"Attendre seulement 5 caractères\"\n  ]\n\nlet i18nAlertTransitionExists() =\n  i18n [\n    \"This transition already exists\";\n    \"Esta transição ja existe\";\n    \"Cette transition existe déjà\"\n  ]\n\n\n(** ---------------- Feedback ----------------- **)\n\nlet i18nFeedbackText () = \n  i18n [\"In order to create an increasingly better application, we appreciate any kind of feedback.\"; \n  \"De forma a criarmos uma aplicacão cada vez melhor, agradecemos qualquer tipo de comentários.\";\n  \"Afin d'améliorer constamment la application, nous apprécierons grandement vos commentaires.\"]\n\nlet i18nFeedbackText2 () = \n  i18n [\"If you have any questions or want to give an opinion, please send an email to \"; \n  \"Se tiver alguma dúvida ou queira dar opinião, envie, por favor, um email para \";\n  \"Si vous avez des questions ou souhaitez donner votre opinion, veuillez nous envoyer un e-mail à \"]\n\nlet i18nFeedbackThankYou () = \n  i18n [\"Thank You!\"; \"Obrigado!\"; \"Merci!\"]\n\n(** ---------------- Sobre ----------------- **)\n\nlet i18nAboutTitle () = \n  i18n [\"About\"; \"Sobre\"; \"À propos de\"]\n\nlet i18nAboutSubtitle () = \n  i18n [\"About OFLAT\"; \"Sobre OFLAT\"; \"À propos de OFLAT\"]\n\nlet i18nAboutSubtitle2 () = \n  i18n [\"Instructions\"; \"Instruções\"; \"Instructions\"]\n\nlet i18nAboutText1 () = \n  i18n [\"This tool is being developed at \"; \"Esta ferramenta está a ser desenvolvida na \"; \"Cet outil est en cours de développement au \"]\n\nlet i18nAboutText2 () = \n  i18n [\" (at the Computer Science Department of FCT-UNL) by the projects \"; \n  \" (no Departamento de Informática da FCT- UNL) pelo projecto \";\n  \" (au Département d'informatique du FCT-UNL) par les projets \"]\n\nlet i18nAboutText16 () = \n  i18n [\" and \"; \" e \"; \" et \"]\n\nlet i18nAboutText17 () = \n  i18n [\" LEAFs\"; \" LEAFs\"; \" LEAFs\"]\n\nlet i18nAboutText3 () = \n  i18n [\" and co-financed by \"; \" e co-financiado pela \"; \" et cofinancé par \"]\n\nlet i18nAboutText4 () = \n  i18n [\"It is being developed in OCaml with the help of the libraries js_of_ocaml em Cytoscape.js, the source code being available on \"; \n  \"Está a ser desenvolvido em OCaml com a ajuda das bibliotecas js_of_ocaml e Cytoscape.js, estando o código fonte disponível no \";\n  \"Il est développé en OCaml à l'aide des bibliothèques js_of_ocaml et Cytoscape.js, le code source étant disponible à \"]\n\nlet i18nAboutText5 () =  \n  i18n [\"At this moment it is possible to work with finite automata, regular expressions and perform exercises.\"; \n  \"Neste momento é possível trabalhar com autómatos finitos, expressões regulares e realizar exercícios.\";\n  \"En ce moment, il est possible de travailler avec des automates finis, des expressions régulières et de résoudre des exercices.\"]\n\nlet i18nAboutText6 () = \n  i18n [\"To import a file it must be in txt or JSON. The format of an automaton is:\"; \n  \"Para se importar um ficheiro este deve estar em txt ou JSON. O formato de um autómato é:\";\n  \"Pour importer un fichier il doit être au format txt ou JSON. Le format d'un automate est:\"]\n\nlet i18nAboutText7 () = \n  i18n [\"\n  {\n    kind: finite automaton,\n    description: description of the automaton,\n    name: name of the automaton,\n    alphabet: [list of elements],\n    states: [list of states],\n    initialState: an initial state,\n    transitions: [List of transitions in the format [departure state, alphabet element, arrival state]],\n    acceptStates: [list of states]\n  } \" ; \n  \"\n              {\n                kind: finite automaton,\n                description: descrição do autómato,\n                name: nome do autómato,\n                alphabet: [lista de elementos],\n                states: [lista de estados],\n                initialState: um estado inicial,\n                transitions: [Lista de transições com formato [estado de partida, elemento do alfabeto, estado de chegada]],\n                acceptStates: [lista de estados]\n              } \";\n              \"\n              {\n                kind: finite automaton,\n                description: description de l'automate,\n                name: nom de l'automate,\n                alphabet: [liste des éléments],\n                states: [liste des états],\n                initialState: un état initial,\n                transitions: [Liste des transitions au format [état de départ, élément de l'alphabet, état d'arrivée]],\n                acceptStates: [liste des états]\n              } \"]\n\nlet i18nAboutText8 () = \n  i18n [\"The format of a regular expression is:\"; \n  \"O formato de uma expressão regular é:\";\n  \"Le format d'une expression régulière est:\"]\n\nlet i18nAboutText9 () = \n  i18n [\"\n  {\n    kind: regular expression,\n    description: description of the regular expression,\n    name: name of the regular expression,\n    re: regular expression\n  } \"   ; \n  \"\n            {\n              kind: regular expression,\n              description: descrição da expressão regular,\n              name: nome da expressão regular,\n              re: expressão regular\n            } \";\n            \"\n  {\n    kind: regular expression,\n    description: description de l'expression régulière,\n    name: nom de l'expression régulière,\n    re: expression régulière\n  } \" ]\n\nlet i18nAboutText10 () = \n  i18n [\"The format of an exercise is:\"; \n  \"O formato de um exercício é:\";\n  \"Le format d'un exercice est:\"]\n\nlet i18nAboutText11 () = \n  i18n [\"\n  {\n    kind: enumeration,\n    description: description of the automaton,\n    name: exercise name,\n    problem: exercise presented to the student,\n    inside: [list of words to be accepted],\n    outside: [list of words that should not be accepted]\n  } \"; \n  \"\n            {\n              kind: enumeration,\n              description: descrição do autómato,\n              name: nome do exercício,\n              problem: exercício apresentado ao aluno,\n              inside: [lista de palavras que devem ser aceites],\n              outside: [lista de palavras que não devem ser aceites]\n            } \";\n            \"\n  {\n    kind: enumeration,\n    description: description de l'automate,\n    name: nom de l'exercice,\n    problem: exercice présenté à l'élève,\n    inside: [liste de mots à accepter],\n    outside: [liste de mots qui ne devraient pas être acceptés]\n  } \"]\n\nlet i18nAboutText12 () = \n  i18n [\"All elements on the right side of the colon must be enclosed in quotation marks.\"; \n  \"Todos os elementos do lado direito dos dois pontos devem ser colocados entre aspas.\";\n  \"Tous les éléments du côté droit des deux points doivent être placés entre guillemets.\"]\n\nlet i18nAboutText13 () = \n  i18n [\"It is also possible to load predefined examples from the server.\"; \n  \"É possivel também carregar exemplos predefinidos do servidor.\";\n  \"Il est également possible de charger des exemples prédéfinis à partir du serveur.\"]\n\nlet i18nAboutText14 () = \n  i18n [\"The regular expression can also be created by typing it in the text box and the automata can be created step by step using the State and Transition select boxes. To create or edit a state it is necessary to indicate its name in the text box and to create or edit a transition put in the text box start status, alphabet element, arrival status (example: A a B). \"; \n  \"A expressão regular pode também ser criada escrevendo a mesma na caixa de texto e os autómatos pode ser criados passo a passo usando as caixas de seleção Estado e Transição. Para se criar ou editar um estado é necessário indicar o nome do mesmo na caixa de texto e para se criar ou editar uma transição coloca-se na caixa de texto estado de partida, elemento do alfabeto, estado de chegada (exemplo: A a B).\";\n  \"L'expression régulière peut également être créée en tapant dans la zone de texte et les automates peuvent être créés étape par étape à l'aide des boîtes de sélection État et Transition. Pour créer ou modifier un état, il est nécessaire d'indiquer son nom dans la zone de texte et pour créer ou modifier une transition mise dans la zone de texte état de départ, élément alphabet, état d'arrivée (exemple: A a B). \"]\n\nlet i18nAboutText15 () = \n  i18n [\"In the automata the epsilon transition is represented by ~.\"; \n  \"Nos autómatos a transição épsilon é representada por ~.\";\n  \"Dans les automates, la transition epsilon est représentée par ~.\"]\n\n(** ---------------- ToolTips ----------------- **)\nlet i18nTooltipSave () =\n  i18n [\"Save model in repository\";\n  \"Guardar modelo em repositório\";\n  \"Enregistrer le modèle dans le référentiel\";] (*Carolina*)\n\nlet i18nTooltipNewModel () =\n  i18n [\"Allows the creation of a new model.\"; \"Permite a criação de um novo modelo.\"; \"Permet la création d'un nouveau modèle.\"]\n  \nlet i18nTooltipEditModel () =\n  i18n [\"Edit the visible model.\"; \"Editar o modelo visível.\"; \"Modifiez le modèle visible.\"]\n\nlet i18nTooltipFitGraph () = \n  i18n [\"Fit visible graphics to the view box\"; \n  \"Ajustar gráficos vísiveis à caixa de visualização\";\n  \"Ajuster les graphiques visibles à la zone d'aperçu\"]\n\nlet i18nTooltipGenerate () = \n  i18n [\"Gives a list of words, of size smaller or equal a given size, accepted by the automaton\"; \n  \"Dá uma lista de palavras aceites, até um determinado tamanho dado pelo autómato\";\n  \"Donne une liste de mots, de taille inférieure ou égale à une taille donnée, acceptés par l'automate\"]\n\nlet i18nTooltipTest () = \n  i18n [\"Shows, with an animation, how the automaton accepts or rejects a given word; or shows, with a tree, the acceptance process of a regular expression; the input is asked through a box on the screen\"; \n  \"Mostra-se, com uma animação, como o autómato aceita ou rejeita uma dada palavra; ou mostra, com uma árvore, o processo de aceitação de uma expressão regular; a palavra é solicitada através de uma caixa no ecrã\";\n  \"Montre, avec une animation, comment l'automate accepte ou rejette un mot donné; ou montre, avec un arbre, le processus d'acceptation d'une expression régulière; la saisie est demandée par une boîte à l'écran\"]\n\nlet i18nTooltipStep () = \n  i18n [\"Allows the user to see the acceptance process step-by-step; the input is asked through a box on the screen\"; \n  \"Permite que o utilizador veja o processo de aceitação passo a passo; a palavra é solicitada através de uma caixa no ecrã\";\n  \"Permet à l'utilisateur de voir le processus d'acceptation pas à pas; la saisie est demandée par une boîte à l'écran\"]\n\nlet i18nTooltipClear () = \n  i18n [\"Removes all colors of the automaton\"; \n  \"Limpa as cores do autómato\";\n  \"Supprime toutes les couleurs de l'automate\"]\n\nlet i18nTooltipConvert () = \n  i18n [\"In a new box converts the automaton in a regular expression or a regular expression in an automaton\"; \n  \"Numa nova caixa converte um autómato em expressão regular e uma expressão regular num autómato\";\n  \"Dans une nouvelle boîte, il convertit l'automate en une expression régulière et une expression régulière en un automate\"]\n\nlet i18nTooltipFile () = \n  i18n [\"Allows the user to import a file from filesystem. Allowed formats txt or JSON\"; \n  \"Permite ao utilizador importar um ficheiro do sistema de ficheiros. Formatos permitidos txt ou JSON\";\n  \"Permet à l'utilisateur d'importer un fichier à partir du système de fichiers. Formats autorisés txt ou JSON\"]\n\nlet i18nTooltipExportModel () = \n  i18n [\"Download the textual representation of the currently visible model.\"; \n  \"Transfere a representação textual do modelo atualmente visivel.\";\n  \"Téléchargez la représentation textuelle du modèle actuellement visible.\"]\n\n\nlet i18nTooltipAbout () = \n  i18n [\"More about the page and some instructions\"; \n  \"Mais sobre a página e algumas instruções\";\n  \"Pour en savoir plus sur la page et quelques instructions\"]\n\nlet i18nTooltipFeedback () = \n  i18n [\"Information page if you want to give feedback\"; \n  \"Página sobre como dar comentários\";\n  \"Page d'informations si vous souhaitez donner votre avis\"]\n\nlet i18nTooltipLang () = \n  i18n [\"The user can choose the language of the page\"; \n  \"Permite ao utilizador escolher o idioma da página\";\n  \"L'utilisateur peut choisir la langue de la page\"]\n\nlet i18nTooltipCloseLeft () = \n  i18n [\"If there is a second figure on the screen, closes the left and keeps the right one; otherwise cleans the screen\"; \n  \"Se existir uma segunda figura no ecrã, fecha a da esquerda e mantém a da direita; senão limpa tudo\";\n  \"S'il y a une deuxième figure sur l'écran, fermez celle de gauche et gardez cellede droite; sinon nettoie l'écran\"]\n\nlet i18nTooltipCloseRight () = \n  i18n [\"Closes the right box on the screen\"; \n  \"Fecha a caixa direita\";\n  \"Ferme la boîte de droite sur l'écran\"]\n\nlet i18nTooltipDirection () = \n  i18n [\"If the tree is horizontal becomes vertical and vice-versa\"; \n  \"Se a árvore é horizontal torna-se vertical e vice-versa\";\n  \"Si l'arbre est horizontal devient vertical et vice-versa\"]\n\nlet i18nTooltipVerify () = \n  i18n [\"Verifies if the answer is correct or not, and if it is not, says where it fails\"; \n  \"Verifica se a resposta está correcta ou errada; se estiver errada diz onde falha\";\n  \"Vérifie si la réponse est correcte ou fausse, si c'est faux, il dit où il échoue\"]\n\nlet i18nTooltipClean () = \n  i18n [\"Creates a new automaton removing all useless states\"; \n  \"Cria um novo autómato removendo os estados inúteis\";\n  \"Crée un nouvel automate supprimant tous les états inutiles\"]\n\nlet i18nTooltipDeterministic () = \n  i18n [\"Creates on a new box a deterministic version of the automaton\"; \n  \"Cria numa nova caixa uma versão determinística do autómato\";\n  \"Crée sur une nouvelle boîte une version déterministe de l'automate\"]\n\nlet i18nTooltipMinimize () = \n  i18n [\"Creates on a new box a minimized version of the automaton\"; \n  \"Cria numa nova caixa uma versão minimizada do autómato\";\n  \"Crée sur une nouvelle boîte une version minimisée de l'automate\"]\n\nlet i18nTooltipProductive () = \n  i18n [\"Paints all the productive states of the automaton\"; \n  \"Pinta todos os estados produtivos do autómato\";\n  \"Peint tous les états productifs de l'automate\"]\n\nlet i18nTooltipAccessible () = \n  i18n [\"Paints all the accessible states of the automaton\"; \n  \"Pinta todos os estados acessíveis do autómato\";\n  \"Peint tous les états accessibles de l'automate\"]\n\nlet i18nTooltipUseful () = \n  i18n [\"Paints all the useful states of the automaton\"; \n  \"Pinta todos os estados úteis do autómato\";\n  \"Peint tous les états utiles de l'automate\"]\n\nlet i18nTooltipSpecification () = \n  i18n [\"Show the specification of the model in a new box\"; \n  \"Mostra a especificação do modelo numa nova caixa\";\n  \"Afficher la spécification du modèle dans une nouvelle case\"]\n\nlet i18nPropertyTrue () =\n  i18n [\"Does not require any property.\";\n  \"Não requer nenhuma propriedade\";\n  \"Ne nécessite aucune propriété.\"]\n\nlet i18nPropertyFiniteAutomaton () =\n  i18n [\"The solution must be a finite automaton\";\n  \"A solução deve ser um autómato finito\";\n  \"La solution doit être un automate fini\"]\n\nlet i18nPropertyRegularExpression () =\n  i18n [\"The solution must be a regular expression\";\n  \"A solução deve ser uma expressão regular\";\n  \"La solution doit être une expression régulière\"]\n\nlet i18nPropertyDeterministic () =\n  i18n [\"The automaton must be deterministic\";\n  \"O autómato deve ser determinista\";\n  \"L'automate doit être déterministe\"]\n\nlet i18nPropertyMinimized () =\n    i18n [\"The automaton must be minimal\";\n    \"O autómato deve ser mínimo\";\n    \"L'automate doit être minimal\"]\n\n    let i18nProperties () =\n      i18n [\"Properties to satisfy:\";\n      \"Propriedades para satisfazer:\";\n      \"Propriétés à satisfaire:\"]\n\n\nlet i18nPromptTextTestWord () =\n  i18n [\"Please enter the word to test\";\n  \"Por favor indique a palavra para testar\";\n  \"Veuillez saisir le mot à tester\"]\n\n let i18nTextRegex () =\n  i18n [\"Please enter the regular expression\";\n  \"Por favor indique a expressão regular\";\n  \"Veuillez saisir l'expression régulière\"]\n\n  let i18nWhichTransition () =\n    i18n [\"Which of the symbols do you want to delete?\";\n    \"Qual dos simbolos quer apagar?\";\n    \"Lequel des symboles souhaitez-vous supprimer?\"]\n\n  let i18nRenameStateQuestion () =\n    i18n [\"What is the new name of the state?\";\n    \"Qual o novo nome do estado?\";\n    \"Quel est le nouveau nom de l'état?\"]\n    \n  let i18nRenameTransition () =\n    i18n [\"Which transition to rename?\";\n    \"Qual a transição a renomear?\";\n    \"Quelle transition pour renommer?\"]\n\n  let i18nTextMaximumSize () =\n    i18n [\"Please enter the maximum size for the words\";\n    \"Por favor indique o tamanho máximo para as palavras\";\n    \"Veuillez saisir la taille maximale des mots\"]\n  \n  let i18nTextRemove () = \n      i18n[\"Remove\"; \"Remover\";\"Supprimer\"]\n\n  let i18nTextAdd () =\n    i18n [\"Add state\";\"Adicionar estado\"; \"Ajouter un état\"]\n      \n  let i18nTextAddInitial () =\n    i18n [\"Add initial state\"; \"Adicionar estado inicial\"; \"Ajouter un état initial\"]\n      \n  let i18nTextAddFinal () = \n    i18n [\"Add final state\"; \"Adicionar estado final\"; \"Ajouter l'état final\"]\n  \n  let i18nTextRenameState () =\n    i18n [\"Rename state\"; \"Renomear estado\"; \"Renommer l'état\"]\n      \n  let i18nTextAddTransition () =\n    i18n [\"Add transition\"; \"Adicionar transição\"; \"Ajouter une transition\"]\n      \n  let i18nTextTurnFinal () =\n    i18n [\"Make final\"; \"Tornar final\"; \"Rendre définitif\"]\n      \n  let i18nTextRemoveFinal () =\n     i18n [\"Remove final\"; \"Remover final\"; \"Supprimer la finale\"]\n      \n  let i18nTextTurnInitial () = \n     i18n [\"Make initial\"; \"Tornar inicial\"; \"Faire initiale\"]\n      \n  let i18nTextEnterState () =\n    i18n [\"Please enter the state name\"; \n    \"Por favor indique o nome do estado\";\n    \"Veuillez saisir le nom de l'état\"]\n      \n  let i18nTextEnterStartState () =\n    i18n [\"Please enter the start state\";\n    \"Por favor indique o nome do estado de partida\";\n    \"Veuillez saisir l'état de départ\"]\n      \n  let i18nTextEnterTransition () =\n    i18n [\"Please enter the transition symbol\";\n    \"Por favor indique o simbolo da transição\";\n    \"Veuillez saisir le symbole de transition\"]\n\n  let i18nTextEnterTransitionTM () =\n      i18n [\"Please enter the the information in the following format: read symbol/write symbol/direction\";\n      \"Por favor indique a informação no seguinte formato: simbolo lido/simbolo esrito/direção\";\n      \"Veuillez saisir les informations au format suivant : symbole de lecture/symbole d'écriture/direction\"]\n\n  let i18nTextEnterTransitionPda () =\n    i18n [\"Please enter the transition\";\n    \"Por favor indique a transição\";\n    \"Veuillez saisir le transition\"]\n\n  let i18nChangeInitialStackSymbolPda () =\n    i18n [\"Please enter the initial stack symbol\";\n    \"Por favor indique o símbolo inicial da pilha\";\n    \"Veuillez indiquer le symbole initial de la pile\"]\n      \n  let i18nTextEnterEndState () =\n    i18n [\"Please enter the end state\";\n    \"Por favor indique o estado de chegada\";\n    \"Veuillez saisir l'état final\"]\n  \nlet i18nTooltipCFGClean () =\n  i18n [\"Removes unproductive and inaccessible symbols from the grammar\";\n        \"Remover símbolos não produtivos e inacessíveis da gramática\";\n        \"Supprime les symboles improductifs et inaccessibles de la grammaire\"]\n\nlet i18nTooltipGRKuroda () =\n  i18n [\"Convert grammar to Kuroda normal form\";\n        \"Coverter para a forma normal de Kuroda\";\n        \"Conversion en forme normale de Kuroda\"]\n\nlet i18nTooltipGRPenttonen () =\n  i18n [\"Convert grammar to Penttonen normal form\";\n        \"Converter para a forma normal de Penttonen\";\n        \"Conversion en forme normale de Penttonen\"]\n\nlet i18nTooltipnonContractingToCSG () =\n  i18n [\"Convert monotonic grammar to context-sensitive grammar\";\n        \"Converter gramática monótona em gramática sensível ao contexto\";\n        \"Convertir la grammaire monotone en grammaire sensible au contexte\"]\n\nlet i18nTooltipRemoveLeftRecursion () =\n  i18n [\"Removes left recursion productions from the grammar\";\n        \"Remover produções recursivas à esquerda da gramática\";\n        \"Supprime les productions de récursivité gauche de la grammaire\"]\n\nlet i18nTooltipLeftFactoring () =\n  i18n [\"Left factorize grammar productions\";\n        \"Fazer factorização esquerda das produções da gramática\";\n        \"Factoriser à gauche les productions de grammaire\"]\n\nlet i18nTooltipRemoveEpsilonProductions () =\n  i18n [\"Removes all ε productions from the grammar\";\n        \"Remove todas as produções ε da gramática\";\n        \"Supprime toutes les productions ε de la grammaire\"]\n\nlet i18nTooltipRemoveUnitProductions () =\n  i18n [\"Removes all unit productions from the grammar\";\n        \"Remove todas as produções unitárias da gramática\";\n        \"Supprime toutes les productions unitaires de la grammaire\"]\n\nlet i18nTooltipTransformLL1 () =\n  i18n [\"Attempts to transform the current grammar into an equivalent LL1 grammar for the same language as the original grammar\";\n        \"Tenta fazer a transformação da gramática atual para uma gramática equivalente LL1 para a mesma linguagem da gramática original\";\n        \"Tente de transformer la grammaire actuelle en une grammaire LL1 équivalente pour la même langue que la grammaire d'origine\"]\n\nlet i18nTooltipFirstAndFollow () =\n  i18n [\"Finds the all first and follow sets\";\n        \"Encontra todos os conjuntos dos primeiros e seguintes\";\n        \"Trouve tous les premiers et suivants ensembles\"]\n\nlet i18nTooltipLookahead () =\n  i18n [\"Finds the lookahead set from a word\";\n        \"Encontra o conjunto dos diretores a partir de uma palavra\";\n        \"Recherche l'ensemble d'anticipation à partir d'un mot\"]\n\nlet i18nTooltipCFGLL1Accept () =\n  i18n [\"Verifies if word is accepted by the language generated by a LL1 grammar using a parsing table\";\n        \"Verifica se a palavra é aceite pela linguagem gerada pela gramática LL1 recorrendo ao uso da tabela de análise sintática\";\n        \"Vérifie si le mot est accepté par le langage généré par une grammaire LL1 à l'aide d'une table d'analyse\"]\n        \nlet i18nTooltipSetTables () =\n  i18n [\"Show tables for first, follows and parsing table\";\n        \"Mostra as tabelas dos primeiros, seguintes e de análise sintática\";\n        \"Afficher les tables pour la première, les suivantes et la table d'analyse\"]\n        \nlet i18nTooltipRDParser () =\n  i18n [\"Generates code for a recursive descendent parser in the chosen programming language\";\n        \"Gera código para um analisador descendente recursivo na linguagem de programação escolhida\";\n        \"Génère du code pour un analyseur descendant récursif dans le langage de programmation choisi\"]\n\nlet i18nTooltipToggleMode () =\n  i18n [\"Toggles between simple and traditional modes\";\n        \"Alterna entre os modos simples e tradicional\";\n        \"Bascule entre les modes simple et traditionnel\"]\n\n(** ----------------- Outros ------------------ **)\nlet i18nSave () =\n  i18n [\"Save\"; \"Guardar\"; \"sauvegarder\"] (*Carolina*)\nlet i18nSaveText () =\n  i18n [\"Enter the name of the model\"; \"Enter the name of the model\"; \"Entrez le nom du modèle\"]\n\nlet i18nConfirm () =\n  i18n [\"Confirm\"; \"Confirmar\"; \"Confirmer\"]\n  \nlet i18nCancel () =\n  i18n [\"Cancel\"; \"Cancelar\"; \"Annuler\"]\n\nlet i18nErrorParsing () =\n  i18n [\"Failed to parse string\"; \"Falha ao analisar a string\"; \"Impossible d'analyser la chaîne\"]\n\nlet i18nModelEditFA () =\n  i18n [\"Edit the model directly on the graph. Try right-clicking or long-pressing an element of the graph.\";\n        \"Edita o modelo diretamente no grafo. Experimenta clicar com o lado direito do rato ou manter premido num elemento do grafo.\";\n        \"Modifiez le modèle directement sur le graphique. Essayez de cliquer avec le bouton droit de la souris ou d'appuyer longuement sur un élément du graphique.\"]\n\n(** ---------------- Antigos (fora de uso) -----------------\n\n    let defineInputTitle lang =\n      match lang with \n      \"\" -> \"\"\n        | \"en\" -> \"Input\"\n        | \"pt\" -> \"Input\"\n\n    let defineSelectState lang =\n      match lang with \n      \"\" -> \"\"\n        | \"en\" -> \"State\"\n        | \"pt\" -> \"Estado\"\n\n    let defineSelectAdd lang =\n      match lang with \n      \"\" -> \"\"\n        | \"en\" -> \"Add\"\n        | \"pt\" -> \"Adicionar\"\n\n    let defineSelectInitial lang =\n      match lang with \n      \"\" -> \"\"\n        | \"en\" -> \"Initial\"\n        | \"pt\" -> \"Inicial\"\n    \n    let defineSelectFinal lang =\n      match lang with \n      \"\" -> \"\"\n        | \"en\" -> \"Final\"\n        | \"pt\" -> \"Final\"\n\n    let defineSelectErase lang =\n      match lang with \n      \"\" -> \"\"\n        | \"en\" -> \"Erase\"\n        | \"pt\" -> \"Apagar\"\n\n    let defineSelectTransition lang =\n      match lang with \n      \"\" -> \"\"\n        | \"en\" -> \"Transition\"\n        | \"pt\" -> \"Transição\"\n\n    **)\n\n    let i18nErrorConversion () =\n      i18n [\"Conversion not possible\"; \"Conversão não possível\"; \"Conversion impossible\"]\n\n  end\n","(*\n * JS.ml\n *\n * This file is part of the OFLAT app\n *\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\n *\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\n *\n * This software is distributed under the terms of the GPLv3 license.\n * See the included LICENSE file for details.\n *\n *  Written by Rita Macedo\n *)\n\nopen Js_of_ocaml\nopen OCamlFlat\nopen BasicTypes\n\nmodule JS = \nstruct \n    let global =\n      Js.Unsafe.global\n  \n    let eval s =\n      Js.Unsafe.eval_string s\n      \n    let exec s =\n      ignore (eval s)\n\n    let console =\n      Console.console\n\n    let string s =\n      Js.string s\n\n    let log j =\n      ignore (console##log j)\n\n    let alert j =\n      ignore (global##alert j)\n\n    let alertStr s =\n      alert (Js.string s)\n\n    let prompt text default =\n      Dom_html.window##prompt (Js.string text) (Js.string default)\n\n    let confirm text =\n      Js.to_bool (Dom_html.window##confirm (Js.string text))\n\n(*    let prompt text default =*)\n(*        Js.Opt.get*)\n(*            (Dom_html.window##prompt (Js.string text) (Js.string default))*)\n(*                  (fun () -> Error.fatal \"teste\")*)\n(*                  |> Js.to_string*)\n  \nend\n\nmodule type HTMLTableSig =\nsig\n\ttype t\n  type r\n  type c\n  type tableType\n\tval create: string -> string -> t\n  val insertRow: t -> r\n  val insertCell: r -> string -> string -> c\n  val modifyCell: c -> string -> c\n  val modifyRowId: r -> string -> unit\n  val tableExists: string -> bool\n  val tableFilled: t -> bool\n  val cToCell : c -> Dom_html.tableCellElement Js.t\n  val rToRow : r -> Dom_html.tableRowElement Js.t\n  val tToTable: t -> Dom_html.tableElement Js.t\n  val toTable: Dom_html.element Js.t -> t\n  val fetchTable : string -> t\n  val fetchRow: t -> int -> r Js.opt\n  val fetchCell: r -> int -> c Js.opt\n  val fetchLastRow: t -> r Js.opt\n  val setWidth: t -> string -> unit\n  val addEventListener: r -> string -> 'a -> unit\n  val appendChildtoCell: c -> Dom_html.element Js.t -> unit\n  val appendChildtoRow: r -> Dom_html.element Js.t -> unit\n  val appendChildtoTable: t -> Dom_html.element Js.t -> unit\n  val lowLevelApply: t -> (_ Js.t -> unit) -> unit\n  val changeDisplay: t -> string -> unit\n  val buildTable : string list list -> string -> string -> unit\n  val makeFAStateRow: OCamlFlat.BasicTypes.state ->\n    'a list ->\n    (OCamlFlat.BasicTypes.state * 'a * OCamlFlat.BasicTypes.state)\n    OCamlFlat.Set.t -> string list\n  val makePDAStateRow: OCamlFlat.BasicTypes.state ->\n    OCamlFlat.BasicTypes.symbol ->\n    'a list ->\n    (OCamlFlat.BasicTypes.state * OCamlFlat.BasicTypes.symbol * 'a *\n     OCamlFlat.BasicTypes.state * OCamlFlat.BasicTypes.symbol list)\n    OCamlFlat.Set.t -> string list\n  val makeFAPath: (OCamlFlat.BasicTypes.state * OCamlFlat.BasicTypes.word) list \n      -> int -> string list list\n  val makePDAPath: (OCamlFlat.BasicTypes.state * OCamlFlat.BasicTypes.symbol list *\n      OCamlFlat.BasicTypes.word) list \n      -> int -> string list list\n  val makeCFGPath: (OCamlFlat.BasicTypes.word * OCamlFlat.BasicTypes.word) list \n      -> int -> string list list\n  val makeGRPath: (OCamlFlat.BasicTypes.word * OCamlFlat.BasicTypes.word) list \n      -> int -> string list list\n  val makeREPath: (OCamlFlat.RegularExpression.t * OCamlFlat.BasicTypes.word) list \n      -> int -> string list list\n  val makeTMPath: (OCamlFlat.TuringMachine.path) -> int -> string list list\n  val paint : t -> int -> int -> string -> unit\nend\n\nmodule HTMLTable : HTMLTableSig = \nstruct\n\t(* https://ocsigen.org/js_of_ocaml/latest/api/js_of_ocaml/Js_of_ocaml/Dom_html/ *)\n\ttype t = Dom_html.tableElement Js.t\n\ttype r = Dom_html.tableRowElement Js.t\n\ttype c = Dom_html.tableCellElement Js.t \n  type tableType = Table of t | Row of r | Cell of c\n\n\tlet create (id: string) (parent: string) : t =\n\t\tlet doc = Dom_html.document in\n    let parentElement = Dom_html.getElementById parent in\n\t\tlet table = Dom_html.createTable doc in\n\t\t\ttable##.id := Js.string id;\n      Dom.appendChild parentElement table;\n\t\t\ttable\n\n  let insertRow (table: t) : r =\n    table##insertRow(-1)\n\n  let insertCell (row: r) (id: string) (contents: string) : c =\n    let newCell = row##insertCell (-1) in\n      newCell##.id := Js.string id;\n      newCell##.innerHTML := Js.string contents;\n      newCell##.classList##add(Js.string \"monospaceClass\");\n      newCell\n\n  (* let insertCellHTML (cell: c) (contents: string) =\n    let newCell = modifyCell cell \"\" in\n      let firstChar = String.get contents 0 in\n      let charSpan = Dom_html.createSpan doc in\n        charSpan##.id := Js.string \"firstChar\";\n        charSpan##.innerHTML := Js.string (String.make 1 firstChar);\n        Dom.appendChild newCell charSpan;\n      let subString = String.sub contents 1 ((String.length contents) - 1) in\n      let stringSpan = Dom_html.createSpan doc in\n        stringSpan##.id := Js.string \"restOfString\"; subString in\n        Dom.appendChild newCell stringSpan; *)\n\n  let modifyCell (cell: c) (contents: string) : c =\n      cell##.innerHTML := Js.string contents;\n      cell\n\n  let tableFilled (table: t) : bool =\n    if table##.rows##.length = 0 then true else false\n\n  let tableExists (table: string) : bool =\n    let _ = Dom_html.document in \n    let currTab = Dom_html.getElementById_opt table in\n    (match currTab with\n    | None -> false\n    | Some a -> true)\n\n    let toTable (element: Dom_html.element Js.t) : t =\n      Js.Unsafe.coerce (element)\n\n    let fetchTable (id: string) : t =\n        toTable(Dom_html.getElementById(id))\n\n    let fetchRow (table: t) (index: int) : r Js.opt=\n        table##.rows##item(index)\n      \n    let fetchCell (row :r) (index: int) : c Js.opt =\n        row##.cells##item(index)\n\n    let fetchLastRow (table: t) : r Js.opt =\n        let length = table##.rows##.length in\n        fetchRow table (length-1)\n    \n    let cToCell (cell: c) : Dom_html.tableCellElement Js.t =\n      Js.Unsafe.coerce (cell)\n\n    let rToRow (row: r) : Dom_html.tableRowElement Js.t =\n      Js.Unsafe.coerce (row)\n\n    let tToTable (table: t) : Dom_html.tableElement Js.t =\n      Js.Unsafe.coerce (table)\n\n    let setWidth (table: t) (width: string) =\n      table##.width := (Js.string width)\n    \n    let modifyRowId (row: r) (id: string) =\n      row##.id := (Js.string id)\n\n    let addEventListener (row: r) (s: string) f =\n      let newRow = Js.Unsafe.coerce (row) in\n      newRow##addEventListener (Js.string s) (f)\n\n    let appendChildtoCell (parent: c) (child: Dom_html.element Js.t) =\n      let u = Js.Unsafe.coerce parent in\n        u##appendChild child\n    let appendChildtoRow (parent: r) (child: Dom_html.element Js.t) =\n      let u = Js.Unsafe.coerce parent in\n        u##appendChild child\n    let appendChildtoTable (parent: t) (child: Dom_html.element Js.t) =\n      let u = Js.Unsafe.coerce parent in\n        u##appendChild child\n        \n    let lowLevelApply (table: t) process =\n      let lowTab = Js.Unsafe.coerce (tToTable table) in \n        process lowTab\n      \n    let changeDisplay (table: t) (disp: string) =\n      table##.style##.display := Js.string (disp)\n\n  (*CODE WITH NEW LOGIC*)\n\n  let buildTable contents id parent =\n    let rec fillTable table contents nRow =\n      match contents with\n      | [] -> []\n      | (a::b) ->\n          let rec fillRow cells row nIter =\n          match cells with\n            | [] -> []\n            | (a :: c) ->\n              let _ = if (nIter = 0 || nRow = 0) then (insertCell row \"edgeCell\" a) else (insertCell row \"contentCell\" a) in\n                fillRow c row (nIter+1)\n          in\n          let newRow = insertRow table in\n          let _ = fillRow a newRow 0 in\n            fillTable table b (nRow+1)\n    in\n    let table = create id parent in\n      let _ = fillTable table contents 0 in\n        table##.style##.display := Js.string \"none\"\n\n\n  (*makeCell para FAs*)\n  let makeFACell st sy transitions =\n    let trans1 = Set.filter (fun (st1,sy1,st2) -> st1 = st && sy1 = sy) transitions in\n    let targets = Set.map ( fun (st1,sy1,st2) -> state2str st2) trans1 in\n    String.concat \", \" (Set.toList targets)\n\n  (*makeCell para PDAs*)\n  let makePDACell st sa sy transitions =\n    let trans1 = Set.filter( \n      fun (st1, sa1, sy1, st2, sa2) -> \n        st1 = st && sa1 = sa && sy1 = sy\n        ) \n      transitions \n      in\n    let targets = Set.map (\n      fun (st1, sa1, sy1, st2, sa2) ->\n        (\n          let stack : string list = List.map(fun symb -> symb2str symb) sa2 in\n            match stack with\n            | [] -> state2str st2\n            | a :: b -> state2str st2 ^ \", \" ^ String.concat \"\" stack\n          )\n      ) trans1\n    in\n    String.concat \" | \" (Set.toList targets)\n\n    \n  (*makeStateRow para FAs*)\n  let makeFAStateRow st alphabet transitions : string list =\n    state2str st :: (List.map (fun sy -> makeFACell st sy transitions) alphabet)\n\n  (*makeStateRow para PDAs*)\n  let makePDAStateRow st sa ia transitions : string list =\n    (state2str st ^ \", \" ^ symb2str sa) :: \n    (List.map (fun input -> makePDACell st sa input transitions) ia)\n\n\n  (*TRACE*)\n\n  let rec makeFAPath path step : string list list =\n    match path with \n      | [] -> []\n      | (state, word) :: b ->\n        [\"Step \" ^ (Int.to_string step); (state2str state); (word2str word)] :: makeFAPath b (step+1)\n\n  let rec makePDAPath path step : string list list =\n    match path with \n      | [] -> []\n      | (state, stack, word) :: b ->\n        [\"Step \" ^ (Int.to_string step); (state2str state); (word2str stack); (word2str word)] :: makePDAPath b (step+1)\n\n  let rec makeCFGPath path step : string list list =\n    match path with\n      | [] -> []\n      | (symbs, word) :: b ->\n        [\"Step \" ^ (Int.to_string step); (word2str symbs); (word2str word)] :: makeCFGPath b (step+1)\n\n  let rec makeGRPath path step : string list list =\n    match path with\n      | [] -> []\n      | (symbs, word) :: b ->\n        [\"Step \" ^ (Int.to_string step); (word2str symbs); (word2str word)] :: makeGRPath b (step+1)\n\n  let rec makeREPath path step : string list list =\n    match path with\n      | [] -> []\n      | (t, word) :: b ->\n        [\"Step \" ^ (Int.to_string step); RegularExpression.toString t; (word2str word)] :: makeREPath b (step+1)\n\n  let rec makeTMPath (path: OCamlFlat.TuringMachine.path) step : string list list =\n    match path with\n      | [] -> []\n      | (state, tapes) :: b ->\n        let (left, right) = List.hd tapes in\n        let currChar = List.hd right in\n        let tmSpan = \"<span id='currChar'>\" ^ (symb2str currChar) ^ \"</span>\" in\n        [\"Step \" ^ (Int.to_string step); state2str state; word2str (List.rev left) ^ tmSpan ^ word2str (List.tl right)] :: makeTMPath b (step+1)\n\n  (*PAINTING METHODS*)\n\n  let paint (tab: t) (rowIndex: int) (cellIndex: int) (color: string) =\n    let row = fetchRow tab rowIndex in\n    match Js.Opt.to_option row with\n    | None -> ()\n    | Some r -> \n      let cell = fetchCell r cellIndex in\n      match Js.Opt.to_option cell with\n      | None -> ()\n      | Some c -> c##.style##.backgroundColor := Js.string color\n\n\n      \n\n\n\n      \nend\n\n\n\n","(*\n * View.ml\n *\n * This file is part of the OFLAT app\n *\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\n *\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\n *\n * This software is distributed under the terms of the GPLv3 license.\n * See the included LICENSE file for details.\n *\n *  Written by Rita Macedo\n *)\n\nopen Js_of_ocaml\nopen JS\nopen Lang\n\nmodule ViewUtil\n=\nstruct\n\n  (** Function to paint the states of the automaton in the cy div **)\n(*  let paintNode node color = *)\n(*      JS.exec (\"paintNode('\" ^ node ^ \"', '\"^ color ^\"')\")*)\n\n  (** Function to paint the states of the automaton in the cy2 div **)\n(*  let paintNode1 node color = *)\n(*      JS.exec (\"paintNode1('\" ^ node ^ \"', '\"^ color ^\"')\")*)\n\n  (** Function to create edge on the div cy **)\n\n(* PEDRO CARLOS VER! duas funcoes novas para...?   veio de ControllerListeners.ml *)\n  let extractStringFromTextArea () =\n      try\n          match Dom_html.getElementById_coerce \"modelStringContainer\" Dom_html.CoerceTo.textarea with\n          | None -> \"\"\n          | Some textarea -> Js.to_string textarea##.value\n      with\n      | _ -> JS.alert (Lang.i18nErrorParsing()); \"\"\n\n  let rec replace_str toReplace replacement str =\n    match str with\n    | \"\" -> \"\"  (* Base case: empty string *)\n    | _ ->\n      let first = String.get str 0 in\n      let rest = String.sub str 1 (String.length str - 1) in\n      if first = toReplace then\n        replacement ^ replace_str toReplace replacement rest\n      else\n        String.make 1 first ^ replace_str toReplace replacement rest\n  \n  let createEdge (f, s, t) = \n      JS.exec (\"makeEdge('\" ^ f ^ \"', '\" ^ t ^ \"', '\" ^ (String.make 1 s) ^ \"')\")\n\n  (** Function to eliminate edge on the div cy **)\n  let eliminateEdge (f, s, t) = \n      JS.exec (\"removeEdge('\" ^ f ^ \"', '\" ^ t ^ \"', '\" ^ (String.make 1 s) ^ \"')\")\n\n  (** Function to create edge on the div cy2 **)\n  let createEdge1 (f, s, t) = \n      JS.exec (\"makeEdge2('\" ^ f ^ \"', '\" ^ t ^ \"', '\" ^ (String.make 1 s) ^ \"')\")\n\n  (** Function to create state on the div cy **)\n  let createNode node isStart isFinal =\n      JS.exec (\"makeNode('\" ^ node ^ \"', '\" ^ string_of_bool (isStart) ^ \"', '\" ^ string_of_bool (isFinal) ^ \"')\")\n\n  (** Function to eliminate state on the div cy **)\n  let eliminateNode node =\n      JS.exec (\"removeNode('\" ^ node ^ \"')\")\n\n  (** Function to create state on the div cy2 **)\n  let createNode1 node isStart isFinal =\n      JS.exec (\"makeNode2('\" ^ node ^ \"', '\" ^ string_of_bool (isStart) ^ \"', '\" ^ string_of_bool (isFinal) ^ \"')\")\n  \n  (** Function to start a new automaton in the div cy **)\n  let startGraph () =   \n      JS.exec (\"start()\")\n  \n  (** Function to start a new automaton in the div cy2 **)\n  let startGraph1 () =   \n      JS.exec (\"start2()\")\n\n  (** Function to start a new Tree in the div cy **)\n  let startGraph2 (s : Js.js_string Js.t) : unit =   \n    Js.Unsafe.fun_call (Js.Unsafe.js_expr \"startTree\") [|Js.Unsafe.inject s|]\n\n  (** Function to start a new Tree in the div cy2 **)\n  let startGraph3 (nString) =   \n      JS.exec (\"startTree1('\" ^ nString ^ \"')\")\n\n  (** Function to eliminate the automaton/tree in the div cy **)\n  let destroyGraph () =   \n      JS.exec (\"destroy1()\")\n\n  (** Function to eliminate the automaton/tree in the div cy2 **)\n  let destroyGraph1 () =   \n      JS.exec (\"destroy2()\")\n\n  (** Clear all the color changes made to the automaton **)\n  let resetStyle () = \n      JS.exec (\"resetStyle()\")\n\n  (** Adjust the automaton to the size of the div cy **)\n  let fit () =   \n    JS.exec (\"fit()\")\n\n  (** Generate a random color - used when the automaton is minimized and has the need of more colors than the pre-defined ones **)\n  let getRandom() = \n      let test = Random.int 16777215 in\n      Printf.sprintf \"#%06x\" test\n  \n  (** Used when the user wants to change the direction of the regular Expression tree **)\n  let changeDirection () =\n    JS.exec (\"changeDirection()\")\n  \n  let turnFinal name =\n    JS.exec (\"turnFinal('\" ^ name ^ \"')\")\n\n  let removeFinal name =\n    JS.exec (\"removeFinal('\" ^ name ^ \"')\")\n\n  let changeLang name =\n    JS.exec (\"changeLanguage('\" ^ name ^ \"')\")\n\n    let bcSend name =\n      let name2 = String.escaped name in \n      (* JS.exec (\"alert('ola\\\\nole')\")*)\n      (*JS.exec (\"alert(`\" ^ name2 ^ \"`)\");*)\n      JS.exec (\"bcSend(`\" ^ name2 ^ \"`)\")\n\nend\n\n","(*\n * Listeners.ml\n *\n * This file is part of the OFLAT app\n *\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\n *\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\n *\n * This software is distributed under the terms of the GPLv3 license.\n * See the included LICENSE file for details.\n *\n *  Written by Rita Macedo\n *)\n\n(* \n * Description: Part of the controller that is acessible from the\n * Visualizer (HtmlPageClient). Using this module, we avoid the need to use\n * mutually recursive modules.\n *)\nopen OCamlFlat.BasicTypes\n\nmodule Listeners = \nstruct\n\tlet save = ref (fun () -> ()) (*carolina*)\n  let saveModel = ref (fun () -> ())\n\tlet closeLeftListener = ref (fun () -> ())\n\tlet closeRightListener = ref (fun () -> ())\n\tlet openEntityListener = ref (fun (txt : string) -> ())\n\tlet defineInformationBoxListener = ref (fun () -> ())\n\tlet showModelListener = ref (fun () -> ())\n\tlet createModelListener = ref (fun () -> ())\n\tlet updateRightListener = ref (fun () -> ())\n\tlet editModelListener = ref (fun () -> ())\n\tlet runOp = ref (fun (op : string) -> ())\nend\n\n\nmodule ListenersAutomaton = \nstruct\n\tinclude Listeners\n\tlet removeNode = ref (fun (node : state) -> ())\n\tlet turnFinal = ref (fun (node : state) -> ())\n\tlet addNode = ref (fun (x : int) (y : int) -> ())\n\tlet removeTypeFinal = ref (fun (node : state) -> ())\n\tlet turnNodeInitial = ref (fun (node : state) -> ())\n\tlet addInitialNode = ref (fun (x : int) (y : int) -> ())\n\tlet addFinalNode = ref (fun (x : int) (y : int) -> ())\n\tlet addTransition = ref (fun (src : state) (trg : state) -> ())\n\tlet removeTransition = ref (fun (srcId : state) (trgId : state) (symb : state) -> ())\n\tlet renameNodeListener = ref (fun (state : state) -> ())\n\tlet paintAllProductivesListener = ref (fun () -> ())\n\tlet paintAllReachableListener = ref (fun () -> ())\n\tlet paintAllUsefulListener = ref (fun () -> ())\n\tlet clearAutoListener = ref (fun () -> ())\n\tlet showTable = ref (fun () -> ())\n\tlet editModelListener = ref (fun () -> ())\nend\n\nmodule ListenersFA = \nstruct\n\tinclude ListenersAutomaton\n\tlet createModelListener = ref (fun () -> ())\n\tlet changeDirectionListener = ref (fun () -> ())\n\tlet defineInformationBoxListener = ref (fun () -> ())\n\tlet getDeterministicListener = ref (fun () -> ())\n\tlet defineMinimizedListener = ref (fun () -> ())\n\tlet cleanUselessListener = ref (fun () -> ())\n\nend\n\nmodule ListenersTM = \n    struct\n      include ListenersAutomaton\n      let createModelListener = ref (fun () -> ())\n      (*let changeDirectionListener = ref (fun () -> ())*)\n      let paintAllProductivesListener = ref (fun () -> ())\n      let paintAllReachableListener = ref (fun () -> ())\n      let paintAllUsefulListener = ref (fun () -> ())\n      let cleanUselessListener = ref (fun () -> ())\n      let getDeterministicListener = ref (fun () -> ())\n      let clearAutoListener = ref (fun () -> ())\n    end\n\nmodule ListenersPDA = \nstruct\n\tinclude ListenersAutomaton\n\tlet createModelListener = ref (fun () -> ())\n\tlet cleanUselessListener = ref (fun () -> ())\n\tlet toggleAcceptanceCriteria = ref (fun () -> ())\n\tlet changeInitialStackSymbol = ref (fun () -> ())\n\tlet convertAcceptStates = ref (fun () -> ())\n\tlet convertEmptyStackAccept = ref (fun () -> ())\nend\n\nmodule ListenersRE =\nstruct\n\tinclude Listeners\n\tlet createModelListener = ref (fun () -> ())\n\tlet resultCountListener = ref (fun () -> ())\n\tlet previousTreeListener = ref (fun () -> ())\n\tlet nextTreeListener = ref (fun () -> ())\n\tlet defineNumberTreesListener = ref (fun () -> ())\n\tlet changeDirectionListener = ref (fun () -> ())\n\tlet editModelListener = ref (fun () -> ())\n\t\nend\n\nmodule ListenersCFG =\nstruct\n\tinclude Listeners\n\tlet createModelListener = ref (fun () -> ())\n\tlet cleanCFGListener = ref (fun () -> ())\n\tlet removeLeftRecursionListener = ref (fun () -> ())\n\tlet leftFactoringListener = ref (fun () -> ())\n\tlet tablesListener = ref (fun () -> ())\n\tlet parsingTableListener = ref (fun () -> ())\n\tlet generateCFGListener = ref (fun () -> ())\n\tlet recursiveDescedentParserListener = ref (fun () -> ())\n\tlet simpleToggleListener = ref (fun () -> ())\n\tlet removeEpsilonListener = ref (fun () -> ())\n\tlet removeUnitListener = ref (fun () -> ())\n\tlet previousNewCFGListener = ref (fun () -> ())\n\tlet nextNewCFGListener = ref (fun () -> ())\n\tlet transformLL1Listener = ref (fun () -> ())\n\tlet editModelListener = ref (fun () -> ())\nend \n\n\nmodule ListenersGR =\nstruct\n    include Listeners\n\t\tlet createModelListener = ref (fun () -> ())\n    let tablesListener = ref (fun () -> ())\n    let parsingTableListener = ref (fun () -> ())\n    let generateGRListener = ref (fun () -> ())\n    let editModelListener = ref (fun () -> ())\n    let grOps = ref (fun (_: string) -> ())\nend\n\nlet undefinedListener () = JS.JS.alertStr \"undefined listener\"\n\nmodule ListenersLR =\nstruct\n\tlet\tbuildLR0DiagramListener = ref undefinedListener\n\tlet\tbuildSLR1DiagramListener = ref (fun () -> ())\n\tlet\tbuildLR1DiagramListener = ref (fun () -> ()) \n\tlet\tbuildLALR1DiagramListener = ref (fun () -> ()) \n\tlet\tbuildLR0TableListener = ref (fun () -> ()) \n\tlet\tbuildSLR1TableListener = ref (fun () -> ())    \n\tlet\tbuildLR1TableListener = ref (fun () -> ())   \n\tlet\tbuildLALR1TableListener = ref (fun () -> ())\n\tlet acceptLR0Listener = ref (fun () -> ())\n\tlet\tacceptSLR1Listener = ref (fun () -> ())\n\tlet\tacceptLR1Listener = ref (fun () -> ())\n\tlet\tacceptLALR1Listener = ref (fun () -> ())\nend \n\nmodule ListenersComp =  (*carolina*)\nstruct\n\tinclude Listeners\n\tlet createModelListener = ref (fun () -> ())\n\tlet editModelListener = ref (fun () -> ())\n\tlet showTreeNode = ref (fun (model : string) -> ())\n\t\nend\n\nmodule ListenersEXER = \nstruct\n\tinclude Listeners\n\tlet checkExerciseListener = ref (fun () -> ())\n\tlet clearExerciseListener = ref (fun () -> ())\nend\n","open Js_of_ocaml\nopen Js\nopen JS\nopen Lang\nopen Listeners\nopen Random\nopen OCamlFlat.BasicTypes\n\nclass type position =\n  object\n    method x : int readonly_prop\n    method y : int readonly_prop\n  end\n\nclass type ['a] style =\n  object\n    method selector : js_string t prop\n    method style : 'a prop\n    method resetToDefault : unit meth\n    method update : unit meth\n  end\n\nclass type popper =\n  object\n    method destroy : unit -> unit meth\n    method update : unit -> unit meth\n  end\n\nclass type contextMenus =\n  object\n    method destroy : unit -> unit meth\n    method showMenuItem: js_string t -> unit meth\n    method hideMenuItem: js_string t -> unit meth\n  end\n\nmodule DataItem =\nstruct\n\n  class type data =\n    object\n      method id : js_string t prop\n      method parent : js_string t prop (* PEDROCARLOS VER! para que serve    deve ser invisivel para o cytoscape *)\n      method source : js_string t prop\n      method target : js_string t prop\n      method label : js_string t prop\n      method nodeType : js_string t prop\n    end\n\n  class type t =\n    object\n      method data : data Js.t prop\n      method data_fromName: js_string Js.t -> js_string Js.t meth (*ele.data(name) Get a particular data field for the element.*)\n      method data_update: js_string Js.t -> js_string Js.t -> unit meth (*ele.data(name,value)Set a particular data field for the element.*)\n      method group : js_string Js.t prop\n      method position : position Js.t prop\n      method renderedPosition : position Js.t prop\n      method classes : js_string Js.t prop\n      method length : number Js.t prop\n      method remove : unit -> 'res Js_of_ocaml.Js.meth \n      method addClass : js_string Js.t -> unit meth\n      method removeClass : js_string Js.t -> unit meth\n      method lock : unit Js_of_ocaml.Js.meth\n      method unlock : unit Js_of_ocaml.Js.meth \n      method incomers : js_string Js.t -> t js_array Js.t meth\n      method outgoers : js_string Js.t -> t js_array Js.t meth\n      method popper : 'z -> popper Js.t meth\n    end\nend\n\nclass type layout_options =\n  object\n    method name : js_string t readonly_prop\n    method rankDir : js_string t readonly_prop\n  end\n\nclass type layout =\n  object\n    method run : unit meth\n  end\n\nclass type props =\n  object\n    method container : Dom_html.element t prop\n    method elements : DataItem.t t js_array t prop\n    method style : Unsafe.any style t js_array t prop\n    method layout : layout_options t prop\n    method zoom : int prop\n    method pan : position t prop\n    method minZoom : float prop\n    method maxZoom : float prop\n    method zoomingEnabled : bool t prop\n    method userZoomingEnabled : bool t prop\n    method panningEnabled : bool t prop\n    method userPanningEnabled :bool t prop\n    method boxSelectionEnabled : bool t prop\n    method selectionType : js_string t prop\n    method touchTapThreshold : int prop\n    method desktopTapThreshold : int prop\n    method autolock : bool t prop\n    method autoungrabify : bool t prop\n    method autounselectify : bool t prop\n    method headless : bool t prop\n    method styleEnabled : bool t prop\n    method hideEdgesOnViewport : bool t prop\n    method textureOnViewport : bool t prop\n    method motionBlur : bool t prop\n    method motionBlurOpacity : float prop\n    method wheelSensitivity : float prop\n    method pixelRatio : js_string t prop\n  end\n\nclass type cytoscape =\n  object\n    method add : DataItem.t t -> unit meth\n    method remove : DataItem.t t -> unit meth\n    method remove_fromSelector : js_string t -> unit meth\n    method mount : Dom_html.element t -> unit meth\n    method layout : layout_options t -> layout t meth\n    method resize : unit meth\n    method on_3 : js_string t -> (Dom_html.event Js.t -> unit) -> unit meth\n    method on_4 : js_string t -> js_string t opt -> ((< > t) Js.t -> (DataItem.t) Js.t -> (DataItem.t) Js.t -> (DataItem.t) Js.t -> unit) -> unit meth\n    method on : js_string t -> js_string t -> (Dom_html.event Js.t -> unit) -> unit meth\n    method edgehandles: 'a Js.t -> 'res meth\n    method getElementById: js_string t -> DataItem.t t meth\n    method cxtmenu : 'b t  -> unit meth\n    method style : Unsafe.any style Js.t Js.meth\n    method style_n : Unsafe.any style t js_array t -> unit meth\n    method destroy: unit -> unit meth\n    method autolock: bool -> unit Js.meth\n    method fit : unit meth\n    method edges : js_string t -> DataItem.t Js.t js_array Js.t meth\n    method nodes : js_string t -> DataItem.t Js.t js_array Js.t meth\n    method tapdragover: DataItem.t t -> unit meth\n    method contextMenus : 'c t  -> contextMenus Js.t meth\n    method popper : 'z -> popper Js.t meth\n  end\n\ntype cytoscape_cs = (props Js.t -> cytoscape Js.t) constr\n\nlet cytoscape_cs : cytoscape_cs = Js.Unsafe.pure_js_expr \"cytoscape\"\n\nlet default_style : Unsafe.any style t js_array t =\n  let node_style = Unsafe.coerce @@ object%js\n      val selector = string \"node\"\n      val style = def (object%js\n          val label = string \"data(id)\"\n        end)\n    end in\n  array [| node_style |]\n\nlet default_layout : layout_options t =\n  object%js val name = string \"preset\" \n    val rankDir = Js.string \"LR\"\nend\n\nlet position x y : position t =\n  object%js val x = x val y = y end\n\nlet node id pos nodeType classes label : DataItem.t t =\n  let data : DataItem.data t = Unsafe.obj [||] in\n  let node : DataItem.t t = Unsafe.obj [||] in\n  data##.id := string id;\n  (match pos with None -> () | Some (x, y) -> node##.position := position x y);\n  data##.nodeType := string nodeType;\n  node##.classes := string classes;\n  data##.label := string label;\n  node##.data := data;\n  node##.group := Js.string \"nodes\";\n  node\n\n\nlet edge id source target label : DataItem.t t =\n  let data : DataItem.data t = Unsafe.obj [||] in\n  (match id with None -> () | Some id -> data##.id := Js.string id);\n  data##.source := string source;\n  data##.target := string target;\n  data##.label := string label;\n  let edge : DataItem.t t = Unsafe.obj [||] in\n  edge##.data := data;\n  edge##.group := string \"edges\";\n  edge\n\nlet mk_graph ?(style=default_style) ?(layout=default_layout) ?(props=[]) container_id =\n  let container = Dom_html.getElementById container_id in\n  let props = array @@ Array.of_list props in\n  let g : props t = Unsafe.obj [||] in\n  g##.container := container;\n  g##.elements := props;\n  g##.style := style;\n  g##.layout := layout;\n  g\n\nlet display props = new%js cytoscape_cs props\n\nlet add_node cy id ?pos nodeType classes label =\n(*  Firebug.console##log (\"Adding node with id: \" ^ id);*)\n  cy##add (node id pos nodeType classes label)\n\n(*PEDROCARLOS VER!  nos compostos das arvores para gramaticas irreestritas *)\nlet addCompoundNode cy id ?pos label =\n  let data : DataItem.data t = Unsafe.obj [||] in\n  data##.id := string id;\n  (match label with None -> () | Some label -> data##.label := string label);\n  let node : DataItem.t t = Unsafe.obj [||] in\n  node##.data := data;\n  node##.group := string \"nodes\";\n  (match pos with None -> () | Some pos -> node##.position := pos);\n  cy##add node\n\nlet addChildNode cy parentId childId ?pos childLabel=\n  let data : DataItem.data t = Unsafe.obj [||] in\n  data##.id := string childId;\n  data##.parent := string parentId; \n  (match childLabel with None -> () | Some label -> data##.label := string label);\n  let node : DataItem.t t = Unsafe.obj [||] in\n  node##.data := data;\n  node##.group := string \"nodes\";\n  (match pos with None -> () | Some pos -> node##.position := pos);\n  cy##add node\n\nlet add_edge cy ?id source target label =\n(*  Firebug.console##log (\"Adding edge with id: '\" ^ (match id with |None -> \"\" | Some a -> a) ^ \"' from: '\" ^ source ^ \"' to: '\" ^ target ^ \"' with symbol: '\" ^ label ^ \"'.\");*)\n  cy##add (edge id source target label)\n\nlet random_layout g : layout t =\n  let layout_opt = object%js\n    val name = string \"random\"\n  end in\n  g##layout layout_opt\n\nlet run_layout (l : layout t) =\n  l##run\n\nlet on cy event selector cb =\n  match selector with\n    | \"\" -> cy##on_4 (string event) Js.null cb\n    | _ -> cy##on_4 (string event) (Js.some (string selector)) cb\n\nlet elementId (cy: cytoscape Js_of_ocaml.Js.t) (node : string) =\n  cy##getElementById (Js.string node)\n\nlet getIncomers cy nodeId selector =\n  let node = elementId cy nodeId in\n  let elements = node##(incomers (Js.string selector)) in\n    Array.to_list (Js.to_array elements)\n    \nlet getOutgoers cy nodeId selector =\n  let node = elementId cy nodeId in\n  let elements = node##(outgoers (Js.string selector)) in\n    Array.to_list (Js.to_array elements)\n    \nlet getEdges cy selector =\n  Array.to_list (Js.to_array (cy##edges (Js.string selector)))\n\nlet getAllNodes (cy: cytoscape Js_of_ocaml.Js.t): DataItem.t Js_of_ocaml.Js.t list =\n  Array.to_list (Js.to_array (cy##nodes (Js.string \"*\")))\n\nlet data_fromName element name =\n  Js.to_string (element##data_fromName (Js.string name))\n  \nlet data_update element name value =\n  element##data_update (Js.string name) (Js.string value)\n\nlet faLayout : layout_options Js.t = (**Layout for finite automata**)\n  object%js val name = Js.string \"grid\"\n            val rankDir = Js.string \"LR\"\n          end\n\nlet reLayout : layout_options Js.t = (**Layout for regular expression trees**)\n  object%js val name = Js.string \"dagre\"\n            val rankDir = Js.string \"TB\"\n          end\n\nlet cfglayout : layout_options Js.t = (**Layout for context free grammars**)\n  object%js val name = Js.string \"dagre\" \n            val rankDir = Js.string \"\"\n          end\n\nlet grlayout : layout_options Js.t = (**Layout for grammars**)\nobject%js val name = Js.string \"dagre\" \n          val rankDir = Js.string \"\"\n        end\n\n(* let treeGrlayout : layout_options Js.t = (**Layout for grammars**)\nobject%js val name = Js.string \"dagre\" \n          val rankDir = Js.string \"\"\n        end *)\nlet treeGrlayout : layout_options Js.t = (**Layout for grammars**)\nobject%js val name = Js.string \"dagre\" \n          val rankDir = Js.string \"\"\nend\n\nlet edgehandlesOptions =\n  object%js\n    val canConnect = fun (sourceNode : DataItem.t) (targetNode : DataItem.t) -> Js.bool true\n    val edgeParams = fun (sourceNode : DataItem.t) (targetNode : DataItem.t) -> object%js end\n    val hoverDelay = 150\n    val snap = Js.bool true\n    val snapThreshold = 50\n    val snapFrequency = 15\n    val noEdgeEventsInDraw = Js.bool true\n    val disableBrowserGestures = Js.bool true\n  end\n\nlet menu cy eh= \n  Js.Unsafe.coerce @@ object%js\n(*    val menuRadius = fun element -> (70)*)\n    val selector = Js.string \"node\"\n    val commands = \n      let menu1 = Js.def (object%js\n        val content = Js.string (Lang.i18nTextRemove())\n        val select = fun element -> \n          !ListenersAutomaton.removeNode (data_fromName element \"id\");\n          !Listeners.updateRightListener ()\n      end) in\n      let menu2 = Js.def (object%js\n        val content = Js.string (Lang.i18nTextTurnFinal())\n        val select = fun element -> \n          !ListenersAutomaton.turnFinal (data_fromName element \"id\");\n          !Listeners.updateRightListener ()\n      end) in\n      let menu3 = Js.def (object%js\n        val content = Js.string (Lang.i18nTextRemoveFinal())\n        val select = fun element -> \n          !ListenersAutomaton.removeTypeFinal (data_fromName element \"id\");\n          !Listeners.updateRightListener ()\n      end) in \n      let menu4 = Js.def (object%js\n        val content = Js.string (Lang.i18nTextTurnInitial())\n        val select = fun element -> \n          !ListenersAutomaton.turnNodeInitial (data_fromName element \"id\");\n          !Listeners.updateRightListener ()\n      end) in\n      let menu5 = Js.def (object%js\n        val content = Js.string (Lang.i18nTextRenameState())\n        val select = fun element -> \n          !ListenersAutomaton.renameNodeListener (data_fromName element \"id\");\n          !Listeners.updateRightListener ()\n      end) in\n      let menu6 = Js.def (object%js\n        val content = Js.string (Lang.i18nTextAddTransition())\n        val select = fun element -> \n          eh##start element\n      end) in\n      Js.array [|menu1; menu2; menu3; menu4; menu5; menu6|]\n  end \n\nlet menu2 = \n  Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \"core\"\n    val commands = \n      let menu1 = Js.def (object%js\n        val content = Js.string (Lang.i18nTextAdd ())\n        val select = fun element evt -> \n          !ListenersAutomaton.addNode evt##.position##.x evt##.position##.y;\n          !Listeners.updateRightListener ()\n      end) in\n      let menu2 = Js.def (object%js\n        val content = Js.string (Lang.i18nTextAddInitial ())\n        val select = fun element evt -> \n          !ListenersAutomaton.addInitialNode evt##.position##.x evt##.position##.y;\n          !Listeners.updateRightListener ()\n      end) in \n      let menu3 = Js.def (object%js\n        val content = Js.string (Lang.i18nTextAddFinal ())\n        val select = fun element evt -> \n          !ListenersAutomaton.addFinalNode evt##.position##.x evt##.position##.y;\n          !Listeners.updateRightListener ()\n      end) in \n      Js.array [|menu1; menu2; menu3|]\n  end\n\n  let menu3 = \n    Js.Unsafe.coerce @@ object%js\n      val selector = Js.string \"edge\"\n      val commands = \n        let menu1 = Js.def (object%js\n          val content = Js.string (Lang.i18nTextRemove ())\n          val select = fun element -> \n            (let source = element##source in \n              let srcId = data_fromName source \"id\" in\n              let target = element##target in \n              let trgId = data_fromName target \"id\" in\n              let symb = data_fromName element \"label\" in\n                !ListenersAutomaton.removeTransition srcId trgId symb;\n                !Listeners.updateRightListener ())\n        end) in\n        Js.array [|menu1|]\n    end\n\nlet paintNodeStyle node color: Js.Unsafe.any style Js.t Js.js_array Js.t =\n  let node_name_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string (\"#\" ^ node)\n      val style = Js.def (object%js\n        val backgroundColor = Js.string color\n      end)\n  end in\n  Js.array [|node_name_style|]\n\nlet encodeURI svg =\n    Js_of_ocaml.Js.encodeURI (Js.string svg)\n\nlet insertLoopStyle cy nId =\n    ignore(\n        (Js.Unsafe.coerce cy)##\n        style##\n        (selector (Js.string (\"#\" ^ nId)) )##\n        style(Js.Unsafe.coerce @@ object%js\n            val curveStyle = Js.string \"bezier\"\n            val controlPointStepSize = Js.string \"120px\" (* metade da largura, no minimo 60 *)\n            val targetArrowShape = Js.string \"triangle\"\n\n            val loopDirection = Js.string \"-90deg\"\n            val loopSweep = Js.string \"-90deg\"\n\n            val sourceEndpoint = Js.string \"-90deg\"\n            val targetEndpoint = Js.string \"-90deg\"\n        end)\n  )##update\n\n\nlet insertNodeImage cy node itemString itemListSize maxSymbolCount =\n  ignore(\n    (Js.Unsafe.coerce cy)##\n    style##\n    (selector (Js.string (\"#\" ^ node)) )##\n    style(Js.Unsafe.coerce @@ object%js\n      val opacity = Js.string \"0.50\"\n      val backgroundColor = Js.string \"white\"\n      val backgroundImage = itemString\n      val backgroundClip = Js.string \"none\"\n      val borderWidth = Js.string \"3px\"\n      val borderColor = Js.string \"black\"\n      val width = Js.string (string_of_int ((maxSymbolCount*9) -20) ^\"px\")\n      val height = Js.string (string_of_int ((itemListSize*20) + 10) ^\"px\")\n      val shape = Js.string \"roundrectangle\"\n    end)\n  )##update\n\nlet rec tspan stringItems increment =\n        match stringItems with\n        | [] -> \"\"\n        | x::xs -> Printf.sprintf {|<tspan x=\"20\" y=\"%s\"> %s </tspan>|} (string_of_int (increment)) x ^ tspan xs (increment + 20)\n\nlet rec maxLR0SymbolCount itemList max =\n            match itemList with\n            | [] -> max\n            | x::xs -> if(String.length x > max) then maxLR0SymbolCount xs (String.length x)\n                       else maxLR0SymbolCount xs max\n\n\nlet buildStyleImage stringItems=\n\n    let prefix = \"data:image/svg+xml;utf8,\" in\n\n    let itemListSize = List.length stringItems in\n\n    let maxSymbolCount = maxLR0SymbolCount stringItems 0 in\n\n    let svg = Printf.sprintf {| <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"%s\" width=\"%s\"> |} (string_of_int ((itemListSize*20) + 30)) (string_of_int ((maxSymbolCount*9) + 10)) in\n    let text = {| <text x=\"0\" y=\"0\" style=\"fill:black;\"> |} in\n\n\n    let textSpan = tspan stringItems 30 in\n\n\n    let finish =    {|</text>\n                </svg> |} in\n\n    let style = prefix ^ svg ^ text ^ textSpan ^ finish in\n        style\n\n\n    (*\n    let suffix = \n    \"<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"100\" width=\"100\">\n        <text x=\"10\" y=\"20\" style=\"fill:red;\">Several lines:\n                <tspan x=\"10\" y=\"45\">First line.</tspan>\n                <tspan x=\"10\" y=\"70\">Second line.</tspan>\n        </text>\n    </svg>\" in\n    *)\n\nlet buildLR0NodeStyle cy node stringItemList =\n    let styleImage = buildStyleImage stringItemList in\n    let encodeStyle = encodeURI styleImage in\n    let itemListSize = List.length stringItemList in\n    let maxSymbolCount = maxLR0SymbolCount stringItemList 0 in\n        insertNodeImage cy node encodeStyle itemListSize maxSymbolCount\n\n\nlet faStyle : Js.Unsafe.any style Js.t Js.js_array Js.t = (**Left FA style**)\n  let node_name_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \"node[label]\"\n      val style = Js.def (object%js\n        val content = Js.string \"data(label)\"\n        val textHalign = Js.string \"center\"\n        val textValign = Js.string \"bottom\"\n        val width = Js.string \"40px\"\n        val height = Js.string \"40px\"\n        val textMarginY = Js.string \"2\"\n      end)\n  end in\n  let edge_symbol_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \"edge[label]\"\n      val style = Js.def (object%js\n        val content = Js.string \"data(label)\"\n      end)\n    end in\n  let edge_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \"edge\"\n    val style = Js.def (object%js\n      val curveStyle = Js.string \"bezier\"\n      val targetArrowShape = Js.string \"triangle\"\n    end)\n  end in\n  (*\n  let loop_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \"loop\"\n        val style = Js.def (object%js\n        val curveStyle = Js.string \"bezier\"\n        val targetArrowShape = Js.string \"triangle\"\n        val loopDirection = Js.string \"-45deg\"\n        val loopSweep = Js.string \"-90deg\"\n        val sourceEndpoint = Js.string \"outside-to-node-or-label\"\n        val targetEndpoint = Js.string \"outside-to-node-or-label\"\n        val controlPointStepSize = Js.string \"1\"\n    end)\n  end in\n  *)\n  let node_transparent_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \"#transparent\"\n    val style = Js.def (object%js\n      val visibility = Js.string \"hidden\"\n    end)\n  end in\n  let node_style_success = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \".SUCCESS\"\n    val style = Js.def (object%js\n      val borderWidth = Js.string \"7px\"\n      val borderColor = Js.string \"black\"\n      val borderStyle = Js.string \"double\"\n      val textMarginY = Js.string \"5\"\n    end)\n  end in\n  let eh_handle_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \".eh-handle\"\n      val style = Js.def (object%js\n        val backgroundColor = Js.string \"red\"\n        val width = Js.string \"12\"\n        val height = Js.string \"12\"\n        val shape = Js.string \"ellipse\"\n        val overlayOpacity = Js.string \"0\"\n        val borderWidth = Js.string \"12\"\n        val borderOpacity = Js.string \"0\"\n      end)\n  end in\n  let eh_hover_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \".eh-hover\"\n      val style = Js.def (object%js\n        val backgroundColor = Js.string \"red\"\n      end)\n  end in\n  let eh_source_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \".eh-source\"\n      val style = Js.def (object%js\n        val borderWidth = Js.string \"2\"\n        val borderColor = Js.string \"red\"\n      end)\n  end in\n  let eh_target_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \".eh-target\"\n      val style = Js.def (object%js\n        val borderWidth = Js.string \"2\"\n        val borderColor = Js.string \"red\"\n      end)\n  end in\n  let eh_preview_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \".eh-preview\"\n      val style = Js.def (object%js\n        val backgroundColor = Js.string \"red\"\n        val lineColor = Js.string \"red\"\n        val targetArrowColor = Js.string \"red\"\n        val sourceArrowColor = Js.string \"red\"\n      end)\n  end in\n  let eh_ghost_edge_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \".eh-ghost-edge\"\n      val style = Js.def (object%js\n        val backgroundColor = Js.string \"red\"\n        val lineColor = Js.string \"red\"\n        val targetArrowColor = Js.string \"red\"\n        val sourceArrowColor = Js.string \"red\"\n      end)\n  end in\n  let eh_ghost_edge_preview_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \".eh-ghost-edge.eh-preview-active\"\n      val style = Js.def (object%js\n        val opacity = Js.string \"0\"\n      end)\n  end in\n  Js.array [| node_name_style; edge_symbol_style; edge_style;\n              node_transparent_style; node_style_success;\n              eh_handle_style; eh_hover_style; eh_source_style;\n              eh_target_style; eh_preview_style; eh_ghost_edge_style;\n              eh_ghost_edge_preview_style |]\n\nlet faStyle2 : Js.Unsafe.any style Js.t Js.js_array Js.t = (**Right FA style**)\n  let node_name_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \"node[label]\"\n    val style = Js.def (object%js\n      val content = Js.string \"data(label)\"\n      val textHalign = Js.string \"center\"\n      val textValign = Js.string \"bottom\"\n      val width = Js.string \"40px\"\n      val height = Js.string \"40px\"\n    end)\n  end in\n  let edge_symbol_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \"edge[label]\"\n    val style = Js.def (object%js\n      val content = Js.string \"data(label)\"\n    end)\n  end in\n  let edge_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \"edge\"\n    val style = Js.def (object%js\n      val curveStyle = Js.string \"bezier\"\n      val targetArrowShape = Js.string \"triangle\"\n    end)\n  end in\n  let node_transparent_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \"#transparent1\"\n    val style = Js.def (object%js\n      val visibility = Js.string \"hidden\"\n    end)\n  end in\n  let node_style_success = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \".SUCCESS\"\n    val style = Js.def (object%js\n      val borderWidth = Js.string \"7px\"\n      val borderColor = Js.string \"black\"\n      val borderStyle = Js.string \"double\"\n    end)\n  end in\n  Js.array [| node_name_style; edge_symbol_style; edge_style;\n              node_transparent_style; node_style_success |]\n\n\nlet reStyle : Js.Unsafe.any style Js.t Js.js_array Js.t = (**RE style**)\n  let node_name_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \"node[label]\"\n    val style = Js.def (object%js\n      val content = Js.string \"data(label)\"\n      val textHalign = Js.string \"center\"\n      val textValign = Js.string \"center\"\n      val width = Js.string \"40px\"\n      val height = Js.string \"40px\"\n    end)\n  end in\n  let node_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \"node\"\n    val style = Js.def (object%js\n      val backgroundColor = Js.string \"white\"\n    end)\n  end in\n  let edge_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \"edge\"\n    val style = Js.def (object%js\n      val curveStyle = Js.string \"bezier\"\n      val targetArrowShape = Js.string \"triangle\"\n      val width = Js.string \"4\"\n      val lineColor = Js.string \"#9dbaea\"\n      val targetArrowColor = Js.string \"#9dbaea\"\n    end)\n  end in\n  let node_fail_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \"node[label = \\'Fail\\']\"\n    val style = Js.def (object%js\n      val color = Js.string \"red\"\n    end)\n  end in\n  Js.array [| node_name_style; node_style; edge_style; node_fail_style |]\n\nlet cfgStyle : Js.Unsafe.any style Js.t Js.js_array Js.t = (**CFG style**)\n  let node_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \"node\"\n    val style = Js.def (object%js\n      val label = Js.string \"data(label)\"\n      val textHalign = Js.string \"center\"\n      val textValign = Js.string \"center\"\n      val borderWidth = Js.string \"2\"\n      val fontFamily = Js.string \"monospace\"\n    end)\n  end in\n  let node_selected_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \"node.selected\"\n    val style = Js.def (object%js\n      val backgroundColor = Js.string \"lightblue\"\n    end)\n  end in\n  let node_child_selected_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \"node.childrenSelected\"\n    val style = Js.def (object%js\n      val backgroundColor = Js.string \"lightgreen\"\n    end)\n  end in\n  let node_child_epsilon_syle = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \"node.epsilon\"\n    val style = Js.def (object%js\n      val backgroundColor = Js.string \"lightyellow\"\n    end)\n  end in\n  let node_style_root = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \"node[nodeType = \\'root\\']\"\n    val style = Js.def (object%js\n      val backgroundColor = Js.string \"white\"\n    end)\n  end in\n  let node_style_leaf = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \"node[nodeType = \\'leaf\\']\"\n    val style = Js.def (object%js\n      val backgroundColor = Js.string \"white\"\n    end)\n  end in\n  Js.array [| node_style; node_style_root; node_style_leaf;\n              node_selected_style;\n              node_child_selected_style;\n              node_child_epsilon_syle |]\n\n\nlet grStyle : Js.Unsafe.any style Js.t Js.js_array Js.t = (**GR style**)\nlet node_style = Js.Unsafe.coerce @@ object%js\n  val selector = Js.string \"node\"\n  val style = Js.def (object%js\n    val label = Js.string \"data(label)\"\n    val textHalign = Js.string \"center\"\n    val textValign = Js.string \"center\"\n    val borderWidth = Js.string \"2\"\n    val fontFamily = Js.string \"monospace\"\n  end)\nend in\nlet node_selected_style = Js.Unsafe.coerce @@ object%js\n  val selector = Js.string \"node.selected\"\n  val style = Js.def (object%js\n    val backgroundColor = Js.string \"lightblue\"\n  end)\nend in\nlet node_child_selected_style = Js.Unsafe.coerce @@ object%js\n  val selector = Js.string \"node.childrenSelected\"\n  val style = Js.def (object%js\n    val backgroundColor = Js.string \"lightgreen\"\n  end)\nend in\nlet node_child_epsilon_syle = Js.Unsafe.coerce @@ object%js\n  val selector = Js.string \"node.epsilon\"\n  val style = Js.def (object%js\n    val backgroundColor = Js.string \"lightyellow\"\n  end)\nend in\nlet node_style_root = Js.Unsafe.coerce @@ object%js\n  val selector = Js.string \"node[nodeType = \\'root\\']\"\n  val style = Js.def (object%js\n    val backgroundColor = Js.string \"white\"\n  end)\nend in\nlet node_style_leaf = Js.Unsafe.coerce @@ object%js\n  val selector = Js.string \"node[nodeType = \\'leaf\\']\"\n  val style = Js.def (object%js\n    val backgroundColor = Js.string \"white\"\n  end)\nend in\nlet node_style_compound = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \"node[nodeType = 'compound']\"\n    val style = Js.def (object%js\n      val backgroundColor = Js.string \"#eee\"\n      val textValign = Js.string \"top\"\n      val label = Js.string \"data(label)\" (* Add this line *)\n    end)\n  end in\n  let child_node_style = Js.Unsafe.coerce @@ object%js\n    val selector = Js.string \"node:child\"  (* Style for child nodes*)\n    val style = Js.def (object%js\n      val backgroundColor = Js.string \"white\"\n  end)\n  end in\nJs.array [| child_node_style; node_style_compound; node_style; node_style_root; node_style_leaf;\n            node_selected_style;\n            node_child_selected_style;\n            node_child_epsilon_syle |]\n\nlet applyStyle cy style =\n  cy##style##resetToDefault;\n  Array.iter (fun s -> let s = Js.Unsafe.coerce s in\n                     cy##style##(selector(s##.selector))##style(s##.style)\n           ) style;\n  cy##style##update\n  \nlet resetStyle cy style = (*TODO Port from original resetStyle and especific for FA. Make for any model?*)\n  let styles = Js.to_array style in\n  cy##style##resetToDefault;\n  Array.iter (fun s -> let s = Js.Unsafe.coerce s in\n                       (Js.Unsafe.coerce cy)##style##(selector(s##.selector))##style(s##.style)\n             ) styles;\n  cy##style##update\n\nlet removeAllElements cy = \n  cy##remove_fromSelector (Js.string \"node\")\n\nlet resetFaElems cy = \n  removeAllElements cy;\n  add_node cy \"transparent\" ~pos:(0,200) \"\" \"transparent\" \"transparent\"\n  \n\nlet paintNode cy node color = \n  ignore(\n    (Js.Unsafe.coerce cy)##\n    style##\n    (selector (Js.string (\"#\" ^ node)) )##\n    style(Js.Unsafe.coerce @@ object%js\n      val backgroundColor = Js.string color\n    end)\n  )##update\n\nlet initCy cy =\n  let props = mk_graph cy in\n  let cy = display props in\n  cy\n\nlet initFaCy cyContainer =\n  let props = mk_graph ~style:faStyle ~layout: faLayout cyContainer in\n  let cy = display props in\n  let eh = (Js.Unsafe.coerce cy)##edgehandles edgehandlesOptions in\n    on cy \"ehcomplete\" \"\" (fun event sourceNode targetNode addedEles -> \n      let source = data_fromName sourceNode \"id\" in \n      let target = data_fromName targetNode \"id\" in\n      let ele = data_fromName addedEles \"id\" in \n      let getElement = elementId cy ele in \n       cy##remove (getElement);\n        !ListenersAutomaton.addTransition source target;\n        !Listeners.updateRightListener ()\n    );\n  if cyContainer <> \"cy2\" then begin\n    cy##cxtmenu(menu cy eh);\n    cy##cxtmenu(menu2);\n    cy##cxtmenu(menu3) end;\n  add_node cy ~pos:(0,200) \"transparent\" \"\" \"transparent\" \"transparent\";\n  cy##autolock( false );\n  cy\n\nlet startTree cyContainer =\n  let props = mk_graph ~style:reStyle cyContainer in\n  let cy = display props in\n  run_layout (cy##layout reLayout);\n  cy\n\nlet initLL1Cy cyContainer =\n  let props = mk_graph ~style:cfgStyle cyContainer in\n  let cy = display props in\n  run_layout (cy##layout cfglayout);\n  cy\n\nlet initGRCy cyContainer =\n  let props = mk_graph ~style:grStyle cyContainer in\n  let cy = display props in\n  run_layout (cy##layout grlayout);\n  cy\n\nlet initGRCy3 cyContainer =\n  let props = mk_graph ~style:grStyle cyContainer in\n  let cy = display props in\n  run_layout (cy##layout treeGrlayout);\n  cy\n\nlet generateEdgeID source target =\n\tsource ^ \"-\" ^ target (* \"-\" avoid ambiguity: \"A-AA\" \"AA-A\" *)\n\nlet addEdge cy (first, edgeLabel, second) =\n  let nId = generateEdgeID first second in\n    let getEdge = elementId cy nId in\n      if (Js.float_of_number getEdge##.length) = 0. then(\n        add_edge cy ~id:nId first second edgeLabel)\n      else \n        (let  test1 = Js.Unsafe.coerce (getEdge) in\n          let k = Js.to_string (test1##data##.label) in \n        cy##remove (getEdge);\n        let newSymbol = k ^ \", \" ^ edgeLabel in\n        add_edge cy ~id:nId first second newSymbol)\n\n(* ML *)\nlet addEdgeGeneral cy (first, edgeLabel, second) =\n  let nId = first ^ second in\n    let getEdge = elementId cy nId in\n      if (Js.float_of_number getEdge##.length) = 0. then(\n        add_edge cy ~id:nId first second edgeLabel)\n      else \n        (let  test1 = Js.Unsafe.coerce (getEdge) in\n          let k = Js.to_string (test1##data##.label) in \n        cy##remove (getEdge);\n        let newSymbol = k ^ \",  \" ^ edgeLabel in\n        add_edge cy ~id:nId first second newSymbol)\n\nlet addNode cy node ?(x = Random.int 1399) ?(y = Random.int 299) isStart isFinal =\n  let verify = elementId cy node in\n    if ((Js.float_of_number verify##.length) < 1.) then\n      if (isFinal = true) then\n        if (isStart = true) then\n          (add_node ~pos:(100, 200) cy node \"\" \"SUCCESS\" node;\n          (elementId cy node)##lock;\n          addEdge cy (\"transparent\", \" \", node) )\n        else\n          add_node cy ~pos:(x, y) node \"\" \"SUCCESS\" node\n      else \n        if (isStart = true) then\n          (add_node cy ~pos:(100, 200) node \"\" \"NOT\" node;\n          (elementId cy node)##lock;\n          addEdge cy (\"transparent\", \" \", node) )\n        else \n          add_node cy ~pos:(x, y) node \"\" \"NOT\" node\n\nlet addNode2 cy node isStart isFinal =\n  let verify = elementId cy node in\n  let y = 100 + (100 * (int_of_string node)) in\n  (*let y = 200 + (50 * ((int_of_string node) -1)) in *)\n  (* let y = Random.int 399 in **)\n  let x = 200 + (50 * ((int_of_string node mod 2)-2) * ((int_of_string node))) * -1 in\n    if ((Js.float_of_number verify##.length) < 1.) then\n        if (node = \"0\") then\n          add_node cy ~pos:(100, 200) node \"\" \"\" node\n        else\n          add_node cy ~pos:(x, y) node \"\" \"\" node\n\nlet removeNode cy node =\n  let element = elementId cy node in\n    cy##remove(element)\n\nlet turnFinal cy name =\n  let nn = elementId cy name in\n    nn##addClass(Js.string \"SUCCESS\")\n\nlet removeFinal cy name =\n  let nn = elementId cy name in\n    nn##removeClass (Js.string \"SUCCESS\")\n\nlet removeEdge cy source label target =\n  let open Re in\n  let nId = generateEdgeID source target in\n  let getEdge = cy##getElementById (Js.string nId) in\n  let labelEdge = Js.to_string (Js.Unsafe.coerce getEdge)##data##.label in\n  let labelEscSpecialChars = Str.global_replace (Str.regexp {|\\([\\*\\+\\.\\^\\]\\)|}) {|\\\\\\1|} label in\n  let newLabel = Str.replace_first (Str.regexp (\"^\"^labelEscSpecialChars^\", \\\\|\\\\(, \\\\)?\"^labelEscSpecialChars)) \"\" labelEdge in\n  cy##remove(getEdge);\n  if (newLabel <> \"\") then add_edge cy ~id:nId source target newLabel \n\nlet destroyGraph cy =\n  cy##destroy()\n\nlet fit cy = \n  match cy with\n  | None -> ()\n  | Some c -> c##resize; c##fit\n\nlet centerGraph cy =\n  cy##resize;\n  cy##fit\n  \nlet makeTreeNode cy id node =\n  add_node cy id \"\" \"\" node;\n  run_layout (cy##layout reLayout)\n\n(* Carolina *)\nlet makeTreeNode2 cy id name =\n    add_node cy id \"\" \"\" name;\n    (*let elem = elementId cy id in\n    elem##on_3 \"tap\" (fun event a b c -> JS.alertStr (\"aaa\"));*)\n    run_layout (cy##layout reLayout);\n    cy##on (Js.string \"tap\") (Js.string \"node\") \n    (fun evt -> \n      match Js.Opt.to_option (evt##.target) with \n      | None -> JS.log(\"Error, none node selected\")\n      | Some t ->\n        let target = Js.Unsafe.coerce t in\n        let label = Js.to_string target##data##.label in\n          !ListenersComp.showTreeNode label\n    )\n\n\nlet makeTreeEdge cy idNode1 idNode2 =\n  let nId = idNode1 ^ \"_\" ^ idNode2 in\n    add_edge cy ~id:nId idNode1 idNode2 \"\";\n    run_layout (cy##layout reLayout)\n\nlet changeDirection cy2 layoutDir =\n  if (layoutDir = \"LR\") then\n    (run_layout (cy2##layout (object%js \n                            val name = Js.string \"dagre\"\n                            val rankDir = Js.string \"TB\"\n                            end));\n    \"TB\")\n  else \n    (run_layout (cy2##layout (object%js \n                            val name = Js.string \"dagre\"\n                            val rankDir = Js.string \"LR\"\n                            end));\n    \"LR\")\n\n\n","open OCamlFlat\nopen BasicTypes\nopen JS\nopen Lang\n\nmodule AutomatonView =\nstruct\n\t\n  let productiveColor = \"orange\"\n  let reachableColor = \"yellow\"\n  let usefulColor = \"purple\"\n  let stepState = \"blue\"\n  let acceptState = \"green\"\n  let wrongFinalState = \"red\"\n\n  let rec intersection l1 l2 =\n    match l1 with\n       [] -> []\n     | x::xs -> (if List.mem x l2 then [x] else []) @ intersection xs l2\n\n    let cut s = (String.get s 0, String.sub s 1 ((String.length s)-1))\n\n    let rec stringAsList s =\n      if s = \"\" then []\n      else\n          let (x,xs) = cut s in\n              x::stringAsList xs\n\n  let iterateList meth (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t) list =\n    List.iter (meth cy) list\n\n  let paintProductive (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t) state =\n    Cytoscape.paintNode cy state productiveColor\n      \n  let paintReachable (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t) state =\n        Cytoscape.paintNode cy state reachableColor\n        \n  let paintUseful (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t)  state =\n        Cytoscape.paintNode cy state usefulColor\n\n  class virtual model (arg: ('r) Arg.alternatives) =\n\t\tobject(self)\n\n      val mutable steps = [||]\n      val mutable position = 0\n      val mutable isOver = false\n\n      val sentence: char list ref = ref []\n      val newSentence = ref \"\"\n\n      method virtual inputEdges: Cytoscape.cytoscape Js_of_ocaml.Js.t -> unit     \n      method virtual reachableFromInitialState: states\n      method virtual usefulPainting: Cytoscape.cytoscape Js_of_ocaml.Js.t -> unit\n      method virtual productivePainting: Cytoscape.cytoscape Js_of_ocaml.Js.t -> unit\n      method virtual areAllStatesUseful: bool\n      method virtual productive: states\n      method virtual paintCurrentStates: Cytoscape.cytoscape Js_of_ocaml.Js.t -> unit\n      method virtual staticGenerate : int -> words\n      method virtual getInitialState: state\n      method virtual getAcceptStates: states\n      method virtual getStates: states\n      method virtual staticAccept: unit\n      method virtual staticAcceptFull: unit\n      method virtual setInitialStep: Cytoscape.cytoscape Js_of_ocaml.Js.t -> unit\n      method virtual setNextStep: Cytoscape.cytoscape Js_of_ocaml.Js.t -> unit\n      method virtual buildTable: unit\n      method virtual displayTrace: unit\n      method virtual returnStats: bool * int * bool * float\n      \n      method private virtual getCurrConfigFromBestPath: 'configuration option\n      method private virtual getWordFromConfig: 'configuration -> word\n\n      method resetToEditModel = ()\n\n      method setBackStep (cy: Cytoscape.cytoscape Js_of_ocaml.Js.t) = ()\n\n      method inputNodes cy = \n        Set.iter (fun el -> \n          Cytoscape.addNode cy el (el = self#getInitialState) (Set.belongs el self#getAcceptStates)\n        ) self#getStates\n\n      method drawExample cy = \n        self#inputNodes cy;\n        self#inputEdges cy\n\n      method reachablePainting (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t) =\n        let list1 = Set.toList self#reachableFromInitialState in\n          iterateList paintReachable cy list1 \n\n      method usefulPainting cy =\n        let intre = intersection (Set.toList self#productive) (Set.toList self#reachableFromInitialState) in\n        iterateList paintUseful cy intre \n\n      method productivePainting (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t)  =\n        let list1 = Set.toList self#productive in\n        iterateList paintProductive cy list1 \n\n      method changeTheTestingSentence word =\n        sentence := stringAsList word\n\n      method newSentence = !newSentence\n\n      method isOver = isOver\n\n      method staticAccept =\n        self#staticAccept\n\n      method startAccept (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t) =\n        steps <- Array.make 1 Set.empty;\n        position <- 0;\n        isOver <- false;\n        self#setInitialStep cy;\n        self#paintCurrentStates cy; \n        if (position = (List.length !sentence)) then\n          (isOver <- true);\n        match self#getCurrConfigFromBestPath with\n          | None -> ()\n          | Some config -> self#changeSentence config; \n\n      method next (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t) =\n        if isOver then\n          (JS.alertStr (Lang.i18nAlertNoMoreStates ()))\n        else \n          (position <- position + 1;\n          JS.log(steps);\n          self#setNextStep cy;\n          match self#getCurrConfigFromBestPath with\n              | None -> ()\n              | Some config -> \n                  self#changeSentence config;\n                  if (Array.length steps) - 1 = position then (isOver <- true);\n                  JS.log(isOver);\n                  self#paintCurrentStates cy;\n          )\n\n      method back (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t) =\n        position <- position - 1;\n        isOver <- false;\n        if position < 0 then\n          (position <- 0; JS.alertStr (Lang.i18nAlertArrivedInitial ()))\n        else\n          (self#setBackStep cy;\n          self#paintCurrentStates cy;\n          match self#getCurrConfigFromBestPath with\n              | None -> ()\n              | Some config -> self#changeSentence config;\n          )\n\n      method changeToEditModelMode (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t) =\n        steps <- [||];\n        position <- 0;\n        isOver <- false;\n        sentence := [];\n        newSentence :=\"\";\n        Cytoscape.resetStyle cy Cytoscape.faStyle;\n        self#resetToEditModel\n          \n      method private changeSentence config = \n        newSentence := \"\";\n        let wordToConsume = self#getWordFromConfig config in\n        let bar = '|' in \n        for i = 0 to (List.length !sentence) - (List.length wordToConsume) - 1 do \n              newSentence:= !newSentence ^ String.make 1 (List.nth !sentence i);\n            done;\n            newSentence:= !newSentence ^ String.make 1 bar;\n        for i = 0 to (List.length wordToConsume) - 1 do\n          newSentence:= !newSentence ^ symb2str (List.nth wordToConsume i);\n        done\n        \n\n      method private paint (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t) state length final = \n          if (length != 0) then \n            Cytoscape.paintNode cy state stepState\n          else \n              (if (final) then\n                Cytoscape.paintNode cy state acceptState\n              else \n                Cytoscape.paintNode cy state wrongFinalState)\n\n\n      method private paintStates (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t) states (isFinal: BasicTypes.state -> bool) = \n        Cytoscape.resetStyle cy Cytoscape.faStyle;\n        Set.iter (fun el -> self#paint cy el self#getLenghtLeftAccept (isFinal el)) states\n\n      method private getLenghtLeftAccept = (Array.length steps) - position - 1\n\n  end\nend\n","(*\n * FiniteAutomatonView.ml\n *\n * This file is part of the OFLAT app\n *\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\n *\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\n *\n * This software is distributed under the terms of the GPLv3 license.\n * See the included LICENSE file for details.\n *\n *  Written by Rita Macedo\n *)\n\nopen OCamlFlat\nopen BasicTypes\nopen Js_of_ocaml\nopen JS\nopen ViewUtil\nopen Lang\nopen Cytoscape\nopen AutomatonView\nopen HTMLTable\n\nmodule FiniteAutomatonView = \nstruct\n\topen FiniteAutomaton\n\t\n  let htmlDelta = \"ẟ\"\n\n  (** Auxiliar Methods **)\n        \n  let paintMinimization (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t)  state color = \n        Cytoscape.paintNode cy state color\n  \n  let paintMinimized (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t)  state color = \n        Cytoscape.paintNode cy state color\n\n  let getMinStates cy list color = \n    Set.iter (fun el -> paintMinimization cy el color) list\n\n  let delay n =\n    Js_of_ocaml_lwt.Lwt_js.sleep (float_of_int n *. 0.01)\n\n  let rec delay1 n = if n = 0 then Lwt.return ()\n                                  else Lwt.bind (Lwt.pause()) (fun () -> delay1 (n-1))\n  \n  let transitionGet3 trns = Set.map ( fun (_,_,c) -> c ) trns\n  \n  let nextEpsilon2 st ts =\n        let trns = Set.filter (fun (a,b,c) -> st = a && b = epsilon) ts in\n        let nextStates = transitionGet3 trns in\t\n\t\t\tSet.add st nextStates \n\n  let rec closeEmpty sts t = \n\t\tlet ns = Set.flatMap (fun st -> nextEpsilon2 st t) sts in\n\t\t\tif (Set.subset ns sts) then ns else closeEmpty (Set.union sts ns) t \n\n  let nextEpsilon1 st t =\n          let n = Set.filter (fun (a,b,c) -> st = a && b = epsilon) t in\n                  Set.map ( fun (_,_,d) -> d ) n\t\t\n\t\t\t\t\n\tlet rec nextEpsilons currsts t = \n\t\tlet ns = Set.flatMap (fun nst -> nextEpsilon1 nst t) currsts in\n\t\t\tif (Set.subset ns currsts) then ns else nextEpsilons (Set.union currsts ns) t\n\t\t\t\n  let nextStates st sy t =\n    let n = Set.filter (fun (a,b,c) -> st = a && sy = b) t in\n            Set.map ( fun (_,_,d) -> d) n\n\n  let transition sts sy t = \n        let nsts = Set.flatMap (fun st -> nextStates st sy t) sts in\n          Set.union nsts (nextEpsilons nsts t)\n\n  let isFinal acceptStates el =\n    Set.belongs el acceptStates\n\n  (*JP*)\n\n  let __none__ = \"__none__\"\n  let bestStateColor = \"DarkBlue\"\n\n  let optionsPopper = \n    Js.def (object%js \n      val placement = Js.string \"right-end\"\n    end)\n\n  let _popperDiv_ = \"popper-div\"\n  let _displayConfig_ = \"display-config\"\n  let _displayConfigClass_ = \"display-config-class\"\n  let _infoConfigDisplayID_ = \"infoConfigDisplay\"\n  let _nodeConfigDisplayID_ = \"nodeConfigDisplay\"\n\n  let buildPopper nConfigs (node: Cytoscape.DataItem.t Js_of_ocaml.Js.t) =\n    node##popper (\n      Js.Unsafe.coerce @@ object%js\n        val content = fun () -> \n          let countConfigsDiv = Dom_html.document##createElement (Js.string \"div\") in\n            (countConfigsDiv##.classList)##add(Js.string _popperDiv_);\n            countConfigsDiv##.innerHTML := Js.string (string_of_int nConfigs);\n            Dom.appendChild (Dom_html.getElementById \"cy\") countConfigsDiv;\n              countConfigsDiv\n        val popper = optionsPopper\n      end\n    )\n\n  let getConfigCountForNode node configs : int =\n    Set.fold_left (fun c (st,_) -> if (state2str st) = (data_fromName node \"id\") then c+1 else c) 0 configs\n\n  let buildConfigsCount (cy: Cytoscape.cytoscape Js_of_ocaml.Js.t) configs = \n    let nodes = List.filter (fun node -> (data_fromName node \"id\") <> \"transparent\") (Cytoscape.getAllNodes cy) in\n      List.map (fun node -> buildPopper (getConfigCountForNode node configs) node) nodes\n\n  let updateAllPoppers (poppers: Cytoscape.popper Js_of_ocaml.Js.t list) =\n    List.iter (fun popper -> popper##update ()) poppers\n\n  let destroyAllPoppers (poppers: Cytoscape.popper Js_of_ocaml.Js.t list) =\n    List.iter (fun popper -> popper##destroy ()) poppers\n\n  let getConfigsWithState state configs =\n    Set.filter (fun (st, _) -> st = state) configs\n\n  let buildInfoString state info =\n    \"[\"^(state2str state)^\", \"^(word2str info)^\"]\"\n    \n  \n  (*que info queremos dar display??*)\n  let buildConfigMenu ((menuID, state, info)) = \n    let infoDisplay = buildInfoString state info in\n      Js.def (object%js \n        val id = Js.string menuID\n        val content = Js.string infoDisplay\n        val selector = Js.string \"node\"\n        val show = Js.bool false\n        val disabled = Js.bool true\n        val onClickFunction = fun element -> ()\n      end)\n  \n  let buildIdFromState state (suffix: int) =\n    (state2str state)^\"_\"^(string_of_int suffix)\n  \n  (*MUDAR*)\n  let processNodeConfig (configs: FiniteAutomaton.configurations) state =\n    let configsOfState = getConfigsWithState state configs in\n    Set.mapi (fun i (state, symb) -> buildConfigMenu (buildIdFromState state i, state, symb)) configsOfState\n\n  let processConfigMenus (configs:FiniteAutomaton.configurations) =\n    let states = Set.map (fun (a, _) -> a) configs in\n    Set.flatMap (processNodeConfig configs) states\n\n  let menuConfigFA (configs: FiniteAutomaton.configurations) =\n    Js.Unsafe.coerce @@ object%js \n      val evtType = Js.string \"tapdragover\"\n      val menuItems = Js.array (Array.of_list (Set.toList (processConfigMenus configs)))\n    end \n\n  let buildIdsStateAndApplyF f node configs: unit =\n    let configsOfState = getConfigsWithState (state node) configs in\n    Set.iteri (fun idSuffix (st, _) -> f (buildIdFromState st idSuffix)) configsOfState\n\n  let hideMenu menu id =\n    menu##hideMenuItem (Js.string id)\n  \n  let showMenu menu id =\n    menu##showMenuItem (Js.string id)\n\n  let hideMenus menu configs node =\n    buildIdsStateAndApplyF (hideMenu menu) node configs\n    \n  let showMenus menu configs node =\n    buildIdsStateAndApplyF (showMenu menu) node configs \n\n  let hideAllConfigMenus menu configs =\n    let states = Set.map (fun (a, _ ) -> a) configs in\n      Set.iter (hideMenus menu configs) states\n\n  let getStatesFromConfigs (configs: FiniteAutomaton.configurations) =\n      Set.map (fun (st, _) -> st) configs\n\n\n  class model (arg: (t) Arg.alternatives) =\n\t\tobject(self) \n      inherit AutomatonView.model arg as abstractAutomaton\n      inherit FiniteAutomaton.model arg as super\n\n      val mutable bestPath: FiniteAutomaton.path = []\n      val mutable configsCounter: Cytoscape.popper Js_of_ocaml.Js.t list = []\n      val mutable selectedNodeConfigMenu = __none__\n      val mutable configDisplay: Cytoscape.popper Js_of_ocaml.Js.t option = None\n      val mutable configMenu: contextMenus Js.t option = None\n      val mutable accepted : bool = false\n      val mutable visitedConfigs : int = 0\n      val mutable exactResult : bool = false\n      val mutable acceptTime : float = 0.0\n\n\n      method inputNodesPainting cy2 colors number = \n        let listStates = Set.toList self#representation.states in \n        for i=0 to number-1 do\n          let newState = List.nth listStates i in \n          Cytoscape.addNode cy2 newState (newState = self#representation.initialState) (Set.belongs newState self#representation.acceptStates);\n          let color = Array.get colors i in\n          paintMinimized cy2 newState color\n        done\n\n      method inputEdges cy = \n        let mapToCytoscapeEdge transitions = \n          Set.map (fun (n1,s,n2) -> (n1, symb2str s, n2)) self#representation.transitions \n        in\n          Set.iter (Cytoscape.addEdge cy) (mapToCytoscapeEdge self#representation.transitions)\n\n      method accept3 (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t) (w: word) =\n        let transition sts sy t = \n          let nsts = Set.flatMap (fun st -> nextStates st sy t) sts in\n                    Set.union nsts (nextEpsilons nsts t) in\n                  \n        let rec accept2X sts w t exists =\n          match w with\n            [] -> Lwt.bind (delay 40) (fun () -> Lwt.bind (Lwt.return (self#paintStates cy sts (isFinal self#getAcceptStates))) (fun () -> Lwt.return ((Set.inter sts self#representation.acceptStates) <> Set.empty)))\n            |x::xs -> Lwt.bind (delay 40) (fun () -> Lwt.bind (Lwt.return (self#paintStates cy sts (isFinal self#getAcceptStates))) \n              (fun () -> let nextTrans = transition sts x t in\n                            if (Set.size nextTrans) = 0 then\n                              accept2X sts [] t false\n                            else \n                              accept2X (transition sts x t) xs t true\n              )) in\n          \n        let i = closeEmpty (Set.make [self#representation.initialState]) self#representation.transitions in\n          accept2X i w self#representation.transitions true\n\n      method drawMinimize cy2 colors number =\n        self#inputNodesPainting cy2 colors number;\n        self#inputEdges cy2\n\n      method addInitialNode node firstNode exists =\n        if firstNode then\n          (new model (Arg.Representation {\n            alphabet = Set.empty;\n\t          states = Set.make [node]; \n            initialState = node;\n            transitions = Set.empty;\n            acceptStates = Set.empty\n          }))  \n        else\n          if exists then\n            (let rep: t = self#representation in \n            new model (Representation{\n              alphabet = rep.alphabet;\n\t            states = rep.states;\n              initialState = node;\n              transitions = rep.transitions;\n              acceptStates = rep.acceptStates\n            }))\n          else\n            (let rep: t = self#representation in \n            new model (Representation{\n              alphabet = rep.alphabet;\n\t            states = Set.add node rep.states;\n              initialState = node;\n              transitions = rep.transitions;\n              acceptStates = rep.acceptStates\n            }))\n      \n      method addNode node firstNode =\n      if firstNode then\n        (new model (Representation {\n          alphabet = Set.empty;\n\t        states = Set.make [node]; \n          initialState = node;\n          transitions = Set.empty;\n          acceptStates = Set.empty\n        }))  \n      else\n        (let rep: t = self#representation in \n          new model (Representation{\n            alphabet = rep.alphabet;\n\t          states = Set.add node rep.states;\n            initialState = rep.initialState;\n            transitions = rep.transitions;\n            acceptStates = rep.acceptStates\n          }))\n\n      method addFinalNode node firstNode exists = \n        if firstNode then\n          (new model (Representation {\n          alphabet = Set.empty;\n\t        states = Set.make [node]; \n          initialState = node;\n          transitions = Set.empty;\n          acceptStates = Set.make [node]\n        })) \n        else \n          if exists then\n          (let rep: t = self#representation in \n            new model (Representation{\n              alphabet = rep.alphabet;\n\t            states = rep.states;\n              initialState = rep.initialState;\n              transitions = rep.transitions;\n              acceptStates = Set.add node rep.acceptStates\n            }))\n          else \n            (let rep: t = self#representation in \n              new model (Representation{\n              alphabet = rep.alphabet;\n\t            states = Set.add node rep.states;\n              initialState = rep.initialState;\n              transitions = rep.transitions;\n              acceptStates = Set.add node rep.acceptStates\n            }))\n\n      method changeToFinal node =\n        let rep: t = self#representation in \n              new model (Representation{\n              alphabet = rep.alphabet;\n\t            states = rep.states;\n              initialState = rep.initialState;\n              transitions = rep.transitions;\n              acceptStates = Set.add node rep.acceptStates\n            })\n\n        method removeFinal node =\n        let rep: t = self#representation in \n              new model (Representation{\n              alphabet = rep.alphabet;\n\t            states = rep.states;\n              initialState = rep.initialState;\n              transitions = rep.transitions;\n              acceptStates = Set.remove node rep.acceptStates\n            })\n\n      method eliminateNode node isStart isFinish = \n        let rep: t = self#representation in \n        if (isStart && isFinish) then\n          new model (Representation{  \n            alphabet = rep.alphabet;\n\t          states = Set.remove node rep.states;\n            initialState = \"\";\n            transitions = rep.transitions;\n            acceptStates = Set.remove node rep.acceptStates\n            })\n        else\n          if (isStart) then\n            new model (Representation{  \n              alphabet = rep.alphabet;\n\t            states = Set.remove node rep.states;\n              initialState = \"\";\n              transitions = rep.transitions;\n              acceptStates = rep.acceptStates\n            })\n          else \n            if (isFinish) then\n              new model (Representation{  \n                alphabet = rep.alphabet;\n\t              states = Set.remove node rep.states;\n                initialState = rep.initialState;\n                transitions = rep.transitions;\n                acceptStates = Set.remove node rep.acceptStates\n            })\n          else\n            new model (Representation{  \n              alphabet = rep.alphabet;\n\t            states = Set.remove node rep.states;\n              initialState = rep.initialState;\n              transitions = rep.transitions;\n              acceptStates = rep.acceptStates\n            })\n\n\n      method newTransition (a, b, c) = \n      let rep: t = self#representation in \n        new model (Representation{\n            alphabet = Set.add b rep.alphabet;\n\t          states = rep.states;\n            initialState = rep.initialState;\n            transitions = Set.add (a, b , c) rep.transitions;\n            acceptStates = rep.acceptStates\n      })\n\n      method newEpsylonTransition (a, b, c) = \n      let rep: t = self#representation in \n        new model (Representation{\n            alphabet = rep.alphabet;\n\t          states = rep.states;\n            initialState = rep.initialState;\n            transitions = Set.add (a, b , c) rep.transitions;\n            acceptStates = rep.acceptStates\n      })\n\n      method eliminateTransition (a, b, c) = \n        let rep: t = self#representation in \n        let transitions = Set.remove (a, b, c) rep.transitions in\n        new model (Representation{\n          alphabet = rep.alphabet;\n          states = rep.states;\n          initialState = rep.initialState;\n          transitions = transitions;\n          acceptStates = rep.acceptStates\n      })\n\n      method getColors:int =\n        Set.size self#equivalencePartition\n\n      method paintMinimization cy colors: unit = \n          let number = self#getColors in\n          let listEquivalence = Set.toList self#equivalencePartition in\n          for i=0 to number-1 do \n            getMinStates cy (List.nth listEquivalence i) (Array.get colors i)\n          done\n\n      method minimize1: model = \t\t\t\n        let min = super#minimize in\n          let rep = min#representation in \n            new model (Representation rep) \n \n    method toDeterministic1: model = \n      let deter = super#toDeterministic in\n        let rep = deter#representation in \n        new model (Representation rep) \n\n    method reachableFromInitialState: states = self#reachable self#representation.initialState\n\n      method cleanUselessStates1 (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t) : model =\n        Cytoscape.resetStyle cy Cytoscape.faStyle;\n        let uss = self#getUselessStates in\n        Set.iter (fun s -> Cytoscape.paintNode cy s AutomatonView.usefulColor) uss;\n        let clean = super#cleanUselessStates in\n        let rep = clean#representation in \n        new model (Representation rep) \n\n      method numberStates: int =\n        Set.size self#representation.states\n\n      method numberTransitions: int =\n        Set.size self#representation.transitions\n        \n      method renameState state name =\n        let rep: t = self#representation in \n        let initial = if state = rep.initialState then name else rep.initialState in\n        let newStates = Set.remove state (Set.add name rep.states) in\n        let newTransitions = Set.map (fun (s,n,t) -> \n          if s = state && t = state then (name,n,name) else\n          if s = state then (name,n,t) else\n          if t = state then (s,n,name) else (s,n,t)\n        ) rep.transitions in\n        let newAcceptStates = Set.map (fun s -> if s = state then name else s) rep.acceptStates in\n        new model (Representation{\n          alphabet = rep.alphabet;\n          states = newStates;\n          initialState = initial;\n          transitions = newTransitions;\n          acceptStates = newAcceptStates\n      })\n\n    method paintCurrentStates cy = \n      self#paintStates cy (getStatesFromConfigs steps.(position)) (isFinal self#getAcceptStates);\n      self#paintBestCurrentStep cy\n\n    method getAcceptStates = self#representation.acceptStates\n    method getInitialState = self#representation.initialState\n    method getStates = self#representation.states\n\n    method staticGenerate len =\n      let res = self#generate len in\n      let (exact, configVisited, time) = Model.stats() in\n      exactResult <- exact;\n      acceptTime <- time;\n      visitedConfigs <- configVisited;\n      res\n      \n\n\n    method staticAccept =\n      let acc = self#accept (List.map char2symb !sentence) in\n      let (exact, configVisited, time) = Model.stats() in\n      self#setConfigsAndBestPath2 acc exact time configVisited;\n      JS.log(\"set initial step\");\n\n      method staticAcceptFull =\n        let (acc, bestPath, trail) = self#acceptFull (List.map char2symb !sentence) in\n        let (exact, configVisited, time) = Model.stats() in\n        self#setConfigsAndBestPath trail bestPath acc exact time configVisited;\n        JS.log(\"set initial step\");\n\n\n    method setInitialStep cy =\n      self#staticAcceptFull;\n      self#initAllMenusAndFeatures cy steps.(0)\n\n    method setNextStep cy =\n      self#updateAllMenusAndFeatures cy steps.(position)\n\n    method setBackStep (cy: Cytoscape.cytoscape Js_of_ocaml.Js.t) =\n      self#updateAllMenusAndFeatures cy steps.(position)\n      \n(*      method renameTransition transition name =*)\n\n    (* vvvvvvvvvv  Joao Pinto vvvvvvvvvvv*)\n\n    method getWordFromConfig config : word =\n      let (state, word) = config in\n      word\n    \n    method returnStats =\n      (accepted, visitedConfigs, exactResult, acceptTime)\n\n    method returnPath = bestPath\n\n    (*TABELAS*)\n\n    method buildTable =\n      let makeFATable () : string list list =\n          let alphabet = Set.toList self#representation.alphabet in\n          let states = Set.toList self#representation.states in\n          let headers = List.map symb2str alphabet in\n          let contents = List.map (fun st -> HTMLTable.makeFAStateRow st alphabet self#representation.transitions) states in\n          (htmlDelta :: headers) :: contents\n      in\n      if not (HTMLTable.tableExists \"automataTable\") then (\n        let contents = makeFATable () in\n        HTMLTable.buildTable contents \"automataTable\" \"tab\";\n      )\n      else (\n        let parent = Dom_html.getElementById \"tab\" in\n        parent##.innerHTML := Js.string \"\";\n        let contents = makeFATable () in\n        HTMLTable.buildTable contents \"automataTable\" \"tab\"\n      )\n\n    method displayTrace =\n      let makePath () : string list list =\n        let headers = [\"Trace\"; \"Current State\"; \"Word To Consume\"] in\n          headers :: HTMLTable.makeFAPath bestPath 0\n      in\n      if not (HTMLTable.tableExists \"pathTable\") then (\n        let contents = makePath () in\n      (*expected string list list*)\n        HTMLTable.buildTable contents \"pathTable\" \"cy2\";\n        let tab = HTMLTable.fetchTable \"pathTable\" in\n        let lastRowIndex = List.length bestPath in\n        let _ =\n          for n = 1 to 4 (*List.length headers + 1*) do\n            if accepted then HTMLTable.paint tab lastRowIndex n \"mediumseagreen\"\n            else HTMLTable.paint tab lastRowIndex n \"crimson\"\n          done\n        in\n        HTMLTable.changeDisplay tab \"\"   \n      )\n      else ()\n    \n      \n    (*ANIMS*)\n\n    method private resetConfigMenu =\n      match configMenu with\n      | None -> ()\n      | Some menu -> \n          menu##destroy();\n          configMenu <- None;\n          selectedNodeConfigMenu <- __none__\n\n    method resetToEditModel = \n      self#resetConfigMenu;\n      self#destroyAllPoppers\n\n\n    method private updateConfigMenu (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t) configs =\n      self#resetConfigMenu;\n      let cm = cy##contextMenus(menuConfigFA configs) in\n      configMenu <- Some cm;\n      hideAllConfigMenus cm configs\n\n    method private updateAllPoppers =\n      updateAllPoppers configsCounter\n\n    method private subscribeNodesPositionUpdate cy =\n      cy##on (Js.string \"position\") (Js.string \"node\")\n      (fun _ -> self#updateAllPoppers);\n\n      cy##on_3 (Js.string \"pan zoom resize\")\n      (fun _ -> self#updateAllPoppers);\n    \n    method private paintBestCurrentStep cy =\n      match self#getCurrConfigFromBestPath with\n        | None -> ()\n        | Some (currBestState, _ ) -> \n          if position <> (List.length bestPath)-1 \n            then Cytoscape.paintNode cy currBestState bestStateColor \n          else ()\n    \n    \n    method private setConfigsAndBestPath trail bestPathAutomaton acc exact time configVisited=\n      steps <- Array.of_list trail;\n      JS.log(\"METI OS STEPS\");\n      JS.log(steps);\n      (*let setConfigs = List.fold_left (fun c config -> \n        steps.(c) <- config;\n        c+1;\n        ) 0 trail in*)\n      (*let rec setConfigs configs position =\n        match configs with\n          | [] -> ()\n          | configs :: cs ->\n            steps.(position) <- configs;\n            setConfigs cs (position + 1)\n      in\n      *)\n        bestPath <- bestPathAutomaton;\n        accepted <- acc;\n        exactResult <- exact;\n        acceptTime <- time;\n        visitedConfigs <- configVisited\n\n        method private setConfigsAndBestPath2 acc exact time configVisited=\n          accepted <- acc;\n          exactResult <- exact;\n          acceptTime <- time;\n          visitedConfigs <- configVisited\n    \n\n    method private destroyPopperDivs =\n      let cyDiv = Dom_html.getElementById \"cy\" in\n      let elems = Dom_html.document##getElementsByClassName (Js.string _popperDiv_) in\n      for _ = 0 to elems##.length - 1 do\n        let elem = elems##item 0 in\n        match Js.Opt.to_option elem with\n          | None -> ()\n          | Some r ->\n          \t\tlet r = Js.Unsafe.coerce r in\n          \t\t\tDom.removeChild cyDiv r\n      done\n    \n    method private destroyAllPoppers =\n      destroyAllPoppers configsCounter;\n      self#destroyPopperDivs;\n      configsCounter <- []     \n\n    method private buildPoppersConfigsCounter cy configs =\n      self#destroyAllPoppers;\n      configsCounter <- buildConfigsCount cy configs\n\n    method private getCurrConfigFromBestPath = \n      if bestPath <> [] then Some (List.nth bestPath position) else None\n\n      \n      \n\n    method private showConfigurationMenu node =\n      if selectedNodeConfigMenu <> node then \n        match configMenu with\n          | None -> ()\n          | Some menu ->\n            let configs = steps.(position) in\n            let selectedNode = selectedNodeConfigMenu in\n              if selectedNode <> __none__ then \n                begin\n                  hideMenus menu configs selectedNode;\n                  selectedNodeConfigMenu <- __none__\n                end;\n              if Set.belongs (state node) (\n                Set.map (fun (a, _) -> a) configs\n              ) then\n                begin \n                  showMenus menu configs node;\n                  selectedNodeConfigMenu <- node;\n                end\n    \n    method private subscribeConfigEventMenu (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t): unit =\n      cy##on (Js.string \"mouseover\") (Js.string \"node\")\n                (fun evt -> \n                    match Js.Opt.to_option (evt##.target) with \n                    | None -> JS.log(\"Error, none node selected\")\n                    | Some t ->\n                      let target = Js.Unsafe.coerce t in\n                        self#showConfigurationMenu (Js.to_string target##data##.id)\n                )\n\n    method private initAllMenusAndFeatures cy configs =\n      self#updateConfigMenu cy configs;\n      self#buildPoppersConfigsCounter cy configs;\n      self#subscribeNodesPositionUpdate cy;\n      self#subscribeConfigEventMenu cy \n    \n    method private updateAllMenusAndFeatures cy configs =\n      self#buildPoppersConfigsCounter cy configs;\n      self#updateConfigMenu cy configs\n  \n    \n    \n    \n      \n      \n\n\n      \n\n\n    \n\n\nend\nend\n","(*\n * RegularExpressionView.ml\n *\n * This file is part of the OFLAT app\n *\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\n *\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\n *\n * This software is distributed under the terms of the GPLv3 license.\n * See the included LICENSE file for details.\n *\n *  Written by Rita Macedo\n *)\n\nopen OCamlFlat\nopen BasicTypes\nopen Js_of_ocaml\nopen Lang\nopen JS\n\nmodule RegularExpressionView =\nstruct\n\topen RegularExpression\n        \n      let cut s = (String.get s 0, String.sub s 1 ((String.length s)-1)) ;;\n    \n      let rec stringAsList s =\n            if s = \"\" then []\n            else\n                let (x,xs) = cut s in\n                    x::stringAsList xs\n        ;;\n        let nGetName = ref 0\n\n        let genName () = \n          let prefix = \"N\" in \n            nGetName := !nGetName + 1;\n            prefix ^ (string_of_int !nGetName)\n    \n      let rec isNotFail t = \n            match t with\n              Fail -> false\n              | Tree ([], re, []) -> true\n              | Tree (w, re, []) -> true\n              | Tree ([], re, x::xs) -> (isNotFail x) && (isNotFail (Tree ([], re, xs)))\n              | Tree (w, re, x::xs) -> (isNotFail x) && (isNotFail (Tree (w, re, xs)))\n    \n      class model (arg: t Arg.alternatives) =\n        object(self) inherit RegularExpression.model arg as super\n    \n          val mutable allTrees = [Fail]\n          val mutable rightTrees = [Fail]\n    \n          val mutable typeOfTree = \"wrong\"\n    \n          val mutable position = 0\n\n          val mutable accepted : bool = false\n          val mutable visitedConfigs : int = 0\n          val mutable exactResult : bool = false\n          val mutable acceptTime : float = 0.0\n          val mutable bestPath = []\n    \n          method stringAsList1 = stringAsList\n    \n          method countTree t = \n            match t with\n              Fail -> 0\n              | Tree (w, re, []) -> 1\n              | Tree (w, re, x::xs) -> (self#countTree x) + (self#countTree (Tree (w, re, xs)))\n    \n          method countRightTrees (w: word): int * int  = \n            let partition w = \n              let rec partX w pword =\n                match w with \n                  [] -> Set.empty\n                  | x::xs -> let fwp = pword@[x] in\n                          Set.add (fwp, xs) (partX xs fwp) in\n                 Set.add ([],w) (partX w []) in\t\t\n            \n            let rec acc w rep = \t\t\t\t\n              match rep with \n                | Plus(l, r) -> \n                    let (l1, l2) = acc w l in\n                    let (r1, r2) = acc w r in \n                      (l1 + r1, l2 + r2)\n                | Seq(l, r) -> let wps =  partition w in\n                          let wpl = Set.toList wps in \n                            List.fold_left (fun (a, b) (c,d) -> (a+c, b+d)) (0,0) (List.map (fun (wp1,wp2) -> \n                            let (sl, fl) = acc wp1 l in\n                            let (sr, fr) = acc wp2 r in\n                              (sl * sr, fl * fr + fl * sr + fr * sl)\n                            ) wpl)\t\t\t\t\t\t\t\n                | Star(re) -> if w = [] then \n                      (1,0)\n                    else \t\t\t\t\t\t \n                        (let wps = Set.remove ([],w) (partition w) in\n                          let wpl = Set.toList wps in \n                           List.fold_left (fun (a, b) (c,d) -> (a+c, b+d)) (0,0) (List.map (fun (wp1,wp2) -> \n                            let (sl, fl) = acc wp1 re in\n                            let (sr, fr) = acc wp2 (Star re) in\n                              (sl * sr, fl * fr + fl * sr + fr * sl)\n                            ) wpl))\t\t\t\t\t\t\t\n                | Symb(c) -> \n                    if w = [c] then \n                      (1,0)\n                    else \n                      (0,1)\n                | Empty -> \n                    if w = [] then\n                      (1,0) \n                    else\n                     (0,1)\n                | Zero -> (0,1)\n            in\t\n              \n              acc w self#representation\n    \n          method printTree t (cy: Cytoscape.cytoscape Js_of_ocaml.Js.t) =\n            match t with \n              Fail -> let rootName = genName () in \n                      Cytoscape.makeTreeNode cy rootName \"Fail\";\n                      rootName\n              | Tree ([], re, []) -> \"\"\n              | Tree ([], re, x::xs) -> let l = (self#printTree x cy) in\n                                        ignore ((self#printTree (Tree ([], re, xs)) cy));\n                                        l\n              | Tree (w, re, []) -> let rootName = genName () in \n                                    let text = String.concat \"\" (List.map symb2str w) in\n                                    let regex = RegularExpression.toString re in\n                                    let text1 = text ^ \"<=>\" ^ regex in\n                                    Cytoscape.makeTreeNode cy rootName text1;\n                                    rootName\n              | Tree (w, re, x::xs) -> let rootName = genName () in \n                                       let regex = RegularExpression.toString re in\n                                       let text = String.concat \"\" (List.map symb2str w) in\n                                       let text1 = text ^ \"<=>\" ^ regex in\n                                       let l = (self#printTree x cy) in \n                                       let l1 = (self#printTree (Tree ([], re, xs)) cy) in \n                                       Cytoscape.makeTreeNode cy rootName text1;\n                                       Cytoscape.makeTreeEdge cy rootName l;\n                                       if (l1 <> \"\") then\n                                          Cytoscape.makeTreeEdge cy rootName l1;\n                                       rootName\n    \n          method accept1 (w: word): reTree  = \n            let partition w = \n              let rec partX w pword =\n                match w with \n                  [] -> Set.empty\n                  | x::xs -> let fwp = pword@[x] in\n                          Set.add (fwp, xs) (partX xs fwp) in\n                 Set.add ([],w) (partX w []) in\t\t\n    \n            let rec reFind f l =\n              match l with \n                [] -> Fail\n                | x::xs -> let res = f x in \n                              if res = Fail then\n                                reFind f xs\n                              else res\tin\t\t\n            \n            let rec acc w rep = \t\t\t\t\n              match rep with \n                | Plus(l, r) -> \n                    let l1 = acc w l in\n                    let r1 = acc w r in \n                    if l1 = Fail then\n                      if r1 = Fail then \n                        Fail\n                      else \n                        Tree (w, rep, [r1])\n                    else \n                      Tree (w, rep, [l1])\n                | Seq(l, r) -> let wps =  partition w in\n                          let wpl = Set.toList wps in \n                          reFind (fun (wp1,wp2) -> \n                            let tl = acc wp1 l in\n                            let tr = acc wp2 r in\n                            if tl = Fail || tr = Fail then \n                              Fail\n                            else \n                              Tree (w, rep, [tl; tr])\n                            ) wpl\t\t\t\t\t\t\t\n                | Star(re) -> if w = [] then \n                      Tree (w, rep, []) \n                    else \t\t\t\t\t\t \n                        (let wps = Set.remove ([],w) (partition w) in\n                          let wpl = Set.toList wps in \n                          reFind (fun (wp1,wp2) -> \n                            let tl = acc wp1 re in\n                            let tr = acc wp2 (Star re) in\n                            if tl = Fail || tr = Fail then \n                              Fail\n                            else \n                              Tree (w, rep, [tl; tr])\n                            ) wpl)\n                | Symb(c) -> \n                    if w = [c] then \n                      Tree (w, rep, []) \n                    else \n                      Fail\n                | Empty -> \n                    if w = [] then\n                      Tree (w, rep, []) \n                    else\n                     Fail\n                | Zero -> Fail\n            in\t\n              \n              acc w self#representation     \n    \n          method getTrees w = \n          let partition w = \n              let rec partX w pword =\n                match w with \n                  [] -> Set.empty\n                  | x::xs -> let fwp = pword@[x] in\n                          Set.add (fwp, xs) (partX xs fwp) in\n                 Set.add ([],w) (partX w []) in\t\t\n            \n            let rec acc w rep = \t\t\t\t\n              match rep with \n                | Plus(l, r) -> \n                    let l1 = acc w l in\n                    let r1 = acc w r in \n                      List.map (fun t -> Tree (w, rep, [t])) (l1 @ r1)\n                | Seq(l, r) -> let wps =  partition w in\n                          let wpl = Set.toList wps in \n                          List.flatten (List.map (fun (wp1, wp2) ->  \n                            let tl = acc wp1 l in\n                            let tr = acc wp2 r in\n                            List.flatten (List.map (fun x -> List.map (fun y -> Tree (w, rep, [x; y])) tr) tl)    \n                          ) wpl)\n                | Star(re) -> if w = [] then \n                      [Tree ([epsilon], rep, [])] \n                    else \t\t\t\t\t\t \n                        (let wps = Set.remove ([],w) (partition w) in\n                          let wpl = Set.toList wps in \n                            List.flatten (List.map (fun (wp1, wp2) ->  \n                            let tl = acc wp1 re in\n                            let tr = acc wp2 (Star re) in\n                            List.flatten (List.map (fun x -> List.map (fun y -> Tree (w, rep, [x; y])) tr) tl)    \n                          ) wpl))\n                | Symb(c) -> \n                    if w = [c] then \n                      [Tree (w, rep, [])]\n                    else \n                      [Tree (w, rep, [Fail])]\n                | Empty -> \n                    if w = [] then\n                      [Tree ([epsilon], rep, [])]\n                    else\n                     [Tree (w, rep, [Fail])]\n                | Zero -> [Tree (w, rep, [Fail])]\n            in\t\n              \n              acc w self#representation\n    \n          method startAllTrees w =\n            allTrees <- self#getTrees w;\n            position <- 0\n            \n          method next = \n            position <- position + 1;\n            if position > (List.length allTrees) -1 then\n              position <- 0;\n            List.nth allTrees position\n    \n          method back = \n            position <- position - 1;\n            if position < 0 then\n              position <- (List.length allTrees) - 1;\n            List.nth allTrees position\n    \n          method length =\n            List.length allTrees\n    \n          method position =\n            position +1 \n    \n          method getRightTrees =\n            let rightTrees = List.filter (fun x -> isNotFail x) allTrees in \n            allTrees <- rightTrees;\n            List.nth allTrees position\n    \n          method getWrongTrees =\n            List.nth allTrees position\n\n          method staticAccept word =\n            let acc = self#accept word in\n            let (exact, configVisited, time) = Model.stats() in\n            JS.log(\"set initial step\");\n            self#setConfigsAndBestPath2 acc exact time configVisited;\n\n            method staticAcceptFull word =\n              let (acc, bestPath, trail) = self#acceptFull word in\n              let (exact, configVisited, time) = Model.stats() in\n              JS.log(\"set initial step\");\n              self#setConfigsAndBestPath trail bestPath acc exact time configVisited;\n          \n          method staticGenerate len =\n            let res = self#generate len in\n            let (exact, configVisited, time) = Model.stats() in\n            exactResult <- exact;\n            acceptTime <- time;\n            visitedConfigs <- configVisited;\n            res\n\n          method returnStats =\n            (accepted, visitedConfigs, exactResult, acceptTime)\n\n          method displayTrace =\n              let makePath () : string list list =\n                let headers = [\"Trace\"; \"Current Derivative\"; \"Word To Consume\"] in\n                  headers :: HTMLTable.makeREPath bestPath 0\n              in\n              if not (HTMLTable.tableExists \"pathTable\") then (\n                let contents = makePath () in\n                (*expected string list list*)\n                HTMLTable.buildTable contents \"pathTable\" \"cy2\";\n                let tab = HTMLTable.fetchTable \"pathTable\" in\n                let lastRowIndex = List.length bestPath in\n                let rec paintCells step =\n                  match step with\n                  | n when n < 4 -> \n                    if accepted then HTMLTable.paint tab lastRowIndex step \"mediumseagreen\"\n                    else (HTMLTable.paint tab lastRowIndex step \"crimson\");\n                    paintCells (step+1);\n                  | n when n = 4 -> ()\n                in\n                paintCells 1; (*ignore step column*)\n                HTMLTable.changeDisplay tab \"\"\n              )   \n              else ()\n\n          method private setConfigsAndBestPath trail bestPathAutomaton acc exact time configVisited=\n            JS.log(\"METI OS STEPS\");\n            bestPath <- bestPathAutomaton;\n            accepted <- acc;\n            exactResult <- exact;\n            acceptTime <- time;\n            visitedConfigs <- configVisited\n\n            method private setConfigsAndBestPath2 acc exact time configVisited=\n              accepted <- acc;\n              exactResult <- exact;\n              acceptTime <- time;\n              visitedConfigs <- configVisited\n          \n        end\n    \n    end\n","(* \n * StateVariables.ml\n *\n * This file is part of the OFLAT app\n *\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\n *\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\n *\n * This software is distributed under the terms of the GPLv3 license.\n * See the included LICENSE file for details.\n *\n *  Written by Rita Macedo\n *)\n\n(* \n * Description: Model component of the application.\n *)\n\nopen OCamlFlat\nopen FiniteAutomatonView\nopen RegularExpressionView\n\nmodule StateVariables = \n    struct\n      (** -------------------------------  State Variables --------------------------------------- **)\n      (** Can be \"finite automaton\", \"regular expression\", \"info\", \"feedback\" or \"clean\" **)\n      let cyType = ref \"clean\"\n  \n      (** Can be \"finite automaton\", \"regular expression\", \"enumeration\", \"info\", \"verify\" or \"clean\" **)\n      let cy2Type = ref \"clean\"\n  \n      let cySize = ref 100\n  \n      let empty = ref \"ε\"\n\n      let automata = ref (new FiniteAutomatonView.model (Representation {\n        alphabet = Set.empty;\n        states = Set.make [\"START\"]; \n        initialState = \"START\";\n        transitions = Set.empty;\n        acceptStates = Set.empty\n      }))\n  \n      let automata1 = ref (new FiniteAutomatonView.model (Representation {\n        alphabet = Set.empty;\n        states = Set.make [\"STARTZ\"]; \n        initialState = \"STARTZ\";\n        transitions = Set.empty;\n        acceptStates = Set.empty\n      }))\n  \n      let re = ref (new RegularExpressionView.model (Representation Empty))\n  \n      let enum = ref (new Exercise.exercise (Representation {\n        problem = \"No exercise yet\";\n        inside = Set.empty;\n        outside = Set.empty;\n        properties = Set.empty;\n      }))\n  \n      let resultTree = ref false\n  \n      (** -------------------------------  Functions --------------------------------------- **)\n      \n      let changeAutomata res =\n        automata := res \n  \n      let returnAutomata () =\n        !automata\n  \n      let returnAutomataRE () =\n        automata\n  \n      let changeAutomata1 res =\n        automata1 := res \n  \n      let returnAutomata1 () =\n        !automata1\n  \n      let changeRe res =\n        re := res \n  \n      let changeEmpty symb =\n        empty := symb\n  \n      let returnEmpty () = !empty\n      \n      let returnRe () =\n        !re\n  \n      let returnReNR () =\n        re\n  \n      let changeEnum res =\n        enum := res \n  \n      let returnEnum () =\n        !enum\n  \n      let changeResultTree res =\n        resultTree := res \n  \n      let returnResultTree () =\n        !resultTree\n  \n      let changeCy1ToAutomaton () =\n        cyType := \"finite automaton\"\n  \n      let changeCy1ToRegex () =\n        cyType := \"regular expression\"\n  \n      let changeCy1ToText () =\n        cyType := \"info\"\n  \n      let changeCy1ToFeedback () =\n        cyType := \"feedback\"\n  \n      let cleanCy1Type () =\n        cyType := \"clean\"\n  \n      let getCy1Type() =\n        !cyType\n  \n      let getAutomatonType() = \"finite automaton\"\n  \n      let getRegexType() = \"regular expression\"\n  \n      let getEnumerationType() = \"enumeration\"\n  \n      let getInfoType() = \"info\"\n  \n       let getFeedbackType() = \"feedback\"\n  \n      let getVerifyType() = \"verify\"\n  \n      let getClean() = \"clean\"\n  \n      let changeCy2ToAutomaton () =\n        cy2Type := \"finite automaton\"\n  \n      let changeCy2ToRegex () =\n        cy2Type := \"regular expression\"\n  \n      let changeCy2ToEnumeration () =\n        cy2Type := \"enumeration\"\n  \n      let changeCy2ToInfo () =\n        cy2Type := \"info\"\n      \n      let changeCy2ToVerify () =\n        cy2Type := \"verify\"\n  \n      let cleanCy2Type () =\n        cy2Type := \"clean\"\n  \n      let getCy2Type() =\n        !cy2Type\n  \n      let completeSize() =\n        cySize := 100\n      \n      let halfSize() =\n        cySize := 45\n  \n    end\n","open OCamlFlat\nopen BasicTypes\nopen JS\nopen Js_of_ocaml\nopen Js.Opt\nopen Lang\nopen StateVariables\n\n\nopen ContextFreeGrammarBasicView\n\nmodule ContextFreeGrammarLL1View =\nstruct\n\topen ContextFreeGrammarBasic\n\topen ContextFreeGrammarLL1\n\n\ttype cfgTree2 = Leaf of string * symbol | Root of string * symbol * cfgTree2 list\n\ttype acceptStep = {\n\t\tsyntaxTable : syntaxTable;\n\t\tacceptedString: string;\n\t\tacceptTable : acceptTable;\n\t\trecognized : recognized;\n\t\taccepted: bool option;\n\t\tnodes: cfgTree2 list;\n\t\tcyId: string option\n\t}\n\t\n  let removeDollarFromWord w =\n    word2str (List.filter (fun c -> c <> dollar) (str2word w) )\n\n\t(**HTML entities**)\n  let htmlEpsilon = \"ε\" (*\"&epsilon;\"*)\n  let htmlArrow = \" → \" (*\" &rarr; \"*)\n  let htmlDollar = \"$\"\n  \n  (**IDs**)\n  let firstFollowTableId() = \"cfgFirstFollowTable\"\n  let parsingTableId() = \"cfgParsingTable\"\n  let parsingGuideTableId() = \"cfgGuideTable\"\n  let productionsTableId() = \"cfgProductionsTable\"\n  let productionsTableId2() = \"cfgProductionsTable2\"\n  \n  (**Classes**)\n  let bgSymbolColorClass = \"bgSymbolColor\"\n  let bgSymbolColorFail = \"bgSymbolColorFail\"\n  let bgRuleColor = \"bgRuleColor\"\n  let bgRuleColorFail = \"bgRuleColorFail\"\n  let monospaceClass = \"monospaceClass\"\n  let currentRow = \"currentRow\"\n  let stringSymbolRemove = \"stringSymbolRemove\"\n  let stringSymbolAdd = \"stringSymbolAdd\"\n  let wordAccepted = \"wordAccepted\"\n  let wordRejected = \"wordRejected\"\n\n  (**HTML helpers**)\n  let doc = Dom_html.document\n\n\n  let createHtmlTable id =\n    let t = Dom_html.createTable doc in\n\t\tt##.id := Js.string id;\n\t\tt\n  \n  \n  (**Misc helper functions**)\n  let bodiesOfHead h rl =\n\t\tlet rls = Set.filter (fun r -> r.head = h) rl in\n\t\t\tSet.map (fun r -> r.body) rls\n\n\n  (*Shows symbols in a set*)\n  let setToHtmlString s =\n    let rec insideBracesString cs =\n      if cs = Set.empty then \"\"\n      else let (x,xs) = Set.cut cs in\n        let x = if x = epsilon then StateVariables.returnEmpty() else symb2str x in\n        x ^ (if xs = Set.empty then \"\" else \",\") ^ insideBracesString xs\n    in\n    \"{ \" ^ insideBracesString s ^ \" }\"\n\n  \n  let rec doWordGenerateEmptyX w seen (rep:t) =\n    let rec doGenerateEmpty x =\n      if List.mem x seen\n      then false\n      else(\n\t\t    let bodies = bodiesOfHead x rep.rules in\n\t\t    Set.exists (fun b -> doWordGenerateEmptyX b (x::seen) rep) bodies \n\t\t  )\n\t\tin      \n      List.for_all doGenerateEmpty w\n  \n  \n  let doWordGenerateEmpty w (rep:t) =\n    doWordGenerateEmptyX w [] rep\n\n\n  let first f (rep:t) =\n    let rec setString vars =\n      if vars = Set.empty then \"\"\n      else let (x,xs) = Set.cut vars in\n        let firstSet = f [x] in\n          Lang.i18nCFGFirst() ^ \"(\" ^ (word2str [x]) ^ \") = \" ^ setToHtmlString firstSet ^ \"<br>\" ^ setString xs\n        in\n      setString rep.variables    \n\n\n  let follow f (rep:t) =\n    let rec setString vars =\n      if vars = Set.empty then \"\"\n      else let (x,xs) = Set.cut vars in\n        let followSet = f x in\n        Lang.i18nCFGFollow() ^ \"(\" ^ (symb2str x) ^ \") = \" ^ setToHtmlString followSet ^ \"<br>\" ^ setString xs\n    in\n    setString rep.variables\n\n\n(**-----------------------------Element creation-----------------------------**)\n  let createGrammarTableHtml (rep:t) id =\n    let rec fillRule row bodies =\n      if bodies = Set.empty then ()\n      else let (x,xs) = Set.cut bodies in\n        let span = Dom_html.createSpan doc in\n    (* talvez visualização!!! JOAO CARLOS VER! perceber... era: span##.innerHTML := Js.string (if x = [] then StateVariables.returnEmpty() else word2str x); *)\n          span##.textContent := Js.some (Js.string (if x = [] then StateVariables.returnEmpty() else word2str x));\n          span##.classList##add (Js.string monospaceClass);\n          HTMLTable.appendChildtoRow row span;\n        if xs = Set.empty then fillRule row xs\n        else (\n          let orSpan = Dom_html.createSpan doc in\n            orSpan##.innerHTML := Js.string \" | \";\n            orSpan##.classList##add (Js.string monospaceClass);\n            HTMLTable.appendChildtoRow row orSpan;\n            fillRule row xs\n        )\n    in\n    let fillRow table head bodies =\n      let open ViewUtil in\n      let head = symb2str head in\n      let escapedHeadStr = (* PEDRO CARLOS *)\n        head\n        |> ViewUtil.replace_str '&' \"&amp;\"\n        |> ViewUtil.replace_str '<' \"&lt;\"\n        |> ViewUtil.replace_str '>' \"&gt;\"\n      in\n      let row = HTMLTable.insertRow table in\n      let _ = HTMLTable.insertCell row (escapedHeadStr ^ \"Prods\") (escapedHeadStr) in\n      let _ = HTMLTable.insertCell row htmlArrow htmlArrow in\n        fillRule row bodies in\n    let nonInitialRules = Set.map (fun r -> r.head) rep.rules in\n    let nonInitialRules = Set.filter (fun h -> h <> rep.initial) nonInitialRules in\n    let id = if id = \"\" then productionsTableId() else id in\n      let table = HTMLTable.fetchTable id in\n      fillRow table rep.initial (bodiesOfHead rep.initial rep.rules);\n      Set.iter (fun head -> fillRow table head (bodiesOfHead head rep.rules)) nonInitialRules\n\n\n  let createParsingTableGuideHtml () =\n    let tableHeader = [\n      (\"cfgGuideTableRecognized\", (Lang.i18nAcceptRecognized()));\n      (\"cfgGuideTableInput\", (Lang.i18nAcceptInput()));\n      (\"cfgGuideTableStack\", (Lang.i18nAcceptStack()));\n      (\"cfgGuideTableProduction\", (Lang.i18nAcceptProduction()));\n    ] in\n\t\tlet table = HTMLTable.fetchTable(parsingGuideTableId()) in\n    let row = HTMLTable.insertRow table in\n    (**First row**)\n    List.iter (fun (id, txt) -> \n      let _ = HTMLTable.insertCell row id txt in ();\n    ) tableHeader\n\n\n  let createFirstAndFollowTableHtml (rep: ContextFreeGrammarBasic.t) firstF followF =\n    let table = HTMLTable.fetchTable(firstFollowTableId()) in\n    let row = HTMLTable.insertRow table in\n    let _ = HTMLTable.insertCell row \"\" \"\" in\n    let _ = HTMLTable.insertCell row \"cfgFirstLabel\" (Lang.i18nCFGFirst()) in\n    let _ = HTMLTable.insertCell row \"cfgFollowLabel\" (Lang.i18nCFGFollow()) in\n    Set.iter ( fun v ->\n      let newRow = HTMLTable.insertRow table in\n      let _ = HTMLTable.insertCell newRow (symb2str v) (symb2str v) in\n      let _ = HTMLTable.insertCell newRow (setToHtmlString (firstF [v])) (setToHtmlString (firstF [v])) in\n      let _ = HTMLTable.insertCell newRow (setToHtmlString (followF v)) (setToHtmlString (followF v)) in ();\n    ) rep.variables\n\n\n  let createParsingTableHtml (rep:t) cPTF =\n    let rec prods2span cell l var =\n      if l = Set.empty then ()\n      else let (x,xs) = Set.cut l in\n        match x with\n        | None -> prods2span cell xs var\n        | Some x -> \n            let varSpan = Dom_html.createSpan doc in\n              varSpan##.innerHTML := Js.string (symb2str var);\n              varSpan##.classList##add (Js.string monospaceClass);\n            let arrowSpan = Dom_html.createSpan doc in\n              arrowSpan##.innerHTML := Js.string htmlArrow;\n              arrowSpan##.classList##add (Js.string monospaceClass);\n            let ruleSpan = Dom_html.createSpan doc in\n            let ruleStr = (\n              (if x = [] then StateVariables.returnEmpty() else word2str x)\n            ) in\n              ruleSpan##.innerHTML := Js.string (ruleStr ^\n              (if xs = Set.empty then \"\" else \"<br>\"));\n              ruleSpan##.classList##add (Js.string monospaceClass);\n            HTMLTable.appendChildtoCell cell varSpan;\n            HTMLTable.appendChildtoCell cell arrowSpan;\n            HTMLTable.appendChildtoCell cell ruleSpan;\n            prods2span cell xs var\n    in\n    let fillTable2 row var pTable =\n      let assocVar var a pTable =\n        Set.map (fun ((v,t),l) -> if v = var && t = a then Some l else None ) pTable\n      in\n        Set.iter ( fun a ->\n          let cell = HTMLTable.insertCell row ((symb2str a)^(symb2str var)) \"\" in\n          let assoc = assocVar var a pTable in\n            prods2span cell assoc var\n        ) rep.alphabet;\n      let dollarCell = HTMLTable.insertCell row ((symb2str dollar) ^ (symb2str var)) \"\" in\n      let dollarAssoc = assocVar var dollar pTable in\n        prods2span dollarCell dollarAssoc var\n    in\n    let fillTable table pTable =\n      Set.iter ( fun v ->\n        let varString = symb2str v in\n        let row = HTMLTable.insertRow table in\n        let _ = HTMLTable.insertCell row varString varString in\n        fillTable2 row v pTable\n      ) rep.variables\n    in\n    let parsingTable = cPTF in\n    let table = HTMLTable.fetchTable (parsingTableId()) in\n    let row = HTMLTable.insertRow table in\n    let _ = HTMLTable.insertCell row \"empty\" \"\" in (*Empty 1st cell *)\n    (**First row with alphabet and $**)\n      Set.iter (fun a -> let varString = symb2str a in\n                         let _ = HTMLTable.insertCell row varString varString in ()\n               ) rep.alphabet;\n    let _ = HTMLTable.insertCell row htmlDollar htmlDollar in\n    (**Rest of rows**)\n    fillTable table parsingTable\n\n(**-----------------------------Element paiting------------------------------**)\n  let paintGrammarTable step = \n    let clean row =\n    let rowElements = row##.childNodes in\n    for i = 0 to rowElements##.length - 1 do\n      let elem = rowElements##item i in\n        elem##.className := Js.string monospaceClass;\n    done\n    in\n    let paint () =\n      match step.accepted with\n        | Some a -> ()\n        | None -> \n          match step.syntaxTable.var with\n            | None -> ()\n            | Some var -> \n              match step.syntaxTable.rBody with\n                | None -> ()\n                | Some rule -> \n                  let rule = (if List.length rule = 0 then StateVariables.returnEmpty() else word2str rule) in\n                  let var = Dom_html.getElementById ((symb2str var) ^ \"Prods\") in\n                    var##.classList##add (Js.string \"bgSymbolColor\");\n                  let row = (Js.Unsafe.coerce var)##.parentElement in\n                    ignore (row##.classList##add (Js.string \"currentProds\"));\n                  let rowElements = row##.childNodes in\n                  for i = 2 to rowElements##.length - 1 do (*Not interested in var and arrow*)\n                    let prod = rowElements##item i in\n                    let prodString = Js.to_string (prod##.innerHTML) in\n                    if prodString = rule\n                    then prod##.classList##add (Js.string \"bgRuleColor\")\n                    else ()\n                  done\n    in\n    let currentProds = doc##getElementsByClassName (Js.string \"currentProds\") in\n    for i = 0 to currentProds##.length - 1 do (*Should be only one*)\n      let row = currentProds##item i in\n      match to_option row with\n        | None -> ()\n        | Some r -> let r = Js.Unsafe.coerce r in \n                      clean r\n    done;\n        paint()\n    \n    \n  let paintWord step =\n    let elem = Dom_html.getElementById \"cfgAcceptWord\" in\n    let accepted = step.recognized.recog in\n    let input = step.acceptTable.input in\n    let prod = step.acceptTable.production in\n    let toAccept =\n      match step.accepted with\n      | None -> if String.length accepted > 0 && String.length input > 0 && String.length prod = 0 \n                then String.sub input 1 ((String.length input) - 1)\n                else input\n      | Some a ->\n          match a with\n          | true -> \"\"\n          | false -> input\n    in\n      elem##.innerHTML := Js.string (accepted ^ \"|\" ^ toAccept);\n    match step.accepted with\n      | None -> elem##.className := (Js.string \"\")\n      | Some a -> if a \n                  then elem##.classList##add (Js.string \"wordAccepted\")\n                  else elem##.classList##add (Js.string \"wordRejected\")\n    \n    \n  let paintParsingTableHtmlGuide step currPos =\n    let splitWord s =\n      if String.length s > 0\n      then\n        let first = String.sub s 0 1 in\n        let rest = String.sub s 1 ((String.length s)-1) in\n          (first,rest)\n        else (\"\",\"\")\n    in\n    let splitRule s =\n      if String.length s > 0 \n      then let var = String.sub s 0 1 in\n           let rule = String.split_on_char '>' s in\n           let rule = String.trim (List.hd (List.rev rule)) in\n           let rule = \n             match rule with\n               | \"\" -> StateVariables.returnEmpty()\n               | s -> s\n           in\n           (var ^ htmlArrow, rule)\n      else (\"\",\"\")\n    in\n    let splitRecognize s =\n      if String.length s > 1\n      then\n        let rest = String.sub s 0 ((String.length s)-1) in \n        let last = String.sub s ((String.length s)-1) 1  in\n          (rest,last)\n      else if String.length s > 0\n            then\n            let last = String.sub s ((String.length s)-1) 1 in\n              (\"\",last)\n            else (\"\",\"\")\n    in\n    let clean () =\n      let rowsWithClass = doc##getElementsByClassName (Js.string \"currentRow\") in\n      for i = 0 to rowsWithClass##.length - 1 do\n        let row = to_option (rowsWithClass##item i) in\n        match row with\n          | None -> ()\n          | Some r -> r##.classList##remove (Js.string \"currentRow\");\n                      let cells = r##.childNodes in\n                      for j = 0 to cells##.length - 1 do\n                        let cell = to_option (cells##item j) in\n                          match cell with\n                            | None -> ()\n                            | Some c -> (Js.Unsafe.coerce c)##.classList := (Js.string \"\");\n                                        let spans = c##.childNodes in\n                                        for k = 0 to spans##.length - 1 do\n                                          let span = to_option (spans##item k) in\n                                          match span with\n                                            | None -> ()\n                                            | Some s -> let s = Js.Unsafe.coerce s in\n                                                        s##.classList := (Js.string monospaceClass);\n                                        done\n                      done\n      done\n    in\n    let paint table = \n      let currentRow = table##.rows##item (currPos+1) in (*Ignore table headers*)\n      match to_option currentRow with\n        | None -> ();\n        | Some r ->   r##.classList##add (Js.string \"currentRow\");\n                    let recogCell = r##.cells##item 0 in\n                    let inputCell = r##.cells##item 1 in\n                    let stackCell = r##.cells##item 2 in\n                    let prodCell = r##.cells##item 3 in\n                      recogCell##.innerHTML := Js.string \"\";\n                      inputCell##.innerHTML := Js.string \"\";\n                      stackCell##.innerHTML := Js.string \"\";\n                      prodCell##.innerHTML := Js.string \"\";\n                    let term = step.syntaxTable.term in\n                    let var = step.syntaxTable.var in\n                    let prod = step.acceptTable.production in\n                    let (s1,s2) = splitWord step.acceptTable.input in\n                    let (s3,s4) = splitWord step.acceptTable.stack in\n                    let s1Span = Dom_html.createSpan doc in\n                      s1Span##.classList##add (Js.string monospaceClass);\n                    let s2Span = Dom_html.createSpan doc in\n                      s2Span##.classList##add (Js.string monospaceClass);\n                    let s3Span = Dom_html.createSpan doc in\n                      s3Span##.classList##add (Js.string monospaceClass);\n                    let s4Span = Dom_html.createSpan doc in\n                      s4Span##.classList##add (Js.string monospaceClass);\n                    let s5Span = Dom_html.createSpan doc in\n                      s5Span##.classList##add (Js.string monospaceClass);\n                    let s6Span = Dom_html.createSpan doc in\n                      s6Span##.classList##add (Js.string monospaceClass);\n                    match (term, var) with\n                      | (None, None) -> (*When the same symbol is found on input and stack*)\n                        let (s5,s6) = splitRecognize step.recognized.recog in\n                          s5Span##.innerHTML := Js.string s5;\n                          s6Span##.innerHTML := Js.string s6;\n                          recogCell##appendChild s5Span;\n                          recogCell##appendChild s6Span;\n                          s1Span##.innerHTML := Js.string s1;\n                          inputCell##appendChild s1Span;\n                          s2Span##.innerHTML := Js.string s2;\n                          inputCell##appendChild s2Span;\n                        (match step.accepted with\n                        | None -> \n                          if step.recognized.recog = \"\" &&\n                              step.acceptTable.input <> \"\" &&\n                              step.acceptTable.stack <> \"\" &&\n                              step.acceptTable.production = \"\" \n                          then (\n                            () (*Don't paint first line*)\n                          ) else (\n                            s6Span##.classList##add (Js.string \"stringSymbolAdd\");\n                            s1Span##.classList##add (Js.string \"stringSymbolRemove\");\n                            s3Span##.innerHTML := Js.string s3;\n                            s3Span##.classList##add (Js.string \"stringSymbolRemove\");\n                            stackCell##appendChild s3Span;\n                            s4Span##.innerHTML := Js.string s4;\n                            stackCell##appendChild s4Span\n                          )\n                        | Some a -> \n                          stackCell##.innerHTML := Js.string step.acceptTable.stack;\n                          (match a with\n                          | true -> s5Span##.classList##add (Js.string \"stringSymbolAdd\");\n                                    s6Span##.classList##add (Js.string \"stringSymbolAdd\")\n                          | false -> inputCell##.classList##add (Js.string \"bgRuleColorFail\");\n                                     stackCell##.classList##add (Js.string \"bgRuleColorFail\")\n                          )\n                        );\n                          prodCell##.innerHTML := Js.string prod\n                      | (Some i1, Some i2) -> (*When a rule was found with terminal i1 and veriable i2*) \n                        let (s5,s6) = splitRule prod in\n                          recogCell##.innerHTML := Js.string step.recognized.recog;\n                            \n                          s1Span##.innerHTML := Js.string s1;\n                          s1Span##.classList##add (Js.string \"bgSymbolColor\");\n                          inputCell##appendChild s1Span;\n                          s2Span##.innerHTML := Js.string s2;\n                          inputCell##appendChild s2Span;\n\n                          s3Span##.innerHTML := Js.string s3;\n                          s3Span##.classList##add (Js.string \"bgSymbolColor\");\n                          stackCell##appendChild s3Span;\n                          s4Span##.innerHTML := Js.string s4;\n                          stackCell##appendChild s4Span;\n                            \n                          s5Span##.innerHTML := Js.string s5;\n                          prodCell##appendChild s5Span;\n                          s6Span##.innerHTML := Js.string s6;\n                          s6Span##.classList##add (Js.string \"bgRuleColor\");\n                          prodCell##appendChild s6Span;\n                          match step.accepted with\n                          | None -> ()\n                          | Some a ->\n                            match a with \n                            | true -> ()\n                            | false -> prodCell##.classList##add (Js.string \"bgRuleColorFail\")\n    in\n    let process (table: _ Js.t) = \n      clean();\n      paint table\n    in\n    let table = HTMLTable.fetchTable(parsingGuideTableId()) in\n    HTMLTable.lowLevelApply table process\n\n\n\n  let paintParsingTableHtml term var =\n    let paintSpans ?(clean = false) cell =\n      let paintSpan spanNode spanClass =\n        match to_option spanNode with\n        | None -> ()\n        | Some s -> s##.className := Js.string spanClass\n      in\n      let varStr = if clean then monospaceClass else \"bgSymbolColor\" ^ \" \" ^ monospaceClass in\n      let ruleStr = if clean then monospaceClass else \"bgRuleColor\" ^ \" \" ^ monospaceClass in\n      let spanNodeList = cell##.childNodes in\n        paintSpan (spanNodeList##item 0) varStr;\n        paintSpan (spanNodeList##item 2) ruleStr\n    in\n    let clean cell =\n      paintSpans ~clean:true cell\n    in\n    let term = match term with | None -> \"\" | Some t -> symb2str t in\n    let var = match var with | None -> \"\" | Some v -> symb2str v in\n    let rowProcess table =\n    let rows = table##.rows in\n    for i = 0 to rows##.length - 1 do \n      let r = rows##item i in \n      match to_option r with \n       | None -> ()\n        | Some r -> let cells = r##.cells in \n                   for i = 0 to (cells##.length - 1) do\n                     let c = cells##item i in\n                     let b1 = (Js.to_string c##.id) = term || (Js.to_string c##.id) = var in\n                     let b2 = (Js.to_string c##.id) = (term ^ var) in\n                     if b1 || b2\n                     then (\n                       if b1 \n                       then c##.className := Js.string (\"bgSymbolColor\" ^ \" \" ^ monospaceClass)\n                       else (if Js.to_string c##.innerHTML = \"\" \n                              then c##.className := Js.string \"bgRuleColorFail\"\n                              else (paintSpans c; c##.className := Js.string \"currentRow\")\n                            )\n                       )\n                    else (\n                      clean c;\n                      c##.className := Js.string monospaceClass\n                    )\n                    done\n    done\n    in\n    let process (table: _ Js.t) =\n       rowProcess table \n    in\n    let table = HTMLTable.fetchTable(parsingTableId()) in\n    HTMLTable.lowLevelApply table process\n    \n\n\n  let addNode tree newNode =\n    let rec addNodeToTree tree toAdd newNode =\n      let rec addNodeToTree2 treeList newNode =\n        List.map (fun t -> addNodeToTree t toAdd newNode) treeList\n      in\n    match tree with\n    | Leaf (a,b) -> Leaf (a,b)\n    | Root (a,b,c) -> if List.length c <> 0 \n                    then Root (a,b,addNodeToTree2 c newNode) \n                    else if !toAdd \n                          then (toAdd := false; Root (a,b,newNode))\n                          else Root (a,b,c)\n    in\n    let x = ref true in\n    addNodeToTree tree x newNode\n  \n    \n  let buildTree stepsList =\n    let treeRoot = List.hd (List.hd stepsList) in\n    let stepsList = List.tl stepsList in\n    let rec buildTree2 tree stepsList =\n      match stepsList with\n      | [] -> tree\n      | x::xs -> buildTree2 (addNode tree x) xs\n    in\n    buildTree2 treeRoot stepsList\n\n\n  let addNodesToParent cy nodes parent =\n    let addNodesAux a nClass b parent =\n      Cytoscape.add_node cy a nClass \"\" b;\n      match parent with\n       |None -> ()\n       |Some n -> Cytoscape.add_edge cy n a \"\"\n    in\n    let rec addNodes n parent =\n      match n with\n        | [] -> ()\n        | x::xs -> \n            match x with\n              | Leaf (a,b) -> let b = if b = epsilon \n                                      then StateVariables.returnEmpty()\n                                      else (symb2str b) in\n                                addNodesAux a \"leaf\" b parent;\n                                addNodes xs parent\n              | Root (a,b,c) -> addNodesAux a \"root\" (symb2str b) parent;\n                                addNodes xs parent\n    in\n    addNodes nodes parent;\n    Cytoscape.run_layout (cy##layout Cytoscape.cfglayout)\n\n\n  let paintNodes cy step =\n    let clean cy =\n      cy##elements##removeClass (Js.string \"selected childrenSelected epsilon\");\n    in\n    let paint cy step =\n      match step.cyId with\n      | None -> (match step.accepted with\n                | None -> \n                  (match Js.Optdef.to_option (Js.array_get (cy##elements) 0) with\n                  | None -> ()\n                  | Some elem -> \n                    (*Case for only highlighting root node*)\n                    elem##addClass (Js.string \"childrenSelected\"))\n                | Some a -> if a \n                            then (\n                              let baseElems = \n                                cy##nodes (Js.string \"node[nodeType = \\'leaf\\']\")\n                              in\n                              baseElems##\n                              (difference (Js.string (\"node[label = \\'\" ^ StateVariables.returnEmpty() ^ \"\\']\")))##\n                              addClass (Js.string \"childrenSelected\");\n                              baseElems##\n                              (difference (Js.string (\"node[label != \\'\" ^ StateVariables.returnEmpty() ^ \"\\']\")))##\n                              addClass (Js.string \"epsilon\")\n                            ) else (\n                              ()\n                            )\n                )\n      | Some s -> \n          let node = cy##getElementById (Js.string s) in\n            if Js.to_string node##data##.nodeType = \"leaf\"\n            then (\n              node##addClass (Js.string \"childrenSelected\")\n            )\n            else (\n              node##addClass (Js.string \"selected\");\n              node##outgoers##addClass (Js.string \"childrenSelected\")\n            )\n    in\n    clean cy;\n    paint cy step\n                                  \n\n  let acceptListNoRepeats (acceptList:ContextFreeGrammarLL1.acceptStep list) =\n    let repeatsTbl = Hashtbl.create 10 (**TODO initial table size**) in\n    let getRepeatNum c repeatsTbl =\n      let repeat = Hashtbl.find_opt repeatsTbl c in\n      match repeat with\n      | None -> Hashtbl.add repeatsTbl c 1; 0\n      | Some a -> Hashtbl.add repeatsTbl c (a+1); a\n    in\n    List.map ( fun {ContextFreeGrammarLL1.syntaxTable; acceptedString; acceptTable; recognized; accepted; nodes} -> \n        let nodes = List.map (fun f -> match f with\n               | ContextFreeGrammarBasic.Leaf a -> let id = (symb2str a ^ string_of_int (getRepeatNum a repeatsTbl)) in\n                                      Leaf (id,a) \n               | ContextFreeGrammarBasic.Root (a,b) -> let id = (symb2str a ^ string_of_int (getRepeatNum a repeatsTbl)) in\n                                      Root (id,a,[])\n          ) nodes in\n        let cyId = None in\n      { \n        (*ContextFreeGrammarLL1View.*)syntaxTable;\n        acceptedString;\n        acceptTable;\n        recognized;\n        accepted; \n        nodes;\n        cyId\n      }\n    ) acceptList\n  \n  \n  let rec sliceTree l p =\n    match l with\n    | [] -> []\n    | t::xs -> if p <= 0 then [t.nodes] else t.nodes::sliceTree xs (p-1)\n\n\n  let rec sliceList l p =\n    match l with\n    | [] -> []\n    | t::xs -> if p <= 0 then [t] else t::sliceList xs (p-1)\n    \n    \n  let treeNoRepeats (acceptList:(*ContextFreeGrammarLL1View.*)acceptStep list) =\n    let tree = buildTree (sliceTree acceptList (List.length acceptList)) in\n    let rec repeatTree tree =\n      match tree with\n      | Leaf (a,b) -> [a]\n      | Root (a,b,c) -> [a]@List.flatten (List.map (repeatTree) c);\n    in\n    repeatTree tree\n\n\n  let insertStep table step evtMethod =\n    let row = HTMLTable.insertRow table in\n      (match step.cyId with\n        | None -> HTMLTable.addEventListener row \"click\" \n                  (fun evt -> let row = evt##.currentTarget in evtMethod (row##.rowIndex - 1))\n                    \n        | Some id -> HTMLTable.modifyRowId row id;\n                     HTMLTable.addEventListener row \"click\" \n                     (fun evt -> let row = evt##.currentTarget in evtMethod (row##.rowIndex - 1))\n                      \n      );\n    let recognized = step.recognized in\n    let acceptTable = step.acceptTable in\n    let _ = HTMLTable.insertCell row \"\" (recognized.recog) in\n    let _ = HTMLTable.insertCell row \"\" (acceptTable.input) in\n    let _ = HTMLTable.insertCell row \"\" (acceptTable.stack) in\n    let _ = HTMLTable.insertCell row \"\" (acceptTable.production) in ()\n\n\n  let test acceptList tree =\n    let first = ref true in\n    let rec test2 acceptList tree =\n      match acceptList with\n      | [] -> []\n      | x::xs ->\n        if !first then (first := false; None::test2 xs tree)\n        else ( \n          match tree with\n          | Leaf (a,b) -> if b <> epsilon \n                          then [Some a]\n                          else []\n          | Root (a,b,c) -> Some a :: (List.flatten (List.map (test2 xs) c))\n        )\n    in\n    let steps = (test2 acceptList tree) in\n    steps@[None]\n\n\n  let checkAcceptError step alertError =\n    if !alertError\n    then (\n      match step.accepted with\n      | None -> ()\n      | Some a -> \n        let input = removeDollarFromWord step.acceptTable.input in\n        let stack = removeDollarFromWord step.acceptTable.stack in\n        alertError := false;\n        match a with\n        | true -> ()\n        | false -> if input = \"\" && stack <> \"\"\n                    then JS.alertStr (Lang.i18nAlertCFGAcceptNoInput())\n                    else (\n                      if input <> \"\" && stack = \"\"\n                      then JS.alertStr (Lang.i18nAlertCFGAcceptNoStack())\n                      else (\n                        JS.alertStr (Lang.i18nAlertCFGAcceptNoProduction())\n                      )\n                    )\n    )\n    \n\n  class model (arg: t Arg.alternatives) =\n    object(self) inherit ContextFreeGrammarBasicView.model arg as super\n\n      val mutable acceptList = []\n      val mutable currPos = 0 (*For knowing accept step state*)\n      val mutable maxPos = 0 (*Draw table until position maxPos*)\n      val mutable acceptList2 = []\n      val mutable isOver = false\n      val alertError = ref true (*For showing accept fail alert only once*)\n      val mutable transformationIndex = 0\n      val mutable transformations = [||]\n\n      method nSteps = \n        List.length acceptList2\n\n      method first1 =\n        first super#first super#representation\n\n      method follow1 =\n        follow super#follow super#representation\n\n      method createFirstAndFollowTableHtml =\n        createFirstAndFollowTableHtml super#representation (super#first) (super#follow)\n\n      method lookahead1 r =\n        let lookaheadSet = super#lookahead r in\n          setToHtmlString lookaheadSet\n\n      method createGrammarTableHtml id =\n        createGrammarTableHtml super#representation id\n\n      method createParsingTableHtml =\n        createParsingTableHtml super#representation self#createParsingTable\n\n      method private paintParsingTableHtml term var =\n        paintParsingTableHtml term var \n        \n      method createParsingTableGuideHtml =                \n        createParsingTableGuideHtml () \n      \n      method accept1 w = \n        acceptList <- self#acceptZ w;\n\n      method startAccept cy word =\n        let initListeners =\n          let epsilon = symb2str epsilon in\n          cy##on (Js.string \"click\") (Js.string \"node\") (\n            fun evt ->\n              let id =  \n                (match Js.Opt.to_option (evt##.target) with\n                | None -> \"\"\n                | Some b -> \n                  let b = Js.Unsafe.coerce b in\n                  if (Js.to_string b##data##.label) = epsilon\n                    then (\n                      (match Js.Optdef.to_option (Js.array_get (b##incomers (Js.string \"node\")) 0) with\n                      | None -> \"\" (*Should not happen*)\n                      | Some elem -> Js.to_string elem##data##.id\n                      )\n                    )\n                  else \n                    Js.to_string b##data##.id\n                ) in\n                let row = Dom_html.getElementById_opt id in\n                  match row with\n                  | None -> () (*Row may not exist yet*)\n                  | Some r -> \n                    let r = Js.Unsafe.coerce r in\n                    self#selectStep cy (r##.rowIndex - 1)\n          );\n          cy##on (Js.string \"mouseover\") (Js.string (\"node[label = \\'\" ^ epsilon ^ \"\\']\"))\n            (fun evt ->\n              let node = Js.Unsafe.coerce (match Js.Opt.to_option evt##.target with | None -> Dom_html.getElementById(\"\") (*Should not happen*) | Some n -> n) in\n              Console.console##log node\n            );\n        in\n        self#accept1 word;\n        acceptList2 <- acceptListNoRepeats acceptList;\n        let listWithIds = sliceList (test acceptList2 (buildTree (sliceTree acceptList2 (List.length acceptList2)))) ((List.length acceptList2) - 1) in\n        acceptList2 <- List.map2 (\n          fun {syntaxTable; acceptedString;\n            acceptTable; recognized;\n            accepted; nodes;\n            cyId} id -> \n              {syntaxTable; acceptedString;\n              acceptTable; recognized;\n              accepted; nodes;\n              cyId = id}\n        ) acceptList2 listWithIds;\n        currPos <- 0;\n        maxPos <- 0;\n        isOver <- false;\n        alertError := true;\n        initListeners;\n        let guide = Dom_html.getElementById \"cfgGuideTable\" in\n        guide##.innerHTML := Js.string \"\";\n        self#createParsingTableGuideHtml;\n        self#updateElements cy true\n      \n      method next cy =\n        (if currPos = List.length acceptList2 - 1\n          then (currPos <- currPos; isOver <- true)\n          else currPos <- currPos + 1);\n        if maxPos < currPos \n        then (maxPos <- currPos; self#updateElements cy true)\n        else self#updateElements cy false\n        \n      method back cy = \n        (if currPos <= 0\n          then currPos <- currPos\n          else currPos <- currPos - 1);\n        self#updateElements cy false\n\n      method private paintWord step =\n        paintWord step\n      \n      method private paintGrammarTable step =\n        paintGrammarTable step                     \n      \n      method private updateElements (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t) insert =\n        let step = List.nth acceptList2 currPos in\n          if insert && not isOver \n          then \n            let table = HTMLTable.fetchTable(\"cfgGuideTable\") in\n            (insertStep table (List.nth acceptList2 currPos) (self#selectStep cy);\n            addNodesToParent cy step.nodes step.cyId;\n          );\n          paintNodes (Js.Unsafe.coerce cy) step;\n          paintGrammarTable step;\n          paintWord step;\n          paintParsingTableHtmlGuide step currPos;\n          (*The following tables may not be visible, don't crash*)\n          (if (HTMLTable.tableExists (firstFollowTableId())) then (\n            let table = HTMLTable.fetchTable (firstFollowTableId()) in\n            if HTMLTable.tableFilled table (*if visible but not drawn, draw them*)\n            then (\n              self#createFirstAndFollowTableHtml;\n              self#createParsingTableHtml\n            );\n            paintParsingTableHtml (step.syntaxTable.term) (step.syntaxTable.var)\n          )\n          );\n        checkAcceptError step alertError\n\n\n      method clearCy (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t) =\n        Cytoscape.removeAllElements cy\n\n      method selectStep cy index =\n        currPos <- index;\n        self#updateElements cy false\n\n      method private newTransformation ( t : ContextFreeGrammarLL1.transformation list ) : unit =\n        let rec toView ( l : ContextFreeGrammarLL1.transformation list ) : (*ContextFreeGrammarLL1View.*)transformation list =\n          match l with\n          | [] -> []\n          | x::xs -> \n  (* AMD *)    let newModel = new ContextFreeGrammarBasic.model (Representation x.grammar#representation) in\n            { tType = x.tType; grammar = newModel }\n             :: toView xs\n        in\n        transformationIndex <- List.length t - 1;\n        let t = toView t in\n        transformations <- Array.of_list t\n\n      method clean1 =\n        let newGrammars = super#clean in\n        self#newTransformation newGrammars;\n        let pos = (List.length newGrammars - 1) in\n          transformations.(pos)\n\n      method removeLeftRecursion1 =\n        let newGrammar = super#removeLeftRecursion in\n        self#newTransformation [newGrammar];\n          transformations.(0)\n\n      method leftFactoring1 =\n        let newGrammar = super#leftFactoring in\n        self#newTransformation [newGrammar];\n          transformations.(0)\n\n      method removeEmptyProductions1 =\n        let newGrammar = super#removeEmptyProductions in\n        self#newTransformation [newGrammar];\n          transformations.(0)\n\n      method removeUnitProductions1 =\n        let newGrammar = super#removeUnitProductions in\n        self#newTransformation [newGrammar];\n          transformations.(0)\n\n      method getPreviousTransformed =\n        (if transformationIndex <= 0\n          then transformationIndex <- transformationIndex\n          else transformationIndex <- transformationIndex - 1);\n        transformations.(transformationIndex)\n      \n      method getNextTransformed =\n        (if transformationIndex = Array.length transformations - 1\n          then transformationIndex <- transformationIndex\n          else transformationIndex <- transformationIndex + 1);\n        transformations.(transformationIndex)\n\n      method transformToLL1X =\n        let newGrammars = super#transformToLL1 in\n        self#newTransformation newGrammars;\n        let pos = (List.length newGrammars - 1) in\n          transformations.(pos)\n\n      method toggleSimplified =\n        super#toggleSimplified\n    end\n  end\n","open OCamlFlat\nopen BasicTypes\nopen JS\nopen Js_of_ocaml\nopen Js.Opt\nopen Lang\nopen HTMLTable\nopen StateVariables\n\nopen ContextFreeGrammarLL1View\n\nmodule ContextFreeGrammarLRView\t\t\n=\nstruct\n\topen ContextFreeGrammarBasic\n\topen ContextFreeGrammarLR\n\n\ttype t = ContextFreeGrammarBasic.t\n\ttype cfgTree2 = Leaf of string * symbol | Root of string * symbol * cfgTree2 list\n\ttype syntaxTable = ContextFreeGrammarLL1.syntaxTable\n\ttype acceptTable = ContextFreeGrammarLL1.acceptTable\n\ttype recognized = ContextFreeGrammarLL1.recognized\n\ttype acceptStep = {\n\t\tsyntaxTable : syntaxTable;\n\t\tacceptedString: string;\n\t\tacceptTable : acceptTable;\n\t\trecognized : recognized;\n\t\taccepted: bool option;\n\t\tnodes: cfgTree2 list;\n\t\tcyId: string option\n\t}\n\n\tlet firstFollowTableId = ContextFreeGrammarLL1View.firstFollowTableId\n\tlet parsingTableId = ContextFreeGrammarLL1View.parsingTableId\n\tlet parsingGuideTableId = ContextFreeGrammarLL1View.parsingGuideTableId\n\tlet productionsTableId = ContextFreeGrammarLL1View.productionsTableId\n\tlet productionsTableId2 = ContextFreeGrammarLL1View.productionsTableId2\n\n\ttype lr0Item = LR0Grammar.lr0Item\t\n\ttype lr0State = LR0Grammar.lr0State\t\n\t\n\ttype stateName = LR0Grammar.stateName\n\t\n\ttype lr0StateId = LR0Grammar.lr0StateId \n\ttype lr0DiagramId = LR0Grammar.lr0DiagramId\n\t\n\ttype lr0Action = LR0Grammar.lr0Action\n\ttype lr0TableEntry = LR0Grammar.lr0TableEntry\n\ttype lr0Table = LR0Grammar.lr0Table\n\t\n\ttype lr0TableEntryExt = stateName * (symbol * stateName) set * lr0Action set\n\ttype lr0TableExt = lr0TableEntryExt set\n\t\n\ttype slr1Action = SLR1Grammar.slr1Action\n\ttype slr1TableEntry = SLR1Grammar.slr1TableEntry\n\ttype slr1Table = SLR1Grammar.slr1Table\n\t\n\t\n\ttype lr1Item = LR1Grammar.lr1Item\n\ttype lr1State = LR1Grammar.lr1State\n\ttype lr1Diagram = LR1Grammar.lr1Diagram\n\t\n\ttype lr1StateId = LR1Grammar.lr1StateId\n\ttype lr1DiagramId = LR1Grammar.lr1DiagramId\n\t\n\ttype lr1Action = LR1Grammar.lr1Action\n\ttype lr1TableEntry = LR1Grammar.lr1TableEntry\n\ttype lr1Table = LR1Grammar.lr1Table\n\t\n\t\n\tlet writeLR0StateItems (lr0state:lr0State)  = \n\t\tlet open LR0Grammar in\n\t\tList.map (fun it -> (symb2str it.head)  ^ \" →\" ^ \" \"  \n\t\t\t\t\t^ (word2str it.body1)  ^ \"•\"  \n\t\t\t\t\t^ (word2str it.body2)) (Set.toList lr0state)\n\t\t\t\t\t\n\tlet writeLR1StateItems (lr1state:lr1State)  = (* Depois alterar para LR1 *)\n\t\tlet open LR1Grammar in\n\t\tList.map (fun it -> (symb2str it.head)  ^ \" →\" ^ \" \"  \n\t\t\t\t\t^ (word2str it.body1)  ^ \"•\"  \n\t\t\t\t\t^ (word2str it.body2)  ^ \" ,{\"\n\t\t\t\t\t^ (word2str (Set.toList it.lookahead)) ^ \"}\") (Set.toList lr1state)\n\t\t\n\t\n\tlet inputLR0Nodes cy lr0Diagram = \n\t\tlet (statesId,transitions) = lr0Diagram in\n\t\tlet ids = Set.map fst statesId in\n\t\t\tSet.iter (fun id -> Cytoscape.addNode2 cy id false false) ids\n\t\t\t\n\tlet inputLR0NodesV2 cy lr0Diagram = \n\t\tlet (statesId,transitions) = lr0Diagram in\n\t\t\tSet.iter (fun (id,state) -> Cytoscape.addNode2 cy id false false; \n\t\t\t\t\t\t\t\t\t\tCytoscape.buildLR0NodeStyle cy id (writeLR0StateItems state)) statesId\n\t\t\n        \n       \n    let inputLR0Edges cy lr0Diagram =\n\t\tlet (statesId,transitions) = lr0Diagram in\n\t\t\tSet.iter (fun ((id1,_),symb,(id2,_)) -> (Cytoscape.addEdge cy (id1,symb2str symb,id2)) ) transitions\n\t\t\t\n\t\n\tlet inputLR1NodesV2 cy lr1Diagram = \n\t\tlet (statesId,transitions) = lr1Diagram in\n\t\tSet.iter (fun (id,state) -> Cytoscape.addNode2 cy id false false; \n\t\t\t\t\t\t\t\t\tCytoscape.buildLR0NodeStyle cy id (writeLR1StateItems state)) statesId\n\t\t\n        \n       \n    let inputLR1Edges cy lr1Diagram =\n\t\tlet (statesId,transitions) = lr1Diagram in\n\t\t\tSet.iter (fun ((id1,_),symb,(id2,_)) -> (Cytoscape.addEdge cy (id1,symb2str symb,id2)) ) transitions\n\n\n\n\tlet rec rev l =\n\t\tmatch l with\n\t\t| [] -> []\n\t\t| x::xs -> (rev xs) @ [x]\n\n\n\tlet actionToString action =\n\t\tlet open LR0Grammar in\n\t\tmatch action with\n\t\t| Accept -> \"Accept\"\n\t\t| Shift -> \"Shift\"\n\t\t| Reduce({head = h;body = b}) -> \n\t\t\t\tif(List.length b = 0) then \n\t\t\t\t\t(symb2str h) ^ \"→\" ^ StateVariables.returnEmpty()\n\t\t\t\telse\n\t\t\t\t\t(symb2str h) ^ \"→\" ^ (word2str b)\n\t\t\n\tlet slr1actionToString action =\n\t\tlet open SLR1Grammar in\n\t\tmatch action with\n\t\t| Accept -> \"Accept\"\n\t\t| Shift -> \"Shift\"\n\t\t| Reduce({head = h;body = b}) -> \n\t\t\t\tif(List.length b = 0) then \n\t\t\t\t\t(symb2str h) ^ \"→\" ^ StateVariables.returnEmpty()\n\t\t\t\telse\n\t\t\t\t\t(symb2str h) ^ \"→\" ^ (word2str b)\n\t\t\n\tlet lr1actionToString action =\n\t\tlet open LR1Grammar in\n\t\tmatch action with\n\t\t| Accept -> \"Accept\"\n\t\t| Shift -> \"Shift\"\n\t\t| Reduce({head = h;body = b}) -> \n\t\t\t\tif(List.length b = 0) then \n\t\t\t\t\t(symb2str h) ^ \"→\" ^ StateVariables.returnEmpty()\n\t\t\t\telse\n\t\t\t\t\t(symb2str h) ^ \"→\" ^ (word2str b)\n\n\n\tlet fillLR0Row row entry symbSet = (*symbSet is a set containg all variable and alphabet symbols *)\n\t\tlet (stateName,shifts,action) = entry in\n\t\tlet _ = HTMLTable.insertCell row stateName stateName in\n\t\tlet s = Set.iter ( fun symb -> (* Para cada simbolo, se existir uma transição possivel, preencher com o estado resultante *)\n\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = symb) shifts in\n\t\t\tif(Set.size targetShifts > 0) then \n\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\n\t\t\t\tlet _ = HTMLTable.insertCell row nextState nextState in ()\n\t\t) symbSet in\n\t\t(*Inserir ação LR0 no final da linha*)\n\t\tlet _ = HTMLTable.insertCell row (actionToString action) (actionToString action) in\n\t\t\ts\n\n\n\tlet createLR0ParsingTableHtml (cfg:t) = (* Não é usado atualmente, versão anterior que so retorna uma ação LR0 por coluna. *)\n\t\tlet table = HTMLTable.fetchTable(\"cfgParsingTable\") in\n\t\tlet lr0Table = LR0Grammar.getLR0Table cfg in\n\t\tlet row = HTMLTable.insertRow table in\n\t\t(*Inserir celula vazia *)\n\t\tlet _ = HTMLTable.insertCell row \"LR0\" \"LR0\" in\n\t\tlet symbSet = Set.union cfg.alphabet cfg.variables in\n\t\t(* criar header da tabela *)\n\t\t    Set.iter ( fun symb ->\n\t\t\tlet _ = HTMLTable.insertCell row (symb2str symb) (symb2str symb) in ();\n\t\t\t) symbSet;\n\t\t(*Inserir celula de ação LR0 *)\t\n\t\tlet _ = HTMLTable.insertCell row \"Action\" \"Action\" in ();\n\t\t\tSet.iter ( fun entry -> (* preencher linha correspondente a um estado, repetindo para todos os estados/linhas da tabela *)\n\t\t\t\tlet row = HTMLTable.insertRow table in\n\t\t\t\t\tfillLR0Row row entry symbSet\n\t\t\t) lr0Table;\n\t\t\t\n\t\tlet numberOfCells = (Set.size symbSet) + 2 in\n\t\tlet cellWidth = 50 in\n\t\tlet width = Printf.sprintf \"%d\" (numberOfCells*cellWidth) in\n\t\t\tHTMLTable.setWidth table width\n\n\t\t\n(* -------extended LR0 for clarity----------- Allows LR0 Tables to display multiple actions in each state line.*)\n\n\tlet rec concActionsLR0 actions =\n\t\tmatch actions with\n\t\t| [] -> \"\"\n\t\t| x::xs -> (actionToString x) ^ \"\\n\" ^ concActionsLR0 xs\n\n\n\tlet fillLR0RowExt row entry symbSet = (*symbSet is a set containg all variable and alphabet symbols *)\n\t\tlet (stateName,shifts,actionSet) = entry in\n\t\tlet _ = HTMLTable.insertCell row stateName stateName in\n\t\tlet s = Set.iter ( fun symb -> (* Para cada simbolo, se existir uma transição possivel, preencher com o estado resultante *)\n\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = symb) shifts in\n\t\t\tlet newCell1 = HTMLTable.insertCell row \"\" \"\" in\n\t\t\tif(Set.size targetShifts > 0) then \n\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\n\t\t\t\tlet _ = HTMLTable.modifyCell newCell1 nextState in ()\n\t\t) symbSet in\n\t\t(*Inserir ação LR0 no final da linha*)\n\t\tlet actionList = Set.toList actionSet in\n\t\t\t(*newCell1##.innerHTML := Js.string (actionToString action); *)\n\t\t\tlet newCell3 = HTMLTable.insertCell row (concActionsLR0 (Set.toList actionSet)) (concActionsLR0 (Set.toList actionSet)) in (* metodo para devolver o conjunto de ações em conflito em vez de CONF*)\n\t\t\tif(List.length actionList > 1) then\n\t\t\t\tlet newCell4 = HTMLTable.cToCell newCell3 in\n\t\t\t\tnewCell4##.style##.backgroundColor := (Js.string \"red\");\n\t\t\ts\n\t\t\n\t\t\n\tlet createLR0ParsingTableHtmlExt (cfg:t) =\n\t\tlet table = HTMLTable.fetchTable(\"cfgParsingTable\") in\n\t\tlet lr0Table = LR0Grammar.getLR0TableExt cfg in\n\t\tlet row = HTMLTable.insertRow table in\n\t\t(*Inserir celula vazia *)\n\t\tlet _ = HTMLTable.insertCell row \"LR0\" \"LR0\" in\n\t\tlet symbSet = Set.union cfg.alphabet cfg.variables in\n\t\t(* criar header da tabela *)\n\t\t    Set.iter ( fun symb ->\n\t\t\t\t\tlet _ = HTMLTable.insertCell row (symb2str symb) (symb2str symb) in ();\n\t\t\t) symbSet;\n\t\t(*Inserir celula de ação LR0 *)\t\n\t\tlet _ = HTMLTable.insertCell row \"Action\" \"Action\" in ();\n\t\t\tSet.iter ( fun entry -> (* preencher linha correspondente a um estado, repetindo para todos os estados/linhas da tabela *)\n\t\t\t\tlet row = HTMLTable.insertRow table in\n\t\t\t\t\tfillLR0RowExt row entry symbSet\n\t\t\t) lr0Table;\t\n\t\tlet numberOfCells = (Set.size symbSet) + 3 in\n\t\tlet cellWidth = 50 in\n\t\tlet width = Printf.sprintf \"%d\" (numberOfCells*cellWidth) in\n\t\t\tHTMLTable.setWidth table width\n\n\t(* ------- End of extended LR0 -----------*)\n\n\tlet rec concActions actions =\n\t\tmatch actions with\n\t\t| [] -> \"\"\n\t\t| x::xs -> (slr1actionToString x) ^ \"\\n\" ^ concActions xs\n\t\t\n\t\n\tlet rec concActionsLR1 actions =\n\t\tmatch actions with\n\t\t| [] -> \"\"\n\t\t| x::xs -> (lr1actionToString x) ^ \"\\n\" ^ concActionsLR1 xs\n\t\t\n\t\t\n\tlet fillSLR1Row row (entry:SLR1Grammar.slr1TableEntry) symbSet completeAlphabet = (*symbSet is a set containg all variable and alphabet symbols *)\n\t\tlet (stateName,shifts,actionSet) = entry in\n\t\tlet _ = HTMLTable.insertCell row stateName stateName in\n\t\tSet.iter ( fun symb -> (* Para cada simbolo, se existir uma transição possivel, preencher com o estado resultante *)\n\t\tlet newCell1 = HTMLTable.insertCell row \"\" \"\" in\n\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = symb) shifts in\n\t\t\tif(Set.size targetShifts > 0) then \n\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\n\t\t\t\tlet _ = HTMLTable.modifyCell newCell1 nextState in ()\n\t\t) symbSet;\n\t\t(*Inserir ação SLR1 no final da linha*)\n\t\t\n\t\t\tSet.iter ( fun symb -> \n\t\t\t\tlet symbActions = Set.filter( fun (s,a) -> s = symb && Set.size a > 0 ) actionSet in\n\t\t\t\tlet newCell1 = HTMLTable.insertCell row \"\" \"\" in\n\t\t\t\tif(Set.size symbActions > 0) then \n\t\t\t\t\tlet (symbol,actions) = Set.hd symbActions in (* atualmente está a falhar aqui, com hd failure *)\n\t\t\t\t\tlet action = Set.hd actions in\n\t\t\t\t\tlet newCell2 = HTMLTable.modifyCell newCell1 (slr1actionToString action) in\n\t\t\t\t\tif(Set.size actions > 1) then\n\t\t\t\t\tlet actionList = Set.toList actions in\n\t\t\t\t\tlet newCell2 = HTMLTable.modifyCell newCell2 (concActions (actionList)) in\n\t\t\t\t\t\tif(List.length actionList > 1) then\n\t\t\t\t\t\t\tlet newCell4 = HTMLTable.cToCell newCell2 in\n\t\t\t\t\t\tnewCell4##.style##.backgroundColor := (Js.string \"red\");\n\t\t\t\t\t\t(* newCell1##.style := Js.string \"red\"; *) (* maybe later *)\n\t\t\t\t\t\t(* newCell1##.innerHTML := Js.string (\"Conf\"); *)\n\t\t\t) completeAlphabet\n\t\t\t\t\n\t\n\tlet createSLR1ParsingTableHtml (cfg:t) =\n\t\tlet table = HTMLTable.fetchTable(\"cfgParsingTable\") in\n\t\tlet slr1Table = SLR1Grammar.getSLR1Table cfg in\n\t\tlet row = HTMLTable.insertRow table in\n\t\t(*Inserir celula vazia *)\t\n\t\tlet _ = HTMLTable.insertCell row \"SLR1\" \"SLR1\" in\n\t\tlet symbSet = Set.union cfg.alphabet cfg.variables in\n\t\t(* criar header da tabela *)\n\t\t    Set.iter ( fun symb ->\n\t\t\t\t\tlet _ = HTMLTable.insertCell row (symb2str symb) (symb2str symb) in ();\n\t\t\t) symbSet;\n\t\t(*Inserir celulas de ações para cada simbolo do alfabeto *)\t\n\t\t\n\t\tlet completeAlphabet = (Set.add dollar cfg.alphabet) in\n\t\t\n\t\t\tSet.iter (fun symb ->\n\t\t\t\tlet _ = HTMLTable.insertCell row (symb2str symb) (symb2str symb) in ();\n\t\t\t) completeAlphabet;\n\t\t\n\t\t\tSet.iter ( fun entry -> (* preencher linha correspondente a um estado, repetindo para todos os estados/linhas da tabela *)\n\t\t\tlet row = HTMLTable.insertRow table in\n\t\t\t\t\tfillSLR1Row row entry symbSet completeAlphabet\n\t\t\t) slr1Table;\n\t\t\t\n\t\tlet numberOfCells = (Set.size symbSet) + (Set.size completeAlphabet) + 1 in\n\t\tlet cellWidth = 50 in\n\t\tlet width = Printf.sprintf \"%d\" (numberOfCells*cellWidth) in\n\t\t\tHTMLTable.setWidth table width\n\t\t\t\n\t\n\t\n\tlet fillLR1Row row (entry:LR1Grammar.lr1TableEntry) symbSet completeAlphabet = (*symbSet is a set containg all variable and alphabet symbols *)\n\t\tlet (stateName,shifts,actionSet) = entry in\n\t\tlet _ = HTMLTable.insertCell row stateName stateName in\n\t\tSet.iter ( fun symb -> (* Para cada simbolo, se existir uma transição possivel, preencher com o estado resultante *)\n\t\t\tlet newCell1 = HTMLTable.insertCell row \"\" \"\" in\n\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = symb) shifts in\n\t\t\tif(Set.size targetShifts > 0) then \n\t\t\t\tlet (nextSymbol,nextState) = Set.nth targetShifts 0 in\n\t\t\tlet _ = HTMLTable.modifyCell newCell1 nextState in ()\n\t\t) symbSet;\n\t\t(*Inserir ação SLR1 no final da linha*)\n\t\t\n\t\t\tSet.iter ( fun symb -> \n\t\t\t\tlet symbActions = Set.filter( fun (s,a) -> s = symb && Set.size a > 0 ) actionSet in\n\t\t\t\tlet newCell1 = HTMLTable.insertCell row \"\" \"\" in\n\t\t\t\tif(Set.size symbActions > 0) then \n\t\t\t\t\tlet (symbol,actions) = Set.hd symbActions in \n\t\t\t\t\tlet action = Set.hd actions in\n\t\t\t\t\tlet newCell2 = HTMLTable.modifyCell newCell1 (lr1actionToString action) in\n\t\t\t\t\tif(Set.size actions > 1) then\n\t\t\t\t\tlet actionList = Set.toList actions in\n\t\t\t\t\t\tlet newCell3 = HTMLTable.modifyCell newCell2 (concActionsLR1 (actionList)) in (* metodo para devolver o conjunto de ações em conflito em vez de CONF, provavelmente esta será a opção futura correta *)\n\t\t\t\t\t\tif(List.length actionList > 1) then\n\t\t\t\t\t\t\tlet newCell4 = HTMLTable.cToCell newCell3 in\n\t\t\t\t\t\t\tnewCell4##.style##.backgroundColor := (Js.string \"red\");\n\t\t\t\t\t\t(* newCell1##.innerHTML := Js.string (\"Conf\"); *)\n\t\t\t) completeAlphabet\n\t\t\t\n\tlet createLR1ParsingTableHtml (cfg:t) =\n\t\tlet table = HTMLTable.fetchTable(\"cfgParsingTable\") in\n\t\tlet lr1Table = LR1Grammar.getLR1Table cfg in\n\t\tlet row = HTMLTable.insertRow table in\n\t\t(*Inserir celula vazia *)\t\n\t\tlet _ = HTMLTable.insertCell row \"LR1\" \"LR1\" in\n\t\tlet symbSet = Set.union cfg.alphabet cfg.variables in\n\t\t(* criar header da tabela *)\n\t\t    Set.iter ( fun symb ->\n\t\t\t\t\tlet _ = HTMLTable.insertCell row (symb2str symb) (symb2str symb) in ();\n\t\t\t) symbSet;\n\t\t(*Inserir celulas de ações para cada simbolo do alfabeto *)\t\n\t\t\n\t\tlet completeAlphabet = (Set.add dollar cfg.alphabet) in\n\t\t\n\t\t\tSet.iter (fun symb ->\n\t\t\t\tlet _ = HTMLTable.insertCell row (symb2str symb) (symb2str symb) in ();\n\t\t\t) completeAlphabet;\n\t\t\n\t\t\tSet.iter ( fun entry -> (* preencher linha correspondente a um estado, repetindo para todos os estados/linhas da tabela *)\n\t\t\t\tlet row = HTMLTable.insertRow table in\n\t\t\t\t\tfillLR1Row row entry symbSet completeAlphabet\n\t\t\t) lr1Table;\n\t\t\t\n\t\tlet numberOfCells = (Set.size symbSet) + (Set.size completeAlphabet) + 1 in\n\t\tlet cellWidth = 50 in\n\t\tlet width = Printf.sprintf \"%d\" (numberOfCells*cellWidth) in\n\t\t\tHTMLTable.setWidth table width\n\t\t\t\n\t\t\t\n\t\t\t\n\tlet createLALR1ParsingTableHtml (cfg:t) =\n\t\tlet table = HTMLTable.fetchTable(\"cfgParsingTable\") in\n\t\tlet lalr1Table = LALR1Grammar.getLALR1Table cfg in\n\t\tlet row = HTMLTable.insertRow table in\n\t\t(*Inserir celula vazia *)\t\n\t\tlet symbSet = Set.union cfg.alphabet cfg.variables in\n\t\t(* criar header da tabela *)\n\t\t    Set.iter ( fun symb ->\n\t\t\t\t\tlet _ = HTMLTable.insertCell row (symb2str symb) (symb2str symb) in ();\n\t\t\t) symbSet;\n\t\t(*Inserir celulas de ações para cada simbolo do alfabeto *)\t\n\t\t\n\t\tlet completeAlphabet = (Set.add dollar cfg.alphabet) in\n\t\t\n\t\t\tSet.iter (fun symb ->\n\t\t\t\tlet _ = HTMLTable.insertCell row (symb2str symb) (symb2str symb) in ();\n\t\t\t) completeAlphabet;\n\t\t\n\t\t\tSet.iter ( fun entry -> (* preencher linha correspondente a um estado, repetindo para todos os estados/linhas da tabela *)\n\t\t\t\tlet row = HTMLTable.insertRow table in\n\t\t\t\t\tfillLR1Row row entry symbSet completeAlphabet\n\t\t\t) lalr1Table;\n\t\t\n\t\tlet numberOfCells = (Set.size symbSet) + (Set.size completeAlphabet) + 1 in\n\t\tlet cellWidth = 50 in\n\t\tlet width = Printf.sprintf \"%d\" (numberOfCells*cellWidth) in\n\t\t\tHTMLTable.setWidth table width\n\n\n\n\tlet stringFromBool value =\n\t\tif value then\n\t\t\t\"True\"\n\t\telse\n\t\t\t\"False\"\n\t\t\t\n\tlet boolFromString value =\n\tmatch value with\n\t| \"Ongoing\" -> \"True\"\n\t| \"Aceite\" -> \"True\"\n\t| v -> \"False\"\n\n\n\tlet rec stringListToString l =\n\t\tmatch l with\n\t\t| [] -> \"\"\n\t\t| x::xs -> x ^ stringListToString xs\n\t\t\n\t(* type predictAction = | Error | Conflict | Accept | Shift | Reduce of rule (*Ou Normal of lr0Action*) *)\n\t\n\t\n\t\t\n\tlet parserPredictLR0Action word lr0Table revStack (cfg:t) :  string = \n\t\tlet currentState = int_of_string (List.hd revStack) in \n\t\tlet (_,shifts,(action:lr0Action)) = Set.nth lr0Table currentState in (* get corresponding table entry *)\t\t\n\t\tmatch action with\n\t\t| Shift -> \n\t\t\tbegin\n\t\t\t\tmatch word with\n\t\t\t\t| [] -> \"Error\"\n\t\t\t\t| s::_ -> \n\t\t\t\t\tif(Set.belongs s cfg.alphabet || Set.belongs s cfg.variables) then\n\t\t\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = s) shifts in\n\t\t\t\t\t\t\tif(Set.size targetShifts = 0) then \"Error\"\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\"Shift\"\n\t\t\t\t\telse\t\t\t\t\n\t\t\t\t\t\t\"Error\"\n\t\t\tend\n\t\t| Accept -> \n\t\t\tif (word = [dollar]) then\n\t\t\t\t\t\"Ac\"\n\t\t\t\telse \n\t\t\t\t\t\"Error\"\n\t\t| Reduce({head = h;body = b}) -> \n\t\t\t(symb2str h) ^ \"->\" ^ (word2str b)\n\t\t\t\t\n\tlet rec parserPredictSLR1Action word slr1Table revStack (cfg:t) :  string = \n\t\tlet currentState = int_of_string(List.hd revStack) in \n\t\tlet (id,shifts,actionSet) = Set.nth slr1Table currentState in (* get corresponding table entry *)\n\t\tlet topSymbol = List.nth word 0 in\n\t\t\tif(Set.belongs topSymbol cfg.variables) then (*Fazemos um Shift com uma variavel -> Goto*)\n\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = topSymbol) shifts in\n\t\t\t\t\tif(Set.size targetShifts = 0) then \"Error\"\n\t\t\t\t\telse\n\t\t\t\t\t\t\"Shift\"\n\t\t\telse \n\t\t\t\tlet peekedSymbol = List.nth word 0 in\n\t\t\t\tlet peekedsymbolAndActions = Set.filter( fun (s,a) -> s = peekedSymbol && Set.size a > 0 ) actionSet in\n\t\t\t\tlet nEntries = Set.size peekedsymbolAndActions in\n\t\t\t\t\tif nEntries = 0 then \n\t\t\t\t\t\t\"Error\"\n\t\t\t\t\telse if nEntries > 1 then\n\t\t\t\t\t\t\"Conflict\"\n\t\t\t\t\telse\n\t\t\t\t\t\tlet (symbol,actions) = Set.hd peekedsymbolAndActions in (* atualmente está a falhar aqui, com hd failure *)\n\t\t\t\t\t\tlet (action:slr1Action) = Set.hd actions in\n\t\t\t\t\t\tmatch action with\n\t\t\t\t\t\t| Shift -> \n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tmatch word with\n\t\t\t\t\t\t\t\t| [] -> \"Error\"\n\t\t\t\t\t\t\t\t| s::_ -> \n\t\t\t\t\t\t\t\t\tif(Set.belongs s cfg.alphabet || Set.belongs s cfg.variables) then\n\t\t\t\t\t\t\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = s) shifts in\n\t\t\t\t\t\t\t\t\t\t\tif(Set.size targetShifts = 0) then \"Error\"\n\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t\"Shift\"\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\"Error\"\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t| Accept -> \n\t\t\t\t\t\t\tif (word = [dollar]) then\n\t\t\t\t\t\t\t\t\"Ac\"\n\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t\"Error\"\n\t\t\t\t\t\t| Reduce({head = h;body = b}) -> \n\t\t\t\t\t\t\t(symb2str h) ^ \"->\" ^ (word2str b)\t\t\n\t\t\t\n\tlet rec parserPredictLR1Action word lr1Table revStack (cfg:t) :  string = \n\t\tlet currentState = int_of_string(List.hd revStack) in \n\t\tlet (id,shifts,actionSet) = Set.nth lr1Table currentState in (* get corresponding table entry *)\n\t\tlet topSymbol = List.nth word 0 in\n\t\t\tif(Set.belongs topSymbol cfg.variables) then (*Fazemos um Shift com uma variavel -> Goto*)\n\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = topSymbol) shifts in\n\t\t\t\t\tif(Set.size targetShifts = 0) then \"Error\"\n\t\t\t\t\telse\n\t\t\t\t\t\t\"Shift\"\n\t\t\telse \n\t\t\t\tlet peekedSymbol = List.nth word 0 in\n\t\t\t\tlet peekedsymbolAndActions = Set.filter( fun (s,a) -> s = peekedSymbol && Set.size a > 0 ) actionSet in\n\t\t\t\tlet nEntries = Set.size peekedsymbolAndActions in\n\t\t\t\t\tif nEntries = 0 then \n\t\t\t\t\t\t\"Error\"\n\t\t\t\t\telse if nEntries > 1 then\n\t\t\t\t\t\t\"Conflict\"\n\t\t\t\t\telse\n\t\t\t\t\t\tlet (symbol,actions) = Set.hd peekedsymbolAndActions in (* atualmente está a falhar aqui, com hd failure *)\n\t\t\t\t\t\tlet (action:lr1Action) = Set.hd actions in\n\t\t\t\t\t\tmatch action with\n\t\t\t\t\t\t| Shift -> \n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tmatch word with\n\t\t\t\t\t\t\t\t| [] -> \"Error\"\n\t\t\t\t\t\t\t\t| s::_ -> \n\t\t\t\t\t\t\t\t\tif(Set.belongs s cfg.alphabet || Set.belongs s cfg.variables) then\n\t\t\t\t\t\t\t\t\t\tlet targetShifts = Set.filter (fun (a,b) -> a = s) shifts in\n\t\t\t\t\t\t\t\t\t\t\tif(Set.size targetShifts = 0) then \"Error\"\n\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t\"Shift\"\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\"Error\"\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t| Accept -> \n\t\t\t\t\t\t\tif (word = [dollar]) then\n\t\t\t\t\t\t\t\t\"Ac\"\n\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t\"Error\"\n\t\t\t\t\t\t| Reduce({head = h;body = b}) -> \n\t\t\t\t\t\t\t(symb2str h) ^ \"->\" ^ (word2str b)\n\t\t\n\t\n\tlet buildLR0Steps word2 cfg =\n\t\tlet word = str2word word2 in\n\t\tlet open LR0Grammar in\n\t\tlet firstStep = acceptWordLR0Init word cfg in\n\t\tlet stepList : lr0TableStep list = [firstStep] in\n\t\tlet nextStep = firstStep in\n\t\tlet (word,stateRevStack,symbolRevStack,lr0Table,valid) = nextStep in\n\t\tlet valid = ref valid in\n\t\tlet word = ref word in\n\t\tlet stepList = ref stepList in\n\t\tlet nextStep = ref nextStep in\n\t\t\twhile(!valid && !word != [dollar]) do\n\t\t\t\tnextStep := acceptWordLR0Step !nextStep cfg;\n\t\t\t\tlet (word2,stateRevStack,symbolRevStack,lr0Table,valid2) = !nextStep in\n\t\t\t\t\tstepList := !stepList @ [!nextStep];\n\t\t\t\t\tvalid := valid2;\n\t\t\t\t\tword := word2;\n\t\t\t\t()\n\t\t\tdone;\n\t\t\t!stepList\n\t\n\t\n\tlet createLR0AcceptTableHtml word (cfg:t) =\n\t\tlet table = HTMLTable.fetchTable(\"acceptTable\") in\n\t\tlet row = HTMLTable.insertRow table in\n\t\tlet stepList = buildLR0Steps word cfg in\n\t\t\n\t\t(*Headers *)\n\t\tlet _ = HTMLTable.insertCell row \"Palavra Restante\" \"Palavra Restante\" in\n\t\tlet _ = HTMLTable.insertCell row \"Pilha_Estados\" \"Pilha_Estados\" in\n\t\tlet _ = HTMLTable.insertCell row \"Pilha_Simbolos\" \"Pilha_Simbolos\" in\n\t\tlet _ = HTMLTable.insertCell row \"Valida\" \"Valida\" in\n\t\t\t\n\t\t(* Passos do accept *)\t\n\t\tList.iter ( fun (word2,stateRevStack,symbolRevStack,_,valid) -> \n\t\t\t\tlet row = HTMLTable.insertRow table in\n\t\t\t\tlet _ = HTMLTable.insertCell row (word2str word2) (word2str word2) in\n\t\t\t\tlet _ = HTMLTable.insertCell row (stringListToString stateRevStack) (stringListToString stateRevStack) in\n\t\t\t\tlet _ = HTMLTable.insertCell row (word2str symbolRevStack) (word2str symbolRevStack) in\n\t\t\t\tlet _ = HTMLTable.insertCell row (stringFromBool valid) (stringFromBool valid) in ();\n\t\t\t) stepList;\n\t\t\tlet numberOfCells = 4 in\n\t\t\tlet cellWidth = 100 in\n\t\t\tlet width = Printf.sprintf \"%d\" (numberOfCells*cellWidth) in\n\t\t\tHTMLTable.setWidth table width\n\t\n\t(*updated accept, joining states and symbols *)\t\t\n\t\n\tlet buildLR0StepsV2 word2 cfg =\n\t\tlet word = str2word word2 in\n\t\tlet open LR0Grammar in\n\t\tlet firstStep = acceptWordLR0InitV2 word cfg in\n\t\tlet stepList : truelr0TableStep list = [firstStep] in\n\t\tlet nextStep = firstStep in\n\t\tlet (word,revStack,lr0Table,valid) = nextStep in\n\t\tlet valid = ref valid in\n\t\tlet word = ref word in\n\t\tlet stepList = ref stepList in\n\t\tlet nextStep = ref nextStep in\n\t\t\twhile(!valid = \"Ongoing\") do\n\t\t\t\tnextStep := acceptWordLR0StepV2 !nextStep cfg;\n\t\t\t\tlet (word2,revStack,lr0Table,valid2) = !nextStep in\n\t\t\t\t\tstepList := !stepList @ [!nextStep];\n\t\t\t\t\tvalid := valid2;\n\t\t\t\t\tword := word2;\n\t\t\t\t()\n\t\t\tdone;\n\t\t\t!stepList\n\t\t\t\n\tlet rec listEndWith l a n =\n\tmatch l with\n\t| [] -> []\n\t| x::xs -> if(n=0) then [a] else x::(listEndWith xs a (n-1))\n\t\t\t\t\n\tlet createLR0AcceptTableHtmlV2 word (cfg:t) =\n\t\tlet table = HTMLTable.fetchTable(\"acceptTable\") in\n\t\tlet row = HTMLTable.insertRow table in\n\t\tlet stepList = buildLR0StepsV2 word cfg in\n\t\t\n\t\t(* injecting result, this should be deleted and fixed\n\t\tlet open LR0Grammar in\n\t\tlet lr0Table = LR0Grammar.getLR0Table cfg in \n\t\t\n\t\t\n\t\tlet finalStep : truelr0TableStep = ([],[symb2str cfg.initial],lr0Table,true) in\n\t\t\n\t\tlet finalStepList = listEndWith stepList finalStep ((List.length stepList) -2) in\n\t\tend of injection *)\n\t\t\n\t\t(*Headers *)\n\t\tlet _ = HTMLTable.insertCell row \"Palavra\" \"Palavra\" in\n\t\tlet _ = HTMLTable.insertCell row \"Pilha\" \"Pilha\" in\n\t\tlet _ = HTMLTable.insertCell row \"Ação\" \"Ação\" in\n\t\t(* Passos do accept *)\t\n\t\tList.iter ( fun (word2,revStack,lr0Table,valid) -> \n\t\t\t\tlet row = HTMLTable.insertRow table in\n\t\t\t\tlet _ = HTMLTable.insertCell row (word2str word2) (word2str word2) in\n\t\t\t\tlet _ = HTMLTable.insertCell row (stringListToString (rev revStack)) (stringListToString (rev revStack)) in\n\t\t\t\t(*\t\n\t\t\t\tlet newCell = row##insertCell (-1) in\n\t\t\t\t\tnewCell##.innerHTML := Js.string (word2str symbolRevStack);\n\t\t\t\t\tignore (newCell##.classList##add (Js.string \"monospaceClass\"));\n\t\t\t\t*)\t\n\t\t\t\t\t(*\n\t\t\t\t\tnewCell##.innerHTML := Js.string (boolFromString valid);\n\t\t\t\t\t*)\n\t\t\t\tlet actionString = parserPredictLR0Action word2 lr0Table revStack cfg in\n\t\t\t\tlet _ = HTMLTable.insertCell row actionString actionString in ();\n\t\t\t) stepList;\n\t\t\t\n\t\tlet numberOfCells = 3 in\n\t\tlet cellWidth = 100 in\n\t\tlet numberOfSymbols = String.length word in\n\t\tlet width = Printf.sprintf \"%d\" (numberOfCells*cellWidth*numberOfSymbols) in\n\t\t\tHTMLTable.setWidth table width\n\t\t\t\n\t\t\n\t\t\t\n\tlet buildSLR1StepsV2 word2 cfg =\n\t\tlet word = str2word word2 in\n\t\tlet open SLR1Grammar in\n\t\tlet firstStep = acceptWordSLR1InitV2 word cfg in\n\t\tlet stepList : trueslr1TableStep list = [firstStep] in\n\t\tlet nextStep = firstStep in\n\t\tlet (word,revStack,slr1Table,valid) = nextStep in\n\t\tlet revStack = ref revStack in\n\t\tlet valid = ref valid in\n\t\tlet word = ref word in\n\t\tlet stepList = ref stepList in\n\t\tlet nextStep = ref nextStep in\n\t\t\twhile(!valid = \"Ongoing\") do (*!word != [dollar] *)\n\t\t\t\tnextStep := acceptWordSLR1StepV2 !nextStep cfg;\n\t\t\t\tlet (word2,revStack2,slr1Table,valid2) = !nextStep in\n\t\t\t\t\tstepList := !stepList @ [!nextStep];\n\t\t\t\t\tvalid := valid2;\n\t\t\t\t\tword := word2;\n\t\t\t\t\trevStack := revStack2;\n\t\t\t\t()\n\t\t\tdone;\n\t\t\t!stepList\n\t\n\t\n\tlet createSLR1AcceptTableHtmlV2 word (cfg:t) = \n\t\tlet table = HTMLTable.fetchTable(\"acceptTable\") in\n\t\tlet row = HTMLTable.insertRow table in\n\t\t\n\t\tlet stepList = buildSLR1StepsV2 word cfg in\n\t\t\n\t\t(* injecting result, this should be deleted and fixed *)\n\t\t\n\t\t(* end of injection *)\n\t\t\n\t\t(*Headers *)\n\t\tlet _ = HTMLTable.insertCell row \"Word\" \"Word\" in\n\t\tlet _ = HTMLTable.insertCell row \"Stack\" \"Stack\" in\n\t\tlet _ = HTMLTable.insertCell row \"Action\" \"Action\" in\n\t\t\t\n\t\t(* Passos do accept *)\t\n\t\tList.iter ( fun (word2,revStack,slr1Table,valid) -> \n\t\t\tlet row = HTMLTable.insertRow table in\n\t\t\tlet _ = HTMLTable.insertCell row (word2str word2) (word2str word2) in\n\t\t\tlet _ = HTMLTable.insertCell row \"id\" (stringListToString (rev revStack)) in\n\t\t\t\t(*\t\n\t\t\t\tlet newCell = row##insertCell (-1) in\n\t\t\t\t\tnewCell##.innerHTML := Js.string (word2str symbolRevStack);\n\t\t\t\t\tignore (newCell##.classList##add (Js.string \"monospaceClass\"));\n\t\t\t\t*)\t\n\t\t\t\t\n\t\t\t\tlet actionString = parserPredictSLR1Action word2 slr1Table revStack cfg in\n\t\t\t\t\tlet _ = HTMLTable.insertCell row actionString actionString in ();\n\t\t\t\t\t(*\n\t\t\t\t\tnewCell##.innerHTML := Js.string (boolFromString valid);\n\t\t\t\t\t*)\n\t\t\t) stepList;\n\t\t\t\n\t\t\t\n\t\tlet numberOfCells = 3 in\n\t\tlet cellWidth = 100 in\n\t\tlet numberOfSymbols = String.length word in\n\t\tlet width = Printf.sprintf \"%d\" (numberOfCells*cellWidth*numberOfSymbols) in\n\t\t\tHTMLTable.setWidth table width\n\t\t\t\t\n\t\t\t\t\n\tlet buildLR1StepsV2 word2 cfg =\n\t\tlet word = str2word word2 in\n\t\tlet open LR1Grammar in\n\t\tlet firstStep = acceptWordLR1InitV2 word cfg in\n\t\tlet stepList : truelr1TableStep list = [firstStep] in\n\t\tlet nextStep = firstStep in\n\t\tlet (word,revStack,lr1Table,valid) = nextStep in\n\t\tlet valid = ref valid in\n\t\tlet word = ref word in\n\t\tlet stepList = ref stepList in\n\t\tlet nextStep = ref nextStep in\n\t\t\twhile(!valid = \"Ongoing\") do\n\t\t\t\tnextStep := acceptWordLR1StepV2 !nextStep cfg;\n\t\t\t\tlet (word2,revStack,lr1Table,valid2) = !nextStep in\n\t\t\t\t\tstepList := !stepList @ [!nextStep];\n\t\t\t\t\tvalid := valid2;\n\t\t\t\t\tword := word2;\n\t\t\t\t()\n\t\t\tdone;\n\t\t\t!stepList\n\t\n\tlet createLR1AcceptTableHtmlV2 word (cfg:t) = \n\t\n\t\tlet table = HTMLTable.fetchTable(\"acceptTable\") in\n\t\tlet row = HTMLTable.insertRow table in\n\t\tlet stepList = buildLR1StepsV2 word cfg in\n\t\t\n\t\t(* injecting result, this should be deleted and fixed *)\n\t\t\n\t\t(* end of injection *)\n\t\t\n\t\t(*Headers *)\n\t\tlet _ = HTMLTable.insertCell row \"Word\" \"Word\" in\n\t\tlet _ = HTMLTable.insertCell row \"Stack\" \"Stack\" in\n\t\tlet _ = HTMLTable.insertCell row \"Action\" \"Action\" in\n\t\t\t\n\t\t\t\n\t\t(* Passos do accept *)\t\n\t\tList.iter ( fun (word2,revStack,lr1Table,valid) -> \n\t\t\tlet row = HTMLTable.insertRow table in\n\t\t\tlet _ = HTMLTable.insertCell row (word2str word2) (word2str word2) in\n\t\t\tlet _ = HTMLTable.insertCell row (stringListToString (rev revStack)) (stringListToString (rev revStack)) in\n\t\t\t\t\n\t\t\t\t(*\t\n\t\t\t\tlet newCell = row##insertCell (-1) in\n\t\t\t\t\tnewCell##.innerHTML := Js.string (word2str symbolRevStack);\n\t\t\t\t\tignore (newCell##.classList##add (Js.string \"monospaceClass\"));\n\t\t\t\t*)\t\n\t\t\t\t\n\t\t\t\tlet actionString = parserPredictLR1Action word2 lr1Table revStack cfg in\n\t\t\t\t\tlet _ = HTMLTable.insertCell row actionString actionString in ();\n\t\t\t\t\t(*\n\t\t\t\t\tnewCell##.innerHTML := Js.string (boolFromString valid);\n\t\t\t\t\t*)\n\t\t\t) stepList;\n\t\t\t\n\t\t\t\n\t\tlet numberOfCells = 3 in\n\t\tlet cellWidth = 100 in\n\t\tlet numberOfSymbols = String.length word in\n\t\tlet width = Printf.sprintf \"%d\" (numberOfCells*cellWidth*numberOfSymbols) in\n\t\t\tHTMLTable.setWidth table width\n\t\n\t\n\t\n\tlet buildLALR1StepsV2 word2 cfg =\n\t\tlet word = str2word word2 in\n\t\tlet open LALR1Grammar in\n\t\tlet firstStep = acceptWordLALR1InitV2 word cfg in\n\t\tlet stepList = [firstStep] in\n\t\tlet nextStep = firstStep in\n\t\tlet (word,revStack,lr1Table,valid) = nextStep in\n\t\tlet valid = ref valid in\n\t\tlet word = ref word in\n\t\tlet stepList = ref stepList in\n\t\tlet nextStep = ref nextStep in\n\t\t\twhile(!valid = \"Ongoing\") do\n\t\t\t\tnextStep := acceptWordLALR1StepV2 !nextStep cfg;\n\t\t\t\tlet (word2,revStack,lr1Table,valid2) = !nextStep in\n\t\t\t\t\tstepList := !stepList @ [!nextStep];\n\t\t\t\t\tvalid := valid2;\n\t\t\t\t\tword := word2;\n\t\t\t\t()\n\t\t\tdone;\n\t\t\t!stepList\n\t\n\tlet createLALR1AcceptTableHtmlV2 word (cfg:t) = \n\t\n\t\tlet table = HTMLTable.fetchTable(\"acceptTable\") in\n\t\tlet row = HTMLTable.insertRow table in\n\t\tlet stepList = buildLALR1StepsV2 word cfg in\n\t\t\n\t\t(* injecting result, this should be deleted and fixed *)\n\t\t\n\t\t(* end of injection *)\n\t\t\n\t\t(*Headers *)\n\t\tlet _ = HTMLTable.insertCell row \"Word\" \"Word\" in\n\t\tlet _ = HTMLTable.insertCell row \"Stack\" \"Stack\" in\n\t\tlet _ = HTMLTable.insertCell row \"Action\" \"Action\" in\n\t\t\t\n\t\t(* Passos do accept *)\t\n\t\tList.iter ( fun (word2,revStack,lr1Table,valid) -> \n\t\t\tlet row = HTMLTable.insertRow table in\n\t\t\tlet _ = HTMLTable.insertCell row (word2str word2) (word2str word2) in\n\t\t\tlet _ = HTMLTable.insertCell row (stringListToString (rev revStack)) (stringListToString (rev revStack)) in\n\t\t\t\t\n\t\t\t\t(*\t\n\t\t\t\tlet newCell = row##insertCell (-1) in\n\t\t\t\t\tnewCell##.innerHTML := Js.string (word2str symbolRevStack);\n\t\t\t\t\tignore (newCell##.classList##add (Js.string \"monospaceClass\"));\n\t\t\t\t*)\t\n\t\t\t\t\tlet actionString = parserPredictLR1Action word2 lr1Table revStack cfg in\n\t\t\t\t\tlet _ = HTMLTable.insertCell row actionString actionString in ();\n\n\t\t\t\t\t(*\n\t\t\t\t\tnewCell##.innerHTML := Js.string (boolFromString valid);\n\t\t\t\t\t*)\n\t\t\n\t\t\t) stepList;\n\t\t\t\n\t\t\t\n\t\tlet numberOfCells = 3 in\n\t\tlet cellWidth = 100 in\n\t\tlet numberOfSymbols = String.length word in\n\t\tlet width = Printf.sprintf \"%d\" (numberOfCells*cellWidth*numberOfSymbols) in\n\t\t\tHTMLTable.setWidth table width\n\t\n\t\t\t\t\t\t\t\n\t(* Para futuras implementações remover a função boolFromString *)\n\t\t\t\n\tclass model (arg: t Arg.alternatives) =\n\t\tobject(self) inherit ContextFreeGrammarLL1View.model arg as super\n\t\t\n\n\t\tmethod buildCyLR0Diagram cy = \n\t\t\tlet lr0Diagram = LR0Grammar.getLR0DiagramId super#representation in\n\t\t\t\n\t\t\t\tinputLR0NodesV2 cy lr0Diagram; \n\t\t\t\tinputLR0Edges cy lr0Diagram\n\t\t\t\t\n\t\tmethod buildCySLR1Diagram cy = \n\t\t\tlet slr1Diagram = LR0Grammar.getLR0DiagramId super#representation in\n\t\t\t\n\t\t\t\tinputLR0NodesV2 cy slr1Diagram; \n\t\t\t\tinputLR0Edges cy slr1Diagram\n\t\t\t\t\n\t\tmethod buildCyLR1Diagram cy = \n\t\t\tlet lr1Diagram = LR1Grammar.getLR1DiagramId super#representation in\n\t\t\t\n\t\t\t\tinputLR1NodesV2 cy lr1Diagram; \n\t\t\t\tinputLR1Edges cy lr1Diagram\n\t\t\t\t\n\t\tmethod buildCyLALR1Diagram cy = \n\t\t\t\tlet lalr1Diagram = LALR1Grammar.getLALR1DiagramId super#representation  in\n\t\t\t\tinputLR1NodesV2 cy lalr1Diagram; \n\t\t\t\tinputLR1Edges cy lalr1Diagram\n\t\t\t\t\n\t\tmethod createLR0ParsingTableHtml =\n\t\t\t\t(*createLR0ParsingTableHtml super#representation old version*)\n\t\t\t\tcreateLR0ParsingTableHtmlExt super#representation\n\t\t\t\t\n\t\tmethod createSLR1ParsingTableHtml =\n\t\t\t\tcreateSLR1ParsingTableHtml super#representation\n\t\t\n\t\tmethod createLR1ParsingTableHtml =\n\t\t\t\tcreateLR1ParsingTableHtml super#representation\n\t\t\t\n\t\tmethod createLALR1ParsingTableHtml =\n\t\t\t\tcreateLALR1ParsingTableHtml super#representation\n\t\t\t\t\n\t\tmethod createLR0AcceptTableHtml word =\n\t\t\t\tcreateLR0AcceptTableHtml word super#representation\n\t\t\t\t\n\t\tmethod createLR0AcceptTableHtmlV2 word =\n\t\t\t\tcreateLR0AcceptTableHtmlV2 word super#representation\n\t\t\t\t\n\t\tmethod createSLR1AcceptTableHtmlV2 word =\n\t\t\t\tcreateSLR1AcceptTableHtmlV2 word super#representation\n\t\t\n\t\tmethod createLR1AcceptTableHtmlV2 word =\n\t\t\t\tcreateLR1AcceptTableHtmlV2 word super#representation\n\t\t\t\n\t\tmethod createLALR1AcceptTableHtmlV2 word =\n\t\t\t\tcreateLALR1AcceptTableHtmlV2 word super#representation\n\t\t\t\n\tend\nend\t\n","open OCamlFlat\nopen BasicTypes\nopen JS\nopen Js_of_ocaml\nopen Js.Opt\nopen Lang\nopen ContextFreeGrammarBasicView\nopen ContextFreeGrammarLL1View\nopen ContextFreeGrammarLRView\n\nmodule ContextFreeGrammarView =\nstruct\n\topen ContextFreeGrammarBasic\n\n\ttype t = ContextFreeGrammarBasic.t\n\ttype cfgTree2 = Leaf of string * symbol | Root of string * symbol * cfgTree2 list\n\ttype syntaxTable = ContextFreeGrammarLL1.syntaxTable\n\ttype acceptTable = ContextFreeGrammarLL1.acceptTable\n\ttype recognized = ContextFreeGrammarLL1.recognized\n\ttype acceptStep = {\n\t\tsyntaxTable : syntaxTable;\n\t\tacceptedString: string;\n\t\tacceptTable : acceptTable;\n\t\trecognized : recognized;\n\t\taccepted: bool option;\n\t\tnodes: cfgTree2 list;\n\t\tcyId: string option\n\t}\n\n  let doc = Dom_html.document\n\t\n\tclass model (arg: t Arg.alternatives) =\n\t\tobject(self) inherit ContextFreeGrammarLRView.model arg as super\n\n\t\tval mutable accepted : bool = false\n    val mutable visitedConfigs : int = 0\n    val mutable exactResult : bool = false\n    val mutable acceptTime : float = 0.0\n    val mutable bestPath: ContextFreeGrammarBasic.path = []\n    val mutable tree_rules: (word * rule list * int list) list = [] (*PEDRO CARLOS *)\n\n\t\t(*JP*)\n      method staticGenerate len =\n        let res = self#generate len in\n        let (exact, configVisited, time) = Model.stats() in\n        exactResult <- exact;\n        acceptTime <- time;\n        visitedConfigs <- configVisited;\n        res\n        \n      method staticAccept word =\n        let acc = self#accept word in\n        let (exact, configVisited, time) = Model.stats() in\n          JS.log(\"set initial step\");\n        self#setConfigsAndBestPath2 acc exact time configVisited;\n\n\n      method staticAcceptFull word =\n        let (acc, bestPath, trail) = self#acceptFull word in\n        let (exact, configVisited, time) = Model.stats() in\n          JS.log(\"set initial step\");\n        self#setTreeStruct bestPath;\n        self#setConfigsAndBestPath trail bestPath acc exact time configVisited;\n\n      method returnStats =\n        (accepted, visitedConfigs, exactResult, acceptTime)\n\n      (* method displayTrace =\n        let makePath () : string list list =\n          let headers = [\"Trace\"; \"Current Symbols\"; \"Word To Match\"] in\n            headers :: HTMLTable.makeCFGPath bestPath 0\n          in\n          if not (HTMLTable.tableExists \"pathTable\") then (\n            let contents = makePath () in\n              HTMLTable.buildTable contents \"pathTable\" \"cy2\";\n              let tab = HTMLTable.fetchTable \"pathTable\" in\n              let lastRowIndex = List.length bestPath in\n              let rec paintCells step =\n                match step with\n                | n when n < 4 -> \n                  if accepted then HTMLTable.paint tab lastRowIndex step \"mediumseagreen\"\n                  else (HTMLTable.paint tab lastRowIndex step \"crimson\");\n                  paintCells (step+1);\n                | n when n = 4 -> ()\n              in\n              paintCells 1; (*ignore step column*)\n              HTMLTable.changeDisplay tab \"\"\n              )\n          else () *)\n\n\t\t\t(* PEDRO CARLOS VER! tem representacao abstrata? falta parseTree? o que faz isto *)\n          method displayTrace =\n          let makePath () : string list list =\n            let headers = [\"Trace\"; \"Current Symbols\"; \"Word To Match\"] in\n            headers :: HTMLTable.makeGRPath bestPath 0\n          in\n          let button = Dom_html.createButton doc in\n          button##.textContent := Js.some (Js.string \"Toggle View\");\n          button##.onclick := Dom_html.handler (fun _ ->\n            let table = Dom_html.getElementById \"pathTable\" in\n            let cy3 = Dom_html.getElementById \"cy3\" in\n            let treeDiv = Dom_html.getElementById \"treeDiv\" in\n            let tableStyle = Dom_html.window##getComputedStyle table in\n            if (Js.string (Js.to_string tableStyle##.display) = Js.string \"none\") then (\n                table##.style##.display := Js.string \"\";\n                cy3##.style##.display := Js.string \"none\";\n                cy3##.style##.height := Js.string \"0\";\n                treeDiv##.style##.display := Js.string \"none\"\n              ) else (\n                table##.style##.display := Js.string \"none\";\n                cy3##.style##.display := Js.string \"\";\n                cy3##.style##.height := Js.string \"60vh\";\n                treeDiv##.style##.display := Js.string \"\"\n              );\n            Js._true\n          );\n          let cy2 = Dom_html.getElementById \"cy2\" in\n          Dom.appendChild cy2 button;\n\n          (* Create tree div and append to cy2 *)\n          let treeDiv = Dom_html.createDiv doc in\n          treeDiv##.id := Js.string \"treeDiv\";\n          treeDiv##.style##.display := Js.string \"none\";\n          Dom.appendChild cy2 treeDiv;\n\n          let cy3 = Dom_html.createDiv doc in\n          cy3##.id := Js.string \"cy3\";\n          cy3##.style##.display := Js.string \"\";\n          Dom.appendChild cy2 cy3;\n    \n          (* Create fitToBox button and append to treeDiv and cy3 *)\n          let cy3_cy = Cytoscape.initGRCy3 \"cy3\" in\n          let fitToBoxButton = Dom_html.createButton doc in\n          fitToBoxButton##.textContent := Js.some (Js.string \"Fit To Box\");\n          fitToBoxButton##.onclick := Dom_html.handler (fun _ ->\n            (* Assuming centerGraph is a function that centers the graph in cy3 *)\n            Cytoscape.centerGraph cy3_cy;\n            Js._true\n          );\n          Dom.appendChild treeDiv fitToBoxButton;\n    \n          if not (HTMLTable.tableExists \"pathTable\") then (\n            let contents = makePath () in\n            HTMLTable.buildTable contents \"pathTable\" \"cy2\";\n            let tab = HTMLTable.fetchTable \"pathTable\" in\n            let lastRowIndex = List.length bestPath in\n            let rec paintCells step =\n              match step with\n              | n when n < 4 -> \n                if accepted then HTMLTable.paint tab lastRowIndex step \"mediumseagreen\"\n                else HTMLTable.paint tab lastRowIndex step \"crimson\";\n                paintCells (step + 1)\n              | n when n = 4 -> ()\n            in\n            paintCells 1;\n            HTMLTable.changeDisplay tab \"\";\n            self#buildTree cy3_cy;\n            ()\n          ) else ()\n\n      method private setTreeStruct bestPath = \n        tree_rules <- self#find_applied_rules bestPath\n\n        method buildTree cy3 =\n\n        (* --- Helper Functions --- *)\n        let node_counter = ref 0 in\n        let generate_node_id () = incr node_counter; Printf.sprintf \"N%d\" !node_counter in\n        let add_cy_node node_label =\n          let node_id = generate_node_id () in\n          Cytoscape.add_node cy3 node_id \"root\" \"\" node_label;\n          node_id\n        in\n        let add_cy_edge parent_id child_id =\n          let edge_id = Printf.sprintf \"E_%s_to_%s\" parent_id child_id in\n          Cytoscape.addEdge cy3 (parent_id, edge_id, child_id);\n          edge_id\n        in\n        let isTerminalSymbol (symbol: symbol) : bool =\n          let str = symb2str symbol in\n          (* Consider refining this check based on your exact grammar conventions *)\n          not (str >= \"A\" && str <= \"Z\") (* Basic check for uppercase non-terminals *)\n          && not (String.length str > 1 && String.get str 0 = '<' && String.get str (String.length str - 1) = '>') (* Basic check for <...> non-terminals *)\n        in\n        (* Ensure 'epsilon' symbol is defined in the class/module scope *)\n        let epsilon_str = symb2str epsilon in (* Get epsilon string representation *)\n\n\n        (* --- Tree Building Logic --- *)\n\n        (* 1. Initialization *)\n        (* Get root symbol string from the first step's sentential form *)\n        let (root_sf, _, _) = List.nth tree_rules 0 in\n        let root_label_str = word2str root_sf in \n        let root_id = add_cy_node root_label_str in\n        (* Frontier: List of (cytoscape_node_id, non_terminal_label) *)\n        let frontier : (string * string) list ref = ref [(root_id, root_label_str)] in\n\n        (* 2. Process Each Derivation Step *)\n        tree_rules |> List.iter (fun (_sf, rules, _positions) ->\n          let num_rules = List.length rules in\n          if num_rules >= 1 then (* Handle steps with one or more rules *)\n            begin\n              (* --- Identify Nodes to Expand (Sequential Matching) --- *)\n              (* Stores tuples of: (parent_node_id, parent_node_label, rule_to_apply) *)\n              let nodes_to_expand_this_step = ref [] in\n              let remaining_rules = ref rules in (* Rules for this step to be matched *)\n              let current_frontier_copy = !frontier in (* Iterate over a snapshot of the frontier *)\n\n              (* Iterate through the frontier to find nodes matching the heads of remaining rules *)\n              current_frontier_copy |> List.iter (fun (node_id, node_label) ->\n                match !remaining_rules with\n                | current_rule :: rest_rules ->\n                    (* Check if the current frontier node matches the head of the next rule *)\n                    if symb2str current_rule.head = node_label then\n                      begin\n                        (* Match found! Record it and consume the rule *)\n                        nodes_to_expand_this_step := !nodes_to_expand_this_step @ [(node_id, node_label, current_rule)];\n                        remaining_rules := rest_rules;\n                      end\n                    (* else: This frontier node doesn't match the head of the current rule in sequence. *)\n                    (* It might be matched by a later rule if rules/frontier get out of sync, *)\n                    (* or it might not be expanded in this step. Simple sequential match proceeds. *)\n                | [] -> () (* No more rules left in this step to match *)\n              );\n\n              (* Optional: Warning if not all rules were matched (indicates potential issue) *)\n              if !remaining_rules <> [] then\n                Printf.eprintf \"Warning: Not all rules in the step were matched sequentially to frontier nodes. Step rules: %d, Unmatched: %d\\n\" num_rules (List.length !remaining_rules);\n\n\n              (* --- Expand All Identified Nodes & Collect New Frontier Nodes --- *)\n              (* Use a Hashtbl to map expanded parent_id -> list of its new non-terminal children (id, label) *)\n              let expansion_results : (string, (string * string) list) Hashtbl.t = Hashtbl.create (List.length !nodes_to_expand_this_step) in\n\n              !nodes_to_expand_this_step |> List.iter (fun (parent_id, _parent_label, rule) ->\n                  (* This list collects new non-terminal children ONLY for this specific parent_id *)\n                  let new_children_for_this_parent = ref [] in\n                  (* Expand this parent according to its matched rule *)\n                  rule.body |> List.iter (fun symbol ->\n                    let symbol_str = symb2str symbol in\n                    let is_epsilon = (symbol_str = epsilon_str) in\n                    let child_label = if is_epsilon then \"ε\" else symbol_str in\n\n                    let child_id = add_cy_node child_label in\n                    ignore (add_cy_edge parent_id child_id);\n\n                    (* Check if the child is a non-terminal and not epsilon *)\n                    let is_non_terminal = not is_epsilon && not (isTerminalSymbol symbol) in\n                    if is_non_terminal then\n                      (* Add new non-terminal child to the list for *this parent* *)\n                      new_children_for_this_parent := !new_children_for_this_parent @ [(child_id, child_label)]\n                  );\n                  (* Store the collected children for this parent_id in the Hashtbl *)\n                  Hashtbl.add expansion_results parent_id !new_children_for_this_parent;\n              );\n\n              (* --- Update the Main Frontier --- *)\n              (* Build the next frontier list by replacing expanded nodes with their children *)\n              let next_frontier = ref [] in\n              !frontier |> List.iter (fun (id, label) ->\n                  match Hashtbl.find_opt expansion_results id with\n                  | Some new_children_list ->\n                      (* This node was expanded, replace it with its new non-terminal children *)\n                      next_frontier := !next_frontier @ new_children_list\n                  | None ->\n                      (* This node was not expanded in this step, keep it *)\n                      next_frontier := !next_frontier @ [(id, label)]\n              );\n              frontier := !next_frontier; (* Update the main frontier reference *)\n\n            end (* End of block for num_rules >= 1 *)\n          (* else num_rules = 0: Implicitly do nothing for this step *)\n\n        ); (* End of iterating through tree_rules *)\n\n        (* 6. Apply Tree Layout *)\n        let treeLayout = object%js\n          val name = Js.string \"dagre\"\n          val rankDir = Js.string \"TB\"\n          (* Add other dagre options if needed *)\n        end in\n        try\n           (* Adapt layout call based on your Cytoscape binding *)\n           Cytoscape.run_layout (cy3##layout treeLayout);\n        with ex -> Printf.eprintf \"Error applying layout: %s\\n\" (Printexc.to_string ex)\n\n      \n              \n      method private setConfigsAndBestPath trail bestPathCFG acc exact time configVisited=\n        JS.log(\"METI OS STEPS\");\n        JS.log(bestPathCFG);\n        bestPath <- bestPathCFG;\n        accepted <- acc;\n        exactResult <- exact;\n        acceptTime <- time;\n        visitedConfigs <- configVisited\n\n        method private setConfigsAndBestPath2 acc exact time configVisited=\n          accepted <- acc;\n          exactResult <- exact;\n          acceptTime <- time;\n          visitedConfigs <- configVisited    \n      \n\n\tend\n\n\tlet adjust (cfg: ContextFreeGrammarBasic.model): model =\n\t\tlet r = cfg#representation in\n\t\t\tnew model (Representation r)\n\n\t\n\nend\t\n","(*\n * FiniteAutomatonView.ml\n *\n * This file is part of the OFLAT app\n *\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\n *\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\n *\n * This software is distributed under the terms of the GPLv3 license.\n * See the included LICENSE file for details.\n *\n *  Written by Carlos Freitas\n *)\n\nopen OCamlFlat\nopen BasicTypes\nopen Js_of_ocaml\nopen JS\nopen ViewUtil\nopen Lang\nopen Cytoscape\nopen AutomatonView\n\nmodule PushdownAutomatonView =\nstruct\n\topen PushdownAutomaton\n\n  (** Auxiliar Methods **)\n\n  let transitionPda2CytoscapeEdge (state1, symbStack, symbInput, state2, topStack) =\n    let topStackString = if topStack = [] then \"~\" else String.concat \"\" (List.map (fun s -> symb2str s) topStack) in\n      let edgeLabel = (symb2str symbInput) ^ \" : \" ^ (symb2str symbStack) ^ \" / \" ^ topStackString in\n        (state1, edgeLabel, state2)\n\n  let symbInputRegex = \" *[A-Za-z0-9~]+ *\"\n\n  let htmlDelta = \"ẟ\"\n\n  let isStateNameValid input =\n    let open Re in\n    Str.string_match (Str.regexp symbInputRegex) input 0\n\n  let isInputValid input =\n    let open Re in\n    Str.string_match (Str.regexp (symbInputRegex^\":\"^symbInputRegex^\"/\"^symbInputRegex)) input 0\n\n  let processToPutInStackInput toPutInStackString =\n    let open Re in\n    let processedString = \n      if toPutInStackString <> \"~\" then Str.global_replace (Str.regexp \"~\") \"\" toPutInStackString \n      else toPutInStackString \n    in\n      if processedString = \"~\" then [] \n      else List.map char2symb (List.init (String.length processedString) (String.get processedString))\n\n  let parseUserInput input = \n    let open Re in\n    let open Lwt in\n    let trimmedStr = Str.global_replace (Str.regexp \" \") \"\" input in\n    let splittedInput = Str.split (Str.regexp \"[:/]\")  trimmedStr in\n    let topStack = symb (List.nth splittedInput 1) in\n    let inputSymb = symb (List.nth splittedInput 0) in\n    let toPutInStack = processToPutInStackInput (List.nth splittedInput 2) in\n      (topStack, inputSymb, toPutInStack)\n\nmodule FILTERI =\nstruct\n\tlet rec genNX n =\n\t\tif n = 0 then [] else (n-1)::genNX (n-1)\n\t;;\n\tlet rec genN n =\n\t\tList.rev (genNX n)\n\t;;\n\tlet makeIndex l =\n\t\tlet idx = genN (List.length l) in\n\t\t\tList.combine idx l\n\t;;\n\tlet rec filteriX f l =\n\t\tmatch l with\n\t\t| [] ->\n\t\t\t[]\n\t\t| (i,v)::xs ->\n\t\t\t(if f i v then [v] else [])@filteriX f xs\n\t;;\t\n\tlet rec filteri f l =\n\t\tlet idx = makeIndex l in\n\t\t\tfilteriX f idx\n\t;;\nend\n\n  let buildStackDisplayString stack = \n    let maxSymbDisplayed = 15 in\n    let (restrictedStack, wasRestricted) = \n      if List.length stack > maxSymbDisplayed then (FILTERI.filteri (fun i _ -> i < maxSymbDisplayed) stack, true) \n      else (stack, false)\n    in\n    let stringStack = List.fold_left (fun acc s -> acc^\"\\n\"^(symb2str s)) \"Stack content:\\n\" restrictedStack in\n    if wasRestricted then stringStack^\"\\n...\" else stringStack\n  \n  let buildConfigMenu ((menuID, stack)) =\n    let stackDisplay = buildStackDisplayString stack in\n    Js.def (object%js\n      val id = Js.string menuID\n      val content = Js.string stackDisplay\n      val selector = Js.string \"node\"\n      val show = Js.bool false\n      val disabled = Js.bool true\n      val onClickFunction = fun element -> ()\n    end)\n\n  let buildIdFromState state (suffix: int) =\n    (state2str state)^\"_\"^(string_of_int suffix)\n\n  let getConfigsWithState state configs =\n    Set.filter (fun (st, _, _) -> st = state) configs\n\n  let processNodeConfig (configs: PushdownAutomaton.configurations_) state =\n    let configsOfState = getConfigsWithState state configs in\n    Set.mapi (fun i (state, stack, _) -> buildConfigMenu (buildIdFromState state i, stack)) configsOfState\n\n  let processConfigMenus (configs:PushdownAutomaton.configurations_) =\n    let states = PushdownAutomaton.configuration_Get1 configs in\n    Set.flatMap (processNodeConfig configs) states\n\n  let menuConfigPDA (configs: PushdownAutomaton.configurations_) = \n    Js.Unsafe.coerce @@ object%js\n      val evtType = Js.string \"tapdragover\"\n      val menuItems = Js.array (Array.of_list (Set.toList (processConfigMenus configs)))\n    end \n\n  let buildIdsStateAndApplyF f node configs: unit =\n    let configsOfState = getConfigsWithState (state node) configs in\n    Set.iteri (fun idSuffix (st, _, _) -> f (buildIdFromState st idSuffix)) configsOfState\n\n  let hideMenu menu id =\n    menu##hideMenuItem (Js.string id)\n  \n  let showMenu menu id =\n    menu##showMenuItem (Js.string id)\n\n  let hideMenus menu configs node =\n    buildIdsStateAndApplyF (hideMenu menu) node configs\n    \n  let showMenus menu configs node =\n    buildIdsStateAndApplyF (showMenu menu) node configs \n\n  let hideAllConfigMenus menu configs =\n    let states = PushdownAutomaton.configuration_Get1 configs in\n      Set.iter (hideMenus menu configs) states\n  \n  let __none__ = \"__none__\"\n\n  let optionsPopper = \n    Js.def (object%js \n      val placement = Js.string \"right-end\"\n    end)\n\n  let _popperDiv_ = \"popper-div\"\n  let _displayConfig_ = \"display-config\"\n  let _displayConfigClass_ = \"display-config-class\"\n  let _stackConfigDisplayID_ = \"stackConfigDisplay\"\n  let _nodeConfigDisplayID_ = \"nodeConfigDisplay\"\n\n  (* let renderedPos target = \n    JS.log(target##.renderedPosition##x);\n    let (x, y) = Cytoscape.getTargetPos target in\n    Js.def (object%js \n      val x = 100\n      val y = 500\n    end)\n\n  let renderedDim target = \n    () *)\n\n  let buildPopper nConfigs (node: Cytoscape.DataItem.t Js_of_ocaml.Js.t) =\n    node##popper (\n      Js.Unsafe.coerce @@ object%js\n      (* val renderedPosition = renderedPos\n      val renderedDimensions = renderedDim *)\n        val content = fun () -> \n          let countConfigsDiv = Dom_html.document##createElement (Js.string \"div\") in\n            (countConfigsDiv##.classList)##add(Js.string _popperDiv_);\n            countConfigsDiv##.innerHTML := Js.string (string_of_int nConfigs);\n            Dom.appendChild (Dom_html.getElementById \"cy\") countConfigsDiv;\n              countConfigsDiv\n        val popper = optionsPopper\n      end\n    )\n\n  let getConfigCountForNode node configs: int =\n    Set.fold_left (fun c (st, _, _) -> if (state2str st) = (data_fromName node \"id\") then c+1 else c) 0 configs\n\n  let buildConfigsCount (cy: Cytoscape.cytoscape Js_of_ocaml.Js.t) configs = \n    let nodes = List.filter (fun node -> (data_fromName node \"id\") <> \"transparent\") (Cytoscape.getAllNodes cy) in\n      List.map (fun node -> buildPopper (getConfigCountForNode node configs) node) nodes\n\n  let updateAllPoppers (poppers: Cytoscape.popper Js_of_ocaml.Js.t list) =\n    List.iter (fun popper -> popper##update ()) poppers\n  \n  let destroyAllPoppers (poppers: Cytoscape.popper Js_of_ocaml.Js.t list) =\n    List.iter (fun popper -> popper##destroy ()) poppers\n\n  let isFinal configs finalStates criteria state =\n    let configsOfState = getConfigsWithState state configs in\n    let stateStack = Set.map (fun (a, b, _) -> (a, b)) configsOfState in\n      PushdownAutomaton.isInAcceptState stateStack finalStates criteria\n\n  let buildStackForTable stack =\n    let stackStr = List.map symb2str stack in\n      String.concat \" \" stackStr\n\n  let buildTableConfigDisplay = \n    let table = Dom_html.document##createElement (Js.string \"table\") in\n    (table##.classList)##add(Js.string _displayConfigClass_);\n\n    let tHead = Dom_html.document##createElement (Js.string \"tHead\") in\n    let trHead = Dom_html.document##createElement (Js.string \"tr\") in\n    let thNode = Dom_html.document##createElement (Js.string \"th\") in\n    let thStack = Dom_html.document##createElement (Js.string \"th\") in\n    thNode##.innerHTML := Js.string (\"Node\");\n    thStack##.innerHTML := Js.string (\"Stack\");\n    Dom.appendChild tHead trHead;\n    Dom.appendChild trHead thNode;\n    Dom.appendChild trHead thStack;\n\n    let tBody = Dom_html.document##createElement (Js.string \"tBody\") in\n    let trBody = Dom_html.document##createElement (Js.string \"tr\") in\n    let tdNode = Dom_html.document##createElement (Js.string \"td\") in\n    let tdStack = Dom_html.document##createElement (Js.string \"td\") in\n    tdNode##.id := Js.string (_nodeConfigDisplayID_);\n    tdStack##.id := Js.string (_stackConfigDisplayID_);\n    Dom.appendChild tBody trBody;\n    Dom.appendChild trBody tdNode;\n    Dom.appendChild trBody tdStack;\n    \n    Dom.appendChild table tHead;\n    Dom.appendChild table tBody;\n      table\n\n  let buildPopperConfigDisplay (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t) =\n    cy##popper (\n      Js.Unsafe.coerce @@ object%js\n        val content = fun () -> \n          let configDisplay = buildTableConfigDisplay in\n          configDisplay##.id := Js.string (_displayConfig_);\n          Dom.appendChild (Dom_html.getElementById \"cy\") configDisplay;\n            configDisplay\n        val renderedPosition = fun () ->\n          Js.def (object%js\n            val x = 50\n            val y = 500\n          end)\n      end\n    ) \n\n  let updateconfigDisplay (config: PushdownAutomaton.configuration_ option) =\n    let nodeDisplay = (Dom_html.getElementById _nodeConfigDisplayID_) in\n    let stackDisplay = (Dom_html.getElementById _stackConfigDisplayID_) in\n    let (nodeString, stackString) = \n      match config with\n      | None -> (\"--\", Lang.i18nNoPathAvailablePDA ())\n      | Some (state, stack, _) -> (state2str state, buildStackForTable stack) \n    in\n      nodeDisplay##.innerHTML := Js.string nodeString;\n      stackDisplay##.innerHTML := Js.string stackString\n\n  let buildModelSpecsMenuDom initialStackSymbol criteria =\n    let specsMenu = Dom_html.document##createElement (Js.string \"div\") in\n    \n    let initialStackSymbDiv = Dom_html.document##createElement (Js.string \"div\") in\n    let issTitle = Dom_html.document##createElement (Js.string \"h3\") in\n    let issInput = Dom_html.document##createElement (Js.string \"input\") in\n    issTitle##.innerHTML := Js.string (\"Initial stack symbol:\");\n    issInput##.innerHTML := Js.string (symb2str initialStackSymbol);\n    Dom.appendChild initialStackSymbDiv issTitle;\n    Dom.appendChild initialStackSymbDiv issInput;\n\n    let citeriaDiv = Dom_html.document##createElement (Js.string \"div\") in\n    let cTitle = Dom_html.document##createElement (Js.string \"h3\") in\n    let cButton = Dom_html.document##createElement (Js.string \"button\") in\n    cTitle##.innerHTML := Js.string (\"Acceptance mode:\");\n    cButton##.innerHTML := Js.string (if criteria then Lang.i18nTogleAcceptCriteriaState () else Lang.i18nTogleAcceptCriteriaEmptyStack ());\n    Dom.appendChild citeriaDiv cTitle;\n    Dom.appendChild citeriaDiv cButton;\n\n    Dom.appendChild specsMenu initialStackSymbDiv;\n    Dom.appendChild specsMenu citeriaDiv;\n      specsMenu\n\n  let bestStateColor = \"DarkBlue\"\n\n  class model (arg: t Arg.alternatives) =\n\t\tobject(self) \n    inherit AutomatonView.model arg as abstractAutomaton\n    inherit PushdownAutomaton.model arg as super\n\n    val mutable specsMenu: Cytoscape.popper Js_of_ocaml.Js.t option = None\n    val mutable bestPath: PushdownAutomatonJoao.path_ = []\n    val mutable configMenu: contextMenus Js.t option = None\n    val mutable selectedNodeConfigMenu = __none__\n    val mutable configsCounter: Cytoscape.popper Js_of_ocaml.Js.t list = []\n    val mutable configDisplay: Cytoscape.popper Js_of_ocaml.Js.t option = None\n    val mutable accepted : bool = false\n    val mutable visitedConfigs : int = 0\n    val mutable exactResult : bool = false\n    val mutable acceptTime : float = 0.0\n\n\n    method inputEdges cy = \n      let addEdgesCytoscape transition = Cytoscape.addEdge cy (transitionPda2CytoscapeEdge transition) in\n        Set.iter addEdgesCytoscape self#representation.transitions\n\n    method cleanUselessStates1 (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t) : model =\n      Cytoscape.resetStyle cy Cytoscape.faStyle;\n      let uselessStates = self#getUselessStates in\n        Set.iter (fun s -> Cytoscape.paintNode cy s AutomatonView.usefulColor) uselessStates;\n      let clean = super#cleanUselessStates in\n      let rep = clean#representation in \n      new model (Arg.Representation rep) \n\n    method reachableFromInitialState: states = self#reachable self#representation.initialState\n    \n    method toggleAcceptanceCriteria =\n      let rep: t = self#representation in \n        new model (Arg.Representation  {\n          inputAlphabet = rep.inputAlphabet;\n          stackAlphabet = rep.stackAlphabet;\n          states = rep.states;\n          initialState = rep.initialState;\n          initialStackSymbol = rep.initialStackSymbol;\n          transitions = rep.transitions;\n          acceptStates = rep.acceptStates;\n          criteria = not rep.criteria\n        })\n\n  method changeInitialStackSymbol symb =\n    let rep: t = self#representation in \n      new model (Arg.Representation  {\n        inputAlphabet = rep.inputAlphabet;\n        stackAlphabet = rep.stackAlphabet;\n        states = rep.states;\n        initialState = rep.initialState;\n        initialStackSymbol = symb;\n        transitions = rep.transitions;\n        acceptStates = rep.acceptStates;\n        criteria = rep.criteria\n      })\n\n    method addState state =\n      let rep: t = self#representation in \n        new model (Arg.Representation {\n          inputAlphabet = rep.inputAlphabet;\n          stackAlphabet = rep.stackAlphabet;\n          states = Set.add state rep.states;\n          initialState = rep.initialState;\n          initialStackSymbol = rep.initialStackSymbol;\n          transitions = rep.transitions;\n          acceptStates = rep.acceptStates;\n          criteria = rep.criteria\n        })\n\n    method removeState state = \n      let rep: t = self#representation in \n        new model (Arg.Representation {\n          inputAlphabet = rep.inputAlphabet;\n          stackAlphabet = rep.stackAlphabet;\n          states = Set.remove state rep.states;\n          initialState = rep.initialState;\n          initialStackSymbol = rep.initialStackSymbol;\n          transitions = rep.transitions;\n          acceptStates = Set.remove state rep.acceptStates;\n          criteria = rep.criteria\n        })\n\n    method updateInitialState state =\n      let rep: t = self#representation in \n      new model (Arg.Representation {\n        inputAlphabet = rep.inputAlphabet;\n        stackAlphabet = rep.stackAlphabet;\n        states = rep.states;\n        initialState = state;\n        initialStackSymbol = rep.initialStackSymbol;\n        transitions = rep.transitions;\n        acceptStates = rep.acceptStates;\n        criteria = rep.criteria\n      })\n\n     method addAcceptState state = \n      let rep: t = self#representation in \n        new model (Arg.Representation {\n          inputAlphabet = rep.inputAlphabet;\n          stackAlphabet = rep.stackAlphabet;\n          states = Set.add state rep.states;\n          initialState = rep.initialState;\n          initialStackSymbol = rep.initialStackSymbol;\n          transitions = rep.transitions;\n          acceptStates = Set.add state rep.acceptStates;\n          criteria = rep.criteria\n      })\n\n    method removeAcceptState state =\n      let rep: t = self#representation in \n        new model (Arg.Representation {\n          inputAlphabet = rep.inputAlphabet;\n          stackAlphabet = rep.stackAlphabet;\n          states = rep.states;\n          initialState = rep.initialState;\n          initialStackSymbol = rep.initialStackSymbol;\n          transitions = rep.transitions;\n          acceptStates = Set.remove state rep.acceptStates;\n          criteria = rep.criteria\n        })\n\n    method addTransition (fromState, topStack, symbol, toState, putInStack) = \n      let rep: t = self#representation in       \n        new model (Arg.Representation {\n          inputAlphabet = if symbol <> epsilon then Set.add symbol rep.inputAlphabet else rep.inputAlphabet;\n          stackAlphabet = Set.union (Set.make (topStack::putInStack)) rep.stackAlphabet;\n          states = rep.states;\n          initialState = rep.initialState;\n          initialStackSymbol = rep.initialStackSymbol;\n          transitions = Set.add (fromState, topStack, symbol, toState, putInStack) rep.transitions;\n          acceptStates = rep.acceptStates;\n          criteria = rep.criteria\n        })\n\n    method removeTransition (fromState, topStack, symbol, toState, putInStack) = \n      let rep: t = self#representation in \n      let newTransitions = Set.remove (fromState, topStack, symbol, toState, putInStack) rep.transitions in\n      let newStackAlphabet = \n        let stackAlphabetTrns = Set.union (PushdownAutomaton.transitionGet2 newTransitions) (PushdownAutomaton.transitionGet5Flat newTransitions) in\n          Set.add rep.initialStackSymbol stackAlphabetTrns\n      in\n      new model (Arg.Representation {\n          inputAlphabet = Set.remove epsilon (PushdownAutomaton.transitionGet3 newTransitions);\n          stackAlphabet = newStackAlphabet;\n          states = rep.states;\n          initialState = rep.initialState;\n          initialStackSymbol = rep.initialStackSymbol;\n          transitions = newTransitions;\n          acceptStates = rep.acceptStates;\n          criteria = rep.criteria\n    }) \n\n    method renameState oldState newState =\n      let rep: t = self#representation in \n      let renameState (state: state) = if state = oldState then newState else state in\n      let renameStates (states: states) = Set.map renameState states in\n      let renameTransition ((fromState, topStack, symbol, toState, putInStack): transition) = \n        (renameState fromState, topStack, symbol, renameState toState, putInStack) in\n      let renameTransitions (transitions: transitions) = Set.map renameTransition transitions in\n\n      new model (Arg.Representation {\n          inputAlphabet = rep.inputAlphabet;\n          stackAlphabet = rep.stackAlphabet;\n          states = renameStates rep.states;\n          initialState = renameState rep.initialState;\n          initialStackSymbol = rep.initialStackSymbol;\n          transitions = renameTransitions rep.transitions;\n          acceptStates = renameStates rep.acceptStates;\n          criteria = rep.criteria\n    })\n\n    method getCriteria = self#representation.criteria\n\n    method private paintBestCurrentStep cy =\n      match self#getCurrConfigFromBestPath with\n      | None -> ()\n      | Some (currBestState, _, _) -> if position <> (List.length bestPath)-1 then Cytoscape.paintNode cy currBestState bestStateColor else ()\n  \n    method paintCurrentStates cy =\n      let states = PushdownAutomaton.configuration_Get1 steps.(position) in\n      self#paintStates cy states (isFinal steps.(position) self#getAcceptStates self#representation.criteria);\n      self#paintBestCurrentStep cy\n\n    method getAcceptStates = self#representation.acceptStates\n    method getInitialState = self#representation.initialState\n    method getStates = self#representation.states\n\n    method staticGenerate len =\n      let res = self#generate len in\n      let (exact, configVisited, time) = Model.stats() in\n      exactResult <- exact;\n      acceptTime <- time;\n      visitedConfigs <- configVisited;\n      res\n      \n\n    method staticAccept =\n      let acc = self#accept (List.map char2symb !sentence) in\n      let (exact, configVisited, time) = Model.stats() in\n      JS.log(\"set initial step\");\n      self#setConfigsAndBestPath2 acc exact time configVisited;\n\n      method staticAcceptFull =\n        let (acc, bestPath, trail) = self#acceptFull (List.map char2symb !sentence) in\n        let (exact, configVisited, time) = Model.stats() in\n        JS.log(\"set initial step\");\n        self#setConfigsAndBestPath trail bestPath acc exact time configVisited;\n\n    method setInitialStep cy =\n      self#staticAcceptFull;\n      self#initAllMenusAndFeatures cy steps.(0)\n\n    method setNextStep cy =\n      self#updateAllMenusAndFeatures cy steps.(position)\n\n    method setBackStep (cy: Cytoscape.cytoscape Js_of_ocaml.Js.t) =\n      self#updateAllMenusAndFeatures cy steps.(position)\n      \n    method resetToEditModel = \n      self#destroyConfigDisplay;\n      self#resetConfigMenu;\n      self#destroyAllPoppers\n\n    method numberStates: int =\n      Set.size self#representation.states\n\n    method numberTransitions: int =\n      Set.size self#representation.transitions\n\n    method getWordFromConfig config : word =\n      let (state, stack, word) = config in\n      word\n      \n    method private initAllMenusAndFeatures cy configs = \n      self#buildConfigDisplay cy configs;\n      self#buildPoppersConfigsCounter cy configs;\n      self#subscribeNodesPositionUpdate cy;\n      self#updateConfigMenu cy configs;\n      self#subscribeConfigEventMenu cy\n\n    method private setConfigsAndBestPath trail bestPathAutomaton acc exact time configVisited=\n      steps <- Array.of_list trail;\n      JS.log(\"METI OS STEPS\");\n        bestPath <- bestPathAutomaton;\n        accepted <- acc;\n        exactResult <- exact;\n        acceptTime <- time;\n        visitedConfigs <- configVisited\n\n        method private setConfigsAndBestPath2 acc exact time configVisited=\n          accepted <- acc;\n          exactResult <- exact;\n          acceptTime <- time;\n          visitedConfigs <- configVisited    \n\n    method private updateAllMenusAndFeatures cy configs =\n      self#updateConfigDisplay configs;\n      self#buildPoppersConfigsCounter cy configs;\n      self#updateConfigMenu cy configs\n\n    method private buildConfigDisplay cy configs = (*latter is not configs but the best path*)\n      (match configDisplay with\n      | None -> configDisplay <- Some (buildPopperConfigDisplay cy)\n      | Some _ -> ());\n      self#updateConfigDisplay configs\n\n    method private getCurrConfigFromBestPath = \n      if bestPath <> [] then Some (List.nth bestPath position) else None\n\n    method private updateConfigDisplay configs = \n      let config = \n        if self#isDeterministic then (if Set.isEmpty configs then None else Some (Set.hd configs))\n        else self#getCurrConfigFromBestPath\n      in\n        updateconfigDisplay config\n    \n    method private destroyConfigDisplay =\n      match configDisplay with\n      | None -> ()\n      | Some s -> \n          s##destroy ();\n          configDisplay <- None;\n          let cy = Dom_html.getElementById \"cy\" in\n          let configDisplayElem = Dom_html.getElementById _displayConfig_ in\n          Dom.removeChild cy configDisplayElem\n\n    method private updateConfigMenu cy configs =\n      self#resetConfigMenu;\n      let cm = cy##contextMenus(menuConfigPDA configs) in\n\t\t  configMenu <- Some cm;\n\t\t  hideAllConfigMenus cm configs\n\n    method private resetConfigMenu =\n      match configMenu with\n      | None -> ()\n      | Some menu -> \n          menu##destroy();\n          configMenu <- None;\n          selectedNodeConfigMenu <- __none__\n    \n    method private showConfigurationMenu node =\n      if selectedNodeConfigMenu <> node then \n        match configMenu with\n          | None -> ()\n          | Some menu ->\n            let configs = steps.(position) in\n            let selectedNode = selectedNodeConfigMenu in\n              if selectedNode <> __none__ then \n                begin\n                  hideMenus menu configs selectedNode;\n                  selectedNodeConfigMenu <- __none__\n                end;\n              if Set.belongs (state node) (PushdownAutomaton.configuration_Get1 configs) then\n                begin \n                  showMenus menu configs node;\n                  selectedNodeConfigMenu <- node;\n                end\n              \n    method private subscribeConfigEventMenu (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t): unit =\n      cy##on (Js.string \"mouseover\") (Js.string \"node\")\n      (fun evt -> \n          match Js.Opt.to_option (evt##.target) with \n          | None -> JS.log(\"Error, none node selected\")\n          | Some t ->\n            let target = Js.Unsafe.coerce t in\n              self#showConfigurationMenu (Js.to_string target##data##.id)\n      )\n\n    method private destroyPopperDivs =\n      let cyDiv = Dom_html.getElementById \"cy\" in\n      let elems = Dom_html.document##getElementsByClassName (Js.string _popperDiv_) in\n      for _ = 0 to elems##.length - 1 do\n        let elem = elems##item 0 in\n        match Js.Opt.to_option elem with\n          | None -> ()\n          | Some r ->\n          \t\tlet r = Js.Unsafe.coerce r in\n          \t\t\tDom.removeChild cyDiv r\n      done\n\n    method private destroyAllPoppers =\n      destroyAllPoppers configsCounter;\n      self#destroyPopperDivs;\n      configsCounter <- []            \n\n    method private buildPoppersConfigsCounter cy configs =\n      self#destroyAllPoppers;\n      configsCounter <- buildConfigsCount cy configs\n      \n    method private updateAllPoppers =\n      updateAllPoppers configsCounter\n\n    method private subscribeNodesPositionUpdate cy =\n      cy##on (Js.string \"position\") (Js.string \"node\")\n      (fun _ -> self#updateAllPoppers);\n\n      cy##on_3 (Js.string \"pan zoom resize\")\n      (fun _ -> self#updateAllPoppers);\n    \n\n\n    (*JP*)\n\n    method buildTable =\n\n      let makeStateContents st stckAlp inpAlp trans =\n          let rec stateRows states stack =\n          match states with\n          | [] -> []\n          | a :: b ->  \n              let rec stateStackRow state stack =\n              match stack with\n              | [] -> []\n              | sa :: [] -> HTMLTable.makePDAStateRow state sa inpAlp trans :: stateRows b stckAlp\n              | sa :: sb -> HTMLTable.makePDAStateRow state sa inpAlp trans :: stateStackRow state sb\n              in\n              stateStackRow a stckAlp\n          in\n          let result = stateRows st stckAlp in\n          result\n      in\n      let makePDATable () : string list list =\n          let inputAlphabet = (Set.toList self#representation.inputAlphabet) in\n          let states = Set.toList self#representation.states in\n          let trans = self#representation.transitions in\n          let stackAlphabet = Set.toList self#representation.stackAlphabet in\n          let headers = List.map symb2str inputAlphabet in \n          let contents = makeStateContents states stackAlphabet inputAlphabet trans in\n          (htmlDelta :: headers) :: contents\n      in\n      if not (HTMLTable.tableExists \"automataTable\") then (\n      let contents = makePDATable () in\n      HTMLTable.buildTable contents \"automataTable\" \"tab\"\n      )\n      else (\n        let parent = Dom_html.getElementById \"tab\" in\n        parent##.innerHTML := Js.string \"\";\n        let contents = makePDATable () in\n        HTMLTable.buildTable contents \"automataTable\" \"tab\"\n      )\n\n\n    method returnStats =\n      (accepted, visitedConfigs, exactResult, acceptTime)\n\n    method displayTrace =\n      let makePath () : string list list =\n        let headers = [\"Trace\"; \"Current State\"; \"Stack\"; \"Word To Consume\"] in\n          headers :: HTMLTable.makePDAPath bestPath 0\n      in\n      if not (HTMLTable.tableExists \"pathTable\") then (\n        let contents = makePath () in\n      (*expected string list list*)\n        HTMLTable.buildTable contents \"pathTable\" \"cy2\";\n        let tab = HTMLTable.fetchTable \"pathTable\" in\n        let lastRowIndex = List.length bestPath in\n        let rec paintCells step =\n          match step with\n          | n when n < 5 -> \n            if accepted then HTMLTable.paint tab lastRowIndex step \"mediumseagreen\"\n            else (HTMLTable.paint tab lastRowIndex step \"crimson\");\n            paintCells (step+1);\n          | n when n = 5 -> ()\n        in\n        paintCells 1; (*ignore step column*)\n        HTMLTable.changeDisplay tab \"\"  \n      )\n      else () \nend\nend\n","(*\n * FiniteAutomatonView.ml\n *\n * This file is part of the OFLAT app\n *\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\n *\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\n *\n * This software is distributed under the terms of the GPLv3 license.\n * See the included LICENSE file for details.\n *\n *  Written by Rita Macedo\n *)\n\nopen OCamlFlat\nopen BasicTypes\nopen Js_of_ocaml\nopen JS\nopen Lang\nopen Cytoscape\nopen TuringMachine\nopen JSon\n\n\nmodule TuringMachineView\n=\nstruct\n\topen TuringMachine\n\n\n  (* ******************Auxiliar Functions****************** *)\n\n  let productiveColor = \"orange\"\n  let reachableColor = \"yellow\"\n  let usefulColor = \"purple\"\n  let stepState = \"blue\"\n  let acceptState = \"green\"\n  let wrongFinalState = \"red\"\n  let uncertainState = \"#a34900\" (*\"LightBrown\"*)\n  let bestStateColor = \"DarkBlue\"\n\n  let sentence: char list ref = ref []\n \n  let newSentence = ref \"\"\n\n  let direction2string direction = if direction = L then \"L\" else if direction = R then \"R\" else \"S\"\n\n  let iterateList meth (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t) list =\n    List.iter (fun el -> (meth cy el) ) list\n\n  let nextStates st sy t =\n    let n = Set.filter (fun (a,b,c,_,_) -> st = a && sy = b) t in\n      Set.map (fun (_,_,d,_,_) -> d) n\n\n  let getNextSteps sts sy t = \n    Set.flatMap (fun st -> nextStates st sy t) sts (*O que acontece quando se faz flat map de um array em que cada celula contem apenas uma string/simbolo*)\n\n  let rec intersection l1 l2 =\n    match l1 with\n        [] -> []\n      | x::xs -> (if List.mem x l2 then [x] else []) @ intersection xs l2\n\n  let cut s = (String.get s 0, String.sub s 1 ((String.length s)-1))\n\n  let getCurrConfigFromBestPath bestPath position: configuration option =\n\tif (bestPath <> []) && (not ((List.length bestPath) <= position)) then Some (List.nth bestPath position) else None\n\n\n  (* ******************Function Method Functions****************** *)\n\n  (*-------------makeLabel-------------*)\n  let makeLabel rsymbs wsymbs directions =\n    let r_str = \"[\" ^ (String.concat \";\" (List.map symb2str rsymbs)) ^ \"]\" in\n    let w_str = \"[\" ^ (String.concat \";\" (List.map symb2str wsymbs)) ^ \"]\" in\n    let d_str = \"[\" ^ (String.concat \";\" (List.map direction2string directions)) ^ \"]\" in\n      String.concat \"/\" [r_str; w_str; d_str]\n\n  \n  (*-------------inputEdges-------------*)\n  let transformTransitions (trs: transitions) =\n\tSet.map (fun (rstate, rsymbs, nstate, wsymbs, directions) -> (rstate, (makeLabel rsymbs wsymbs directions), nstate)) trs\n  let inputEdges cy (trs: transitions) =\n\tSet.iter (fun el -> (Cytoscape.addEdgeGeneral cy el) ) (transformTransitions trs)\n\n\n  (*-------------inputNodes-------------*)\n  let inputNodes cy rep = \n    Set.iter (fun el -> (\n      JS.log (el); \n      Cytoscape.addNode cy el (el = rep.initialState) (Set.belongs el rep.acceptStates)\n    )) rep.states\n\n\n  (*-------------drawExample-------------*)\n  let drawExample cy rep = \n    inputNodes cy rep;\n    inputEdges cy rep.transitions\n\n\n  (*-------------numberStates-------------*)\n  let numberStates sts = Set.size sts\n\n\n  (*-------------numberTransitions-------------*)\n  let numberTransitions trs = Set.size trs\n\n\n  (*-------------productivePainting-------------*)\n  let productivePainting cy prod =\n    let paintProductive cy state = Cytoscape.paintNode cy state productiveColor in\n    let list1 = Set.toList prod in\n      iterateList paintProductive cy list1\n\n\n  (*-------------reachablePainting-------------*)\n  let reachablePainting cy reach initSt =\n    let paintReachable cy state = Cytoscape.paintNode cy state reachableColor in\n    let list1 = Set.toList (reach (initSt)) in\n      iterateList paintReachable cy list1 \n\n\n  (*-------------usefulPainting-------------*)\n  let usefulPainting cy prod reach initSt =\n    let paintUseful cy state = Cytoscape.paintNode cy state usefulColor in\n    let intre = intersection (Set.toList prod) (Set.toList (reach (initSt))) in\n      iterateList paintUseful cy intre \n\n(*********** AMD\n  (*-------------cleanUselessStatesCy-------------*)\n  let cleanUselessStatesCy cy cleanUSt: TuringMachineView.model =\n    (*Cytoscape.resetStyle cy Cytoscape.faStyle;\n    Set.iter (fun el -> paintUseful cy el) self#getUselessStates;*)\n    new TuringMachineView.model (Arg.Representation cleanUSt) \n*)\n\n  (*-------------stringAsList-------------*)\n  let rec stringAsList s =\n    if s = \"\" then []\n    else\n        let (x,xs) = cut s in\n            x::stringAsList xs\n\n\n  (*-------------changeTheTestingSentence-------------*)\n  let changeTheTestingSentence word = sentence := stringAsList word\n\n\n  (*-------------changeSentence-------------*)\n  let changeSentence config = \n    newSentence := \"\";\n    let bar = '|' in \n    let (_,tapes) = config in\n    let (revLeft,right) = List.hd tapes in\n    let notEmptyRight = if List.length right = 0 then [empty] else right in\n    let left = List.rev revLeft in\n      for i = 0 to (List.length left) - 1 do \n        newSentence:= !newSentence ^ symb2str (List.nth left i);\n      done;\n      newSentence:= !newSentence ^ String.make 1 bar;\n      for i = 0 to (List.length notEmptyRight) - 1 do \n        newSentence:= !newSentence ^ symb2str (List.nth notEmptyRight i);\n      done\n\n\n  (*-------------paint-------------*)\n  let paint (cy: Cytoscape.cytoscape Js_of_ocaml.Js.t) state final best finished isOver accepted criteria = \n    if final || ((not criteria) && isOver && accepted) then Cytoscape.paintNode cy state acceptState\n    else if isOver && not finished then Cytoscape.paintNode cy state uncertainState\n    else if not accepted && isOver then Cytoscape.paintNode cy state wrongFinalState\n    else if best then Cytoscape.paintNode cy state bestStateColor\n    else Cytoscape.paintNode cy state stepState\n\n\n  (*-------------paintCurrentStates-------------*)\n\n  let isFinalState criteria finalStates state =\n    if criteria then Set.exists (fun x -> x = state) finalStates else false\n\n  let paintStates cy states criteria acceptSts finished isOver accepted = \n    Set.iter (fun el -> paint cy el (isFinalState criteria acceptSts el) false finished isOver accepted criteria) states\n\n  let paintBestCurrentStep cy bestPath position criteria acceptSts finished isOver accepted =\n    match getCurrConfigFromBestPath bestPath position with\n    | None -> ()\n    | Some (currBestState,_) -> paint cy currBestState (isFinalState criteria acceptSts currBestState) true finished isOver accepted criteria\n\n\tlet configurationGet1 (configs: configurations) = Set.map ( fun (st, tapes) -> st ) configs\n\n  let paintCurrentStates cy configs criteria acceptSts bestPath position finished isOver accepted =\n    Cytoscape.resetStyle cy Cytoscape.faStyle;\n    paintStates cy (configurationGet1 configs) criteria acceptSts finished isOver accepted;\n    paintBestCurrentStep cy bestPath position criteria acceptSts finished isOver accepted \n\n\n  (*-------------startAccept-------------*)    \n\n\n\n  (*-------------next-------------*)\n\n\n\n  (*-------------back-------------*)\n\n\n\n  (*-------------isOver-------------*)\n\n\n\n  (*-------------newSentence1-------------*)\n\n\n\n  (*-------------dissectTransitionInput-------------*)\n  let filterTransitionInput input = \n    let rdSymb = String.sub input 0 1 in\n    let wrtSymb = String.get input 2 in\n    let direction = String.get input 4 in\n      (*Check if everyting is in order*)\n      (rdSymb, wrtSymb, direction)\n\n  let filterTransitionInputWithInv input =\n    let rdSymb = String.sub input 0 2 in\n    let wrtSymb = String.get input 3 in\n    let direction = String.get input 5 in\n      (rdSymb, wrtSymb, direction)\n\n  let dissectTransitionInput input =\n    if String.length input = 5 then filterTransitionInput input \n    else filterTransitionInputWithInv input\n\n\n  (*-------------addNode-------------*)\n\n\n\n  (*-------------addInitialNode-------------*)\n\n\n\n  (*-------------addFinalNode-------------*)\n\n\n\n  (*-------------eliminateNode-------------*)\n\n\n\n  (*-------------changeToFinal-------------*)\n\n\n\n  (*-------------removeFinal-------------*)\n\n\n\n  (*-------------renameNode-------------*)\n\n\n\n  (*-------------newTransition-------------*)\n\n\n\n  (*-------------eliminateTransition-------------*)\n\n\n\n  (*-------------setInitialStep-------------*)\n\n\n\n  (*-------------setStep-------------*)\n\n\n\n  (*-------------isSimulating-------------*)\n\n\n\n  (*-------------Poppers and menus-------------*)\n  \n  let buildConfigMenu ((menuID, tape)) =\n    Js.def (object%js\n      val id = Js.string menuID\n      val content = Js.string tape\n      val selector = Js.string \"node\"\n      val show = Js.bool false\n      val disabled = Js.bool true\n      val onClickFunction = fun element -> ()\n    end)\n\n  let buildIdFromState state (suffix: int) =\n    (state2str state)^\"_\"^(string_of_int suffix)\n\n  let getConfigsWithState state (configs: configurations) =\n    Set.filter (fun (st, _) -> st = state) configs\n\n  let buildTape left right = \n(* ML   let rightSide = String.cat \"|\" (word2str right) in *)\n    let rightSide = \"|\" ^ (word2str right) in\n    (word2str (List.rev left)) ^ rightSide\n\n  let processNodeConfig (configs: configurations) state =\n    let configsOfState = getConfigsWithState state configs in\n    Set.mapi (fun i (state, tapes) ->\n\t\tlet (left, right) = List.hd tapes in\n\t\t\tbuildConfigMenu (buildIdFromState state i, buildTape left right)) configsOfState\n\n  let processConfigMenus (configs: configurations) =\n    let states = configurationGet1 configs in\n    Set.flatMap (processNodeConfig configs) states\n\n  let menuConfigPDA (configs: TuringMachine.configurations) = \n    Js.Unsafe.coerce @@ object%js\n      val evtType = Js.string \"tapdragover\"\n      val menuItems = Js.array (Array.of_list (Set.toList (processConfigMenus configs)))\n    end \n\n  let buildIdsStateAndApplyF f node configs: unit =\n    let configsOfState = getConfigsWithState (state node) configs in\n    Set.iteri (fun idSuffix (st, _) -> f (buildIdFromState st idSuffix)) configsOfState\n\n  let hideMenu menu id =\n    menu##hideMenuItem (Js.string id)\n  \n  let showMenu menu id =\n    menu##showMenuItem (Js.string id)\n\n  let hideMenus menu configs node =\n    buildIdsStateAndApplyF (hideMenu menu) node configs\n\n  let showMenus menu configs node =\n    buildIdsStateAndApplyF (showMenu menu) node configs\n    \n  let hideAllConfigMenus menu configs =\n    let states = configurationGet1 configs in\n      Set.iter (hideMenus menu configs) states\n  \n  let __none__ = \"__none__\"\n\n  let optionsPopper = \n    Js.def (object%js \n      val placement = Js.string \"right-end\"\n    end)\n\n  let _popperDiv_ = \"popper-div\"\n\n  let buildPopper nConfigs (node: Cytoscape.DataItem.t Js_of_ocaml.Js.t) =\n    node##popper (\n      Js.Unsafe.coerce @@ object%js\n        val content = fun () -> \n          let countConfigsDiv = Dom_html.document##createElement (Js.string \"div\") in\n            (countConfigsDiv##.classList)##add(Js.string _popperDiv_);\n            countConfigsDiv##.innerHTML := Js.string (string_of_int nConfigs);\n            Dom.appendChild (Dom_html.getElementById \"cy\") countConfigsDiv;\n              countConfigsDiv\n        val popper = optionsPopper\n      end\n    )\n\n  let getConfigCountForNode node configs: int =\n    Set.fold_left (fun c (st,_) -> if (state2str st) = (data_fromName node \"id\") then c+1 else c) 0 configs\n\n  let buildConfigsCount (cy: Cytoscape.cytoscape Js_of_ocaml.Js.t) configs = \n    let nodes = List.filter (fun node -> (data_fromName node \"id\") <> \"transparent\") (Cytoscape.getAllNodes cy) in\n      List.map (fun node -> buildPopper (getConfigCountForNode node configs) node) nodes\n\n  let updateAllPoppers (poppers: Cytoscape.popper Js_of_ocaml.Js.t list) =\n    List.iter (fun popper -> popper##update ()) poppers\n  \n  let destroyAllPoppers (poppers: Cytoscape.popper Js_of_ocaml.Js.t list) =\n    List.iter (fun popper -> popper##destroy ()) poppers\n\n  let isSimulating bpath =\n    if Set.size (Set.make bpath) = 0 then false else true\n\n\n  let getInitConfig rep sentence: configuration =\n    let word = str2word (String.init (List.length !sentence) (fun i -> List.nth !sentence i)) in\n      Set.hd (initialConfigs rep word)\n       \n  class model (arg: t Arg.alternatives) =\n    object(self) inherit TuringMachine.model arg as super\n\n      val mutable specsMenu: Cytoscape.popper Js_of_ocaml.Js.t option = None\n      val mutable bestPath: TuringMachine.path = []\n      val mutable configMenu: contextMenus Js.t option = None\n      val mutable selectedNodeConfigMenu = __none__\n      val mutable configsCounter: Cytoscape.popper Js_of_ocaml.Js.t list = []\n\n      val mutable steps = [||]\n      val mutable position = -1\n      val mutable currentState: state = \"\"\n      val mutable isOver = false\n      val mutable accepted = false\n      val mutable finished = true\n      val mutable visitedConfigs : int = 0\n      val mutable exactResult : bool = false\n      val mutable acceptTime : float = 0.0\n\n      method numberStates = \n        numberStates self#getStates\n  \n      method numberTransitions = \n        numberTransitions self#getTransitions\n\n      method isOver = \n        isOver\n\n      method isSimulating = \n        not (position = -1)\n\n      (* Edition Methods *)\n\n      method inputEdges cy = \n        inputEdges cy self#getTransitions\n      \n      method inputNodes cy = \n        inputNodes cy self#representation\n\n      method drawExample cy = \n        drawExample cy self#representation\n\n      method paint (cy: Cytoscape.cytoscape Js_of_ocaml.Js.t) state final best = \n        paint cy state final best finished isOver accepted self#getCriteria\n\n      method productivePainting cy = \n        productivePainting cy self#productive \n\n      method reachablePainting cy = \n        reachablePainting cy self#reachable self#getInitialState\n\n      method usefulPainting cy =  \n        usefulPainting cy self#productive self#reachable self#getInitialState\n\n      method addNode node: model = \n        new model (Arg.Representation (self#addState node))\n\n      method addInitialNode node: model =\n        new model (Arg.Representation (self#addInitialState node))\n\n      method addFinalNode node: model =\n        new model (Arg.Representation (self#addFinalState node))\n\n      method eliminateNode node: model = \n        new model (Arg.Representation (self#removeState node))\n      \n      method changeToFinal node: model =\n        new model (Arg.Representation (self#changeStateToFinal node))\n      \n      method removeFinal node: model =\n        new model (Arg.Representation (self#changeStateFromFinal node))\n\n      method renameNode node newNode: model =\n        new model (Arg.Representation (self#renameState node (state newNode)))\n\n      method newTransition trs: model = \n        new model (Arg.Representation (self#addTransition trs))\n\n      method eliminateTransition trs: model = \n        new model (Arg.Representation (self#removeTransition trs))\n\n      (* Simulation Methods *)\n\n      method startAccept cy =\n        steps <- Array.make 1000 Set.empty;\n        position <- 0;\n        isOver <- false;\n        Cytoscape.resetStyle cy Cytoscape.faStyle;\n        self#setInitialStep cy;\n        if (Set.size steps.(position + 1)) = 0 then(\n          isOver <- true\n        );\n        self#paintCurrentStates cy; \n        match self#getCurrConfigFromBestPath with\n          | None -> ()\n          | Some config -> self#changeSentence config; \n\n      method next (cy: Cytoscape.cytoscape Js_of_ocaml.Js.t) =\n        if isOver then\n          (JS.alertStr (Lang.i18nAlertEndTMSim ()))\n        else \n          (\n            position <- position + 1;\n            let currConfig: TuringMachine.configuration = \n              match self#getCurrConfigFromBestPath with\n              | None -> getInitConfig self#representation sentence\n              | Some config -> config\n            in\n            self#setStep cy;\n            self#changeSentence currConfig;\n            if (Set.size steps.(position + 1)) = 0 then(\n              isOver <- true\n            );\n            self#paintCurrentStates cy;\n          )\n              \n      method back cy =\n        if position = 0 then\n          (JS.alertStr (Lang.i18nAlertArrivedInitial ()))\n        else\n          (\n            position <- position - 1;\n            isOver <- false;\n            self#setStep cy;\n            self#paintCurrentStates cy;\n            match self#getCurrConfigFromBestPath with\n              | None -> ()\n              | Some config -> self#changeSentence config;\n          )\n  \n      method setInitialStep cy =\n        self#staticAcceptFull;\n        self#initAllMenusAndFeatures cy steps.(0)\n  \n      method setStep (cy: Cytoscape.cytoscape Js_of_ocaml.Js.t) =\n        self#updateAllMenusAndFeatures cy steps.(position)\n\n      method changeTheTestingSentence word = \n        changeTheTestingSentence word\n\n      method changeSentence config = \n        changeSentence config\n\n      method newSentence1 = \n        !newSentence\n\n      method changeToEditModelMode (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t) =\n        steps <- [||];\n        position <- -1;\n        isOver <- false;\n        currentState <- \"\";\n        accepted <- false;\n        finished <- true;\n        sentence := [];\n        newSentence := \"\";\n        Cytoscape.resetStyle cy Cytoscape.faStyle;\n        self#resetSimulationHelpers\n\n      method cleanUselessStatesCy (cy: Cytoscape.cytoscape Js_of_ocaml.Js.t): model =\n\t\tnew model (Arg.Representation self#cleanUselessStates)\n  \n      method makeLabel rsymb wsymb direction = \n        makeLabel rsymb wsymb direction\n\n      method dissectTransitionInput input = \n        dissectTransitionInput input\n\n      (* Private Methods *)\n\n      method private getStates = \n        self#representation.states\n\n      method private getInitialState = \n        self#representation.initialState\n\n      method private getTransitions = \n        self#representation.transitions\n\n      method private getAcceptStates = \n        self#representation.acceptStates\n\n      method private getCriteria = \n        self#representation.criteria \n\n      method private getCurrConfigFromBestPath = \n        getCurrConfigFromBestPath bestPath position\n\n      method private paintCurrentStates cy  = \n        paintCurrentStates cy steps.(position) self#getCriteria self#getAcceptStates bestPath position finished isOver accepted\n\n      method private resetSimulationHelpers = \n        self#resetConfigMenu;\n        self#destroyAllPoppers\n        \n      method private initAllMenusAndFeatures cy configs = \n        self#resetSimulationHelpers;\n        self#buildPoppersConfigsCounter cy configs;\n        self#subscribeNodesPositionUpdate cy;\n        self#updateConfigMenu cy configs;\n        self#subscribeConfigEventMenu cy\n \n      method private setConfigsAndBestPath trail bestPathAutomaton acc exact time configVisited=\n        steps <- Array.of_list trail;\n          bestPath <- bestPathAutomaton;\n          accepted <- acc;\n        finished <- exact;\n        acceptTime <- time;\n        visitedConfigs <- configVisited\n\n        method private setConfigsAndBestPath2 acc exact time configVisited=\n          accepted <- acc;\n          finished <- exact;\n          acceptTime <- time;\n          visitedConfigs <- configVisited\n  \n      method private updateAllMenusAndFeatures cy configs =\n        self#resetSimulationHelpers;\n        self#buildPoppersConfigsCounter cy configs;\n        self#updateConfigMenu cy configs\n\n  (*  method private updateConfigMenu cy configs =\n        configMenu <- Some (cy##contextMenus(menuConfigPDA configs));\n        hideAllConfigMenus (Option.get configMenu) configs  ML *)\n   \n      method private updateConfigMenu cy configs =\n        let cm = cy##contextMenus(menuConfigPDA configs) in\n          configMenu <- Some cm;\n          hideAllConfigMenus cm configs\n  \n      method private resetConfigMenu =\n        match configMenu with\n        | None -> ()\n        | Some menu -> \n            menu##destroy();\n            configMenu <- None;\n            selectedNodeConfigMenu <- __none__\n      \n      method private showConfigurationMenu node =\n        if selectedNodeConfigMenu <> node then \n          match configMenu with\n            | None -> ()\n            | Some menu ->\n              let configs = steps.(position) in\n              let selectedNode = selectedNodeConfigMenu in\n                if selectedNode <> __none__ then \n                  begin\n                    hideMenus menu configs selectedNode;\n                    selectedNodeConfigMenu <- __none__\n                  end;\n                if Set.belongs (state node) (configurationGet1 configs) then\n                  begin \n                    showMenus menu configs node;\n                    selectedNodeConfigMenu <- node;\n                  end\n                \n      method private subscribeConfigEventMenu (cy:Cytoscape.cytoscape Js_of_ocaml.Js.t): unit =\n        cy##on (Js.string \"mouseover\") (Js.string \"node\")\n        (fun evt -> \n            match Js.Opt.to_option (evt##.target) with \n            | None -> JS.log(\"Error, none node selected\")\n            | Some t ->\n              let target = Js.Unsafe.coerce t in\n                self#showConfigurationMenu (Js.to_string target##data##.id)\n        )\n  \n      method private destroyPopperDivs =\n        let cyDiv = Dom_html.getElementById \"cy\" in\n        let elems = Dom_html.document##getElementsByClassName (Js.string _popperDiv_) in\n        for _ = 0 to elems##.length - 1 do\n          let elem = elems##item 0 in\n          match Js.Opt.to_option elem with\n            | None -> ()\n            | Some r ->\n                let r = Js.Unsafe.coerce r in\n                  Dom.removeChild cyDiv r\n        done\n  \n      method private destroyAllPoppers =\n        destroyAllPoppers configsCounter;\n        self#destroyPopperDivs;\n        configsCounter <- []            \n  \n      method private buildPoppersConfigsCounter cy configs =\n        configsCounter <- buildConfigsCount cy configs\n        \n      method private updateAllPoppers =\n        updateAllPoppers configsCounter\n  \n      method private subscribeNodesPositionUpdate cy =\n        cy##on (Js.string \"position\") (Js.string \"node\")\n        (fun _ -> self#updateAllPoppers);\n  \n        cy##on_3 (Js.string \"pan zoom resize\")\n        (fun _ -> self#updateAllPoppers);\n\n\n      (*JP*)\n\n      method staticAccept =\n        let acc = self#accept (List.map char2symb !sentence) in\n        let (exact, configs, time) = Model.stats() in\n        self#setConfigsAndBestPath2 acc exact time configs;\n\n        method staticAcceptFull =\n          let (acc, bestPath, trail) = self#acceptFull (List.map char2symb !sentence) in\n          let (exact, configs, time) = Model.stats() in\n          self#setConfigsAndBestPath trail bestPath acc exact time configs;\n\n      method returnStats =\n        (accepted, visitedConfigs, exactResult, acceptTime)\n\n      method displayTrace =\n        let makePath () : string list list =\n          let headers = [\"Trace\"; \"State\"; \"Tape\"] in\n            headers :: HTMLTable.makeTMPath bestPath 0\n        in\n        if not (HTMLTable.tableExists \"pathTable\") then (\n          let contents = makePath () in\n          HTMLTable.buildTable contents \"pathTable\" \"cy2\";\n          let tab = HTMLTable.fetchTable \"pathTable\" in\n          let lastRowIndex = List.length bestPath in\n          let _ =\n            for n = 1 to 4 (*List.length headers + 1*) do\n              if accepted then HTMLTable.paint tab lastRowIndex n \"mediumseagreen\"\n              else HTMLTable.paint tab lastRowIndex n \"crimson\"\n            done\n          in\n          HTMLTable.changeDisplay tab \"\" \n        )\n        else () \n      \n  end\nend\n","(*\n * CompositionView.ml\n *\n * This file is part of the OFLAT app\n *\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\n *\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\n *\n * This software is distributed under the terms of the GPLv3 license.\n * See the included LICENSE file for details.\n *\n *  Written by Carolina Duarte\n *)\n\n\nopen OCamlFlat\nopen BasicTypes\nopen JS\nopen ViewUtil\nopen Lang\nopen Cytoscape\nopen AutomatonView\n\nmodule CompositionView = \nstruct\n   open Composition\n\n  class model (arg: t Arg.alternatives) =\n        object(self) inherit Composition.model arg as super\n\n      val mutable accepted : bool = false\n      val mutable visitedConfigs : int = 0\n      val mutable exactResult : bool = false\n      val mutable acceptTime : float = 0.0\n      val mutable bestPath = []\n\n      method staticAccept word =\n            let acc = self#accept word in\n            let (exact, configVisited, time) = Model.stats() in\n            JS.log(\"set initial step\");\n            self#setConfigsAndBestPath2 acc exact time configVisited;\n\n      method private setConfigsAndBestPath2 acc exact time configVisited=\n            accepted <- acc;\n            exactResult <- exact;\n            acceptTime <- time;\n            visitedConfigs <- configVisited\n\n      method returnStats =\n            (accepted, visitedConfigs, exactResult, acceptTime)      \n\n  end\n      \n\nend\n\n","open OCamlFlat\nopen BasicTypes\nopen JS\nopen Js_of_ocaml\nopen Js.Opt\nopen Lang\nopen StateVariables\n\nmodule GrammarView =\nstruct\n  open Grammar\n\n  type t = Grammar.t\n  type grTree = Grammar.grTree\n  type acceptStep = {\n    acceptedString: string;\n    accepted: bool option;\n    tree: grTree;\n    cyId: string option\n  }\n\n  (**HTML entities**)\n  let htmlEpsilon = \"ε\" (*\"&epsilon;\"*) (** Define a representação HTML para épsilon. *)\n  let htmlArrow = \" → \" (*\" &rarr; \"*) (** Define a representação HTML para a seta de produção. *)\n  let htmlDollar = \"$\" (** Define a representação HTML para o símbolo de fim de entrada (geralmente usado em análise). *)\n\n  let productionsTableId() = \"grProductionsTable\" (** Retorna o ID para a tabela principal de produções da gramática. *)\n  let productionsTableId2() = \"grProductionsTable2\" (** Retorna o ID para uma segunda tabela de produções da gramática. *)\n  let monospaceClass = \"monospaceClass\" (** Define o nome da classe CSS para texto monoespaçado. *)\n  let doc = Dom_html.document (** Atalho para o objeto 'document' do DOM HTML. *)\n  \n\n  (** Cria um elemento de tabela HTML com um ID específico. *)\n  let createHtmlTable id =\n    let t = Dom_html.createTable doc in\n    t##.id := Js.string id;\n    t\n\n  (**\n   * Retorna um conjunto de corpos de regras para uma dada cabeça 'h' numa representação de gramática 'rep'.\n   * Se a cabeça for o símbolo inicial e não tiver regras, retorna um conjunto contendo épsilon.\n   *)\n  let bodiesOfHead h rep =\n    let rls = Set.filter (fun r -> r.head = h) rep.rules in\n    if Set.isEmpty rls && h = [rep.initial] then\n      Set.singleton [epsilon]\n    else\n      Set.map (fun r -> r.body) rls\n\n\n  (**\n   * Cria e preenche uma tabela HTML com as produções da gramática.\n   * @param rep A representação da gramática.\n   * @param id O ID a ser atribuído à tabela HTML; se vazio, usa o ID padrão.\n   *)\n  let createGrammarTableHtml (rep: t) id =\n    (** Preenche uma linha da tabela com os corpos das regras, separados por \" | \". *)\n    let rec fillRule row bodies =\n      if bodies = Set.empty then ()\n      else let (x, xs) = Set.cut bodies in\n        let span = Dom_html.createSpan doc in\n          span##.textContent := Js.some (Js.string (if x = [] then StateVariables.returnEmpty() else word2str x));\n          span##.classList##add (Js.string monospaceClass);\n          HTMLTable.appendChildtoRow row span;\n        if xs = Set.empty then fillRule row xs\n        else (\n          let orSpan = Dom_html.createSpan doc in\n            orSpan##.innerHTML := Js.string \" | \";\n            orSpan##.classList##add (Js.string monospaceClass);\n            HTMLTable.appendChildtoRow row orSpan;\n            fillRule row xs\n        )\n    in\n\n    (** Preenche uma linha da tabela para uma dada cabeça e os seus corpos de regra. *)\n    let fillRow table head bodies =\n      let open ViewUtil in\n      let headStr = word2str head in (* Converte a cabeça (lista de símbolos) para uma string *)\n      let escapedHeadStr =\n        headStr\n        |> ViewUtil.replace_str '&' \"&amp;\"\n        |> ViewUtil.replace_str '<' \"&lt;\"\n        |> ViewUtil.replace_str '>' \"&gt;\"\n      in\n      let row = HTMLTable.insertRow table in\n      let _ = HTMLTable.insertCell row (escapedHeadStr ^ \"Prods\") (escapedHeadStr) in\n      let _ = HTMLTable.insertCell row htmlArrow htmlArrow in\n        fillRule row bodies\n    in\n    let nonInitialRules = Set.map (fun r -> r.head) rep.rules in\n    let nonInitialRules = Set.filter (fun h -> List.hd h <> rep.initial) nonInitialRules in\n    let id = if id = \"\" then productionsTableId() else id in\n      let table = HTMLTable.fetchTable id in\n      fillRow table [rep.initial] (bodiesOfHead [rep.initial] rep);\n      Set.iter (fun head -> fillRow table head (bodiesOfHead head rep)) nonInitialRules\n\n    (**\n     * Divide uma lista de símbolos 'symbols' em duas partes: antes e depois da ocorrência da 'head' (cabeça da regra),\n     * começando a procurar a partir de 'start_index'.\n     * Retorna (símbolos_antes, símbolos_depois). Se a 'head' não for encontrada ou se 'head' for igual a 'symbols',\n     * pode retornar (symbols, []) ou ([], []) dependendo das condições.\n     *)\n    let split_around_rule_head symbols head start_index =\n      let head_len = List.length head in\n      let symbols_len = List.length symbols in\n    \n      if head_len = symbols_len then (* Se a cabeça tem o mesmo tamanho que os símbolos, não há o que dividir em torno dela. *)\n        ([], [])\n      else\n        (* Verifica se 'sub' é uma subsequência de 'lst' começando do início de ambas. *)\n        let rec find_subsequence lst sub =\n          match lst, sub with\n          | _, [] -> true (* Subsequência vazia é sempre encontrada. *)\n          | [], _ -> false (* Lista principal vazia, mas subsequência não. *)\n          | h::t, s::sub_t -> h = s && find_subsequence t sub_t (* Compara cabeças e continua recursivamente. *)\n        in\n    \n        (* Divide 'lst' na posição 'pos'. Retorna (elementos_antes_de_pos, elementos_a_partir_de_pos). *)\n        let rec split_at pos lst =\n          if pos <= 0 then ([], lst) (* Posição de divisão atingida ou ultrapassada. *)\n          else match lst with\n            | [] -> ([], []) (* Lista vazia. *)\n            | h::t -> \n                let (before, after) = split_at (pos - 1) t in (* Chamada recursiva. *)\n                (h::before, after) (* Adiciona elemento atual à parte 'antes'. *)\n        in\n    \n        (* Tenta encontrar 'head' em 'symbols' a partir de 'pos'. *)\n        let rec try_positions pos =\n          if pos > symbols_len - head_len then (* Se não há espaço suficiente para 'head'. *)\n            (symbols, []) (* Retorna todos os símbolos como 'antes' e nada como 'depois'. Considerar se este é o comportamento ideal. *)\n          else\n            let (_, rest) = split_at pos symbols in (* Pega a parte dos símbolos a partir de 'pos'. *)\n            if find_subsequence rest head then (* Se 'head' é encontrada no 'rest'. *)\n              let (before_match, after_head_temp) = split_at pos symbols in (* Divide os símbolos originais em 'pos'. *)\n              let (_, after_match) = split_at head_len after_head_temp in (* Remove 'head' de 'after_head_temp' para obter 'after_match'. *)\n              (before_match, after_match)\n            else\n              try_positions (pos + 1) (* Tenta a próxima posição. *)\n        in\n        try_positions start_index (* Inicia a busca a partir de 'start_index'. *)\n      \n  (** Classe que modela uma gramática, estendendo Grammar.model com funcionalidades de visualização e análise. *)\n  class model (arg: t Arg.alternatives) =\n    object(self) inherit Grammar.model arg as super\n\n    val mutable accepted : bool = false (** Indica se a última palavra testada foi aceite. *)\n    val mutable visitedConfigs : int = 0 (** Número de configurações visitadas durante a última análise. *)\n    val mutable exactResult : bool = false (** Indica se o resultado da última análise é exato (não limitado por tempo/passos). *)\n    val mutable acceptTime : float = 0.0 (** Tempo gasto na última operação de aceitação/geração. *)\n    val mutable bestPath: Grammar.path = [] (** O melhor caminho de derivação encontrado para a última palavra aceite. *)\n    val mutable tree_rules: ((symbol list * int) * (rule option * int)) list = [] (** Regras aplicadas e os seus índices, usadas para construir a árvore de derivação. *)\n\n\n\n    method createGrammarTableHtml id =\n      createGrammarTableHtml self#representation id\n\n    method isContextFreeGrammar : bool =\n      Grammar.isContextFreeGrammar self#representation\n\n    method isContextSensitiveGrammar : bool =\n      Grammar.isContextSensitiveGrammar self#representation\n\n    method isMonotonicGrammar : bool =\n      Grammar.isMonotonicGrammar self#representation\n\n    method isLinearGrammar : bool =\n      Grammar.isLinearGrammar self#representation\n\n    method isLeftLinearGrammar : bool =\n      Grammar.isLeftLinearGrammar self#representation\n\n    method isRightLinearGrammar : bool =\n      Grammar.isRightLinearGrammar self#representation\n\n    method isUnrestrictedGrammar : bool =\n      Grammar.isUnrestrictedGrammar self#representation\n\n    (** Encontra as regras aplicadas num dado caminho de derivação. *)\n    method find_applied_rules bestPath =\n      Grammar.find_applied_rules self#representation bestPath\n\n    method isClean : bool =\n      Grammar.isClean self#representation\n\n    method clean : model =\n      let cleanedGrammar = Grammar.clean self#representation in\n      new model (Arg.Representation cleanedGrammar)\n\n    method kuroda : model =\n      let kurodaGrammar = Grammar.kurodaNormalForm self#representation in\n      new model (Arg.Representation kurodaGrammar)\n\n    method penttonen : model =\n      let penttonenGrammar = Grammar.penttonenNormalForm self#representation in\n      new model (Arg.Representation penttonenGrammar)\n      \n    method nonContractingToCSG : model =\n      let csgGrammar = Grammar.nonContractingToCSG self#representation in\n      new model (Arg.Representation csgGrammar)\n\n    method allRulesProductive : bool =\n      Grammar.allRulesProductive self#representation\n\n    method allRulesAccessible : bool =\n      Grammar.allRulesAccessible self#representation\n\n\n    method staticGenerate len =\n      let res = Grammar.generate self#representation len in\n      let (exact, configVisited, time) = Model.stats() in\n      exactResult <- exact;\n      acceptTime <- time;\n      visitedConfigs <- configVisited;\n      res\n      \n\n    method staticAccept word =\n      let acc = Grammar.accept self#representation word in\n      let (exact, configVisited, time) = Model.stats() in\n      self#setConfigsAndBestPath2 acc exact time configVisited;\n\n\n    method staticAcceptFull word =\n      let (acc, bestPath, trail) = Grammar.acceptFull self#representation word in\n      let (exact, configVisited, time) = Model.stats() in\n      self#setTreeStruct bestPath;\n      self#setConfigsAndBestPath trail bestPath acc exact time configVisited; \n\n    method returnStats =\n      (accepted, visitedConfigs, exactResult, acceptTime)\n\n    (**\n     * Configura e mostra a visualização do trace e da árvore de derivação.\n     * Cria uma tabela para o trace e um grafo Cytoscape para a árvore.\n     * Inclui um botão para alternar entre a visualização da tabela e da árvore.\n     *)\n    method displayTrace =\n          let makePath () : string list list = (* Cria os dados para a tabela de traço. *)\n            let headers = [\"Trace\"; \"Current Symbols\"; \"Word To Match\"] in\n            headers :: HTMLTable.makeGRPath bestPath 0\n          in\n          let button = Dom_html.createButton doc in (* Botão para alternar visualização. *)\n          button##.textContent := Js.some (Js.string (Lang.i18nToggleView()));\n          button##.onclick := Dom_html.handler (fun _ -> (* Lógica para alternar a visibilidade. *)\n            let table = Dom_html.getElementById \"pathTable\" in\n            let cy3 = Dom_html.getElementById \"cy3\" in\n            let treeDiv = Dom_html.getElementById \"treeDiv\" in\n            let tableStyle = Dom_html.window##getComputedStyle table in\n            if (Js.string (Js.to_string tableStyle##.display) = Js.string \"none\") then (\n                table##.style##.display := Js.string \"\";\n                cy3##.style##.display := Js.string \"none\";\n                cy3##.style##.height := Js.string \"0\";\n                treeDiv##.style##.display := Js.string \"none\"\n              ) else (\n                table##.style##.display := Js.string \"none\";\n                cy3##.style##.display := Js.string \"\";\n                cy3##.style##.height := Js.string \"60vh\";\n                treeDiv##.style##.display := Js.string \"\";\n              );\n            Js._true\n          );\n          let cy2 = Dom_html.getElementById \"cy2\" in (* Container para a visualização. *)\n          Dom.appendChild cy2 button;\n\n          let treeDiv = Dom_html.createDiv doc in (* Div para a árvore Cytoscape. *)\n          treeDiv##.id := Js.string \"treeDiv\";\n          treeDiv##.style##.display := Js.string \"none\";\n          Dom.appendChild cy2 treeDiv;\n\n          let cy3 = Dom_html.createDiv doc in (* Div que conterá o grafo Cytoscape (visível por padrão). *)\n          cy3##.id := Js.string \"cy3\";\n          cy3##.style##.display := Js.string \"\"; (* Inicialmente visível *)\n          Dom.appendChild cy2 cy3;\n    \n          let cy3_cy = Cytoscape.initGRCy3 \"cy3\" in (* Inicializa o grafo Cytoscape. *)\n          let fitToBoxButton = Dom_html.createButton doc in (* Botão para ajustar o grafo. *)\n\n          fitToBoxButton##.textContent := Js.some (Js.string (Lang.i18nFitGraph()));\n          fitToBoxButton##.onclick := Dom_html.handler (fun _ ->\n            Cytoscape.centerGraph cy3_cy;\n            Js._true\n          );\n          Dom.appendChild treeDiv fitToBoxButton; (* Adiciona botão de ajuste ao div da árvore. *)\n          if self#isContextFreeGrammar then ( (* Adiciona nota sobre representação geral se for GLC. *)\n            let p = Dom_html.createP doc in\n            p##.textContent := Js.some (Js.string (Lang.i18nGeneralRepresentation()));\n            p##.style##.margin := Js.string \"0px\";\n            p##.style##.padding := Js.string \"0px 20px\";\n            Dom.appendChild treeDiv p\n          );\n    \n          if not (HTMLTable.tableExists \"pathTable\") then ( (* Se a tabela de traço não existe, cria-a. *)\n            let contents = makePath () in\n            HTMLTable.buildTable contents \"pathTable\" \"cy2\";\n            let tab = HTMLTable.fetchTable \"pathTable\" in\n            let lastRowIndex = List.length bestPath in\n            let rec paintCells step = (* Pinta a última linha da tabela para indicar aceitação/rejeição. *)\n              match step with\n              | n when n < 4 -> \n                if accepted then HTMLTable.paint tab lastRowIndex step \"mediumseagreen\"\n                else HTMLTable.paint tab lastRowIndex step \"crimson\";\n                paintCells (step + 1)\n              | n when n = 4 -> ()\n            in\n            paintCells 1;\n            HTMLTable.changeDisplay tab \"\"; (* Torna a tabela visível. *)\n            self#buildTree cy3_cy bestPath; (* Constrói a árvore de derivação. *)\n            ()\n          ) else () (* Se a tabela já existe, não faz nada. *)\n    \n      (**\n       * Constrói a árvore de derivação no grafo Cytoscape 'cy3' com base no 'bestPath'.\n       * Utiliza 'tree_rules' (preenchido por setTreeStruct) para identificar as regras aplicadas.\n       * Adiciona nós para símbolos e nós compostos para regras.\n       * Tenta simplificar a árvore removendo nós e arestas redundantes.\n       *)\n      method buildTree cy3 (bestPath: Grammar.path) =\n        \n        let edges = ref [] in (* Lista para armazenar as arestas do grafo. *)\n\n        (** Adiciona um nó épsilon ao grafo Cytoscape. *)\n        let fill_epsilon current_level index offset=\n          let nodeLabel = \"ε\" in\n          let nodeId = Printf.sprintf \"L%d_N%d_W%s_TNORMAL\" current_level index nodeLabel in\n          let x = ((index) * 50) - offset - 50 in \n          let y = current_level * 100 in \n          Cytoscape.add_node cy3 nodeId ~pos:(x, y) \"root\" \"\" nodeLabel;\n        in\n        \n        (** Adiciona um nó auxiliar (normal) para um símbolo ao grafo Cytoscape. *)\n        let addNodeAux level index word path_len =\n          let nodeLabel = word in\n          let nodeId = Printf.sprintf \"L%d_N%d_W%s_TNORMAL\" level index nodeLabel in\n          let offset = (path_len * 100) / 2 in (* Usado para centralizar o grafo. *)\n          let x = (index * 100) - offset in  \n          let y = level * 100 in \n          Cytoscape.add_node cy3 nodeId ~pos:(x, y) \"root\" \"\" nodeLabel;\n        in\n        \n        (** Adiciona um nó composto para uma regra (cabeça como pai, corpo como filhos) ao grafo Cytoscape. \n            Retorna o próximo índice disponível após adicionar os nós do corpo da regra. *)\n        let addCompoundNodeForRule level index rule path_len =\n          let labelParent = word2str rule.head in\n          let parentId = Printf.sprintf \"L%d_N%d_W%s_TSUPER\" level index labelParent in (* Nó \"SUPER\" para a cabeça. *)\n          let offset = (path_len * 100) / 2 in\n          let x = (index * 100) - offset in \n          let y = level * 100 in \n          let pos = object%js val x = x val y = y end in\n          Cytoscape.addCompoundNode cy3 parentId ~pos (Some \"\");\n        \n          (* Adiciona nós filhos para cada símbolo na cabeça da regra (dentro do nó composto). *)\n          List.iteri (fun sym_idx symbol ->\n            let childLabel = symb2str symbol in\n            let childId = Printf.sprintf \"L%d_N%d_W%s_TNORMAL\" level (index + sym_idx) childLabel in\n            let x = ((index + sym_idx) * 100) - offset in \n            let y = level * 100 in \n            let pos = object%js val x = x val y = y end in\n            Cytoscape.addChildNode cy3 parentId childId (Some childLabel) ~pos;\n          ) rule.head;\n        \n          (* Adiciona arestas da cabeça para os símbolos do corpo (se não for épsilon). *)\n          if rule.body <> [epsilon] then begin\n            List.iteri (fun sym_idx symbol ->\n              let childLabel = symb2str symbol in\n              edges := ((level, index, labelParent, \"SUPER\"), ((level + 1), (index + sym_idx), childLabel, \"NORMAL\")) :: !edges;\n            ) rule.body;\n            index + List.length rule.body (* Retorna o novo índice inicial para o próximo elemento no mesmo nível. *)\n          end else (* Se o corpo é épsilon. *)\n            let nodeLabel = \"ε\" in\n            edges := ((level, index, labelParent, \"SUPER\"), ((level + 1), (index), nodeLabel, \"NORMAL\") ):: !edges;\n            fill_epsilon (level + 1) index offset; (* Adiciona nó épsilon. *)\n            index (* Índice não muda significativamente para épsilon em termos de largura. *)\n        in\n\n        let levels = List.length bestPath in\n        (* Itera sobre as regras aplicadas (obtidas de find_applied_rules) para construir os nós e arestas. *)\n        tree_rules |> List.iteri (fun i ((path_elem, level), (rule_opt, index_in_path)) ->\n            let path_len = List.length path_elem in (* Comprimento da forma sentencial atual. *)\n            if i < levels then ( (* Processa apenas até ao número de níveis do caminho. *)\n              match rule_opt with\n              | None -> \n                failwith \"Rule not found for tree construction\" \n                \n              | Some rule ->\n                  if index_in_path = -1 then (* Se index_in_path é -1, trata como estado inicial/final ou sem aplicação de regra explícita. *)\n                      List.iteri (fun idx symb ->\n                      addNodeAux level idx (symb2str symb) path_len (* Adiciona cada símbolo como um nó normal. *)\n                    ) path_elem\n                  else (* Uma regra foi aplicada. *)\n                    (* Divide a forma sentencial em volta da cabeça da regra aplicada. *)\n                    let (before_match, after_match) = split_around_rule_head path_elem rule.head index_in_path in\n                    if ((List.length before_match) + (List.length after_match) + (List.length rule.head)) > List.length path_elem then (\n                      JS.log(\"ERROR: Rule head does not match path_elem, or split is incorrect\");\n                    );\n                    let len_before = List.length before_match in\n                    (* Adiciona nós para os símbolos antes da aplicação da regra. *)\n                    List.iteri (fun idx symb ->\n                      addNodeAux level idx (symb2str symb) path_len;\n                      edges := ((level, idx, (symb2str symb), \"NORMAL\"), ((level + 1), (idx), (symb2str symb), \"NORMAL\")) :: !edges;\n                    ) before_match;\n                    (* Adiciona o nó composto para a regra aplicada. *)\n                    let index_next_after_rule = addCompoundNodeForRule level len_before rule path_len in\n                    let len_head = List.length rule.head in\n                    (* Adiciona nós para os símbolos pós aplicação da regra. *)\n                    List.iteri (fun idx symb ->\n                      addNodeAux level (len_before + len_head + idx) (symb2str symb) path_len;\n                      edges := ((level, (len_before + len_head + idx), (symb2str symb), \"NORMAL\"), ((level + 1), (index_next_after_rule + idx), (symb2str symb), \"NORMAL\")) :: !edges;\n                    ) after_match\n            )\n        );\n        \n        (* Simplifica a árvore: remove nós que não mudam e não são usados em expansões futuras. *)\n        let max_index_in_path = (* Maior número de símbolos numa forma sentencial. *)\n          let lengths = List.map (fun step -> List.length (fst (fst step))) tree_rules @ [List.length (fst (List.hd bestPath))] in\n          List.fold_left max 0 lengths\n        in\n        let getEdges = !edges in               \n        let edges_to_delete = ref [] in\n        \n        (* Itera de baixo para cima, por coluna (índice de símbolo), para encontrar arestas redundantes. *)\n        for i = 0 to max_index_in_path do \n          try \n            for j = levels downto 1 do (* Itera pelos níveis da árvore. *)\n              List.iter (fun ((l_from, i_from, w_from, t_from), (l_to, i_to, w_to, t_to) as edge) ->\n                if l_to = j && i = i_to then begin (* Se a aresta aponta para o nó atual (nível j, índice i). *)\n                  if w_from <> w_to || t_from = \"SUPER\" then begin (* Se o símbolo muda ou é uma expansão de regra (SUPER). *)\n                    raise Exit (* Para esta coluna, não há mais simplificações a fazer para cima. *)\n                  end else (* Símbolo é o mesmo, não é SUPER, então esta aresta é candidata à remoção. *)\n                    edges_to_delete := edge :: !edges_to_delete\n                end\n              ) getEdges\n            done\n          with Exit -> (); (* Passa para a próxima coluna (índice i). *)\n        done;\n\n        let getEdgesToDelete = !edges_to_delete in\n        (* Filtra as arestas, removendo as que foram marcadas para eliminar. *)\n        let filtered_edges = List.filter (fun edge -> not (List.mem edge getEdgesToDelete)) getEdges in\n\n        (* Adiciona as arestas filtradas ao grafo Cytoscape. *)\n        List.iter (fun ((l_from, i_from, w_from, t_from), (l_to, i_to, w_to, t_to)) -> \n          Cytoscape.addEdge cy3 \n            ((Printf.sprintf \"L%d_N%d_W%s_T%s\" l_from i_from w_from t_from), (* ID do nó de origem. *)\n             \"\", (* ID da aresta, opcional. *)\n             (Printf.sprintf \"L%d_N%d_W%s_T%s\" l_to i_to w_to t_to)) (* ID do nó de destino. *)\n        ) filtered_edges;\n\n        (* Remove os nós de destino das arestas que foram eliminadas*)\n        List.iter (fun (_, (l_to, i_to, w_to, t_to)) ->\n          let to_id = Printf.sprintf \"L%d_N%d_W%s_T%s\" l_to i_to w_to t_to in\n          Cytoscape.removeNode cy3 to_id;\n        ) getEdgesToDelete;\n\n\n    method private setConfigsAndBestPath trail bestPathGR acc exact time configVisited =\n      bestPath <- bestPathGR;\n      accepted <- acc;\n      exactResult <- exact;\n      acceptTime <- time;\n      visitedConfigs <- configVisited\n\n\n    method private setConfigsAndBestPath2 acc exact time configVisited =\n      accepted <- acc;\n      exactResult <- exact;\n      acceptTime <- time;\n      visitedConfigs <- configVisited    \n\n\n    method private setTreeStruct bestPath = \n      tree_rules <- self#find_applied_rules bestPath\n  end\n\n\n  let adjust (gr: Grammar.model): model =\n    let r = gr#representation in\n      new model (Representation r)\nend","(*\n * HtmlPageClient.ml\n *\n * This file is part of the OFLAT app\n *\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\n *\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\n *\n * This software is distributed under the terms of the GPLv3 license.\n * See the included LICENSE file for details.\n *\n *  Written by Rita Macedo\n *)\n\n(* \n * Description: Visualizer component of the application.\n *)\n\nopen OCamlFlat\nopen BasicTypes\nopen Js_of_ocaml\nopen ViewUtil\nopen Lang\nopen Listeners\nopen StateVariables\nopen JS\nopen HTMLTable\n\nopen ContextFreeGrammarLL1View\nopen ContextFreeGrammarView\nopen FiniteAutomatonView\nopen GrammarView\n\nmodule HtmlPageClient= \nstruct\n  let button_type = Js.string \"button\"\nlet div_type = Js.string \"div\"\nlet text_type = Js.string \"textarea\"\nlet input_type = Js.string \"file\"\nlet doc = Dom_html.document\n\n\nlet button txt idtxt action =\nlet b = Dom_html.createButton ~_type:button_type doc in\nb##.id := Js.string idtxt;\nb##.innerHTML := Js.string txt;\nb##.onclick := Dom_html.handler (fun _ -> action (); Js._true);\nb\n\nlet button1 txt idtxt classtxt action =\nlet b = Dom_html.createButton ~_type:button_type doc in\nb##.id := Js.string idtxt;\nb##.innerHTML := Js.string txt;\nb##.className := Js.string classtxt;\nb##.onclick := Dom_html.handler (fun _ -> action (); Js._true);\nb\n\nlet input idtxt action = \nlet b = Dom_html.createInput ~_type:input_type doc in\nb##.id := Js.string idtxt;\nb##.onchange := Dom_html.handler (fun _ -> action (); Js._true);\nb\n\nlet div idtxt =\nlet d = Dom_html.createDiv doc in\nd##.id := Js.string idtxt;\nd\n\nlet div1 idtxt txt =\nlet d = Dom_html.createDiv doc in\n  d##.id := Js.string idtxt;\n  d##.innerHTML := Js.string txt;\nd\n\nlet div2 idtxt classtxt txt =\nlet d = Dom_html.createDiv doc in\nd##.id := Js.string idtxt;\nd##.className := Js.string classtxt;\nd##.innerHTML := Js.string txt;\nd\n\nlet div3 idtxt classtxt =\n  let d = Dom_html.createDiv doc in\n  d##.id := Js.string idtxt;\n  d##.className := Js.string classtxt;\n  d\n\nlet textarea idtxt rows cols value =\nlet t = Dom_html.createTextarea doc in\n  t##.id := Js.string idtxt;\n  t##.rows := rows;\n  t##.cols := cols;\n  t##.value := value;\nt\n\nlet h2 idtxt txt =\nlet h = Dom_html.createH2 doc in\n    h##.id := Js.string idtxt;\n    h##.innerHTML := Js.string txt;\n  h\n\nlet h1 idtxt txt =\nlet h = Dom_html.createH1 doc in\n  h##.id := Js.string idtxt;\n  h##.innerHTML := Js.string txt;\nh\n\nlet span idtxt txt =\nlet s = Dom_html.createSpan doc in\n  s##.id := Js.string idtxt;\n  s##.innerHTML := Js.string txt;\ns\n\nlet span1 idtxt classtxt txt =\n  let s = Dom_html.createSpan doc in\n    s##.id := Js.string idtxt;\n    s##.className := Js.string classtxt;\n    s##.innerHTML := Js.string txt;\n  s\n\nlet p idtxt txt =\nlet p = Dom_html.createP doc in\n  p##.id := Js.string idtxt;\n  p##.innerHTML := Js.string txt;\np\n\nlet br idtxt =\nlet b = Dom_html.createBr doc in\n    b##.id := Js.string idtxt;\nb\n\nlet a ref1 txt = \nlet c = Dom_html.createA doc in\n  c##.href := Js.string ref1;\n  c##.innerHTML := Js.string txt;\nc\n\nlet a1 idtxt ref1 txt = \nlet c = Dom_html.createA doc in\n  c##.id := Js.string idtxt;\n  c##.href := Js.string ref1;\n  c##.innerHTML := Js.string txt;\nc\n\nlet pre idtxt txt =\nlet p = Dom_html.createPre doc in\n  p##.id := Js.string idtxt;\n  p##.innerHTML := Js.string txt;\np\n\nlet code idtxt txt =\nlet c = Dom_html.createPre doc in\n  c##.id := Js.string idtxt;\n  c##.innerHTML := Js.string txt;\nc\n\nlet table id parent : HTMLTable.t =\n  let t = HTMLTable.create id parent in\n    t\n\nlet table2 idtxt txt =\nlet t = Dom_html.createTable doc in\n  t##.id := Js.string idtxt;\n  t##.innerHTML := Js.string txt;\nt\n\nlet select id elementsList =\n  let select = Dom_html.createSelect doc in\n    select##.id := Js.string id;\n    List.iter\n      (fun l ->\n        let option = Dom_html.createOption doc in\n        Dom.appendChild option (doc##createTextNode (Js.string l));\n        Dom.appendChild select option\n      ) elementsList;\n  select\n\nlet putInnerHtml idtxt txt =\n  let element = Dom_html.getElementById idtxt in\n  element##.innerHTML := Js.string txt\n\nlet putInnerHtmlButtons idtxt txt idtool classTool txt1 =\n  let element = Dom_html.getElementById idtxt in\n    element##.innerHTML := (Js.string txt);\n    let tool = div2 idtool classTool txt1 in\n      Dom.appendChild element tool\n\n  let listOnlyAutomataButtons = [\"backwards\"; \"start\"; \"forward\"; \"selectRegex\"]\n  let listOnlyExpressionButtons = [\"selectFA\"; \"start\"]\n  let listOnlyPDAButtons = [\"selectPDA\"]\n  let listOnlyCFGConvertButtons = [\"selectCFG\"]\n  let listOnlyGRConvertButtons = [\"selectGR\"]\n  let listOnlyTMConvertButtons = [\"selectTM\"] (* carolina *)\n  let listOnlyTM2TapesConvertButtons = [\"selectTM2Tapes\"]\n  let listOnlyCFGButtons = [\"testing\"; \"trace\"; \"generate\"; \"backwards\"; \"start\"; \"forward\"]\n  let listOnlyGRButtons = [\"testing\"; \"trace\"; \"generate\"]\n  let listOtherButtons = [\"testing\"; \"trace\"; \"generate\"; \"fitGraph\"; \"editModel\"]\n\n  let defineMainTitle type1 =\n    let title = Dom_html.getElementById \"mainTitle\" in\n      title##.innerHTML := Js.string \"\";\n    if type1 = \"finite automaton\" then\n      title##.innerHTML := Js.string (Lang.i18nMainTitle1 ())\n    else if type1 = \"pushdown automaton\" then\n      title##.innerHTML := Js.string (Lang.i18nMainTitlePDA ())\n    else if type1 = \"regular expression\" then\n      title##.innerHTML := Js.string (Lang.i18nMainTitle2 ())\n    else if type1 = \"exercise\" then\n      title##.innerHTML := Js.string (Lang.i18nMainTitle3 ())\n    else if type1 = \"context free grammar\" then\n      title##.innerHTML := Js.string (Lang.i18nMainTitle4 ())\n    else if type1 = \"turing machine\" then\n      title##.innerHTML := Js.string (Lang.i18nMainTitleTM ())\n    else if type1 = \"grammar\" then\n      title##.innerHTML := Js.string (Lang.i18nMainTitle5 ())\n    else ()\n\n  let disableButton buttonName =\n    let buttonTo = Dom_html.getElementById buttonName in\n      buttonTo##setAttribute (Js.string \"disabled\") (Js.string \"disabled\")\n  \n  let enableButton buttonName =\n    let buttonTo = Dom_html.getElementById buttonName in\n      buttonTo##removeAttribute (Js.string \"disabled\")\n\n  let disableButtons type1 =\n    if type1 = \"finite automaton\" then\n      (List.iter (fun el -> disableButton el) listOnlyExpressionButtons;\n      List.iter (fun el -> disableButton el) listOnlyCFGButtons;\n      List.iter (fun el -> disableButton el) listOnlyCFGConvertButtons;\n      List.iter (fun el -> enableButton el) listOnlyPDAButtons;\n            (* ????????????????????? TM ?? *)\n      List.iter (fun el -> enableButton el) listOnlyAutomataButtons)\n    else if type1 = \"regular expression\" then\n      (List.iter (fun el -> disableButton el) listOnlyAutomataButtons;\n      List.iter (fun el -> disableButton el) listOnlyCFGButtons;\n      List.iter (fun el -> disableButton el) listOnlyCFGConvertButtons;\n      List.iter (fun el -> enableButton el) listOnlyExpressionButtons)\n    else if type1 = \"context free grammar\" then\n      (List.iter (fun el -> disableButton el) listOnlyAutomataButtons;\n      List.iter (fun el -> disableButton el) listOnlyExpressionButtons;\n      List.iter (fun el -> disableButton el) listOnlyCFGConvertButtons;\n      List.iter (fun el -> enableButton el) listOnlyPDAButtons;\n      List.iter (fun el -> enableButton el) listOnlyGRConvertButtons;\n      List.iter (fun el -> enableButton el) listOnlyCFGButtons)\n    else if type1 = \"grammar\" then\n      (List.iter (fun el -> disableButton el) listOnlyAutomataButtons;\n      List.iter (fun el -> disableButton el) listOnlyExpressionButtons;\n      List.iter (fun el -> disableButton el) listOnlyGRConvertButtons;\n      List.iter (fun el -> disableButton el) listOnlyPDAButtons;\n      List.iter (fun el -> disableButton el) listOnlyCFGConvertButtons;\n      (* List.iter (fun el -> enableButton el) listOnlyTMConvertButtons; TODO *)\n      List.iter (fun el -> enableButton el) listOnlyGRButtons)\n    else\n      (List.iter (fun el -> disableButton el) listOnlyExpressionButtons;\n      List.iter (fun el -> disableButton el) listOnlyAutomataButtons;\n      List.iter (fun el -> disableButton el) listOnlyPDAButtons;\n      List.iter (fun el -> disableButton el) listOnlyCFGConvertButtons;\n      List.iter (fun el -> disableButton el) listOnlyCFGButtons;\n      List.iter (fun el -> enableButton el) listOnlyGRConvertButtons;\n      List.iter (fun el -> disableButton el) listOtherButtons)\n\n    let enableAllButtons type1 =\n      List.iter (fun el -> enableButton el) listOtherButtons;\n      if type1 = \"finite automaton\" then\n        (List.iter (fun el -> enableButton el) listOnlyAutomataButtons)\n\n  let createSpanList word acceptance list =\n    let element = Dom_html.getElementById list in\n    let string_of_word = String.concat \"\" (List.map symb2str word) in\n      let ac = span acceptance (\"' \" ^ string_of_word ^ \" '\") in \n        Dom.appendChild element ac;\n      let space = br \"br\" in \n        Dom.appendChild element space\n\n  let createPropertiesList word acceptance list =\n    let element = Dom_html.getElementById list in\n      let ac = span acceptance word in \n        Dom.appendChild element ac;\n        let space = br \"br\" in \n          Dom.appendChild element space\n\n  let createBox1 () =\n    let box1 = Dom_html.getElementById_opt \"Box1\" in\n    match box1 with\n    | None -> ()\n    | Some box1 ->\n      let buttonBox = div \"buttonBox\" in\n      let regExp = div \"regExp\" in\n      let tab = div \"tab\" in\n      let cy = div \"cy\" in\n      let infoBox = div \"infoBox\" in\n        Dom.appendChild box1 buttonBox;\n        Dom.appendChild box1 regExp;\n        Dom.appendChild box1 tab;\n        Dom.appendChild box1 cy;\n        Dom.appendChild box1 infoBox\n      \n  let createBox2 () =\n    let box2 = Dom_html.getElementById_opt \"Box2\" in\n    match box2 with\n    | None -> ()\n    | Some box2 ->\n      let buttonBox1 = div \"buttonBox1\" in\n      let textBox = div \"textBox\" in\n      let cy2 = div \"cy2\" in\n      let infoBox2 = div \"infoBox2\" in\n        Dom.appendChild box2 buttonBox1;\n        Dom.appendChild box2 textBox;\n        Dom.appendChild box2 cy2;\n        Dom.appendChild box2 infoBox2\n\n  let clearBox1 () =\n    putInnerHtml \"Box1\" \"\";\n    createBox1 ()\n    \n  let clearBox2 () =\n    putInnerHtml \"Box2\" \"\";\n    createBox2 ()\n  \n  let saveButton() = (* carolina *)\n    let s = button1 \"save\" \"save\" \"tooltip1\" !Listeners.save in             \n    let tool = div2 \"tooltipCloseLeft\" \"tooltiptext1\" (Lang.i18nTooltipCloseLeft ()) in\n      Dom.appendChild s tool;\n    s   \n  \n  let closeButton () =\n    let c = button1 \"X\" \"closeLeft\" \"tooltip1\" !Listeners.closeLeftListener in             \n    let tool = div2 \"tooltipCloseLeft\" \"tooltiptext1\" (Lang.i18nTooltipCloseLeft ()) in\n      Dom.appendChild c tool;\n    c\n\n\n  let putLR0Table () =\n\ttable \"lr0Table\" \"\"\n  \n  \tlet putLRButtons () =\n\t\tlet buttonBox = Dom_html.getElementById \"row1\" in\n\t\t(*\tbuttonBox##.innerHTML := Js.string \"\"; *)\n\t(*\t \n\t\t let sep = div \"ButtonRow\" in\n\t\t\tDom.appendChild buttonBox sep; *)\n\t\t \n\t\t\n\t\tlet lr0 = button1 \"BuildLR0Diagram\" \"clean\" \"tooltip3\" !ListenersLR.buildLR0DiagramListener in \n\t\t\tDom.appendChild buttonBox lr0;\n\t\t\n\t\tlet slr1 = button1 \"BuildSLR1Diagram\" \"clean\" \"tooltip3\" !ListenersLR.buildSLR1DiagramListener in \n\t\t\tDom.appendChild buttonBox slr1;\n\t\t\t\n\t\tlet lr1 = button1 \"BuildLR1Diagram\" \"clean\" \"tooltip3\" !ListenersLR.buildLR1DiagramListener in \n\t\t\tDom.appendChild buttonBox lr1;\n\t\t\t\n\t\tlet lalr1 = button1 \"BuildLALR1Diagram\" \"clean\" \"tooltip3\" !ListenersLR.buildLALR1DiagramListener in \n\t\t\tDom.appendChild buttonBox lalr1;\n\t\t\t\n\t\tlet lr0table = button1 \"BuildLR0Table\" \"clean\" \"tooltip3\" !ListenersLR.buildLR0TableListener in \n\t\t\tDom.appendChild buttonBox lr0table;\n\t\t\n\t\tlet slr1table = button1 \"BuildSLR1Table\" \"clean\" \"tooltip3\" !ListenersLR.buildSLR1TableListener in \n\t\t\tDom.appendChild buttonBox slr1table;\n\t\t\t\n\t\tlet lr1table = button1 \"BuildLR1Table\" \"clean\" \"tooltip3\" !ListenersLR.buildLR1TableListener in \n\t\t\tDom.appendChild buttonBox lr1table;\n\t\t\t\n\t\tlet lalr1table = button1 \"BuildLALR1Table\" \"clean\" \"tooltip3\" !ListenersLR.buildLALR1TableListener in \n\t\t\tDom.appendChild buttonBox lalr1table;\n\t\t\t\n\t\tlet acceptLR0 = button1 \"AcceptLR0\" \"clean\" \"tooltip3\" !ListenersLR.acceptLR0Listener in \n\t\t\tDom.appendChild buttonBox acceptLR0;\n\t\t\t\n\t\tlet acceptSLR1 = button1 \"AcceptSLR1\" \"clean\" \"tooltip3\" !ListenersLR.acceptSLR1Listener in \n\t\t\tDom.appendChild buttonBox acceptSLR1;\n\t\t\t\n\t\tlet acceptLR1 = button1 \"AcceptLR1\" \"clean\" \"tooltip3\" !ListenersLR.acceptLR1Listener in \n\t\t\tDom.appendChild buttonBox acceptLR1;\n\t\t\t\n\t\tlet acceptLALR1 = button1 \"AcceptLALR1\" \"clean\" \"tooltip3\" !ListenersLR.acceptLALR1Listener in \n\t\t\tDom.appendChild buttonBox acceptLALR1\n\n\n  let putCyButtons () =\n    let buttonBox = Dom_html.getElementById \"buttonBox\" in\n      buttonBox##.innerHTML := Js.string \"\";\n    let divButtons2 = div \"close\" in\n      Dom.appendChild buttonBox divButtons2;\n    let di = Dom_html.getElementById \"close\" in\n      Dom.appendChild di (closeButton());\n    let save = button1 (Lang.i18nSave ()) \"save\" \"tooltip1\" !Listeners.save in\n      Dom.appendChild di save;\n    let tool1 = div2 \"tooltipSpecification\" \"tooltiptext1\" (Lang.i18nTooltipSave ()) in\n      Dom.appendChild save tool1;\n    let info = button1 (Lang.i18nFormatting  ()) \"formatting\" \"tooltip2\" !Listeners.showModelListener in \n      Dom.appendChild di info;\n    let tool = div2 \"tooltipSpecification\" \"tooltiptext2\" (Lang.i18nTooltipSpecification ()) in\n      Dom.appendChild info tool\n      \n  let putCy2Buttons () = \n    let buttonBox = Dom_html.getElementById \"buttonBox1\" in\n      let test1 = button1 \"X\" \"closeRight\" \"tooltip1\" !Listeners.closeRightListener in \n        Dom.appendChild buttonBox test1;\n      let tool = div2 \"tooltipCloseRight\" \"tooltiptext1\" (Lang.i18nTooltipCloseRight ()) in\n        Dom.appendChild test1 tool\n\n  let oneBox () = \n    let box1 = Dom_html.getElementById \"Box1\" in\n      box1##.style##.width:= Js.string \"99%\";\n    let box2 = Dom_html.getElementById \"Box2\" in\n      box2##.style##.width:= Js.string \"0%\";\n    clearBox2 ()\n\n  (*Shows 2 boxes side-by-side.*)\n  let twoBoxes () =\n    clearBox2 ();\n    putCy2Buttons();\n    let box1 = Dom_html.getElementById \"Box1\" in\n      box1##.style##.width:= Js.string \"49.5%\";\n    let box2 = Dom_html.getElementById \"Box2\" in\n      box2##.style##.width:= Js.string \"49.5%\"\n\n  let fitBoxRegex () = \n\tlet regExp = Dom_html.getElementById \"regExp\" in\n\t\tregExp##.style##.height:= Js.string \"6.5%\"\n      \n  let closeBoxRegex () =\n\tlet regExp = Dom_html.getElementById \"regExp\" in\n\t\tregExp##.style##.height:= Js.string \"0%\";\n\tlet cy = Dom_html.getElementById \"cy\" in\n      cy##.style##.height:= Js.string \"60vh\"\n\t\t\n  let cfgBoxRegex () =\n  let regExp = Dom_html.getElementById \"regExp\" in\n    regExp##.style##.height := Js.string \"auto\";\n    regExp##.style##.overflow := Js.string \"unset\";\n  let cy = Dom_html.getElementById \"cy\" in\n    cy##.style##.height:= Js.string \"40vh\";\n    cy##.style##.textAlign:= Js.string \"unset\";\n    cy##.style##.marginLeft:= Js.string \"50%\"\n(*    cy##.classList##add (Js.string \"cyBorder\")*)\n\n  let grBoxRegex () =\n    let regExp = Dom_html.getElementById \"regExp\" in\n      regExp##.style##.height := Js.string \"auto\";\n      regExp##.style##.overflow := Js.string \"unset\";\n    let cy = Dom_html.getElementById \"cy\" in\n      cy##.style##.height:= Js.string \"40vh\";\n      cy##.style##.textAlign:= Js.string \"unset\";\n      cy##.style##.marginLeft:= Js.string \"50%\"\n\n  let restoreCy () =\n  let cy = Dom_html.getElementById \"cy\" in\n    cy##.style##.marginLeft:= Js.string \"unset\"\n(*    cy##.classList##remove (Js.string \"cyBorder\")*)\n\n  let cfgCyClose() =\n    let cy = Dom_html.getElementById \"cy\" in\n    cy##.style##.height:= Js.string \"0vh\"\n\n  let cfgCyOpen() =\n    let cy = Dom_html.getElementById \"cy\" in\n    cy##.style##.height:= Js.string \"60vh\"\n  \n  let cfgCy2Close() =\n    let cy = Dom_html.getElementById \"cy2\" in\n    cy##.style##.height:= Js.string \"0vh\"\n\n\n    let grCyClose() =\n      let cy = Dom_html.getElementById \"cy\" in\n      cy##.style##.height:= Js.string \"0vh\"\n  \n    let grCyOpen() =\n      let cy = Dom_html.getElementById \"cy\" in\n      cy##.style##.height:= Js.string \"60vh\"\n    \n    let grCy2Close() =\n      let cy = Dom_html.getElementById \"cy2\" in\n      cy##.style##.height:= Js.string \"0vh\"\n\n  let toggleTab flag =\n    let tab = Dom_html.getElementById \"tab\" in\n    let automataTable = Dom_html.getElementById \"automataTable\" in\n    if flag then \n      (tab##.style##.height:= Js.string \"40vh\";\n      automataTable##.style##.display := Js.string \"\";\n      cfgCyClose(); grCyClose())\n       (**TODO *)\n    else \n      (tab##.style##.height:= Js.string \"0vh\";\n      automataTable##.style##.display := Js.string \"none\";\n      cfgCyOpen(); grCyOpen())\n      (**TODO *)\n  \n\n  let editModelContent titleTxt otherTxt textAreaContent okAction =\n    let div = div \"modelContentDiv\" in\n    let title = div1 \"editModelTitle\" titleTxt in\n    let other = div1 \"editModelOther\" otherTxt in\n    let textarea = textarea \"modelStringContainer\" 5 50 (Js.string textAreaContent) in\n    let buttonOk = button (Lang.i18nConfirm()) \"modelContentButtonOk\" okAction in\n      Dom.appendChild div title;\n      Dom.appendChild div other;\n      Dom.appendChild div textarea;\n      Dom.appendChild div buttonOk;\n      div\n  \n  let setModal content = \n    let modalC = Dom_html.getElementById \"modal-content\" in\n    modalC##.innerHTML := Js.string \"\";\n    let break = br \"\" in\n      Dom.appendChild modalC break;\n      Dom.appendChild modalC content\n\n  let hideModalWindow () =\n    let modal = Dom_html.getElementById \"myModal\" in\n    modal##.style##.display := Js.string \"none\"\n\n  let showModalWindow () = (*TODO There already exists a showModal, name may change*)\n    let modal = Dom_html.getElementById \"myModal\" in\n    modal##.style##.display := Js.string \"block\"\n\n    let showModelInfo info =\n      let textBox = Dom_html.getElementById \"textBox\" in\n      let test = Dom_html.createDiv doc in \n      test##.textContent := Js.some (Js.string info);\n      test##.style##.fontSize := Js.string \"14px\";  \n      Dom.appendChild textBox test\n\n  let putCyAutomataButtons () =\n    putCyButtons();\n    let buttonBox = Dom_html.getElementById \"buttonBox\" in\n    let divButtons1 = div \"min\" in\n      Dom.appendChild buttonBox divButtons1;\n    let c = button1 (Lang.i18nClean  ()) \"clean\" \"tooltip3\" !ListenersFA.cleanUselessListener in \n      Dom.appendChild divButtons1 c;\n      let tool = div2 \"tooltipClean\" \"tooltiptext3\" (Lang.i18nTooltipClean ()) in\n        Dom.appendChild c tool;\n    let de = button1 (Lang.i18nDeterministic  ()) \"deterministic\" \"tooltip3\" !ListenersFA.getDeterministicListener in \n      Dom.appendChild divButtons1 de;\n      let tool = div2 \"tooltipDeterministic\" \"tooltiptext3\" (Lang.i18nTooltipDeterministic ()) in\n        Dom.appendChild de tool;\n    let de = button1 (Lang.i18nMinimize  ()) \"minimize\" \"tooltip3\" !ListenersFA.defineMinimizedListener in \n      Dom.appendChild divButtons1 de;\n      let tool = div2 \"tooltipMinimize\" \"tooltiptext3\" (Lang.i18nTooltipMinimize ()) in\n        Dom.appendChild de tool;\n    let divButtons = div \"prod\" in\n      Dom.appendChild buttonBox divButtons;\n    let b = button1 (Lang.i18nProductive  ()) \"productive\" \"tooltip3\" !ListenersFA.paintAllProductivesListener in \n      Dom.appendChild divButtons b;\n      let tool = div2 \"tooltipProductive\" \"tooltiptext3\" (Lang.i18nTooltipProductive ()) in\n        Dom.appendChild b tool;\n    let a = button1 (Lang.i18nAccessible ()) \"accessible\" \"tooltip3\" !ListenersFA.paintAllReachableListener in\n      Dom.appendChild divButtons a;\n      let tool = div2 \"tooltipAccessible\" \"tooltiptext3\" (Lang.i18nTooltipAccessible ()) in\n        Dom.appendChild a tool;\n    let u = button1 (Lang.i18nUseful ()) \"useful\" \"tooltip3\" !ListenersFA.paintAllUsefulListener in\n      Dom.appendChild divButtons u;\n      let tool = div2 \"tooltipUseful\" \"tooltiptext3\" (Lang.i18nTooltipUseful ()) in\n        Dom.appendChild u tool;\n    let divButtons3 = div \"clear\" in\n      Dom.appendChild buttonBox divButtons3;\n    let clearAuto = button1 (Lang.i18nClearAuto ()) \"clearAuto\" \"tooltip3\" !ListenersFA.clearAutoListener in\n      Dom.appendChild divButtons3 clearAuto;\n      let tool = div2 \"tooltipClearAuto\" \"tooltiptext3\" (Lang.i18nTooltipClear ()) in\n        Dom.appendChild clearAuto tool;\n    (*put lang*)\n    let tableView = button1 (\"Show Table View\") \"showTable\" \"tooltip3\" !ListenersAutomaton.showTable in\n      Dom.appendChild divButtons3 tableView\n\n  let putCyAutomataPDAButtons () =\n    putCyButtons();\n    let buttonBox = Dom_html.getElementById \"buttonBox\" in\n\n    let divPdaButtonBox = div \"buttonBoxPda\" in\n      Dom.appendChild buttonBox divPdaButtonBox;\n\n      let divMenuSpecificationPda = div \"specsMenuPda\" in\n        Dom.appendChild divPdaButtonBox divMenuSpecificationPda;\n\n        let toggleAcceptanceCriteria = \n          button1 (Lang.i18nTogleAcceptCriteriaState ()) \"toggleAcceptanceCriteria\" \"pdaSpecificationButtons\" !ListenersPDA.toggleAcceptanceCriteria in\n            Dom.appendChild divMenuSpecificationPda toggleAcceptanceCriteria;\n\n        let initialStackSymbolInputBox = \n          button1 ((Lang.i18nInitialStackSymbol ())^(symb2str PushdownAutomaton.stackSpecialSymb)) \"buttonInitialStackSymbol\" \"pdaSpecificationButtons\" !ListenersPDA.changeInitialStackSymbol in (* TODO: Mudar o simbolo inicial*)\n            Dom.appendChild divMenuSpecificationPda initialStackSymbolInputBox;\n\n    let divButtonsCommands = div3 \"buttonCommands\" \"pdaButtonCommands\" in\n      Dom.appendChild divPdaButtonBox divButtonsCommands;\n            \n      let divButtons1 = div \"topLineButtons\" in\n        Dom.appendChild divButtonsCommands divButtons1;\n\n        let c = button1 (Lang.i18nClean  ()) \"clean\" \"tooltip3\" !ListenersPDA.cleanUselessListener in \n          Dom.appendChild divButtons1 c;\n          \n          let tool = div2 \"tooltipClean\" \"tooltiptext3\" (Lang.i18nTooltipClean ()) in\n            Dom.appendChild c tool;\n\n        let clearAuto = button1 (Lang.i18nClearAuto ()) \"clearAuto\" \"tooltip3\" !ListenersPDA.clearAutoListener in\n          Dom.appendChild divButtons1 clearAuto;\n\n          let tool = div2 \"tooltipClearAuto\" \"tooltiptext3\" (Lang.i18nTooltipClear ()) in\n            Dom.appendChild clearAuto tool;\n\n      let divButtons2 = div \"middleLineButtons\" in\n        Dom.appendChild divButtonsCommands divButtons2;\n\n        let convertAcceptStates = button1 (Lang.i18nConvertToAcceptFinalState ()) \"convertAcceptStates\" \"tooltip3\" !ListenersPDA.convertAcceptStates in\n        Dom.appendChild divButtons2 convertAcceptStates;\n\n        let convertEmptyStackAccept = button1 (Lang.i18nConvertToAcceptEmptyStack ()) \"convertEmptyStackAccept\" \"tooltip3\" !ListenersPDA.convertEmptyStackAccept in\n          Dom.appendChild divButtons2 convertEmptyStackAccept;\n        \n          let tableView = button1 (\"Show Table View\") \"showTable\" \"tooltip3\" !ListenersAutomaton.showTable in\n              Dom.appendChild divButtons2 tableView;\n\n      let divButtons = div \"bottomLineButtons\" in\n        Dom.appendChild divButtonsCommands divButtons;\n\n        let b = button1 (Lang.i18nProductive  ()) \"productive\" \"tooltip3\" !ListenersPDA.paintAllProductivesListener in \n          Dom.appendChild divButtons b;\n\n          let tool = div2 \"tooltipProductive\" \"tooltiptext3\" (Lang.i18nTooltipProductive ()) in\n            Dom.appendChild b tool;\n\n        let a = button1 (Lang.i18nAccessible ()) \"accessible\" \"tooltip3\" !ListenersPDA.paintAllReachableListener in\n          Dom.appendChild divButtons a;\n\n          let tool = div2 \"tooltipAccessible\" \"tooltiptext3\" (Lang.i18nTooltipAccessible ()) in\n            Dom.appendChild a tool;\n\n        let u = button1 (Lang.i18nUseful ()) \"useful\" \"tooltip3\" !ListenersPDA.paintAllUsefulListener in\n          Dom.appendChild divButtons u;\n\n          let tool = div2 \"tooltipUseful\" \"tooltiptext3\" (Lang.i18nTooltipUseful ()) in\n            Dom.appendChild u tool\n\n  let showModal () =\n    let modalC = Dom_html.getElementById \"modal-content\" in \n      let blah = p \"text\" \"Isto vai ser o texto do accept das expressões regulares\" in\n        Dom.appendChild modalC blah\n\n  let closeInfo () =\n    let buttonBox = Dom_html.getElementById \"buttonBox1\" in\n      let test = button1 \"X\" \"closeRight\" \"tooltip1\" !Listeners.closeRightListener in \n        Dom.appendChild buttonBox test;\n        let tool = div2 \"tooltipCloseRight\" \"tooltiptext1\" (Lang.i18nTooltipCloseRight ()) in\n          Dom.appendChild test tool\n    \n  let putCyREButtons() =\n    putCyButtons();\n    let buttonBox = Dom_html.getElementById \"buttonBox\" in\n    let row1 = div \"row1\" in\n      Dom.appendChild buttonBox row1;\n      row1##.style##.cssText := Js.string \"display: flex; flex-wrap: wrap; height: fit-content;\";\n    let direction = button1 (Lang.i18nDirection ()) \"changeDirection\" \"tooltip3\" !ListenersRE.changeDirectionListener in \n      Dom.appendChild row1 direction;\n    let tool = div2 \"tooltipDirection\" \"tooltiptext3\" (Lang.i18nTooltipDirection ()) in\n      Dom.appendChild direction tool\n\n    let putCyCFGButtons () =\n      putCyButtons();\n      let buttonBox = Dom_html.getElementById \"buttonBox\" in\n      let row1 = div \"row1\" in\n        Dom.appendChild buttonBox row1;\n        row1##.style##.cssText := Js.string \"display: flex; flex-wrap: wrap; height: fit-content;\";\n      let clean = button1 (Lang.i18nClean ()) \"cleanCFG\" \"tooltip3\" !ListenersCFG.cleanCFGListener in\n        Dom.appendChild row1 clean; (* Append buttons directly to buttonBox *)\n        let tool = div2 \"tooltipCleanCFG\" \"tooltiptext3\" (Lang.i18nTooltipCFGClean ()) in\n          Dom.appendChild clean tool;\n      let rLRec = button1 (Lang.i18nRemoveLeftRecursion ()) \"rLeftRecursion\" \"tooltip3\" !ListenersCFG.removeLeftRecursionListener in\n        Dom.appendChild row1 rLRec;\n        let tool = div2 \"tooltipRemoveLeftRecursion\" \"tooltiptext3\" (Lang.i18nTooltipRemoveLeftRecursion ()) in\n          Dom.appendChild rLRec tool;      \n      let lf = button1 (Lang.i18nLeftFactoring ()) \"leftFactorization\" \"tooltip3\" !ListenersCFG.leftFactoringListener in\n        Dom.appendChild row1 lf;\n        let tool = div2 \"tooltipLeftFactorization\" \"tooltiptext3\" (Lang.i18nTooltipLeftFactoring ()) in\n          Dom.appendChild lf tool;      \n      let removeEpsilon = button1 (Lang.i18nRemoveEpsilonProductions ()) \"rEpsilon\" \"tooltip3\" !ListenersCFG.removeEpsilonListener in\n        Dom.appendChild row1 removeEpsilon;\n        let tool = div2 \"tooltipRemoveEpsilon\" \"tooltiptext3\" (Lang.i18nTooltipRemoveEpsilonProductions ()) in\n          Dom.appendChild removeEpsilon tool;\n      let removeUnit = button1 (Lang.i18nRemoveUnitProductions ()) \"rUnit\" \"tooltip3\" !ListenersCFG.removeUnitListener in\n        Dom.appendChild row1 removeUnit;\n        let tool = div2 \"tooltipRemoveUnit\" \"tooltiptext3\" (Lang.i18nTooltipRemoveUnitProductions ()) in\n          Dom.appendChild removeUnit tool;\n      let transformLL1 = button1 (Lang.i18nTransformToLL1 ()) \"transformLL1\" \"tooltip3\" !ListenersCFG.transformLL1Listener in\n        Dom.appendChild row1 transformLL1;\n        let tool = div2 \"tooltipTransformLL1\" \"tooltiptext3\" (Lang.i18nTooltipTransformLL1 ()) in\n          Dom.appendChild transformLL1 tool;\n   (* let row3 = div \"row3\" in\n      Dom.appendChild buttonBox row3;*)\n      let parsingTable = button1 (Lang.i18nSetTables ()) \"setTables\" \"tooltip3\" !ListenersCFG.tablesListener in\n        Dom.appendChild row1 parsingTable;\n        let tool = div2 \"tooltipSetTables\" \"tooltiptext3\" (Lang.i18nTooltipSetTables ()) in\n          Dom.appendChild parsingTable tool;\n      let rdParser = button1 (Lang.i18nRDParser ()) \"rdparserCFG\" \"tooltip3\" !ListenersCFG.recursiveDescedentParserListener in \n        Dom.appendChild row1 rdParser;\n        let tool = div2 \"tooltipRDParserCFG\" \"tooltiptext3\" (Lang.i18nTooltipRDParser ()) in \n          Dom.appendChild rdParser tool;\n      let simpleToggle = button1 (Lang.i18nToggle ()) \"toggle\" \"tooltip3\" !ListenersCFG.simpleToggleListener in \n        Dom.appendChild row1 simpleToggle;\n        let tool = div2 \"tooltipRDParserCFG\" \"tooltiptext3\" (Lang.i18nTooltipToggleMode ()) in \n          Dom.appendChild simpleToggle tool\n    \n  let putCyGRButtons () =\n      putCyButtons();\n      let buttonBox = Dom_html.getElementById \"buttonBox\" in\n      let row1 = div \"row1\" in\n        row1##.style##.cssText := Js.string \"display: flex; flex-wrap: wrap; height: fit-content;\";\n        Dom.appendChild buttonBox row1;\n        let clean = button1 (Lang.i18nClean ()) \"cleanGR\" \"tooltip3\" (fun () -> !Listeners.runOp \"clean\") in\n          Dom.appendChild row1 clean;\n          let tool = div2 \"tooltipCleanGR\" \"tooltiptext3\" (Lang.i18nTooltipCFGClean ()) in\n            Dom.appendChild clean tool; \n        let kuroda = button1 (Lang.i18nKuroda ()) \"kurodaGR\" \"tooltip3\" (fun () -> !Listeners.runOp \"kuroda\") in\n          Dom.appendChild row1 kuroda;\n          let tool = div2 \"tooltipKurodaGR\" \"tooltiptext3\" (Lang.i18nTooltipGRKuroda ()) in\n            Dom.appendChild kuroda tool;\n        let penttonen = button1 (Lang.i18nPenttonen ()) \"penttonenGR\" \"tooltip3\" (fun () -> !Listeners.runOp \"penttonen\") in\n          Dom.appendChild row1 penttonen;\n          let tool = div2 \"tooltipPenttonenGR\" \"tooltiptext3\" (Lang.i18nTooltipGRPenttonen ()) in\n            Dom.appendChild penttonen tool;\n        let nonContractingToCSG = button1 (Lang.i18monoCSG ()) \"nonContractingToCSGGRGR\" \"tooltip3\" (fun () -> !Listeners.runOp \"nonContractingToCSG\") in\n          Dom.appendChild row1 nonContractingToCSG;\n          let tool = div2 \"nonContractingToCSGGRGR\" \"tooltiptext3\" (Lang.i18nTooltipnonContractingToCSG ()) in\n            Dom.appendChild nonContractingToCSG tool\n\n  let defineCFG () =\n    let cfgString = Dom_html.getElementById \"regExp\" in\n      let expr = div1 \"cfg\" \"\" in\n        Dom.appendChild cfgString expr;\n      let _ = table \"cfgProductionsTable\" \"cfg\" in\n      let break = br \"grammarToAcceptBr\" in\n        Dom.appendChild cfgString break;\n      let acceptDiv = div \"cfgAccept\" in\n        Dom.appendChild cfgString acceptDiv;\n        let acceptWordDiv = div \"cfgAcceptWord\" in\n        let acceptTableDiv = div \"cfgAcceptTable\" in\n          Dom.appendChild acceptDiv acceptWordDiv;\n          Dom.appendChild acceptDiv acceptTableDiv;\n          let _ = table \"cfgGuideTable\" \"cfgAcceptTable\" in\n      putInnerHtml \"infoBox\" \"\"\n\n      let defineGR () =\n        let grString = Dom_html.getElementById \"regExp\" in\n          let expr = div1 \"gr\" \"\" in\n            Dom.appendChild grString expr;\n          let _ = table \"grProductionsTable\" \"gr\" in\n          let break = br \"grammarToAcceptBr\" in\n            Dom.appendChild grString break;\n          let acceptDiv = div \"grAccept\" in\n            Dom.appendChild grString acceptDiv;\n            let acceptWordDiv = div \"grAcceptWord\" in\n            let acceptTableDiv = div \"grAcceptTable\" in\n              Dom.appendChild acceptDiv acceptWordDiv;\n              Dom.appendChild acceptDiv acceptTableDiv;\n              let _ = table \"grGuideTable\" \"grAcceptTable\" in\n          putInnerHtml \"infoBox\" \"\"\n\n  let putCyTMButtons () =\n    putCyButtons();\n    let buttonBox = Dom_html.getElementById \"buttonBox\" in\n\n    let divButtons1 = div \"min\" in\n      divButtons1##.style##.cssText := Js.string \"display: flex; flex-wrap: wrap; height: fit-content;\";\n      Dom.appendChild buttonBox divButtons1;\n    let c = button1 (Lang.i18nClean  ()) \"clean\" \"tooltip3\" !ListenersTM.cleanUselessListener in \n      Dom.appendChild divButtons1 c;\n      let tool = div2 \"tooltipClean\" \"tooltiptext3\" (Lang.i18nTooltipClean ()) in\n        Dom.appendChild c tool;\n    (* let divButtons = div \"prod\" in\n      Dom.appendChild buttonBox divButtons; *)\n    let b = button1 (Lang.i18nProductive  ()) \"productive\" \"tooltip3\" !ListenersTM.paintAllProductivesListener in \n      Dom.appendChild divButtons1 b;\n      let tool = div2 \"tooltipProductive\" \"tooltiptext3\" (Lang.i18nTooltipProductive ()) in\n        Dom.appendChild b tool;\n    let a = button1 (Lang.i18nAccessible ()) \"accessible\" \"tooltip3\" !ListenersTM.paintAllReachableListener in\n      Dom.appendChild divButtons1 a;\n      let tool = div2 \"tooltipAccessible\" \"tooltiptext3\" (Lang.i18nTooltipAccessible ()) in\n        Dom.appendChild a tool;\n    let u = button1 (Lang.i18nUseful ()) \"useful\" \"tooltip3\" !ListenersTM.paintAllUsefulListener in\n      Dom.appendChild divButtons1 u;\n      let tool = div2 \"tooltipUseful\" \"tooltiptext3\" (Lang.i18nTooltipUseful ()) in\n        Dom.appendChild u tool;\n   (* let divButtons3 = div \"clear\" in\n      Dom.appendChild buttonBox divButtons3; *)\n    let clearAuto = button1 (Lang.i18nClearAuto ()) \"clearAuto\" \"tooltip3\" !ListenersTM.clearAutoListener in\n      Dom.appendChild divButtons1 clearAuto;\n      let tool = div2 \"tooltipClearAuto\" \"tooltiptext3\" (Lang.i18nTooltipClear ()) in\n        Dom.appendChild clearAuto tool\n  \n  let addBr idtxt addTo =\n    let break = br idtxt in\n      Dom.appendChild addTo break\n\n  let printCFGGrammar grammarHTML =\n    let grammarElement = Dom_html.getElementById \"cfg\" in\n      grammarElement##.innerHTML := Js.string grammarHTML\n\n      let printGRGrammar grammarHTML =\n        let grammarElement = Dom_html.getElementById \"gr\" in\n          grammarElement##.innerHTML := Js.string grammarHTML\n\n  let getTransformLang (transformType : string) : string =\n    if transformType = ContextFreeGrammarLL1.leftRecursionRemovalTransform\n    then Lang.i18nRemoveLeftRecursion()\n    else\n    if transformType = ContextFreeGrammarLL1.leftFactoringTransform\n    then Lang.i18nLeftFactoring()\n    else\n    if transformType = ContextFreeGrammarLL1.cleanProductiveTransform\n    then Lang.i18nRemoveUnproductive()\n    else\n    if transformType = ContextFreeGrammarLL1.cleanAccessibleTransform\n    then Lang.i18nRemoveInaccessible()\n    else\n    if transformType = ContextFreeGrammarLL1.unitRemovalTransform\n    then Lang.i18nRemoveUnitProductions()\n    else\n    if transformType = ContextFreeGrammarLL1.epsilonRemovalTransform\n    then Lang.i18nRemoveEpsilonProductions()\n    else\n    if transformType = ContextFreeGrammarLL1.ll1Transform\n    then Lang.i18nTransformToLL1()\n    else transformType\n\n  let printCFG2Grammar transformType tableId = \n    let textBox = Dom_html.getElementById \"textBox\" in\n      textBox##.innerHTML := Js.string \"\";\n    let newGrammarElem = div \"cfgGrammar2\" in\n      Dom.appendChild textBox newGrammarElem;\n    let title = h2 \"newGrammarTitle\" (Lang.i18nNewGrammar()) in\n      Dom.appendChild newGrammarElem title;\n      let prevButton = button1 (Lang.i18nPrevious()) \"previousNewCfg\" \"tooltip3\" !ListenersCFG.previousNewCFGListener in\n      let next = button1 (Lang.i18nNext()) \"nextNewCfg\" \"tooltip3\" !ListenersCFG.nextNewCFGListener in\n      let transformLabel = span \"transformLabel\" (getTransformLang transformType) in\n      Dom.appendChild newGrammarElem transformLabel;\n      addBr \"infoBoxBr\" newGrammarElem;\n      Dom.appendChild newGrammarElem prevButton;\n      Dom.appendChild newGrammarElem next;\n      addBr \"infoBoxBr\" newGrammarElem;\n    let _ = table tableId \"cfgGrammar2\" in\n   (*joao porque desapareceu??? AMD\n\t\tDom.appendChild newGrammarElem grammarTable;*)\n    let grammarDiv = div \"grammarBox\" in\n      Dom.appendChild newGrammarElem grammarDiv\n\n\n    let printGR2Grammar tableId = \n      let textBox = Dom_html.getElementById \"textBox\" in\n        textBox##.innerHTML := Js.string \"\";\n      let newGrammarElem = div \"grGrammar2\" in\n        Dom.appendChild textBox newGrammarElem;\n      let title = h2 \"newGrammarTitle\" (Lang.i18nNewGrammar()) in\n        Dom.appendChild newGrammarElem title;\n        (* let prevButton = button1 (Lang.i18nPrevious()) \"previousNewGr\" \"tooltip3\" !ListenersGR.previousNewGRListener in\n        let next = button1 (Lang.i18nNext()) \"nextNewGr\" \"tooltip3\" !ListenersGR.nextNewGRListener in\n        let transformLabel = span \"transformLabel\" \"grammar cleaned\" in\n        Dom.appendChild newGrammarElem transformLabel; *)\n        addBr \"infoBoxBr\" newGrammarElem;\n        (* Dom.appendChild newGrammarElem prevButton;\n        Dom.appendChild newGrammarElem next; *)\n        addBr \"infoBoxBr\" newGrammarElem;\n      let _ = table tableId \"grGrammar2\" in\n    (*joao porque desapareceu??? AMD\n      Dom.appendChild newGrammarElem grammarTable;*)\n      let grammarDiv = div \"grammarBox\" in\n        Dom.appendChild newGrammarElem grammarDiv;\n      grCy2Close()\n\n  let printGR2GrammarComp tableId =\n    let textBox = Dom_html.getElementById \"textBox\" in\n      textBox##.innerHTML := Js.string \"\";\n    let newGrammarElem = div \"grGrammar2\" in\n      Dom.appendChild textBox newGrammarElem;\n    let title = h2 \"newGrammarTitle\" (Lang.i18nNewGrammar()) in\n      Dom.appendChild newGrammarElem title;\n    let grammarTable = table2 tableId \"\" in  (* ver o table2 AMD *)\n      Dom.appendChild newGrammarElem grammarTable;\n    let grammarDiv = div \"grammarBox\" in\n      Dom.appendChild newGrammarElem grammarDiv\n\n  let printCFG2GrammarComp tableId =\n    let textBox = Dom_html.getElementById \"textBox\" in\n      textBox##.innerHTML := Js.string \"\";\n    let newGrammarElem = div \"grGrammar2\" in\n      Dom.appendChild textBox newGrammarElem;\n    let title = h2 \"newGrammarTitle\" (Lang.i18nNewGrammar()) in\n      Dom.appendChild newGrammarElem title;\n    let grammarTable = table2 tableId \"\" in  (* ver o table2 AMD *)\n      Dom.appendChild newGrammarElem grammarTable;\n    let grammarDiv = div \"grammarBox\" in\n      Dom.appendChild newGrammarElem grammarDiv\n\n  let printCFGTableGuide table =\n    let textBox = Dom_html.getElementById \"cfgAcceptTable\" in\n      textBox##.innerHTML := Js.string \"\";\n      ignore (textBox##appendChild (Js.Unsafe.coerce @@ table))\n  \n  let printCFGCurrentWord word1 word2 origWord wordAccepted =\n    let textBox = Dom_html.getElementById \"cfgAcceptWord\" in\n      textBox##.innerHTML := Js.string \"\";\n      let word2 = (*ac|bc instead of ac|EC*)\n        if String.length word1 > 0\n          then String.sub origWord (String.length word1) ((String.length origWord) - (String.length word1))\n          else String.sub origWord 0 ((String.length origWord) - (String.length word1))\n      in\n      let text = div2 \"acceptLL1CurrentWord\" ( \n        match wordAccepted with\n        | None -> \"\"\n        | Some a when a = true -> \"wordAccepted\"\n        | Some a when a = false -> \"wordRejected\"\n        | _ -> \"\" (*Should not happen*) )\n        (word1 ^ \"|\" ^ word2)\n      in\n      Dom.appendChild textBox text\n\n\n\n      let printGRTableGuide table =\n        let textBox = Dom_html.getElementById \"grAcceptTable\" in\n          textBox##.innerHTML := Js.string \"\";\n          ignore (textBox##appendChild (Js.Unsafe.coerce @@ table))\n      \n      let printGRCurrentWord word1 word2 origWord wordAccepted =\n        let textBox = Dom_html.getElementById \"grAcceptWord\" in\n          textBox##.innerHTML := Js.string \"\";\n          let word2 = (*ac|bc instead of ac|EC*)\n            if String.length word1 > 0\n              then String.sub origWord (String.length word1) ((String.length origWord) - (String.length word1))\n              else String.sub origWord 0 ((String.length origWord) - (String.length word1))\n          in\n          let text = div2 \"acceptLL1CurrentWord\" ( \n            match wordAccepted with\n            | None -> \"\"\n            | Some a when a = true -> \"wordAccepted\"\n            | Some a when a = false -> \"wordRejected\"\n            | _ -> \"\" (*Should not happen*) )\n            (word1 ^ \"|\" ^ word2)\n          in\n          Dom.appendChild textBox text\n\n  (*let printTable id title tableString parent =\n    let parentElement = Dom_html.getElementById parent in\n    let title = h2 (id ^ \"Title\") title in\n      Dom.appendChild parentElement title;\n    addBr \"printBr\" parentElement;\n    let tableHTML = table id tableString in\n      Dom.appendChild parentElement tableHTML*)\n\n  let printTable2 id title table parent =\n    let parentElement = Dom_html.getElementById parent in\n    let title = h2 (id ^ \"Title\") title in\n      Dom.appendChild parentElement title;\n    addBr \"printBr\" parentElement;\n      Dom.appendChild parentElement table\n\n  let prepareAcceptTable () =\n\t   let parent = Dom_html.getElementById \"textBox\" in\n\t   let acceptTable = Dom_html.getElementById_opt \"acceptTable\" in\n    (match acceptTable with\n      | None -> let title1 = h2 (\"acceptTable\" ^ \"Title\") (\"Accept\") in\n                Dom.appendChild parent title1;\n                ignore (table \"acceptTable\" \"textBox\");\n      | Some a -> ())\n\n  let prepareCFG2Tables () =\n    let parent = Dom_html.getElementById \"textBox\" in\n    let id1 = ContextFreeGrammarLL1View.firstFollowTableId() in\n    let id2 = ContextFreeGrammarLL1View.parsingTableId() in\n    let firstFollowTable = Dom_html.getElementById_opt id1 in\n    (match firstFollowTable with\n      | None -> let title1 = h2 (id1 ^ \"Title\") (Lang.i18nFirstAndFollow()) in\n                Dom.appendChild parent title1;\n                ignore (table \"cfgFirstFollowTable\" \"textBox\");\n      | Some a -> ());\n    let parsingTable = Dom_html.getElementById_opt id2 in\n    (match parsingTable with\n      | None -> let title2 = h2 (id2 ^ \"Title\") (Lang.i18nParsingTable()) in\n                Dom.appendChild parent title2;\n                ignore (table \"cfgParsingTable\" \"textBox\");\n      | Some a -> ())\n\n\n      let prepareGR2Tables () =\n        let parent = Dom_html.getElementById \"textBox\" in\n        let id1 = ContextFreeGrammarLL1View.firstFollowTableId() in\n        let id2 = ContextFreeGrammarLL1View.parsingTableId() in\n        let firstFollowTable = Dom_html.getElementById_opt id1 in\n        (match firstFollowTable with\n          | None -> let title1 = h2 (id1 ^ \"Title\") (Lang.i18nFirstAndFollow()) in\n                    Dom.appendChild parent title1;\n                    ignore (table \"grFirstFollowTable\" \"textBox\");\n          | Some a -> ());\n        let parsingTable = Dom_html.getElementById_opt id2 in\n        (match parsingTable with\n          | None -> let title2 = h2 (id2 ^ \"Title\") (Lang.i18nParsingTable()) in\n                    Dom.appendChild parent title2;\n                    ignore (table \"grParsingTable\" \"textBox\");\n          | Some a -> ())\n\n          let printGR2AllTables firstFollowTable parsingTable =\n            printTable2 \"grFirstFollowTable\" (Lang.i18nFirstAndFollow()) firstFollowTable \"textBox\";\n            printTable2 \"grParsingTable\" (Lang.i18nParsingTable()) parsingTable \"textBox\"\n\n  let printCFG2AllTables firstFollowTable parsingTable =\n    printTable2 \"cfgFirstFollowTable\" (Lang.i18nFirstAndFollow()) firstFollowTable \"textBox\";\n    printTable2 \"cfgParsingTable\" (Lang.i18nParsingTable()) parsingTable \"textBox\"\n\n    \n  let printCFGAccept titleAccept titleFirstFollow titleParsingTable firstFollowTable parsingTable parsingGuideTable word1 word2 origWord wordAccepted =\n      printCFGCurrentWord word1 word2 origWord wordAccepted;\n      printCFGTableGuide parsingGuideTable;\n      printCFG2AllTables firstFollowTable parsingTable  \n\n\n      let printGRAccept titleAccept titleFirstFollow titleParsingTable firstFollowTable parsingTable parsingGuideTable word1 word2 origWord wordAccepted =\n        printGRCurrentWord word1 word2 origWord wordAccepted;\n        printGRTableGuide parsingGuideTable;\n        printGR2AllTables firstFollowTable parsingTable  \n\n  let printCFG2RecursiveDescedentParser codeString =\n    let rdParserCode = Dom_html.getElementById \"rdParserCode\" in\n      rdParserCode##.innerHTML := Js.string \"\";\n      Dom.appendChild rdParserCode (doc##createTextNode (Js.string codeString))\n\n\n      let printGR2RecursiveDescedentParser codeString =\n        let rdParserCode = Dom_html.getElementById \"rdParserCode\" in\n          rdParserCode##.innerHTML := Js.string \"\";\n          Dom.appendChild rdParserCode (doc##createTextNode (Js.string codeString))\n\n  let prepareCFG2RecursiveDescedentParser optsList changeFun =\n    let textBox = Dom_html.getElementById \"textBox\" in\n      let title = h2 \"rdParserTitle\" (Lang.i18nRDParser()) in\n      let div = div \"rdParserSelectDiv\" in\n        Dom.appendChild textBox title;\n        Dom.appendChild textBox div;\n      let select = select \"rdParserSelect\" optsList in\n        select##.onchange :=\n          Dom_html.handler (fun _ -> \n            let v = Js.to_string select##.value in\n            printCFG2RecursiveDescedentParser (changeFun v);\n            let button = Dom_html.getElementById(\"copyClipboardBtn\") in\n            button##.innerHTML := Js.string (Lang.i18nRDParserCopyButtonDefault()); \n            Js._true);\n      let copyClipboardBtn = button (Lang.i18nRDParserCopyButtonDefault()) \"copyClipboardBtn\" \n        (fun _ -> \n          let button = Dom_html.getElementById(\"copyClipboardBtn\") in\n          button##.innerHTML := Js.string (Lang.i18nRDParserCopyButtonClick());\n          let text : Js.js_string Js.t = (Js.Unsafe.coerce (Dom_html.getElementById(\"rdParserCode\")))##.innerText in\n          let clipboard = Js.Unsafe.global##.navigator##.clipboard in\n          clipboard##writeText text)\n      in\n        Dom.appendChild div select;\n        Dom.appendChild div copyClipboardBtn;\n        addBr \"rdParserBr\" textBox;\n      let rdParserPre = pre \"rdParserPre\" \"\" in\n      let rdParserCode = code \"rdParserCode\" \"\" in\n        Dom.appendChild textBox rdParserPre;\n        Dom.appendChild rdParserPre rdParserCode;\n        (printCFG2RecursiveDescedentParser (changeFun (List.hd optsList)))\n\n\n\n        let prepareGR2RecursiveDescedentParser optsList changeFun =\n          let textBox = Dom_html.getElementById \"textBox\" in\n            let title = h2 \"rdParserTitle\" (Lang.i18nRDParser()) in\n            let div = div \"rdParserSelectDiv\" in\n              Dom.appendChild textBox title;\n              Dom.appendChild textBox div;\n            let select = select \"rdParserSelect\" optsList in\n              select##.onchange :=\n                Dom_html.handler (fun _ -> \n                  let v = Js.to_string select##.value in\n                  printGR2RecursiveDescedentParser (changeFun v);\n                  let button = Dom_html.getElementById(\"copyClipboardBtn\") in\n                  button##.innerHTML := Js.string (Lang.i18nRDParserCopyButtonDefault()); \n                  Js._true);\n            let copyClipboardBtn = button (Lang.i18nRDParserCopyButtonDefault()) \"copyClipboardBtn\" \n              (fun _ -> \n                let button = Dom_html.getElementById(\"copyClipboardBtn\") in\n                button##.innerHTML := Js.string (Lang.i18nRDParserCopyButtonClick());\n                let text : Js.js_string Js.t = (Js.Unsafe.coerce (Dom_html.getElementById(\"rdParserCode\")))##.innerText in\n                let clipboard = Js.Unsafe.global##.navigator##.clipboard in\n                clipboard##writeText text)\n            in\n              Dom.appendChild div select;\n              Dom.appendChild div copyClipboardBtn;\n              addBr \"rdParserBr\" textBox;\n            let rdParserPre = pre \"rdParserPre\" \"\" in\n            let rdParserCode = code \"rdParserCode\" \"\" in\n              Dom.appendChild textBox rdParserPre;\n              Dom.appendChild rdParserPre rdParserCode;\n              (printGR2RecursiveDescedentParser (changeFun (List.hd optsList)))\n\n\n  let getIsLL1 ll1 infoBox =\n    let text = span \"isLL1\" \n      (if ll1 \n        then (Lang.i18nIsLL1 ()) \n        else (Lang.i18nIsNotLL1 ())\n      )\n    in\n      Dom.appendChild infoBox text\n\n\n   let getIsLR0 bool infoBox =\n    let text = span \"isLR0\" \n      (if bool \n        then \"The grammar is LR0.\"\n        else \"The grammar is not LR0.\"\n      )\n    in\n      Dom.appendChild infoBox text\n      \n   let getIsSLR1 bool infoBox =\n    let text = span \"isSLR1\" \n      (if bool \n        then \"The grammar is SLR1.\"\n        else \"The grammar is not SLR1.\"\n      )\n    in\n      Dom.appendChild infoBox text\n      \n   let getIsLR1 bool infoBox =\n    let text = span \"isLR1\" \n      (if bool \n        then \"The grammar is LR1.\"\n        else \"The grammar is not LR1.\"\n      )\n    in\n      Dom.appendChild infoBox text\n      \n   let getIsLALR1 bool infoBox =\n    let text = span \"isLALR1\" \n      (if bool \n        then \"The grammar is LALR1.\"\n        else \"The grammar is not LALR1.\"\n      )\n    in\n      Dom.appendChild infoBox text\n\n\n\n\n\n      \n  let getIsLeftRecursive lr infoBox =\n    let text = span \"isLeftRecursive\" \n      (if lr\n        then (Lang.i18nIsLeftRecursive ())\n        else (Lang.i18nIsNotLeftRecursive ())\n      )\n    in\n      Dom.appendChild infoBox text\n  \n  let getIsLeftFactoring lf infoBox =\n    let text = span \"isLeftFactoring\"\n      (if lf\n        then (Lang.i18nIsLeftFactoring ())\n        else (Lang.i18nIsNotLeftFactoring ())\n      )\n    in\n      Dom.appendChild infoBox text\n\n  let getHasParsingTableConflict pConf infoBox =\n    let text = span \"hasParsingTableConflict\"\n      (if pConf\n        then (Lang.i18nHasParsingTableConflict())\n        else (Lang.i18nHasNotParsingTableConflict())\n      )\n    in\n      Dom.appendChild infoBox text\n\n  let getIsCFGClean c prod access infoBox =\n    let text = span \"isCFGClean\"\n    (if c\n        then (Lang.i18nIsCFGClean ())\n        else Lang.i18nIsNotCFGClean()\n            ^ (if not prod then Lang.i18nNotProd () else \"\")\n            ^ (if not access then Lang.i18nNotAccess () else \"\")\n    )\n    in\n      Dom.appendChild infoBox text\n\n  let getIsCFG c infoBox =\n    let text = span \"isCFG\"\n    (if c\n        then (Lang.i18nIsCFG ())\n        else \"\"\n    )\n    in\n      Dom.appendChild infoBox text\n\n      let getIsCSG c infoBox =\n        let text = span \"isCSG\"\n        (if c\n            then (Lang.i18nIsCSG ())\n            else \"\"\n        )\n        in\n          Dom.appendChild infoBox text\n\n\n          let getIsMO c infoBox =\n            let text = span \"isMO\"\n            (if c\n                then (Lang.i18nIsMO ())\n                else \"\"\n            )\n            in\n              Dom.appendChild infoBox text\n\n\n              let getIsUG c infoBox =\n                let text = span \"isUG\"\n                (if c\n                    then (Lang.i18nIsUG ())\n                    else \"\"\n                )\n                in\n                  Dom.appendChild infoBox text\n\n\n                  let getIsLG c infoBox =\n                    let text = span \"isLG\"\n                    (if c\n                        then (Lang.i18nIsLG ())\n                        else \"\"\n                    )\n                    in\n                      Dom.appendChild infoBox text\n                      \n                      let getIsRLG c infoBox =\n                        let text = span \"isRLG\"\n                        (if c\n                            then (Lang.i18nIsRLG ())\n                            else \"\"\n                        )\n                        in\n                          Dom.appendChild infoBox text\n\n                          let getIsLLG c infoBox =\n                            let text = span \"isLLG\"\n                            (if c\n                                then (Lang.i18nIsLLG ())\n                                else \"\"\n                            )\n                            in\n                              Dom.appendChild infoBox text\n\n  let getIsGRClean c prod access infoBox =\n    let text = span \"isGRClean\"\n    (if c\n        then (Lang.i18nIsCFGClean ())\n        else Lang.i18nIsNotCFGClean()\n            ^ (if not prod then Lang.i18nNotProd () else \"\")\n            ^ (if not access then Lang.i18nNotAccess () else \"\")\n    )\n    in\n      Dom.appendChild infoBox text\n\n  let putTreeResult text =\n    let textBox = Dom_html.getElementById \"textBox\" in\n      let en = div1 \"treeResult\" text in \n        Dom.appendChild textBox en\n\n  let getDeterminim deter infoBox = \n    let info = if deter then Lang.i18nIsDeterministic () else Lang.i18nNotDeterministic () in\n      let deterministic = span \"isdeterministic\" info in \n        Dom.appendChild infoBox deterministic\n    \n  let getMinimism min infoBox = \n    let info = if min then Lang.i18nIsMinimal () else Lang.i18nNotMinimal () in\n      let minimal = span \"isminimal\" info in \n        Dom.appendChild infoBox minimal\n        \n  let getHasUselessStates use uStates infoBox = \n    if use then \n      (let useful = span \"areuseful\" (Lang.i18nNotUseless ()) in\n        Dom.appendChild infoBox useful)\n    else \n      (let useless = Set.toList uStates in\n        let number = List.length useless in \n          let useful = (Lang.i18nHas ()) ^ (string_of_int number) ^ (Lang.i18nUselessStates ()) in \n            let use = span \"areuseful\" useful in\n              Dom.appendChild infoBox use)\n\n  let getIsEquivalentFA isEquivalentFA infoBox = \n    let info = if isEquivalentFA then Lang.i18nisEquivalentFA () else Lang.i18nisNotEquivalentFA () in\n      let isFA = span \"isEquivalentFA\" info in\n        Dom.appendChild infoBox isFA\n\n  let getNumberStates nStates infoBox = \n    let number = string_of_int nStates in \n      let sentence = (Lang.i18nNumberStates ()) ^ number ^ \". \" in \n        let sentence1 = span \"numberstates\" sentence in\n          Dom.appendChild infoBox sentence1\n    \n  let getNumberTransitions nTransitions infoBox = \n    let number = string_of_int nTransitions in \n        let sentence = (Lang.i18nNumberTransitions ()) ^ number ^ \". \" in \n          let sentence1 = span \"numbertransitions\" sentence in\n            Dom.appendChild infoBox sentence1\n\n(* TM *)\n  let getIsLinearBounded is infoBox = \n    if is then \n      let lb = span \"islinearbounded\" (Lang.i18nIsLinearBounded ()) in \n        Dom.appendChild infoBox lb\n    else \n      let lb = span \"islinearbounded\" (Lang.i18nIsNotLinearBounded ()) in \n        Dom.appendChild infoBox lb\n\n    \n  let defineInformationBox s =\n    let elementStr = if s then \"infoBox2\" else \"infoBox\" in\n    let element = Dom_html.getElementById elementStr in\n    element##.innerHTML := Js.string \"\";\n    element\n\n  let createServerExampleButton name =\n      button name \"exampleButton\" (fun () -> !Listeners.openEntityListener (Repository.getText name));; (* carolina *)\n\n  let putButton name = \n    let examples = Dom_html.getElementById \"examplesServer\" in\n      let title = name in \n        let example = createServerExampleButton title in \n          Dom.appendChild examples example\n\n(* carolina *)\n  let putButton2 name = \n    let examples = Dom_html.getElementById \"examplesServer\" in\n      let title = name in \n        let example = createServerExampleButton title in \n          Dom.insertBefore examples example examples##.firstChild\n\n  let defineRE def s =\n    let elem = if s then Dom_html.getElementById \"textBox\" else Dom_html.getElementById \"regExp\" in\n      let expr = div1 \"reg\" def in\n        Dom.appendChild elem expr;\n      putInnerHtml (if s then \"infoBox2\" else \"infoBox\") \"\"\n\n  let putWords listWords =\n    putInnerHtml \"textBox\" \"\";\n    let textBox = Dom_html.getElementById \"textBox\" in\n    let title = div1 \"generateWords\" (Lang.i18nGenerateWords ()) in \n      Dom.appendChild textBox title;\n    let test = Set.toList listWords in \n      let string_of_word w = \"' \" ^ String.concat \"\" (List.map symb2str w) ^ \" '\" in\n        let string_of_words l = String.concat \", \" (List.map string_of_word l) in \n          let res = string_of_words test in\n            let zz = textarea \"textarea\" 2 20 (Js.string res) in \n              Dom.appendChild textBox zz\n\n  let putEnumButton () = \n    let buttonBox = Dom_html.getElementById \"buttonBox1\" in\n      let clearButton = button \"X\" \"clearEnum\" !ListenersEXER.clearExerciseListener in      \n        Dom.appendChild buttonBox clearButton\n\n  let addEnumTitle () =\n    let textBox = Dom_html.getElementById \"textBox\" in\n      let en = h2 \"enum\" (Lang.i18nEnumTitle ()) in \n        Dom.appendChild textBox en\n\n  let defineEnumProblem prob =\n    let textBox = Dom_html.getElementById \"textBox\" in\n      let test = (Lang.i18nProblem ()) ^ prob in\n        let en = div1 \"prob\" test in \n          Dom.appendChild textBox en;\n    let resultBox = div \"resultBox\" in \n      Dom.appendChild textBox resultBox\n\n  let addAcceptedTitle () =\n    let textBox = Dom_html.getElementById \"textBox\" in\n      let tac = div1 \"accept\" (Lang.i18nAcceptedWords ()) in \n        Dom.appendChild textBox tac;\n      let ac = div \"inside\" in \n        Dom.appendChild textBox ac    \n\n  let addNonAcceptTitle () =\n    let textBox = Dom_html.getElementById \"textBox\" in\n      let twr = div1 \"notAccept\" (Lang.i18nNonAccepted ()) in \n        Dom.appendChild textBox twr;\n      let wr = div \"outside\" in \n        Dom.appendChild textBox wr\n\n  let addPropertiesBox () =\n    let textBox = Dom_html.getElementById \"textBox\" in\n    let twr = div1 \"prop\" (Lang.i18nProperties ()) in \n        Dom.appendChild textBox twr;\n      let ac = div \"properties\" in \n        Dom.appendChild textBox ac    \n    \n  let addEnumCheckButton () =\n    let textBox = Dom_html.getElementById \"textBox\" in\n      let checkButton = button (Lang.i18nVerify ()) \"enumVerify\" !ListenersEXER.checkExerciseListener in\n        Dom.appendChild textBox checkButton\n  \n  let defineResult result =\n    let resultBox = Dom_html.getElementById \"resultBox\" in\n      resultBox##.innerHTML := Js.string \"\";\n    if result then \n      let res = div1 \"correct\" (Lang.i18nRight ()) in\n        Dom.appendChild resultBox res\n    else\n      (let res = div1 \"wrong\" (Lang.i18nWrong ()) in \n        Dom.appendChild resultBox res);\n      putInnerHtml \"properties\" \"\";\n      putInnerHtml \"inside\" \"\";\n      putInnerHtml \"outside\" \"\"\n\n  let defineTreeButtons () =\n    let textBox = Dom_html.getElementById \"textBox\" in\n      let en = div \"treeButtons\" in \n        Dom.appendChild textBox en;\n      let buttonBox = Dom_html.getElementById \"treeButtons\" in \n        let previous = button (Lang.i18nPrevious ()) \"previousTree\" !ListenersRE.previousTreeListener in\n          Dom.appendChild buttonBox previous;\n        let next = button (Lang.i18nNext ()) \"nextTree\" !ListenersRE.nextTreeListener in\n          Dom.appendChild buttonBox next\n\n  let putTreeGoodDerivations text =\n    let textBox = Dom_html.getElementById \"textBox\" in\n      let en = div1 \"treeGoodDerivations\" text in \n        Dom.appendChild textBox en\n\n  let putTreeBadDerivations text =\n    let textBox = Dom_html.getElementById \"textBox\" in\n      let en1 = div1 \"treeBadDerivations\" text in \n        Dom.appendChild textBox en1\n\n  let putTreeNumbers text =\n    let textBox = Dom_html.getElementById \"textBox\" in\n    let treeNumbers = Dom_html.getElementById_opt \"treeNumbers\" in\n    match treeNumbers with\n    | None -> let en = div1 \"treeNumbers\" text in \n                Dom.appendChild textBox en\n    | Some e -> e##.innerHTML := Js.string text\n\n  let about () =\n    putInnerHtml \"regExp\" \"\";\n    putInnerHtml \"infoBox\" \"\";\n    let cy = Dom_html.getElementById \"buttonBox\" in\n      cy##.innerHTML := Js.string \"\";\n        Dom.appendChild cy (closeButton());\n    putInnerHtml \"mainTitle\" (Lang.i18nAboutTitle ());\n    let info = div \"aboutBox\" in \n      Dom.appendChild cy info;\n    let aboutBox = Dom_html.getElementById \"aboutBox\" in\n      let subtitle = h2 \"aboutSubtitle\" (Lang.i18nAboutSubtitle ()) in\n        Dom.appendChild aboutBox subtitle;\n      let aboutTex = p \"aboutText\" \"\" in \n        Dom.appendChild aboutBox aboutTex;\n      let text = span \"aboutText1\" (Lang.i18nAboutText1 ()) in \n        Dom.appendChild aboutTex text;\n      let text1 = a \"http://nova-lincs.di.fct.unl.pt/\" (Lang.i18nNovaLincs ()) in\n        Dom.appendChild aboutTex text1;\n      let text2 = span \"aboutText2\" (Lang.i18nAboutText2 ()) in \n        Dom.appendChild aboutTex text2;\n      let text3 = a \"https://release.di.ubi.pt/factor/index.html\" (Lang.i18nFactor ()) in\n        Dom.appendChild aboutTex text3;\n      let text = span \"aaa\" (Lang.i18nAboutText16 ()) in\n        Dom.appendChild aboutTex text;\n      let text = a \"https://release.di.ubi.pt/leafs/index.html\" (Lang.i18nAboutText17 ()) in\n        Dom.appendChild aboutTex text;\n      let text = span \"bbb\" (Lang.i18nAboutText3 ()) in\n        Dom.appendChild aboutTex text;\n      let text5 = a1 \"tezos\" \"https://tezos.com/\" (Lang.i18nFooter ()) in \n        Dom.appendChild aboutTex text5;\n      let text6 = span \"aboutText16\" (Lang.i18nAboutText16 ()) in\n        Dom.appendChild aboutTex text6;\n      let text7 = a1 \"inria\" \"https://www.inria.fr/\" (Lang.i18nFooter1  ()) in\n        Dom.appendChild aboutTex text7;\n      let text8 = span \"aboutText20\" \". \" in\n        Dom.appendChild aboutTex text8;\n      let aboutTex1 = p \"aboutText17\" \"\" in \n        Dom.appendChild aboutBox aboutTex1;\n      let text9 = span \"aboutText4\" (Lang.i18nAboutText4 ()) in\n        Dom.appendChild aboutTex text9;\n      let text10 = a \"https://gitlab.com/releaselab/leaf/OFLAT\" \"GitLab\" in\n        Dom.appendChild aboutTex text10;\n      let text11 = span \"aboutText18\" \".\" in\n        Dom.appendChild aboutTex text11;\n      let sub = h2 \"aboutSubtitle2\" (Lang.i18nAboutSubtitle2 ()) in\n        Dom.appendChild aboutBox sub;\n      let text12 = p \"aboutText5\" (Lang.i18nAboutText5 ()) in \n        Dom.appendChild aboutBox text12;\n      let text13 = p \"aboutText6\" (Lang.i18nAboutText6 ()) in \n        Dom.appendChild aboutBox text13;\n      let text14 = pre \"aboutText7\" (Lang.i18nAboutText7 ()) in \n        Dom.appendChild aboutBox text14;\n      let text15 = p \"aboutText8\" (Lang.i18nAboutText8 ()) in \n        Dom.appendChild aboutBox text15;\n      let text16 = pre \"aboutText9\" (Lang.i18nAboutText9 ()) in \n        Dom.appendChild aboutBox text16;\n      let text17 = p \"aboutText10\" (Lang.i18nAboutText10 ()) in \n        Dom.appendChild aboutBox text17;\n      let text18 = pre \"aboutText11\" (Lang.i18nAboutText11 ()) in \n        Dom.appendChild aboutBox text18;\n      let text19 = p \"aboutText12\" (Lang.i18nAboutText12 ()) in \n        Dom.appendChild aboutBox text19;\n      let text20 = p \"aboutText13\" (Lang.i18nAboutText13 ()) in \n        Dom.appendChild aboutBox text20;\n      let text21 = p \"aboutText14\" (Lang.i18nAboutText14 ()) in \n        Dom.appendChild aboutBox text21;\n      let text22 = p \"aboutText15\" (Lang.i18nAboutText15 ()) in \n        Dom.appendChild aboutBox text22\n\n    let feedback () = \n      let cy = Dom_html.getElementById \"regExp\" in\n        cy##.innerHTML := Js.string \"\";\n      let cy = Dom_html.getElementById \"infoBox\" in\n        cy##.innerHTML := Js.string \"\";\n      let cy = Dom_html.getElementById \"buttonBox\" in\n        cy##.innerHTML := Js.string \"\";\n          Dom.appendChild cy (closeButton());\n      putInnerHtml \"mainTitle\" (Lang.i18nFeedback ());\n      let test1 = div (\"FeedbackDiv\") in\n        Dom.appendChild cy test1;\n      let text = Dom_html.getElementById \"FeedbackDiv\" in\n        let text1 = p \"feedbackText\" (Lang.i18nFeedbackText ()) in\n          Dom.appendChild text text1;\n        let spanBox = p \"feedbackText1\" \"\" in\n          Dom.appendChild text spanBox;\n       let spanBox1 = Dom_html.getElementById \"feedbackText1\" in\n        let span1 = span \"feedbackText2\" (Lang.i18nFeedbackText2 ()) in\n          Dom.appendChild spanBox1 span1;\n        let link = a \"mailto:amd@fct.unl.pt\" \"Artur Miguel Dias\" in\n          Dom.appendChild spanBox1 link;\n        let span2 = span \"feedbackText3\" \".\" in\n          Dom.appendChild spanBox1 span2;\n        let text3 = p \"feedbackThankYou\" (Lang.i18nFeedbackThankYou ()) in\n          Dom.appendChild text text3\n      \n    \n\n    let putGenText statsDiv visitedConfigs exactResult time =\n      let textConfigs = span \"configs\" (\" | Configurations Visited: \" ^ Int.to_string visitedConfigs) in\n      let textExact = span \"exact\" (\" | Computation Aborted: \" ^ Bool.to_string (not(exactResult))) in\n      let textTime = span \"time\" (\" | Time Taken: \" ^ Printf.sprintf \"%.4f\" time ^ \" seconds. |\") in\n      Dom.appendChild statsDiv textConfigs;\n      Dom.appendChild statsDiv textExact;\n      Dom.appendChild statsDiv textTime\n        \n    let putAcceptText statsDiv accepted visitedConfigs exactResult time =\n      let textAccepted = span \"accepted\" (\"Word Accepted: \" ^ Bool.to_string accepted) in\n      Dom.appendChild statsDiv textAccepted;\n      putGenText statsDiv visitedConfigs exactResult time\n\n\n    let displayGenStats visitedConfigs exactResult time =\n      let prevStatsBox = Dom_html.getElementById_opt(\"statsBox\") in\n      let infoBox = Dom_html.getElementById(\"infoBox\") in\n      match prevStatsBox with\n      | None ->\n        let statsDiv = div \"statsBox\" in\n        Dom.appendChild infoBox statsDiv;\n        putGenText statsDiv visitedConfigs exactResult time\n      | Some statsDiv -> \n        putInnerHtml \"statsBox\" \"\";\n        putGenText statsDiv visitedConfigs exactResult time\n\n    let displayAcceptStats accepted visitedConfigs exactResult time =\n      let prevStatsBox = Dom_html.getElementById_opt(\"statsBox\") in\n      let infoBox = Dom_html.getElementById(\"infoBox\") in\n      match prevStatsBox with\n      | None ->\n        let statsDiv = div \"statsBox\" in\n        Dom.appendChild infoBox statsDiv;\n        putAcceptText statsDiv accepted visitedConfigs exactResult time\n      | Some statsDiv -> \n        putInnerHtml \"statsBox\" \"\";\n        putAcceptText statsDiv accepted visitedConfigs exactResult time\n      \n      \n    \n    let changeButtonColor but color =\n      let button = Dom_html.getElementById but in\n        button##.style##.backgroundColor := Js.string color\n      \n    \n    \n\n      \n      \n    \n  let changeLang () =\n    ViewUtil.changeLang !Lang.lang;\n    putInnerHtml \"title\" (Lang.i18nTitle ());\n    putInnerHtml \"version\" (Lang.i18nVersion ());\n    \n    putInnerHtml \"optionNewDefault\" (Lang.i18nNewModel ());\n    putInnerHtml \"optionNewAutomatonFA\" (Lang.i18nMainTitle1());\n    putInnerHtml \"optionNewAutomatonPDA\" (Lang.i18nMainTitlePDA());\n    putInnerHtml \"optionNewRegularExpression\" (Lang.i18nMainTitle2());\n    putInnerHtml \"optionNewContextFreeGrammar\" (Lang.i18nMainTitle4());\n\n    putInnerHtml \"optionNewGrammar\" (Lang.i18nMainTitle5());\n    putInnerHtml \"optionNewTuringMachine\" (Lang.i18nselectTM());\n    putInnerHtml \"optionNewComposition\" (Lang.i18nMainTitleComp()); (* carolina *)\n\n    putInnerHtml \"editModel\" (Lang.i18nEditModel ());\n    putInnerHtml \"fitGraph\" (Lang.i18nFitGraph ());\n    putInnerHtml \"generate\" (Lang.i18nGenerate ());\n    putInnerHtml \"testing\" (Lang.i18nTesting ());\n    putInnerHtml \"trace\" \"Trace\";\n    putInnerHtml \"step\" (Lang.i18nStep ());\n    putInnerHtml \"start\" (Lang.i18nStart ());\n        \n    putInnerHtml \"selectRegex\" (Lang.i18nSelectRegex ());\n    putInnerHtml \"selectFA\" (Lang.i18nselectFA ());\n    putInnerHtml \"selectPDA\" (Lang.i18nselectPDA ());\n    putInnerHtml \"selectCFG\" (Lang.i18nselectCFG ());\n\n    putInnerHtml \"selectGR\" (Lang.i18nselectGR ());\n\n    putInnerHtml \"selectTM\" (Lang.i18nselectTM ()); (* carolina *)\n    putInnerHtml \"selectTM2Tapes\" (Lang.i18nselectTM2Tapes ()); \n    putInnerHtml \"selectConv\" (Lang.i18nSelectConv ());\n\n    putInnerHtml \"importModel\" (Lang.i18nImportModel ());\n    putInnerHtml \"exportModel\" (Lang.i18nExportModel ());\n    putInnerHtml \"server\" (Lang.i18nServer ());     \n\n    (* putInnerHtml \"selectedL\" (Lang.i18nSelectedL ());   \n    putInnerHtml \"selectPT\" (Lang.i18nSelectPT ());\n    putInnerHtml \"selectEN\" (Lang.i18nSelectEN ());\n    putInnerHtml \"selectFR\" (Lang.i18nSelectFR ()); *)\n\n    putInnerHtml \"about\" (Lang.i18nAbout ());\n    putInnerHtml \"feedback\" (Lang.i18nFeedback ());\n    putInnerHtml \"settings\" \"Settings\" (*TODO: LANG*);\n        \n    putInnerHtml \"developed\" (Lang.i18nDeveloped ());\n    putInnerHtml \"footerButton0\" (Lang.i18nNovaLincs () );\n    putInnerHtml \"project\" (Lang.i18nProject ());\n    putInnerHtml \"footerButton3\" (Lang.i18nFactor ());\n    putInnerHtml \"and\" (Lang.i18nAnd ());\n    (* putInnerHtml \"leaf\" (Lang.i18nLeafs ()); *)\n    putInnerHtml \"financing\" (Lang.i18nFinancing ());\n    putInnerHtml \"footerButton1\" (Lang.i18nFooter ());\n    putInnerHtml \"and1\" (Lang.i18nAnd ());\n    putInnerHtml \"footerButton2\" (Lang.i18nFooter1 ());\n\n    if (StateVariables.getCy1Type() = StateVariables.getAutomatonType()) then\n      (putInnerHtml \"tooltipCloseLeft\" (Lang.i18nTooltipCloseLeft ());\n      putInnerHtmlButtons \"save\" (Lang.i18nSave ()) \"tooltipSpecification\" \"tooltiptext1\" (Lang.i18nTooltipSpecification ());\n      putInnerHtmlButtons \"formatting\" (Lang.i18nFormatting ()) \"tooltipSpecification\" \"tooltiptext2\" (Lang.i18nTooltipSpecification ());\n      putInnerHtmlButtons \"clean\" (Lang.i18nClean ()) \"tooltipClean\" \"tooltiptext3\" (Lang.i18nTooltipClean ());\n      putInnerHtmlButtons \"deterministic\" (Lang.i18nDeterministic ()) \"tooltipDeterministic\" \"tooltiptext3\" (Lang.i18nTooltipDeterministic ());\n      putInnerHtmlButtons \"minimize\" (Lang.i18nMinimize ()) \"tooltipMinimize\" \"tooltiptext3\" (Lang.i18nTooltipMinimize ());\n      putInnerHtmlButtons \"productive\" (Lang.i18nProductive ()) \"tooltipProductive\" \"tooltiptext3\" (Lang.i18nTooltipProductive ());\n      putInnerHtmlButtons \"accessible\" (Lang.i18nAccessible ()) \"tooltipAccessible\" \"tooltiptext3\" (Lang.i18nTooltipAccessible ());\n      putInnerHtmlButtons \"useful\" (Lang.i18nUseful ()) \"tooltipUseful\" \"tooltiptext3\" (Lang.i18nTooltipUseful ());\n      putInnerHtml \"infoBox\" \"\";\n      putInnerHtml \"mainTitle\" (Lang.i18nMainTitle1 ());\n      !Listeners.defineInformationBoxListener());\n\n    if (StateVariables.getCy1Type() = StateVariables.getRegexType()) then\n      (putInnerHtml \"tooltipCloseLeft\" (Lang.i18nTooltipCloseLeft ());\n      putInnerHtmlButtons \"changeDirection\" (Lang.i18nDirection ()) \"tooltipDirection\" \"tooltiptext2\" (Lang.i18nTooltipDirection ());\n      putInnerHtml \"mainTitle\" (Lang.i18nMainTitle2 ()));\n\n    if (StateVariables.getCy2Type() = StateVariables.getEnumerationType()) then\n      (putInnerHtml \"enumVerify\" (Lang.i18nVerify ());\n\n      let prob = (StateVariables.returnEnum())#representation.problem in\n        let prob1 = (Lang.i18nProblem ()) ^ prob in\n        putInnerHtml \"prob\" prob1;\n      putInnerHtml \"enum\" (Lang.i18nEnumTitle ());\n      putInnerHtml \"accept\" (Lang.i18nAcceptedWords ());\n      putInnerHtml \"notAccept\" (Lang.i18nNonAccepted ());\n      if Dom_html.getElementById_opt \"correct\" <> None then\n        putInnerHtml \"correct\" (Lang.i18nRight ());\n      if Dom_html.getElementById_opt \"wrong\" <> None then\n        putInnerHtml \"wrong\" (Lang.i18nWrong ());\n      putInnerHtml \"mainTitle\" (Lang.i18nMainTitle3 ());\n      );\n\n    if (StateVariables.getCy2Type() = StateVariables.getInfoType()) then\n      (putInnerHtml \"generateWords\" (Lang.i18nGenerateWords ());\n      putInnerHtml \"tooltipCloseRight\" (Lang.i18nTooltipCloseRight ());\n      );\n\n    if (StateVariables.getCy2Type() = StateVariables.getVerifyType()) then\n      (putInnerHtml \"textBox\" \"\";\n      !ListenersRE.resultCountListener ();\n      !ListenersRE.defineNumberTreesListener ();\n      defineTreeButtons ();\n      putInnerHtml \"tooltipCloseRight\" (Lang.i18nTooltipCloseRight ());\n      );\n\n      if (StateVariables.getCy1Type() = StateVariables.getFeedbackType()) then\n      (putInnerHtml \"mainTitle\" \"------------\";\n       putInnerHtml \"feedbackText\" (Lang.i18nFeedbackText ());\n       putInnerHtml \"feedbackText2\" (Lang.i18nFeedbackText2 ());\n       putInnerHtml \"feedbackThankYou\" (Lang.i18nFeedbackThankYou ());\n      );\n\n   if (StateVariables.getCy1Type() = StateVariables.getInfoType ()) then\n       (putInnerHtml \"mainTitle\" (Lang.i18nAboutTitle ());\n        putInnerHtml \"aboutSubtitle\" (Lang.i18nAboutSubtitle ());\n        putInnerHtml \"aboutSubtitle2\" (Lang.i18nAboutSubtitle2 ());\n        putInnerHtml \"aboutText1\" (Lang.i18nAboutText1 ());\n        putInnerHtml \"aboutText2\" (Lang.i18nAboutText2 ());\n        putInnerHtml \"aaa\" (Lang.i18nAboutText16 ());\n        putInnerHtml \"bbb\" (Lang.i18nAboutText3 ());\n        putInnerHtml \"aboutText4\" (Lang.i18nAboutText4 ());\n        putInnerHtml \"aboutText5\" (Lang.i18nAboutText5 ());\n        putInnerHtml \"aboutText6\" (Lang.i18nAboutText6 ());\n        putInnerHtml \"aboutText7\" (Lang.i18nAboutText7 ());\n        putInnerHtml \"aboutText8\" (Lang.i18nAboutText8 ());\n        putInnerHtml \"aboutText9\" (Lang.i18nAboutText9 ());\n        putInnerHtml \"aboutText10\" (Lang.i18nAboutText10 ());\n        putInnerHtml \"aboutText11\" (Lang.i18nAboutText11 ());\n        putInnerHtml \"aboutText12\" (Lang.i18nAboutText12 ());\n        putInnerHtml \"aboutText13\" (Lang.i18nAboutText13 ());\n        putInnerHtml \"aboutText14\" (Lang.i18nAboutText14 ());\n        putInnerHtml \"aboutText15\" (Lang.i18nAboutText15 ());\n        putInnerHtml \"aboutText16\" (Lang.i18nAboutText16 ());\n        putInnerHtml \"tezos\" (Lang.i18nFooter ());\n\t\tputInnerHtml \"inria\" (Lang.i18nFooter1 ());\n        \n       )\n\n    (*JP*)\n\n    (*TODO: LANG*)\n\n\tlet rec find_indexX f l i =\n\t\tmatch l with\n\t\t\t| [] -> None\n\t\t\t| x::xs -> if f x then Some i\n\t\t\t\t\telse find_indexX f xs (i+1)\n\t\n\tlet find_index f l =    (* AMD passar para Util *)\n\t\tfind_indexX f l 0 \n\t\n    let settings() =\n      clearBox1();\n      putInnerHtml \"mainTitle\" \"Settings\";\n      let buttonBox = Dom_html.getElementById \"buttonBox\" in\n      let settingsDiv = div \"settings\" in\n        Dom.appendChild buttonBox settingsDiv;\n        Dom.appendChild settingsDiv (closeButton());\n      let h1 = h2 \"settingsIntro\" \"Customizable Settings\" in\n        Dom.appendChild settingsDiv h1;\n      let spanL = span \"settingsText\" \"Change Language\" in\n        Dom.appendChild settingsDiv spanL;\n      let languageOptions = [\"EN\"; \"PT\"; \"FR\"] in\n      let selectLanguage = select \"selectLanguage\" languageOptions in\n        let findIndex = Some 0 (*List.find_index(fun str -> String.lowercase_ascii str == !Lang.lang) languageOptions*) in\n        match findIndex with\n        | None -> ()\n        | Some index ->\n        selectLanguage##.selectedIndex := index;\n        selectLanguage##.onchange := Dom.handler (fun _ ->\n          let langString = String.lowercase_ascii (Js.to_string selectLanguage##.value) in\n            Lang.set_language (Js.string langString);\n            changeLang();\n            Js._true       \n          );\n        Dom.appendChild settingsDiv selectLanguage;\n      let span1 = span \"settingsText\" \"Change Empty Symbol\" in\n        Dom.appendChild settingsDiv span1;\n      let emptyOptions = [\"ε\"; \"∼\"; \"𝜆\"] in\n      let selectEmpty = select \"selectEmpty\" emptyOptions in \n        let findIndex2 = Some 1 (* find_index(fun str -> str == StateVariables.returnEmpty()) emptyOptions *) in\n        match findIndex2 with\n        | None -> ()\n        | Some index2 ->\n        selectEmpty##.selectedIndex := index2;\n        selectEmpty##.onchange := Dom.handler (fun _ -> \n        StateVariables.changeEmpty (Js.to_string selectEmpty##.value);\n        JS.log (\"MUDEI O EMPTY para \" ^ StateVariables.returnEmpty());\n        Js._true);\n        Dom.appendChild settingsDiv selectEmpty\n\n\n\nend \n","(*\n * Controller.ml\n *\n * This file is part of the OFLAT app\n *\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\n *\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\n *\n * This software is distributed under the terms of the GPLv3 license.\n * See the included LICENSE file for details.\n *\n *  Written by Rita Macedo\n *)\n\n(* \n * Description: Controller component of the application.\n *)\n\n\nopen OCamlFlat\nopen BasicTypes\nopen Js_of_ocaml\nopen JS\nopen ViewUtil\nopen AutomatonView\nopen FiniteAutomatonView\nopen PushdownAutomatonView\nopen RegularExpressionView\nopen ContextFreeGrammarView\nopen GrammarView\nopen TuringMachineView\nopen CompositionView\nopen Lang\nopen Listeners\nopen HtmlPageClient\nopen StateVariables\nopen String\nopen Random\nopen Grammar\n\nlet createModelPrep titleTxt otherTxt textAreaString okAction =\n  let modelContent = HtmlPageClient.editModelContent titleTxt otherTxt textAreaString okAction in\n  HtmlPageClient.setModal (Js.Unsafe.coerce modelContent);\n  HtmlPageClient.showModalWindow ()\n\nlet createModelPrepFA textAreaString okAction =\n  createModelPrep (Lang.i18nMainTitle1()) (Lang.i18nInstructionsAutomaton()) textAreaString okAction\n\nlet createModelPrepPDA textAreaString okAction =\n  createModelPrep (Lang.i18nMainTitlePDA()) (Lang.i18nInstructionsAutomaton()) textAreaString okAction\n\nlet createModelPrepRE textAreaString okAction =\n  createModelPrep (Lang.i18nMainTitle2()) \"\" textAreaString okAction\n\nlet createModelPrepComp textAreaString okAction =\n  createModelPrep (Lang.i18nMainTitleComp()) \"\" textAreaString okAction\n  \nlet createModelPrepCFG textAreaString okAction =\n  createModelPrep (Lang.i18nMainTitle4()) (Lang.i18nInstructionsCFG()) textAreaString okAction\n\nlet createModelPrepGR textAreaString okAction =\n  createModelPrep (Lang.i18nMainTitle5()) (Lang.i18nInstructionsGR()) textAreaString okAction\n\nmodule CtrlUtil = struct\n  let changeToControllerCtrlRight = ref (fun () -> ())\n  let changeToControllerCtrlLeft = ref (fun () -> ())\n\n  let oneBox cy = \n    !changeToControllerCtrlRight();\n    HtmlPageClient.oneBox();\n    Cytoscape.fit cy\n    \n  let twoBoxes cy =\n    HtmlPageClient.twoBoxes();\n    Cytoscape.fit cy\nend\n\nclass virtual controller =\n  object(self)\n\n    val mutable layoutDir = None\n    val mutable updateType = None\n    val virtual cy : Cytoscape.cytoscape Js_of_ocaml.Js.t option\n    val mutable activeProm = Lwt.return();\n\n    val listOnlyAutomataButtons = [\"backwards\"; \"start\"; \"forward\"; \"selectRegex\"]\n    val listOnlyTMButtons = [\"backwards\"; \"start\"; \"forward\"]  (* ML *)\n    val listOnlyExpressionButtons = [\"selectFA\"; \"start\"]\n    val listOnlyPDAButtons = [\"selectPDA\"]\n    val listOnlyCFGConvertButtons = [\"selectCFG\"]\n    val listOnlyGRConvertButtons = [\"selectGR\"]\n    val listOnlyTMConvertButtons = [\"selectTM\"]\t(* carolina *)\n    val listOnlyTM2TapesConvertButtons = [\"selectTM2Tapes\"]\n    val listOnlyCFGButtons = [\"testing\"; \"trace\"; \"generate\"; \"backwards\"; \"start\"; \"forward\"]\n    val listOnlyGRButtons = [\"testing\"; \"trace\"; \"generate\"]\n    val listOtherButtons = [\"testing\"; \"trace\"; \"generate\"; \"fitGraph\"; \"editModel\"; \"exportModel\"]\n    val listDisCompButtons = [\"trace\"; \"backwards\"; \"start\"; \"forward\"; \"autoAccept\"]\n\n    method locked : bool = false\n    (* TM *)\n    (* method addNode (x : int) (y : int) (st: state) : unit = Error.fatal \"addNode\" *)\n\tmethod addNode (x : int) (y : int) (initial : bool) (final : bool): unit = Error.fatal \"addNode\"\n    method eliminateNode (st: state) : unit = Error.fatal \"eliminateNode\"\n    method changeTab : unit = Error.fatal \"changeTab\"\n    method getTab : bool = Error.fatal \"getTab\"\n    method startGraph : unit = Error.fatal \"startGraph\"\n    method defineExample : unit = Error.fatal \"defineExample\"\n    method defineExample2 : unit = Error.fatal \"define Example cy 2\"\n    method defineInformationBox : unit = Error.fatal \"defineInformationBox\"\n    method convertToRegExp : RegularExpressionView.model = Error.fatal \"convert to regex\"\n    method convertToFA : FiniteAutomatonView.model = Error.fatal \"convert to FA\"\n    method convertToCFG : ContextFreeGrammarView.model = Error.fatal \"convert to CFG\"\n    method convertToGR : GrammarView.model = Error.fatal \"convert to GR\"\n    method convertToTM_SingleTape : TuringMachineView.model = Error.fatal \"convert to TM single tape\"\n    method convertToTM_DualTape : TuringMachineView.model = Error.fatal \"convert to TM dual tape\"\n    method convertToPDA : PushdownAutomatonView.model = Error.fatal \"convert to PDA\"\n    method createTransition (s1 : state) (s2 : state) : unit = Error.fatal \"createTransition\"\n    method eliminateTransition ((c1: state), (c2: string), (c3: state)): unit = Error.fatal \"eliminateTransition\"\n    method defineMinimize (listColors: string array) (number : int) : unit = Error.fatal \"minimize\"\n    method addFinalNode (x : int) (y : int) (st: state): unit = Error.fatal \"addFinalNode\"\n    method turnFinalNode (st: state): unit = Error.fatal \"turnFinalNode\"\n    method removeFinalNode (st: state): unit = Error.fatal \"removeFinalNode\"\n    method addInitialNode (st: state) : unit = Error.fatal \"addInitialNode\"\n    method autoAccept : bool Lwt.t = Error.fatal \"accept\"\n    method getModel : string = \"\"\n    method getAutomaton: AutomatonView.model = Error.fatal \"addInitialNode\"\n    method changeToEditModelMode: unit = Error.fatal \"changeToEditMode\"\n    method getWords (number: int): unit = Error.fatal \"getWords\"\n    method getNewSentence = Js.string (\"\")\n    method startStep (word: string): unit = Error.fatal \"startStep\"\n    method nextStep: unit  = Error.fatal \"nextStep\"  \n    method backStep: unit = Error.fatal \"backStep\"\n    method model: Model.model = Error.fatal \"model\"\n    method replicateOnLeft: unit = Error.fatal \"replicateOnLeft\"\n    method setUpdateType (s : string) : unit = Error.fatal \"setUpdateType\"\n    method getUpdateType : string option = updateType\n    method updateRight: unit = ()\n    method toggleAcceptanceCriteria: unit = Error.fatal \"toggleAcceptanceCriteria\"\n    method changeInitialStackSymbol: unit = Error.fatal \"changeInitialStackSymbol\"\n    method convertAcceptStates: PushdownAutomatonView.model option = Error.fatal \"convertAcceptStates\"\n    method convertEmptyStackAccept: PushdownAutomatonView.model option = Error.fatal \"convertEmptyStackAccept\"\n    method showTrace (word: string) : unit = Error.fatal \"trace\"\n    method checkWord (word: string) : unit = Error.fatal \"checkword\"\n    method model2Str : string = Error.fatal \"model2Str\"\n\n\n    method getCy: Cytoscape.cytoscape Js_of_ocaml.Js.t = \n      match cy with\n        | None -> Error.fatal \"getCy\"\n        | Some cy -> cy\n    method getCy_opt = cy\n\n    method feedback = ()\n    method about = ()\n\n    method printErrors =\n      let errors = [] in\n        if errors = [] then \n          ()\n        else \n          JS.alertStr (String.concat \"\\n\" errors)\n\n    method clearExerciseAction = \n      HtmlPageClient.oneBox ();\n      HtmlPageClient.clearBox2 ();\n      let element = Dom_html.getElementById \"cy2\" in\n        element##.innerHTML := Js.string \"\"\n\n    method updateButtons = \n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyExpressionButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyAutomataButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyPDAButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyCFGConvertButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyCFGButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyGRConvertButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyTMConvertButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyGRButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOtherButtons\n\n    method setTitle: unit = HtmlPageClient.defineMainTitle (\"\")\n\n    method checkHelper (result: bool) ((insideErrors: word set), (outsideErrors: word set), (properties: property set)) : unit = Error.fatal \"checkHelper\"\n\n    method changeLayoutDir newLayout =\n      layoutDir <- Some (newLayout)\n\n    method getLayoutDir : string = \n      match layoutDir with\n        | None -> \"\"\n        | Some layoutDir -> layoutDir\n      \n\n    method closeRightAction = \n      HtmlPageClient.oneBox ();\n      HtmlPageClient.clearBox2 ();\n      !CtrlUtil.changeToControllerCtrlRight ()\n\n    method resetStyle = ()\n\n    method returnType = \"\"\n\n    method operation opName modelKind: unit =\n      Js.Unsafe.global##logEntry (Js.string opName) (Js.string modelKind)\n    \n\n      method changeProm prom = activeProm <- prom\n      method returnProm = activeProm\n      method cancelProm = Lwt.cancel activeProm\n      method promState = Lwt.state activeProm\n      \n      method finish = self#cancelProm (*upgradeable*)  \n\n    method getFA : FiniteAutomatonView.model = Error.fatal \"get automata\"\n    method getPDA : PushdownAutomatonView.model = Error.fatal \"get PDA\"\n    method getRE : RegularExpressionView.model = Error.fatal \"get RE\"\n    method getCFG : ContextFreeGrammarView.model = Error.fatal \"get CFG\"\n\n    method getGR : GrammarView.model = Error.fatal \"get GR\"\n    method handleOp (operation: string) : unit = Error.fatal \"GR operations\"\n    \n    (*  ????? getTM  *)\n    method getComp : CompositionView.model = Error.fatal \"get Comp\"  (* carolina *)\n    method getExercise : Exercise.exercise = Error.fatal \"get RE\"\n    method getResultTree : bool = Error.fatal \"get Result Tree\"\n    method getWordAsList () : word = Error.fatal \"get word as list\"\n\n    (* method editModel : unit = Error.fatal \"edit model\" *)\n    \n    method box2CFGShow (f : ContextFreeGrammarLL1.transformation) : unit = Error.fatal \"show cfg transformation box 2\"\n\n    method box2GRShow (g : Grammar.model) : unit = Error.fatal \"show gr transformation box 2\"\n    \n    method renameState (s : state) : unit = Error.fatal \"rename state\"\nend\n\nclass textController (s : bool) = \n  object(self) inherit controller as super\n    \n    val side = s\n    \n    val cy = \n      let cyString = if s then \"cy2\" else \"cy\" in\n      let cyElement = Dom_html.getElementById_opt cyString in\n      match cyElement with\n      | None -> None\n      | Some a -> Some (Cytoscape.initCy cyString)\n\n    method returnType = \"\"\n    \n    method defineExample = ()\n    \n    method replicateOnLeft =\n      !CtrlUtil.changeToControllerCtrlLeft ()\n\n    method setUpdateType s =\n      updateType <- Some s\n\n    method feedback =\n      super#operation \"Feedback\" \"Feedback\";\n      HtmlPageClient.oneBox ();\n      HtmlPageClient.disableButtons (self#returnType);\n      HtmlPageClient.feedback()\n  \n    method about =  (* VER SE É PRECISO AMD *****)\n    super#operation \"About\" \"About\";\n      HtmlPageClient.oneBox ();\n      StateVariables.changeCy1ToText();\n      HtmlPageClient.disableButtons (self#returnType);\n      HtmlPageClient.about()\n\nend\n\nmodule Ctrl = struct \n  let textCtrl s = new textController s\n\n  let ctrlL = ref (textCtrl false)\n  let ctrlR = ref (textCtrl true)\n\n  let changeCtrlL (nc: controller) =\n    ctrlL := nc;;\n\n  let changeCtrlR (nc: controller) =\n    ctrlR := nc;;\n\n  let runOp (op: string) =\n    !ctrlL#handleOp op;;\n\n  let _ = changeCtrlL (textCtrl false);\n          changeCtrlR (textCtrl true);\n          Listeners.runOp := runOp;;\n\n  CtrlUtil.changeToControllerCtrlRight := fun () -> (changeCtrlR (textCtrl true));;\n  CtrlUtil.changeToControllerCtrlLeft := fun () -> (changeCtrlL (textCtrl false));;\nend\n","open Controller\nopen AutomatonView\nopen HtmlPageClient\nopen Js_of_ocaml\nopen JS\nopen Listeners\nopen FiniteAutomatonView\nopen OCamlFlat\n\nclass virtual automatonController (s: bool)=\n  object(self) inherit controller as super\n\n    val side = s\n    val cy = Some (if s then Cytoscape.initFaCy \"cy2\" else Cytoscape.initFaCy \"cy\")\n    val mutable tab = false;\n\n\n    method virtual operationAutomaton: string -> unit\n    method virtual defineInformationBox: unit\n    method virtual loadButtons: unit\n    method virtual getAutomaton: AutomatonView.model\n\n    method resetStyle = Cytoscape.resetStyle self#getCy Cytoscape.faStyle\n\n    (*TableView*)\n    method getTab = tab\n    method changeTab =\n      tab <- not tab;\n      JS.log(\"Tab changed to\" ^ Bool.to_string tab)\n\n    method defineExample =\n      self#operationAutomaton \"create example\";\n      HtmlPageClient.disableButton \"autoAccept\";\n      HtmlPageClient.changeButtonColor \"autoAccept\" \"\";\n      self#updateButtons;\n      self#loadButtons;\n      HtmlPageClient.closeBoxRegex ();\n      self#getAutomaton#drawExample self#getCy;\n      self#defineInformationBox;\n      Cytoscape.fit self#getCy_opt\n\n    method defineExample2 = \n      self#getAutomaton#drawExample self#getCy;\n      self#defineInformationBox;\n\n    method getWords v = \n      self#operationAutomaton \"accepted words\";\n      let var = self#getAutomaton#staticGenerate v in \n      let (_, visitedConfigs, exact, time) = self#getAutomaton#returnStats in\n        HtmlPageClient.putWords var;\n        HtmlPageClient.displayGenStats visitedConfigs exact time\n\n    method showTrace word =\n      self#operationAutomaton \"trace\";\n      self#getAutomaton#changeTheTestingSentence word;\n      self#getAutomaton#staticAcceptFull;\n      let (accepted, configs, exact, time) = self#getAutomaton#returnStats in\n        HtmlPageClient.displayAcceptStats accepted configs exact time;\n        self#getAutomaton#displayTrace \n        \n    method getNewSentence = \n      Js.string self#getAutomaton#newSentence\n\n    method startStep word =\n      self#operationAutomaton \"accept start\";\n      self#cancelProm;\n      HtmlPageClient.fitBoxRegex ();\n      HtmlPageClient.enableButton \"autoAccept\";\n      self#getAutomaton#changeTheTestingSentence word;\n      self#getAutomaton#startAccept self#getCy;\n      (Dom_html.getElementById \"regExp\")##.innerHTML := self#getNewSentence;\n      let (accepted, configs, exact, time) = self#getAutomaton#returnStats in\n      HtmlPageClient.displayAcceptStats accepted configs exact time\n    \n    method nextStep =\n      self#operationAutomaton \"accept next\";\n      self#cancelProm;\n      HtmlPageClient.changeButtonColor \"autoAccept\" \"crimson\";\n      self#getAutomaton#next self#getCy;\n      (Dom_html.getElementById \"regExp\")##.innerHTML := self#getNewSentence\n\n    method backStep = \n      self#operationAutomaton \"accept back\";\n      self#cancelProm;\n      HtmlPageClient.changeButtonColor \"autoAccept\" \"crimson\";\n      self#getAutomaton#back self#getCy;\n      (Dom_html.getElementById \"regExp\")##.innerHTML := self#getNewSentence\n\n    method checkWord word =\n      self#operationAutomaton \"checkWord\";\n      HtmlPageClient.fitBoxRegex ();\n      self#getAutomaton#changeTheTestingSentence word;\n      (Dom_html.getElementById \"regExp\")##.innerHTML := Js.string word;\n      self#getAutomaton#staticAccept;\n      let (accepted, configs, exact, time) = self#getAutomaton#returnStats in\n      HtmlPageClient.displayAcceptStats accepted configs exact time\n\n\n    method autoAccept = \n      self#cancelProm;\n      let rec tic n =\n        match n with\n        | true -> HtmlPageClient.changeButtonColor \"autoAccept\" \"crimson\";\n                  Lwt.return()\n        | false -> let prom = Lwt.bind \n                  (Js_of_ocaml_lwt.Lwt_js.sleep 1.0)\n                  (fun () -> self#nextStep; tic self#getAutomaton#isOver)\n      in\n                  HtmlPageClient.changeButtonColor \"autoAccept\" \"green\";\n                  self#changeProm prom;\n                  prom\n      in\n      ignore(tic (self#promState = Lwt.Sleep));  \n      Lwt.return_true\n\n    method changeToEditModelMode =\n      self#operationAutomaton \"editModel\";\n      (Dom_html.getElementById \"regExp\")##.innerHTML := Js.string \"\";\n      self#getAutomaton#changeToEditModelMode self#getCy\n\n(*    method printErrors =\n      let errors = self#getAutomaton#errors in\n        if errors = [] then \n          ()\n        else \n          JS.alertStr (String.concat \"\\n\" errors)\n*)\n    method updateRight =\n      if !Ctrl.ctrlR#getUpdateType = Some \"specification\"\n      then !Listeners.showModelListener ()\nend\n","open OCamlFlat\nopen BasicTypes\nopen HtmlPageClient\nopen Lang\nopen Js_of_ocaml\nopen JS\nopen Controller\nopen AutomatonController\nopen AutomatonView\nopen FiniteAutomatonView\nopen Listeners\n\nclass faController (fa: FiniteAutomatonView.model) (s: bool)=\n  object(self) inherit automatonController(s) as super\n\n    val mutable myFA = fa\n\n    method operationAutomaton opName : unit =\n        super#operation opName \"FA\"\n\n    method model: Model.model = \n      (myFA :> Model.model) \n\n    method getAutomaton: AutomatonView.model =\n      (myFA :> AutomatonView.model)\n\n    method getFA =\n      myFA\n\n    method changeAutomata res =\n      myFA <- res\n\n    method getModel = \n      myFA#toDisplayString \"solution\"\n\n(* ML\n\t  method addNode x y st : unit = \n      self#operationAutomaton \"add Node\";\n      if (Set.belongs st myFA#representation.states) then \n        (JS.alertStr (Lang.i18nAlertExists ()))\n      else \n        (myFA <- myFA#addNode st false;\n        Cytoscape.addNode self#getCy st ~x:x ~y:y false false;\n        self#defineInformationBox;)\n*)\n\n(* imitar TM *)\n\t  method addNode x y initial final: unit = \n      self#operationAutomaton \"add Node\";\n      let promptResult = (JS.prompt (Lang.i18nTextEnterState ()) \"A\") in\n      match Js.Opt.to_option promptResult with\n      | None -> ()\n      | Some v -> let st = (Js.to_string v) in\n                  JS.log myFA#representation.states;\n                  if (Set.belongs st myFA#representation.states) then \n                    (JS.alertStr (Lang.i18nAlertExists ()))\n                  else \n                    (myFA <- myFA#addNode st false;\n                    Cytoscape.addNode self#getCy st ~x:x ~y:y initial final;\n                    self#defineInformationBox;)\n\n\n    method setTitle = \n      CtrlUtil.oneBox self#getCy_opt;\n      HtmlPageClient.defineMainTitle (FiniteAutomaton.kind)\n\n    method returnType = FiniteAutomaton.kind\n\n    method loadButtons = \n      HtmlPageClient.putCyAutomataButtons ()\n\n    method defineInformationBox =\n      let infoBox = HtmlPageClient.defineInformationBox side in\n      let deter = myFA#isDeterministic in \n        HtmlPageClient.getDeterminim deter infoBox;\n      let min = myFA#isMinimized in \n        HtmlPageClient.getMinimism min infoBox;\n      let useful = myFA#areAllStatesUseful in\n      let uStates = myFA#getUselessStates in \n        HtmlPageClient.getHasUselessStates useful uStates infoBox;\n      let nStates = myFA#numberStates in \n        HtmlPageClient.getNumberStates nStates infoBox;\n      let nTransitions = myFA#numberTransitions in\n        HtmlPageClient.getNumberTransitions nTransitions infoBox;\n      let _ = myFA#buildTable in () (*UPDATE TABLE*)\n\n    method createTransition source target =\n      self#operationAutomaton \"add transition\";\n      let promptResult = (JS.prompt (Lang.i18nTextEnterTransition ()) \"c\") in\n      match Js.Opt.to_option promptResult with\n      | None -> ()\n      | Some v ->\n        let v = symb (Js.to_string v) in\n        (if v = epsilon\n        then myFA <- myFA#newEpsylonTransition (source, v, target)\n        else myFA <- myFA#newTransition (source, v, target));\n        Cytoscape.addEdge self#getCy (source, symb2str v, target);\n        self#defineInformationBox;\n      \n(* imitar TM *)\n    method addFinalNode x y node =\n      self#operationAutomaton \"add final node\";\n      if (Set.belongs node myFA#representation.states) then\n        (JS.alertStr (Lang.i18nAlertExists ()))\n      else (\n        myFA <- myFA#addFinalNode node false false;\n        Cytoscape.addNode self#getCy ~x:x ~y:y node false true;\n        self#defineInformationBox;\n      )\n\n(* imitar TM *)\n    method addInitialNode node =\n      self#operationAutomaton \"make node initial\";\n      let stateExists = Set.belongs node myFA#representation.states in \n          myFA <- (myFA#addInitialNode node false stateExists);\n          let cy = self#getCy in\n          Cytoscape.resetFaElems cy;\n          myFA#drawExample cy;\n          self#defineInformationBox;\n\n    method eliminateTransition (v1, s, v2) =\n      self#operationAutomaton \"erase transition\";\n      let c3 = symb s in\n      if (Set.belongs (v1, c3, v2) myFA#representation.transitions) then\n        (myFA <- (myFA#eliminateTransition(v1, c3, v2));\n      Cytoscape.removeEdge self#getCy v1 (symb2str c3) v2;\n        self#defineInformationBox;)\n      else \n        JS.alertStr ((Lang.i18nAlertTheTransition ()) ^ \"(\" ^ v1 ^ \", \" ^ symb2str c3 ^ \", \" ^ v2 ^ \")\" ^ (Lang.i18nAlertDoNotExists ()))\n    \n     method turnFinalNode node =\n      self#operationAutomaton \"make node final\";\n      if (Set.belongs node myFA#representation.acceptStates) then\n          (JS.alertStr (Lang.i18nAlertAlreadyFinal ()))\n      else\n        (myFA <- (myFA#changeToFinal node);\n        Cytoscape.turnFinal self#getCy node);\n      self#defineInformationBox;\n    \n    method removeFinalNode node =\n      self#operationAutomaton \"make node not final\";\n      if (Set.belongs node myFA#representation.acceptStates) then\n        (myFA <- (myFA#removeFinal node);\n        Cytoscape.removeFinal self#getCy node)\n      else\n        (JS.alertStr (Lang.i18nAlertNonFinal ())); \n      self#defineInformationBox;\n      \n    method eliminateNode node =\n      self#operationAutomaton \"eliminate node\";\n      let eliminateNodeTransitions (a, b, c) node = \n        if (a = node || c = node) then\n          (myFA <- (myFA#eliminateTransition (a, b, c));\n      self#defineInformationBox;) in \n        if (node = myFA#representation.initialState )then \n          JS.alertStr (Lang.i18nAlertDelete ()) \n        else \n          if (Set.belongs node myFA#representation.states) then \n            (let isFinal = Set.belongs node myFA#representation.acceptStates in \n            myFA <- myFA#eliminateNode node false isFinal;\n            Set.iter (fun el -> (eliminateNodeTransitions el node)) myFA#representation.transitions;\n            Cytoscape.removeNode self#getCy node;\n            self#defineInformationBox;)\n          else \n            JS.alertStr (Lang.i18nAlertUnexistentState ())\n\n    method renameState state =\n      self#operationAutomaton \"rename node\";\n      let newName = JS.prompt (Lang.i18nRenameStateQuestion()) state in\n      match Js.Opt.to_option newName with\n      | None -> ()\n      | Some n -> myFA <- myFA#renameState state (Js.to_string n);\n                  Cytoscape.resetFaElems self#getCy;\n                  self#defineExample\n\n\t  method updateButtons =\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyTM2TapesConvertButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyExpressionButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyCFGButtons;\n\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyGRConvertButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyPDAButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyCFGConvertButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyTMConvertButtons;\n\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyAutomataButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOtherButtons\n\n      (* method getWords v = \n      self#operationAutomaton \"accepted words\";\n        let var = self#getAutomaton#staticGenerate v in \n        let (_, visitedConfigs, exact, time) = self#getAutomaton#returnStats in\n          HtmlPageClient.putWords var;\n          HtmlPageClient.displayGenStats visitedConfigs exact time *)\n\n    method defineMinimize listColors number =\n      myFA#paintMinimization self#getCy listColors;\n      myFA#drawMinimize self#getCy listColors number;\n      Cytoscape.fit self#getCy_opt\n    \n    method editModel = \n      !ListenersFA.editModelListener(); ()\n    \n    method replicateOnLeft =\n      let c = new faController self#getFA false in\n      Ctrl.ctrlL := (c :> controller);\n\n    method convertToRegExp =\n      let open RegularExpressionView in\n      self#operationAutomaton \"convert to RE\";\n      let reg = PolyModel.fa2re (myFA :> FiniteAutomaton.model) in\n      let r = reg#simplify in \n      let rep = r#representation in \n      new RegularExpressionView.model (Representation (rep))\n\n    method convertToPDA =\n      let open PushdownAutomatonView in\n      self#operationAutomaton \"convert to PDA\";\n      let pda = PolyModel.fa2pda (myFA :> FiniteAutomaton.model) in\n      new PushdownAutomatonView.model (Representation (pda#representation))\n\n    method convertToCFG =\n      let open ContextFreeGrammarView in\n      self#operationAutomaton \"convert to CFG\";\n      let cfg = PolyModel.fa2cfg (myFA :> FiniteAutomaton.model) in\n      new ContextFreeGrammarView.model (Representation (cfg#representation))\n\n    method convertToGR =\n      let open GrammarView in\n      self#operationAutomaton \"convert to GR\";\n      let gr = PolyModel.fa2gr (myFA :> FiniteAutomaton.model) in\n      new GrammarView.model (Representation (gr#representation))\n\n    method convertToTM_SingleTape =\n      let open TuringMachineView in\n      self#operationAutomaton \"convert to TM single tape\";\n      let tm = PolyModel.fa2tm (myFA :> FiniteAutomaton.model) in\n      new TuringMachineView.model (Representation (tm#representation))\n\n    method printErrors =\n          let errors = myFA#errors in\n            if errors = [] then\n              ()\n            else\n              JS.alertStr (String.concat \"\\n\" errors)\nend\n","open OCamlFlat\nopen BasicTypes\nopen HtmlPageClient\nopen Lang\nopen JS\nopen RegularExpressionView\nopen Controller\nopen Listeners\n\nclass reController (re: RegularExpressionView.model) (s: bool) =\n  object(self) inherit controller as super\n\n    val re1 = re\n\n    val side = s\n    val cy = Some (if s then Cytoscape.startTree \"cy2\" else Cytoscape.startTree \"cy\")\n\n    val mutable step = 0\n\n    val mutable re = new RegularExpressionView.model (Representation Empty)\n    val mutable resultTree = false\n    val mutable wordAsList : word = []\n\n    method model: Model.model = \n      (re1 :> Model.model) \n\n    method getWordAsList () =\n      wordAsList\n\n    method getRE =\n      re1\n\n    method getResultTree =\n      resultTree\n\n    method setRe newRe = \n      re <- newRe\n\n    method getModel = \n      re1#toDisplayString \"solution\"\n\n    method setTitle = \n      CtrlUtil.oneBox self#getCy_opt;\n      HtmlPageClient.defineMainTitle (RegularExpression.kind)\n\n    method operationRE opName : unit =\n      super#operation opName \"RE\"\n\n    method returnType = RegularExpression.kind\n\n    method private makeTree cy (re : RegularExpression.t) =\n      let nGetName = ref 0 in\n      let genName () = \n        let prefix = \"N\" in \n        nGetName := !nGetName + 1;\n        prefix ^ (string_of_int !nGetName)\n      in\n      let rec makeTree2 cy (re: RegularExpression.t) =\n      match re with\n        | Plus (l, r) ->  let rootName = genName () in \n                          let rootL = makeTree2 cy l in \n                          let rootR = makeTree2 cy r in\n                            Cytoscape.makeTreeNode cy rootName \"+\"; \n                            Cytoscape.makeTreeEdge cy rootName rootL;\n                            Cytoscape.makeTreeEdge cy rootName rootR;\n                            rootName\n        | Seq (l, r) -> let rootName = genName () in \n                        let rootL = makeTree2 cy l in \n                        let rootR = makeTree2 cy r in\n                          Cytoscape.makeTreeNode cy rootName \".\"; \n                          Cytoscape.makeTreeEdge cy rootName rootL;\n                          Cytoscape.makeTreeEdge cy rootName rootR;\n                          rootName\n        | Star re -> let rootName = genName () in \n                        let root = makeTree2 cy re  in \n                          Cytoscape.makeTreeNode cy rootName \"*\"; \n                          Cytoscape.makeTreeEdge cy rootName root;\n                          rootName\n        | Symb b -> let rootName = genName () in \n                        Cytoscape.makeTreeNode cy rootName (symb2str b);\n                        rootName\n        | Empty  -> let rootName = genName () in \n                        Cytoscape.makeTreeNode cy rootName \"~\";\n                        rootName\n        | Zero   -> let rootName = genName () in \n                        Cytoscape.makeTreeNode cy rootName \"!\";\n                        rootName\n      in\n      makeTree2 cy re\n\n    method private drawTree cy re text =\n      if String.length text >= 120 \n      then Cytoscape.makeTreeNode cy \"nope\" (Lang.i18nAlertRETooBig ())\n      else ignore (self#makeTree cy re1#representation)\n\n    method defineExample =\n      self#operationRE \"create\";\n      self#updateButtons;\n      HtmlPageClient.putCyREButtons();\n      HtmlPageClient.fitBoxRegex ();\n      Cytoscape.fit self#getCy_opt;\n      let test = RegularExpression.toString re1#representation in\n       self#drawTree self#getCy re1#representation test;\n        HtmlPageClient.defineRE test side\n\n    method defineExample2 =\n      self#operationRE \"create 2\";\n      let text = RegularExpression.toString re1#representation in\n        self#drawTree self#getCy re1#representation text;\n        HtmlPageClient.defineRE text side\n\n    method startStep word = \n      self#operationRE \"accept\";\n      let w = str2word word in\n        wordAsList <- w;\n        CtrlUtil.twoBoxes self#getCy_opt;\n        re1#startAllTrees w;\n        resultTree <- re1#accept w;\n        Ctrl.changeCtrlR ((new textController true) :> controller );\n        Cytoscape.resetStyle !Ctrl.ctrlR#getCy Cytoscape.reStyle;\n        if (resultTree) then\n          (!ListenersRE.resultCountListener ();\n          let right = re1#getRightTrees in \n          ignore (re1#printTree right (!Ctrl.ctrlR#getCy));\n            !ListenersRE.defineNumberTreesListener ();\n            HtmlPageClient.defineTreeButtons ();\n          )\n        else \n          (!ListenersRE.resultCountListener();\n          let wrong = re1#getWrongTrees in \n          ignore(re1#printTree wrong (!Ctrl.ctrlR#getCy));\n            !ListenersRE.defineNumberTreesListener ();\n            HtmlPageClient.defineTreeButtons ();\n           )\n\n    method convertToFA =\n      let open FiniteAutomatonView in\n      self#operationRE \"convert to FA\";\n      let auto = PolyModel.re2fa (re1 :> RegularExpression.model) in \n      let maton = auto#representation in \n        new FiniteAutomatonView.model (Representation (maton))\n\n    method convertToPDA =\n      let open PushdownAutomatonView in\n      self#operationRE \"convert to PDA\";\n      let pda = PolyModel.re2pda (re1 :> RegularExpression.model) in\n      new PushdownAutomatonView.model (Representation (pda#representation))\n\n\t(* PEDRO CARLOS VER! porqu este e muitos outros nao existiam? *)\n    method convertToCFG =\n      let open ContextFreeGrammarView in\n      self#operationRE \"convert to CFG\";\n      let cfg = PolyModel.re2cfg (re1 :> RegularExpression.model) in\n      new ContextFreeGrammarView.model (Representation (cfg#representation))\n\n    method convertToGR =\n      let open GrammarView in\n      self#operationRE \"convert to GR\";\n      let gr = PolyModel.re2gr (re1 :> RegularExpression.model) in\n      new GrammarView.model (Representation (gr#representation))\n\n\n    method convertToTM_SingleTape =\n      let open TuringMachineView in\n      self#operationRE \"convert to TM single tape\";\n      let tm = PolyModel.re2tm (re1 :> RegularExpression.model) in\n      new TuringMachineView.model (Representation (tm#representation))\n\n    method model2Str =\n      RegularExpression.toString !Ctrl.ctrlL#getRE#representation\n\n    method updateButtons = \n      HtmlPageClient.disableButton \"autoAccept\";\n      HtmlPageClient.changeButtonColor \"autoAccept\" \"\";\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyTM2TapesConvertButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyAutomataButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyExpressionButtons;\n\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyGRConvertButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyPDAButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyCFGConvertButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyTMConvertButtons;\n\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyCFGButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOtherButtons\n    \n    method getWords v = \n      self#operationRE \"accepted words\";\n      let var = re1#staticGenerate v in\n      let (_, visitedConfigs, exact, time) =\n        re1#returnStats in\n          HtmlPageClient.putWords var;\n          HtmlPageClient.displayGenStats visitedConfigs exact time\n\n    method editModel =\n      !ListenersRE.editModelListener(); ()\n\n    method replicateOnLeft =\n      let c = new reController self#getRE false in\n        Ctrl.ctrlL := (c :> controller)\n\n    method printErrors =\n      let errors = re1#errors in\n        if errors = [] then \n          ()\n        else \n          JS.alertStr (String.concat \"\\n\" errors)\n\n\n    (*JP*)\n    \n    method showTrace word =\n      self#operationRE \"trace\";\n      let w = str2word word in\n      re1#staticAcceptFull w;\n      let (accepted, configs, exact, time) = re1#returnStats in\n      HtmlPageClient.displayAcceptStats accepted configs exact time;\n      re1#displayTrace\n\n    method checkWord word =\n      self#operationRE \"checkWord\";\n      let w = str2word word in\n      re1#staticAccept w;\n      let (accepted, configs, exact, time) = re1#returnStats in\n      HtmlPageClient.displayAcceptStats accepted configs exact time;\nend\n","open OCamlFlat\nopen BasicTypes\nopen HtmlPageClient\nopen JS\nopen Lang\nopen Controller\nopen ContextFreeGrammarView\nopen ContextFreeGrammarLL1View\nopen Listeners\n\n(* PEDRO CARLOS VER! debug? *)\nlet grammar2Str (rep:ContextFreeGrammarView.t) = \n  let open ContextFreeGrammarBasic in\n  let initialRules = Set.filter (fun {head = h; _} -> h = rep.initial) rep.rules in\n  let nonInitialRules = Set.filter (fun {head = h; _} -> h <> rep.initial) rep.rules in\n  let initialRulesStrLst = ContextFreeGrammarBasic.toStringList initialRules in\n  let nonInitialRulesStrLst = ContextFreeGrammarBasic.toStringList nonInitialRules in\n  let rulesList = initialRulesStrLst @ nonInitialRulesStrLst in\n  let rec toString l =\n    match l with\n    | [] -> \"\"\n    | x::xs -> x ^ \"\\n\" ^ (toString xs)\n  in\n    toString rulesList\n\nclass virtual cfgBasicController (cfg: ContextFreeGrammarView.model) (s:bool) =\n  object(self) inherit controller as super\n    val mutable myCFG = cfg \n    val side = s\n    val cy = if s then Some (Cytoscape.initLL1Cy \"cy2\") else Some (Cytoscape.initLL1Cy \"cy\");\n\n    method operationCFG opName: unit =\n      super#operation opName \"CFG\"\n   \n    method model: Model.model =\n      (myCFG :> Model.model)\n    \n    method getCFG = myCFG\n    \n    method changeCFG res = myCFG <- res\n    \n    method getModel =\n      myCFG#toDisplayString \"solution\"\n \n    method setTitle =\n      CtrlUtil.oneBox self#getCy_opt;\n      HtmlPageClient.defineMainTitle (ContextFreeGrammarBasic.kind)\n\n    method returnType = ContextFreeGrammar.kind\n    \n    method defineExample = \n      self#operationCFG \"create example\";\n      self#updateButtons;\n      HtmlPageClient.putCyCFGButtons();\n      HtmlPageClient.cfgBoxRegex();\n      HtmlPageClient.cfgCyClose();\n      HtmlPageClient.defineCFG();\n      myCFG#createGrammarTableHtml \"\"; \n      self#defineInformationBox\nend\n\nclass virtual cfgLL1Controller (cfg: ContextFreeGrammarView.model) (s:bool) =\n  object(self) inherit cfgBasicController cfg s  as super\n\n    method defineInformationBox =\n      let infoBox = HtmlPageClient.defineInformationBox side in\n      if side then HtmlPageClient.cfgCy2Close();\n      let ll1 = myCFG#isLL1 in \n        HtmlPageClient.getIsLL1 ll1 infoBox;\n      let lr = myCFG#isLeftRecursive in \n        HtmlPageClient.getIsLeftRecursive lr infoBox;\n      let lf = myCFG#isLeftFactoring in \n        HtmlPageClient.getIsLeftFactoring lf infoBox;\n      let pConf = myCFG#hasParsingTableConflict in\n        HtmlPageClient.getHasParsingTableConflict pConf infoBox;\n      let c = myCFG#isClean in\n      let prod = myCFG#isFullyProductive in\n      let access = myCFG#isFullyAccessible in\n        HtmlPageClient.getIsCFGClean c prod access infoBox\n\n    method box2CFGShow (f : ContextFreeGrammarLL1.transformation) =\n      self#operationCFG \"create example2\";\n      CtrlUtil.twoBoxes self#getCy_opt;\n      HtmlPageClient.printCFG2Grammar f.tType (ContextFreeGrammarLL1View.productionsTableId2());\n      (ContextFreeGrammarView.adjust f.grammar)#createGrammarTableHtml (ContextFreeGrammarLL1View.productionsTableId2());\n      !Ctrl.ctrlR#defineInformationBox\n\n    method checkWord word =\n      self#operationCFG \"checkWord\";\n      let w = str2word word in\n      myCFG#staticAccept w;\n      let (accepted, configs, exact, time) = myCFG#returnStats in\n      HtmlPageClient.displayAcceptStats accepted configs exact time\n\n    method autoAccept =\n      if myCFG#isLL1\n      then (self#acceptCFGLL1; Lwt.return_true)\n      else (JS.alertStr (Lang.i18nIsNotLL1()); Lwt.return_false)      \n\n    method private acceptCFGLL1 =\n      self#cancelProm;\n      let steps = myCFG#nSteps - 1 in\n      let rec tic state n =\n        match state with\n        | true -> HtmlPageClient.changeButtonColor \"autoAccept\" \"crimson\";\n                  Lwt.return()\n        | false -> let prom = Lwt.bind \n                  (Js_of_ocaml_lwt.Lwt_js.sleep 1.0)\n                  (fun () -> self#nextStep; tic false (n-1)) in\n                  HtmlPageClient.changeButtonColor \"autoAccept\" \"green\";\n                  self#changeProm prom;\n                  prom\n      in\n      ignore (tic (self#promState = Lwt.Sleep) steps)\n\n    method getWords v = \n      self#operationCFG \"accepted words\";\n      let var = myCFG#staticGenerate v in\n      let (_, visitedConfigs, exact, time) =\n        myCFG#returnStats in\n          HtmlPageClient.putWords var;\n          HtmlPageClient.displayGenStats visitedConfigs exact time\n\n\n    method startStep word =\n      self#operationCFG \"accept start\";\n      self#cancelProm;\n      CtrlUtil.twoBoxes self#getCy_opt;\n      HtmlPageClient.cfgCyOpen();\n      HtmlPageClient.prepareCFG2Tables ();\n      HtmlPageClient.enableButton \"autoAccept\";\n      match cy with\n        | None -> ();\n        | Some cy -> Cytoscape.removeAllElements cy;\n      myCFG#createFirstAndFollowTableHtml;\n      myCFG#createParsingTableHtml;\n      if myCFG#isLL1\n        then myCFG#startAccept self#getCy (str2word word)\n        else JS.alertStr (Lang.i18nIsNotLL1())\n    \n    method nextStep =\n      self#operationCFG \"accept next\";\n      self#cancelProm;\n      myCFG#next self#getCy\n          \n    method backStep = \n      self#operationCFG \"accept back\";\n      self#cancelProm;\n      myCFG#back self#getCy\n\n    method editModel =\n      !ListenersCFG.editModelListener(); ()\n\n    method updateButtons = \n      HtmlPageClient.disableButton \"autoAccept\";\n      HtmlPageClient.changeButtonColor \"autoAccept\" \"\";\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyCFGButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyPDAButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOtherButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyGRConvertButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyTMConvertButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyTM2TapesConvertButtons;\n\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyAutomataButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyExpressionButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyCFGConvertButtons\n  \n    method model2Str =\n      let gr_representation = !Ctrl.ctrlL#getCFG#representation in\n      grammar2Str gr_representation\n\n    method convertToPDA =\n      let open PushdownAutomatonView in\n      self#operationCFG \"convert to PDA\";\n      let pda = PolyModel.cfg2pda (myCFG :> ContextFreeGrammar.model) in\n      new PushdownAutomatonView.model (Representation (pda#representation))\n      \n    method convertToGR =\n      let open GrammarView in\n      self#operationCFG \"convert to GR\";\n      let gr = PolyModel.cfg2gr (myCFG :> ContextFreeGrammar.model) in\n      new GrammarView.model (Representation (gr#representation)) \n\n    method convertToTM_SingleTape =\n      let open TuringMachineView in\n      self#operationCFG \"convert to TM single tape\";\n      let tm = PolyModel.cfg2tm (myCFG :> ContextFreeGrammar.model) in\n      new TuringMachineView.model (Representation (tm#representation))\n\n    method convertToTM_DualTape =\n      let open TuringMachineView in\n      self#operationCFG \"convert to TM dual tape\";\n      let tm = PolyModel.cfg2tm_2tapes (myCFG :> ContextFreeGrammar.model) in\n      new TuringMachineView.model (Representation (tm#representation))\n\n    (*Possivelmente mudar para um controlador basic separado*)\n    method showTrace word =\n      self#operationCFG \"trace\";\n      let w = str2word word in\n      myCFG#staticAcceptFull w;\n      let (accepted, configs, exact, time) = myCFG#returnStats in\n      HtmlPageClient.displayAcceptStats accepted configs exact time;\n      myCFG#displayTrace\n\n    \nend\n\n\nclass cfgLRController (cfg: ContextFreeGrammarView.model) (s: bool)=\n  object(self) inherit cfgLL1Controller cfg s as super\n      \n\n\n    method setTitle = \n      CtrlUtil.oneBox self#getCy_opt;\n      HtmlPageClient.defineMainTitle (ContextFreeGrammarBasic.kind)\n      \n     method defineExample = (* abrir elementos de graficos na janela esquerda *)\n\t\tsuper#defineExample;\n\t\t\n\t\tlet infoBox = HtmlPageClient.defineInformationBox side in\n\n\t\tHtmlPageClient.putLRButtons ();\n\t(*     !Listeners.defineInformationBoxListener(); *)\n\t\t(* myLR#buildCyLR0Diagram self#getCy; *)\n\t\tCytoscape.fit self#getCy_opt;\n\t\t \n\t\t \n\t\t(* HtmlPageClient.cfgCyClose(); *)\n\t\tHtmlPageClient.defineCFG();\n\t\t \n\t\t(* JS.log(self#getCy);\n\t\t JS.log(self#getCy##getElementById (Js.string \"14\")) \n\t\t *)\n\t\t \n\t\t if(myCFG#isLR0) then HtmlPageClient.getIsLR0 true infoBox\n\t\t else if(myCFG#isSLR1) then HtmlPageClient.getIsSLR1 true infoBox\n\t\t else if(myCFG#isLALR1) then HtmlPageClient.getIsLALR1 true infoBox\n\t\t else if(myCFG#isLR1) then HtmlPageClient.getIsLR1 true infoBox\n\t\t else HtmlPageClient.getIsLR1 false infoBox\n\t\t \n\n  (*  method defineExample2 = () *) (* abrir codigo na janela direita *)\n  (*    myLR#drawExample self#getCy *)\n(*      !Listeners.defineInformationBoxListener()*)\n\n    method defineExample2 =\n      self#operationCFG \"create example2\";\n      CtrlUtil.twoBoxes self#getCy_opt;\n      HtmlPageClient.printCFG2GrammarComp (ContextFreeGrammarLL1View.productionsTableId2());\n      myCFG#createGrammarTableHtml (ContextFreeGrammarLL1View.productionsTableId2());\n      !Ctrl.ctrlR#defineInformationBox\n\n\n    method replicateOnLeft =\n      let c = new cfgLRController self#getCFG false in\n      Ctrl.ctrlL := (c :> controller);\n\n(* AMD check!!! *)\n\t method updateButtons =\n    List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyCFGButtons;\n    List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyPDAButtons;\n    List.iter (fun el -> HtmlPageClient.enableButton el) listOtherButtons;\n    List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyGRConvertButtons;\n    List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyTMConvertButtons;\n    List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyTM2TapesConvertButtons;\n\n    List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyAutomataButtons;\n    List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyExpressionButtons;\n    List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyCFGConvertButtons;\nend\n\n\nclass cfgController (cfg: ContextFreeGrammarView.model) (s: bool)=\n  object(self) inherit cfgLRController cfg s as super\n\n\n\nend\n","open OCamlFlat\nopen BasicTypes\nopen HtmlPageClient\nopen Lang\nopen Js_of_ocaml\nopen JS\nopen Controller\nopen AutomatonController\nopen AutomatonView\nopen PushdownAutomatonView\nopen Listeners\n\nclass pdaController (pda: PushdownAutomatonView.model) (s: bool)=\n  object(self) inherit automatonController(s) as super\n\n    val mutable myPDA = pda\n\n    method operationAutomaton opName : unit =\n        super#operation opName \"PDA\"\n\n    method model: Model.model = \n      (myPDA :> Model.model)\n\n    method getAutomaton: AutomatonView.model =\n      (myPDA :> AutomatonView.model)\n\n    method getPDA =\n      myPDA\n\n    method changeAutomata res =\n      myPDA <- res\n\n    method getModel = \n      myPDA#toDisplayString \"solution\"\n\n    method setTitle = \n      CtrlUtil.oneBox self#getCy_opt;\n      HtmlPageClient.defineMainTitle (PushdownAutomaton.kind)\n\n    method returnType = PushdownAutomaton.kind\n\n    method loadButtons = \n      HtmlPageClient.putCyAutomataPDAButtons ()\n\n    method updateButtons =\n      HtmlPageClient.disableButton \"autoAccept\";\n      HtmlPageClient.changeButtonColor \"autoAccept\" \"\";\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyCFGButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyPDAButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyCFGConvertButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyAutomataButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyExpressionButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyTMConvertButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyTM2TapesConvertButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOtherButtons\n\n    method defineInformationBox = \n      let infoBox = HtmlPageClient.defineInformationBox side in\n      let deter = myPDA#isDeterministic in \n        HtmlPageClient.getDeterminim deter infoBox;\n      let useful = myPDA#areAllStatesUseful in\n      let uStates = myPDA#getUselessStates in \n        HtmlPageClient.getHasUselessStates useful uStates infoBox;\n      let isEquivalentFA = myPDA#isFiniteAutomaton in\n        HtmlPageClient.getIsEquivalentFA isEquivalentFA infoBox;\n      let nStates = myPDA#numberStates in \n        HtmlPageClient.getNumberStates nStates infoBox;\n      let nTransitions = myPDA#numberTransitions in\n        HtmlPageClient.getNumberTransitions nTransitions infoBox;\n      let _ = myPDA#buildTable in () (*UPDATE TABLE*)\n\n    method toggleAcceptanceCriteria =\n      self#operationAutomaton \"toggle acceptance criteria\";\n      self#changeToEditModelMode;\n      myPDA <- myPDA#toggleAcceptanceCriteria;\n      let toggleButton = Dom_html.getElementById \"toggleAcceptanceCriteria\" in\n        toggleButton##.innerHTML := Js.string (\n          if myPDA#representation.criteria then\n            Lang.i18nTogleAcceptCriteriaState ()\n          else\n            Lang.i18nTogleAcceptCriteriaEmptyStack ()\n        );\n      self#defineInformationBox\n\n    method changeInitialStackSymbol =\n      self#operationAutomaton \"change initial stack symbol\";\n      self#changeToEditModelMode;\n      let promptResult = (JS.prompt (Lang.i18nChangeInitialStackSymbolPda ()) \"z\") in (*TODO need to verify if validInput, (no spaces)*)\n      match Js.Opt.to_option promptResult with\n      | None -> ()\n      | Some v ->\n          let initStackSymbolString = (Js.to_string v) in\n          if initStackSymbolString <> \"\" then \n            begin\n              let initStackSymbol = List.hd (String.split_on_char ' ' initStackSymbolString) in\n              myPDA <- myPDA#changeInitialStackSymbol (symb initStackSymbol);\n              let button = Dom_html.getElementById \"buttonInitialStackSymbol\" in\n              button##.innerHTML := Js.string ((Lang.i18nInitialStackSymbol ())^(initStackSymbol))\n            end else ();\n      self#defineInformationBox\n\n    method convertAcceptStates =\n      if not myPDA#getCriteria then \n        let convertedPDA = myPDA#transformPdaToAcceptStates in\n        Some (new PushdownAutomatonView.model (Representation convertedPDA#representation))\n      else None\n          \n    method convertEmptyStackAccept =\n      if myPDA#getCriteria then \n        let convertedPDA = myPDA#transformPdaToAcceptEmptyStack in\n        Some (new PushdownAutomatonView.model (Representation convertedPDA#representation))\n      else None\n      \n(* imitar TM *)\n (*   method addNode x y st : unit = \n      self#operationAutomaton \"add Node\";\n      if (Set.belongs st myPDA#representation.states) then \n        JS.alertStr (Lang.i18nAlertExists ())\n      else \n        begin\n          myPDA <- myPDA#addState st;\n          Cytoscape.addNode self#getCy st ~x:x ~y:y false false\n        end;\n      self#defineInformationBox *)\n\n\t  method addNode x y initial final: unit = \n      self#operationAutomaton \"add Node\";\n      let promptResult = (JS.prompt (Lang.i18nTextEnterState ()) \"A\") in\n      match Js.Opt.to_option promptResult with\n      | None -> ()\n      | Some v -> let st = (Js.to_string v) in\n                  JS.log myPDA#representation.states;\n                  if (Set.belongs st myPDA#representation.states) then \n\t\t\t\t\t\tJS.alertStr (Lang.i18nAlertExists ())\n\t\t\t\t  else \n\t\t\t\t\tbegin\n\t\t\t\t\t  myPDA <- myPDA#addState st;\n\t\t\t\t\t  Cytoscape.addNode self#getCy st ~x:x ~y:y false false\n\t\t\t\t\tend;\n\t\t\t\t  self#defineInformationBox\n\n    method eliminateNode node =\n      self#operationAutomaton \"eliminate node\";\n      let removeNodeTransitions node (fromNode,st,is,toNode,ts) = \n        if (fromNode = node || toNode = node) then\n          (myPDA <- myPDA#removeTransition (fromNode,st,is,toNode,ts)) \n      in \n        if (node = myPDA#representation.initialState) then \n          JS.alertStr (Lang.i18nAlertDelete ()) \n        else \n          (myPDA <- myPDA#removeState node;\n          Set.iter (removeNodeTransitions node) myPDA#representation.transitions;\n          Cytoscape.removeNode self#getCy node);\n      self#defineInformationBox\n\n(* imitar TM *)\n    method addInitialNode node =\n      self#operationAutomaton \"make node initial\";\n      myPDA <- myPDA#addState node;\n      myPDA <- myPDA#updateInitialState node;\n      let cy = self#getCy in\n      Cytoscape.resetFaElems cy;\n      myPDA#drawExample cy;  \n      self#defineInformationBox     \n      \n(* imitar TM *)\n    method addFinalNode x y node =\n      self#operationAutomaton \"add final node\";\n      myPDA <- myPDA#addAcceptState node;\n      Cytoscape.addNode self#getCy ~x:x ~y:y node false true;\n      self#defineInformationBox\n      \n    method turnFinalNode node =\n      self#operationAutomaton \"make node final\";\n      myPDA <- myPDA#addAcceptState node;\n      Cytoscape.turnFinal self#getCy node;\n      self#defineInformationBox\n    \n    method removeFinalNode node =\n      self#operationAutomaton \"make node not final\";\n      myPDA <- myPDA#removeAcceptState node;\n      Cytoscape.removeFinal self#getCy node;\n      self#defineInformationBox\n\n    method createTransition source target = (*need to check if transition it is already created*)\n      self#operationAutomaton \"add transition\";\n      let promptResult = (JS.prompt (Lang.i18nTextEnterTransitionPda ()) \"a : z / ~\") in\n      match Js.Opt.to_option promptResult with\n      | None -> ()\n      | Some v ->\n        if (PushdownAutomatonView.isInputValid (Js.to_string v)) then\n          begin \n            let (topStack, inputSymb, toPutInStack) = PushdownAutomatonView.parseUserInput (Js.to_string v) in\n            let transition = (source, topStack, inputSymb, target, toPutInStack) in\n            myPDA <- myPDA#addTransition transition;\n            Cytoscape.addEdge self#getCy (PushdownAutomatonView.transitionPda2CytoscapeEdge transition)\n          end;\n      self#defineInformationBox\n\n    method eliminateTransition (source, label, target) =\n      let open Re in\n      self#operationAutomaton \"erase transition\";\n      (if (PushdownAutomatonView.isInputValid label) then\n        (let (topStack, inputSymb, toPutInStack) = PushdownAutomatonView.parseUserInput label in\n        let transition = (source, topStack, inputSymb, target, toPutInStack) in\n        if (Set.belongs transition myPDA#representation.transitions) then\n          begin\n            myPDA <- (myPDA#removeTransition transition);\n            Cytoscape.removeEdge self#getCy source label target\n          end\n        else \n          JS.alertStr ((Lang.i18nAlertTheTransition ()) ^ \"(\" ^ source ^ \", \" ^ label ^ \", \" ^ target ^ \")\" ^ (Lang.i18nAlertDoNotExists ()))));\n      self#defineInformationBox\n      \n    method renameState node =\n      self#operationAutomaton \"rename node\";\n      let newName = JS.prompt (Lang.i18nRenameStateQuestion()) node in\n      match Js.Opt.to_option newName with\n      | None -> ()\n      | Some n -> \n        let stateName = String.trim (Js.to_string n) in\n        if (PushdownAutomatonView.isStateNameValid stateName) then\n          begin\n            myPDA <- myPDA#renameState node (state stateName);\n            Cytoscape.resetFaElems self#getCy;\n            self#defineExample2\n          end\n\n    method replicateOnLeft =\n      let c = new pdaController self#getPDA false in\n      Ctrl.ctrlL := (c :> controller);\n     \n    method convertToFA = \n      let open FiniteAutomatonView in\n      self#operationAutomaton \"convert to FA\";\n      let fa = PolyModel.pda2fa (myPDA :> PushdownAutomaton.model) in\n      new FiniteAutomatonView.model (Representation (fa#representation))\n\n    method convertToCFG = \n      let open ContextFreeGrammarView in\n      let cfg = PolyModel.pda2cfg (myPDA :> PushdownAutomaton.model) in\n      new ContextFreeGrammarView.model (Representation (cfg#representation))\n\n\n    method convertToTM_SingleTape = \n      let open TuringMachineView in\n      self#operationAutomaton \"convert to TM single tape\";\n      let tm = PolyModel.pda2tm (myPDA :> PushdownAutomaton.model) in\n      new TuringMachineView.model (Representation (tm#representation))\n\n    method convertToTM_DualTape = \n      let open TuringMachineView in\n      self#operationAutomaton \"convert to TM dual tape\";\n      let tm = PolyModel.pda2tm_2tapes (myPDA :> PushdownAutomaton.model) in\n      new TuringMachineView.model (Representation (tm#representation))\n\n    method convertToRegExp =\n      let open RegularExpressionView in\n      self#operationAutomaton \"convert to RE\";\n      let reg = PolyModel.pda2re (myPDA :> PushdownAutomaton.model) in\n      let r = reg#simplify in \n      let rep = r#representation in \n      new RegularExpressionView.model (Representation (rep))\nend\n","open OCamlFlat\nopen BasicTypes\nopen HtmlPageClient\nopen Lang\nopen Js_of_ocaml\nopen JS\nopen Controller\nopen AutomatonController\nopen AutomatonView\nopen TuringMachineView\nopen Listeners\n\n\n  class tmController (tm: TuringMachineView.model) (s: bool)=\n    object(self) inherit controller as super\n\n    val mutable myTM = tm\n\n    val side = s\n    val cy = Some (if s then Cytoscape.initFaCy \"cy2\" else Cytoscape.initFaCy \"cy\")\n\n    method operationTM opName : unit =\n        super#operation opName \"TM\"\n\n    method model: Model.model = \n      (myTM :> Model.model) \n\n    method resetStyle = \n      Cytoscape.resetStyle self#getCy Cytoscape.faStyle\n\n    method getTM =\n      myTM\n\n    method changeAutomata res =\n      myTM <- res\n\n    method getModel = \n      myTM#toDisplayString \"solution\" \n\n    method setTitle = \n      CtrlUtil.oneBox self#getCy_opt;\n      HtmlPageClient.defineMainTitle (TuringMachine.kind)\n\n    method returnType = TuringMachine.kind\n\n    method startGraph = self#defineExample (*TODO Remove this call, call defineExample directly*)\n\n    method defineExample =\n      self#operationTM \"create example\";\n      self#updateButtons;\n      HtmlPageClient.putCyTMButtons ();\n      HtmlPageClient.closeBoxRegex ();\n      myTM#drawExample self#getCy;\n      self#defineInformationBox;\n      Cytoscape.fit self#getCy_opt;\n\n    method defineExample2 = \n      myTM#drawExample self#getCy;\n      self#defineInformationBox;\n\n    method defineInformationBox =\n      let infoBox = HtmlPageClient.defineInformationBox side in\n      let deter = myTM#isDeterministic in \n        HtmlPageClient.getDeterminim deter infoBox;\n      let useful = myTM#areAllStatesUseful in\n      let uStates = myTM#getUselessStates in \n        HtmlPageClient.getHasUselessStates useful uStates infoBox;\n      let nStates = myTM#numberStates in \n        HtmlPageClient.getNumberStates nStates infoBox;\n      let nTransitions = myTM#numberTransitions in\n        HtmlPageClient.getNumberTransitions nTransitions infoBox;\n      let isLB = myTM#isLB in\n        HtmlPageClient.getIsLinearBounded isLB infoBox;\n\n    (* TODO *)\n    (* - Para TM's, como e que posso pedir mais dados como simbolo escrever e a direcao,\n       pedir tudo de uma vez ou pedir prompt a prompt?\n       - necessario epsilon?\n    *)\n\n\t  method updateButtons =\n      HtmlPageClient.disableButton \"autoAccept\";\n      HtmlPageClient.changeButtonColor \"autoAccept\" \"\";\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyExpressionButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyCFGButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyAutomataButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyCFGConvertButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyTM2TapesConvertButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyPDAButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyTMButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOtherButtons;\n      if myTM#isDeterministic then begin\n        List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyGRConvertButtons\n      end\n\n\n\n    method convertToGR =\n      let open GrammarView in\n      self#operationTM \"convert to GR\";\n      let gr = PolyModel.tm2gr (myTM :> TuringMachine.model) in\n      new GrammarView.model (Representation (gr#representation)) \n\n    method private checkForSimulation : bool = \n      if self#getTM#isSimulating then \n        (\n          JS.confirm (Lang.i18nLeaveSimulationToEdit())\n        )\n      else \n        (\n          true\n        )\n    \n    method private resetAndRedraw =\n      let cy = self#getCy in   \n      Cytoscape.resetFaElems cy;\n      myTM#drawExample cy;\n      self#defineInformationBox\n      \n    method private drawNode x y node =\n      self#defineInformationBox\n    \n    method editModel = \n      !ListenersTM.editModelListener();\n    \n    method replicateOnLeft =\n      let c = new tmController self#getTM false in\n        Ctrl.ctrlL := (c :> controller);\n\n    method updateRight =\n      if !Ctrl.ctrlR#getUpdateType = Some \"specification\"\n      then !Listeners.showModelListener ()\n    \n    method printErrors =\n      let errors = myTM#errors in\n        if errors = [] then \n          ()\n        else \n          JS.alertStr (String.concat \"\\n\" errors);\n\n(*     method accept =\n      self#cancelProm;\n      let rec tic n =\n        match n with\n        | true -> HtmlPageClient.changeButtonColor \"autoAccept\" \"crimson\";\n                  Lwt.return()\n        | false -> let prom = Lwt.bind \n                  (Js_of_ocaml_lwt.Lwt_js.sleep 1.0)\n                  (fun () -> self#nextStep; tic myTM#isOver) in\n                  HtmlPageClient.changeButtonColor \"autoAccept\" \"green\";\n                  self#changeProm prom;\n                  prom\n      in\n      ignore(tic (self#promState = Lwt.Sleep));\n      Lwt.return_true *)\n\n    method getNewSentence = \n      Js.string myTM#newSentence1\n\n    method updateScreenSentence = \n      (Dom_html.getElementById \"regExp\")##.innerHTML := self#getNewSentence\n\n    method changeToEditMode =\n      self#getTM#changeToEditModelMode self#getCy;\n      self#updateScreenSentence\n\n    method startStep word =\n      self#operationTM \"accept start\";\n      self#cancelProm;\n      HtmlPageClient.fitBoxRegex ();\n(*       HtmlPageClient.enableButton \"autoAccept\";\n *)      \n      myTM#changeTheTestingSentence word;\n      myTM#startAccept self#getCy;\n      self#updateScreenSentence\n\n    method nextStep =\n      self#operationTM \"accept next\";\n      self#cancelProm;\n      myTM#next self#getCy;\n      self#updateScreenSentence\n\n    method backStep = \n      self#operationTM \"accept back\";\n      self#cancelProm;\n      myTM#back self#getCy;\n      self#updateScreenSentence\n\n    method addNode x y initial final: unit = \n      self#operationTM \"add Node\";\n\n      let result = self#checkForSimulation in\n      if result then \n        (          \n          let promptResult = (JS.prompt (Lang.i18nTextEnterState ()) \"A\") in\n          match Js.Opt.to_option promptResult with\n          | None -> ()\n          | Some v -> \n              let node = (Js.to_string v) in\n              if (myTM#hasState node) then \n                (\n                  JS.alertStr (Lang.i18nAlertExists ())\n                )\n              else \n                ( \n                  self#changeToEditMode;\n\n                  if (initial) then \n                    (\n                      myTM <- myTM#addInitialNode node;\n\n                      Cytoscape.resetFaElems self#getCy;\n                      self#defineExample;\n                      self#defineInformationBox\n                    )\n                  else \n                    (\n                      if (final) then\n                        (\n                          myTM <- myTM#addFinalNode node\n                        )\n                      else \n                        (\n                          myTM <- myTM#addNode node\n                        );\n\n                      Cytoscape.addNode self#getCy node ~x:x ~y:y false final;\n                      self#defineInformationBox\n                    )\n                )\n        )\n      else ()\n\n    method eliminateNode node =\n      self#operationTM \"eliminate node\";\n\n      let result = self#checkForSimulation in\n      if result then \n        ( \n          if (not (myTM#hasState node)) then \n            (\n              JS.alertStr (Lang.i18nAlertUnexistentState ())\n            )\n          else if (myTM#isInitial node) then \n            (\n              JS.alertStr (Lang.i18nAlertDelete ()) \n            )\n          else\n            (\n              self#changeToEditMode;\n\n              let eliminateNodeTransitions (a, b, c) node = \n                if (a = node || c = node) then\n                  ( \n                    self#eliminateTransition (a, b, c);\n                  )\n              in \n\n              myTM <- myTM#eliminateNode node;\n              Set.iter (fun (a,b,c,d,e) -> \n\t\t\t\teliminateNodeTransitions (a, myTM#makeLabel b d e, c) node)\n\t\t\t\t\tmyTM#representation.transitions;\n\n              Cytoscape.removeNode self#getCy node;\n              self#defineInformationBox\n            )\n        )\n      else ()\n\n    method turnNodeFinal node =\n      self#operationTM \"make node final\";\n\n      let result = self#checkForSimulation in\n      if result then \n        ( \n          if (myTM#isFinal node) then\n            (\n              JS.alertStr (Lang.i18nAlertAlreadyFinal ())\n            )\n          else\n            (\n              self#changeToEditMode;\n\n              myTM <- myTM#changeToFinal node;\n\n              Cytoscape.turnFinal self#getCy node;\n              self#defineInformationBox\n            )\n        )\n      else()\n\n    method turnNodeInitial node =\n      self#operationTM \"make node initial\";\n\n      let result = self#checkForSimulation in\n      if result then \n        ( \n          if (myTM#isInitial node) then\n            (\n              JS.alertStr (Lang.i18nAlertAlreadyInitial ())\n            )\n          else\n            (\n              self#changeToEditMode;\n\n              myTM <- myTM#addInitialNode node;\n\n              Cytoscape.resetFaElems self#getCy;\n              self#defineExample;\n              self#defineInformationBox\n            )\n        )\n      else()\n\n    method removeFinalNode node =\n      self#operationTM \"make node not final\";\n\n      let result = self#checkForSimulation in\n      if result then \n        ( \n          if (not (myTM#isFinal node)) then\n            (\n              JS.alertStr (Lang.i18nAlertNonFinal ())\n            )\n          else\n            (\n              self#changeToEditMode;\n\n              myTM <- myTM#removeFinal node;\n\n              Cytoscape.removeFinal self#getCy node;\n              self#defineInformationBox\n            )\n        )\n      else ()\n\n    method renameState state =\n      self#operationTM \"rename node\";\n     \n      let result = self#checkForSimulation in\n      if result then \n        ( \n          let prompt = JS.prompt (Lang.i18nRenameStateQuestion()) state in\n          match Js.Opt.to_option prompt with\n          | None -> ()\n          | Some n -> \n              let newName = Js.to_string n in\n                if myTM#hasState newName then\n                  (\n                    JS.alertStr (Lang.i18nAlertExists ())\n                  )\n                else\n                  (\n                    self#changeToEditMode;\n\n                    (* Make a function in cytoscape that reset a single node *)\n                    myTM <- myTM#renameNode state newName;\n\n                    Cytoscape.resetFaElems self#getCy;\n                    self#defineExample;\n                    self#defineInformationBox\n                  )\n        )\n      else ()\n\n    method createTransition source target =\n      self#operationTM \"add transition\";\n\n    let charIsDirection (dirC: char) : bool =\n        List.mem dirC ['L'; 'S'; 'R'] in\n\n    let char2direction (dirC: char) : direction =\n        List.assoc dirC [('L',L);('S',S);('R',S)] in\n        \n     let result = self#checkForSimulation in\n      if result then \n        (\n          let promptResult = (JS.prompt (Lang.i18nTextEnterTransitionTM ()) \"a/a/R\") in\n          match Js.Opt.to_option promptResult with\n          | None -> ()\n          | Some x ->\n              let v = Js.to_string x in\n                let (rdSymbol, wrtSymbol, dir) = myTM#dissectTransitionInput v in\n                let newTrs = (source, [str2symb rdSymbol], target, [char2symb wrtSymbol], [char2direction dir]) in\n                  if not (charIsDirection dir) then\n                    (\n                      (JS.alertStr (Lang.i18nAlertDirectionWrong ()))\n                    )\n                  else if (String.length v != 5 && (String.length v != 6 && (String.get v 0) != '~')) then\n                    (\n                      (JS.alertStr (Lang.i18nAlertExceededCharacters ()))\n                    )\n                  else if (myTM#hasTransition newTrs) then\n                    (\n                      (JS.alertStr (Lang.i18nAlertTransitionExists ()))\n                    )\n                  else\n                    (\n                      self#changeToEditMode;\n\n                      myTM <- myTM#newTransition newTrs;\n\n                      Cytoscape.addEdgeGeneral self#getCy (source, v, target);\n                      self#defineInformationBox\n                    )\n        )\n      else ()\n                  \n\n    method eliminateTransition (a, b, c) =\n      self#operationTM \"erase transition\";\n\n\t  let string2direction = dirI in\n\n      let result = self#checkForSimulation in\n      if result then \n        (\n          let (d,e,f) = match String.split_on_char '/' (b)  with\n            | [d;e;f] -> (d,e,f)\n            | _ -> Error.fatal \"eliminate transition\"\n          in\n          let trans = (a, [str2symb d], c, [str2symb e], [string2direction f]) in\n          if (not (myTM#hasTransition trans)) then\n            (\n              JS.alertStr ((Lang.i18nAlertTheTransition ()) ^ \"(\" ^ a ^ \", \" ^ b ^ \", \" ^ c ^ \")\" ^ (Lang.i18nAlertDoNotExists ()))\n            )\n          else \n            (\n              self#changeToEditMode;\n\n              myTM <- myTM#eliminateTransition trans;\n\n              Cytoscape.removeEdge self#getCy a b c;\n              self#defineInformationBox\n            )\n        )\n      else ()\n\n    method getWords v = \n      self#operationTM \"accepted words\";\n      let var = myTM#generate v in \n        HtmlPageClient.putWords var\n\n    (*JP*)\n    method showTrace word =\n      self#operationTM \"trace\";\n      myTM#staticAcceptFull;\n      let (accepted, configs, exact, time) = myTM#returnStats in\n      HtmlPageClient.displayAcceptStats accepted configs exact time;\n      myTM#displayTrace;\n\n    method checkWord word =\n      self#operationTM \"checkWord\";\n      myTM#changeTheTestingSentence word;\n      myTM#staticAccept;\n      let (accepted, configs, exact, time) = myTM#returnStats in\n      HtmlPageClient.displayAcceptStats accepted configs exact time;\n      self#updateScreenSentence\n\n\n  end\n\n","open OCamlFlat\nopen HtmlPageClient\nopen Controller\n\nclass exerController (exer: Exercise.exercise) (on: bool) (title: string) =\n  object(self) inherit controller as super\n\n    val exer1 = exer\n\n    val title1 = title\n    \n    val cy = Some (Cytoscape.initCy \"cy2\") (*TODO Check if needed*)\n    \n    method locked = true (*Exercises always located on the right*)\n\n    method getExercise =\n      exer1\n\n    method setTitle = \n      HtmlPageClient.defineMainTitle (title1)\n\n    method operationEXER opName : unit =\n      super#operation opName \"Exercise\"\n\n    method returnType = RegularExpression.kind\n\n    method defineExample2 =\n      self#operationEXER \"create\";\n      CtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n      HtmlPageClient.addEnumTitle();\n      let prob = exer1#representation.problem in\n        HtmlPageClient.defineEnumProblem prob;\n      HtmlPageClient.addPropertiesBox ();\n      Set.iter (fun el -> HtmlPageClient.createPropertiesList el \"nothing\" \"properties\") exer1#representation.properties;\n      HtmlPageClient.addAcceptedTitle ();\n      Set.iter (fun el -> HtmlPageClient.createSpanList el \"nothing\" \"inside\") exer1#representation.inside;\n      HtmlPageClient.addNonAcceptTitle ();\n      Set.iter (fun el -> HtmlPageClient.createSpanList el \"nothing\" \"outside\") exer1#representation.outside;\n      HtmlPageClient.addEnumCheckButton ()\n\n    method checkHelper result (insideErrors, outsideErrors, properties) = \n    self#operationEXER \"check exercise\";\n          HtmlPageClient.defineResult result;\n            Set.iter (fun el -> \n              if Set.belongs el properties then HtmlPageClient.createPropertiesList el \"error\" \"properties\" \n              else HtmlPageClient.createPropertiesList el \"right\" \"properties\") exer1#representation.properties;\n            Set.iter (fun el -> \n              if Set.belongs el insideErrors then HtmlPageClient.createSpanList el \"error\" \"inside\" \n              else HtmlPageClient.createSpanList el \"right\" \"inside\") exer1#representation.inside;\n            Set.iter (fun el -> \n              if Set.belongs el outsideErrors then HtmlPageClient.createSpanList el \"error\" \"outside\" \n              else HtmlPageClient.createSpanList el \"right\" \"outside\") exer1#representation.outside\nend\n","open OCamlFlat\nopen BasicTypes\nopen HtmlPageClient\nopen Js_of_ocaml\nopen JS\nopen Lang\nopen Controller\nopen GrammarView\nopen Listeners\nopen ViewUtil\n\n\nlet grammar2Str (rep:GrammarView.t) =\n  let open Grammar in\n  let initialRules = Set.filter (fun {head = h; _} -> List.hd h = rep.initial && List.length h = 1) rep.rules in\n  let nonInitialRules = Set.filter (fun {head = h; _} -> List.hd h <> rep.initial || List.length h <> 1) rep.rules in\n  let initialRulesStrLst = Grammar.toStringList initialRules in\n  let nonInitialRulesStrLst = Grammar.toStringList nonInitialRules in\n  let rulesList = initialRulesStrLst @ nonInitialRulesStrLst in\n  let rec toString l =\n    match l with\n    | [] -> \"\"\n    | x::xs -> x ^ \"\\n\" ^ (toString xs)\n  in\n    toString rulesList\n\n\n  \n\nclass grController (gr: GrammarView.model) (s:bool) =\n  object(self) inherit controller as super\n    val mutable myGR = gr\n    val side = s\n    val cy = if s then Some (Cytoscape.initGRCy \"cy2\") else Some (Cytoscape.initGRCy \"cy\");\n\n    method operationGR opName: unit =\n      super#operation opName \"GR\"\n   \n    method model: Model.model =\n      (myGR :> Model.model)\n    \n    method getGR = myGR\n    \n    method changeGR res = myGR <- res\n    \n    method getModel =\n      myGR#toDisplayString \"solution\"\n \n    method setTitle =\n      CtrlUtil.oneBox self#getCy_opt;\n      HtmlPageClient.defineMainTitle (Grammar.kind)\n\n    method returnType = Grammar.kind\n\n\n    \n    method defineExample = \n      self#operationGR \"create example\";\n      self#updateButtons;\n      HtmlPageClient.putCyGRButtons();\n      HtmlPageClient.grBoxRegex(); \n      HtmlPageClient.grCyClose();  \n      HtmlPageClient.defineGR();\n      myGR#createGrammarTableHtml \"\"; \n      self#defineInformationBox\n\n    method defineExample2 =\n      self#operationGR \"create example2\";\n      CtrlUtil.twoBoxes self#getCy_opt;\n      HtmlPageClient.printGR2GrammarComp (GrammarView.productionsTableId2());\n      myGR#createGrammarTableHtml (GrammarView.productionsTableId2());\n      !Ctrl.ctrlR#defineInformationBox\n\n    method replicateOnLeft =\n      let c = new grController self#getGR false in\n      Ctrl.ctrlL := (c :> controller);\n\n    method defineInformationBox =\n      let infoBox = HtmlPageClient.defineInformationBox side in\n      if side then HtmlPageClient.grCy2Close();\n      let cfg = myGR#isContextFreeGrammar in\n      let csg = myGR#isContextSensitiveGrammar in \n      let mo = myGR#isMonotonicGrammar in \n      let ug = myGR#isUnrestrictedGrammar in\n      if cfg then begin\n        let lg = myGR#isLinearGrammar in\n        let llg = myGR#isLeftLinearGrammar in\n        let lrg = myGR#isRightLinearGrammar in\n        if lg then begin\n          HtmlPageClient.getIsLG lg infoBox;\n          if llg then\n            HtmlPageClient.getIsLLG llg infoBox\n          else\n            HtmlPageClient.getIsRLG lrg infoBox\n        end else\n          HtmlPageClient.getIsCFG cfg infoBox\n      end else if csg then begin\n        HtmlPageClient.getIsCSG csg infoBox\n      end else \n        HtmlPageClient.getIsUG ug infoBox;\n    \n      HtmlPageClient.getIsMO mo infoBox;\n      let c = myGR#isClean in\n      let prod = myGR#allRulesProductive in\n      let access = myGR#allRulesAccessible in\n      HtmlPageClient.getIsGRClean c prod access infoBox;\n      ()\n\n    method box2GRShow (g : Grammar.model) =\n      self#operationGR \"create example2\";\n      CtrlUtil.twoBoxes self#getCy_opt;\n      HtmlPageClient.printGR2Grammar (GrammarView.productionsTableId2());\n      (GrammarView.adjust g)#createGrammarTableHtml (GrammarView.productionsTableId2());\n      !Ctrl.ctrlR#defineInformationBox\n\n    method checkWord word =\n      self#operationGR \"checkWord\";\n      let w = str2word word in\n      myGR#staticAccept w;\n      let (accepted, configs, exact, time) = myGR#returnStats in\n      HtmlPageClient.displayAcceptStats accepted configs exact time\n\n\n    method getWords v = \n      self#operationGR \"accepted words\";\n      let var = myGR#staticGenerate v in\n      let (_, visitedConfigs, exact, time) =\n        myGR#returnStats in\n          HtmlPageClient.putWords var;\n          HtmlPageClient.displayGenStats visitedConfigs exact time\n    \n\n    method editModel =  \n      !ListenersGR.editModelListener(); () \n\n    method updateButtons = \n      HtmlPageClient.disableButton \"autoAccept\";\n      HtmlPageClient.changeButtonColor \"autoAccept\" \"\";\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyTM2TapesConvertButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyAutomataButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyTMConvertButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyExpressionButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyGRConvertButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyCFGConvertButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyPDAButtons;\n\n      if myGR#isContextFreeGrammar then begin\n        List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyCFGConvertButtons;\n        List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyPDAButtons;\n      end;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyGRButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOtherButtons\n  \n    method convertToPDA =\n      let open PushdownAutomatonView in\n      self#operationGR \"convert to PDA\";\n      let pda = PolyModel.gr2pda (myGR :> Grammar.model) in\n      new PushdownAutomatonView.model (Representation (pda#representation)) \n\n    method model2Str =\n      let gr_representation = !Ctrl.ctrlL#getGR#representation in\n      grammar2Str gr_representation\n\n\n    method convertToCFG =\n      let open ContextFreeGrammarView in\n      self#operationGR \"convert to CFG\";\n      let cfg = PolyModel.gr2cfg (myGR :> Grammar.model) in\n      new ContextFreeGrammarView.model (Representation (cfg#representation))\n\n    method showTrace word =\n      self#operationGR \"trace\";\n      let w = str2word word in\n      myGR#staticAcceptFull w;\n      let (accepted, configs, exact, time) = myGR#returnStats in\n      HtmlPageClient.displayAcceptStats accepted configs exact time;\n      myGR#displayTrace\n\n\n\n    method handleOp (operation: string) =\n      match operation with\n      (* | \"create\" ->\n          Js_of_ocaml.Dom_html.window##alert (Js.string \"creating\");\n          let str = ViewUtil.extractStringFromTextArea() in\n          Js_of_ocaml.Dom_html.window##alert (Js.string \"extracted\");\n          let grModel = grStr2Model str in\n          Js_of_ocaml.Dom_html.window##alert (Js.string \"model\");\n          HtmlPageClient.hideModalWindow();\n          CtrlUtil.oneBox self#getCy_opt;\n          HtmlPageClient.clearBox1();\n          createController grModel false;\n          self#defineExample;\n          self#setTitle *)\n      | \"clean\" ->\n          if not myGR#isClean then\n            let newGr = myGR#clean in\n            let newGrModel = (newGr :> Grammar.model) in\n            let gr = GrammarView.adjust newGrModel in\n            let c = new grController gr true in\n              Ctrl.changeCtrlR (c :> Controller.controller);\n            self#box2GRShow newGrModel\n          else\n            JS.alertStr (Lang.i18nAlertIsClean())\n       | \"kuroda\" ->\n          if myGR#isMonotonicGrammar then\n            let newGr = myGR#kuroda in\n            let newGrModel = (newGr :> Grammar.model) in\n            let gr = GrammarView.adjust newGrModel in\n            let c = new grController gr true in\n              Ctrl.changeCtrlR (c :> Controller.controller);\n            self#box2GRShow newGrModel\n          else\n            JS.alertStr (Lang.i18nAlertIsNotMonotonic())\n      | \"penttonen\" ->\n          if myGR#isMonotonicGrammar then\n            let newGr = myGR#penttonen in\n            let newGrModel = (newGr :> Grammar.model) in\n            let gr = GrammarView.adjust newGrModel in\n            let c = new grController gr true in\n              Ctrl.changeCtrlR (c :> Controller.controller);\n            self#box2GRShow newGrModel\n          else\n            JS.alertStr (Lang.i18nAlertIsNotMonotonic())\n      | \"nonContractingToCSG\" ->\n          if myGR#isContextSensitiveGrammar then\n            JS.alertStr (Lang.i18nIsCSG())\n          else if myGR#isMonotonicGrammar then\n            let newGr = myGR#nonContractingToCSG in\n            let newGrModel = (newGr :> Grammar.model) in\n            let gr = GrammarView.adjust newGrModel in\n            let c = new grController gr true in\n              Ctrl.changeCtrlR (c :> Controller.controller);\n            self#box2GRShow newGrModel\n          else\n            JS.alertStr (Lang.i18nAlertIsNotMonotonic())\n      | _ -> JS.alertStr \"Invalid operation\"\n\nend\n\n","open OCamlFlat\nopen BasicTypes\nopen HtmlPageClient\nopen Lang\nopen JS\nopen CompositionView\nopen Controller\nopen Listeners\nopen Js_of_ocaml\n\n\nclass compController (comp: CompositionView.model) (s: bool) =\n  object(self) inherit controller as super\n\n    val comp1 = comp\n\n    val side = s\n    val cy = Some (if s then Cytoscape.startTree \"cy2\" else Cytoscape.startTree \"cy\")\n\n    val mutable step = 0\n\n    val mutable comp = comp\n    val mutable resultTree = false\n    val mutable wordAsList : word = []\n\n    method model: Model.model = \n      (comp1 :> Model.model) \n\n    method getWordAsList () =\n      wordAsList\n\n    method getComp =\n      comp1\n\n    method getResultTree =\n      resultTree\n\n    method setComp newComp = \n      comp <- newComp\n\n    method getModel = \n      comp1#toDisplayString \"solution\"\n\n    method setTitle = \n      CtrlUtil.oneBox self#getCy_opt;\n      HtmlPageClient.defineMainTitle (Composition.kind)\n\n    method operationComp opName : unit =\n      super#operation opName \"COMP\"\n\n    method returnType = Composition.kind\n\n    method private makeTree cy (comp : Composition.t) =\n      let nGetName = ref 0 in\n      let genName () = \n        let prefix = \"N\" in \n        nGetName := !nGetName + 1;\n        prefix ^ (string_of_int !nGetName)\n      in\n      let rec makeTree2 cy (comp: Composition.t) =\n      match comp with\n        | Plus (l, r) ->  let rootName = genName () in \n                          let rootL = makeTree2 cy l in \n                          let rootR = makeTree2 cy r in\n                            Cytoscape.makeTreeNode cy rootName \"+\"; \n                            Cytoscape.makeTreeEdge cy rootName rootL;\n                            Cytoscape.makeTreeEdge cy rootName rootR;\n                            rootName\n        | Seq (l, r) -> let rootName = genName () in \n                        let rootL = makeTree2 cy l in \n                        let rootR = makeTree2 cy r in\n                          Cytoscape.makeTreeNode cy rootName \".\"; \n                          Cytoscape.makeTreeEdge cy rootName rootL;\n                          Cytoscape.makeTreeEdge cy rootName rootR;\n                          rootName\n        | Intersect (l, r) -> let rootName = genName () in \n                        let rootL = makeTree2 cy l in \n                        let rootR = makeTree2 cy r in\n                          Cytoscape.makeTreeNode cy rootName \"^\"; \n                          Cytoscape.makeTreeEdge cy rootName rootL;\n                          Cytoscape.makeTreeEdge cy rootName rootR;\n                          rootName\n        | Star re -> let rootName = genName () in \n                        let root = makeTree2 cy re  in \n                          Cytoscape.makeTreeNode cy rootName \"*\"; \n                          Cytoscape.makeTreeEdge cy rootName root;\n                          rootName\n        | Rep rep -> let rootName = genName () in \n                    Cytoscape.makeTreeNode2 cy rootName (rep);\n                    rootName\n        | _ -> let rootName = genName () in \n                        Cytoscape.makeTreeNode cy rootName \"error\";\n                        rootName\n\n       (* | Symb b -> let rootName = genName () in \n                        Cytoscape.makeTreeNode cy rootName (symb2str b);\n                        rootName\n        | Empty  -> let rootName = genName () in \n                        Cytoscape.makeTreeNode cy rootName \"~\";\n                        rootName\n        | Zero   -> let rootName = genName () in \n                        Cytoscape.makeTreeNode cy rootName \"!\";\n                        rootName*)\n      in\n      makeTree2 cy comp\n\n    method private drawTree cy comp text =\n      if String.length text >= 120 \n      then Cytoscape.makeTreeNode cy \"nope\" (Lang.i18nAlertRETooBig ())\n      else ignore (self#makeTree cy comp1#representation)\n\n    method defineExample =\n      self#operationComp \"create\";\n      self#updateButtons;\n      HtmlPageClient.putCyREButtons();\n      HtmlPageClient.fitBoxRegex ();\n      Cytoscape.fit self#getCy_opt;\n      let test = Composition.toString comp1#representation in\n       self#drawTree self#getCy comp1#representation test;\n       HtmlPageClient.defineRE test side\n\n    method defineExample2 =\n      self#operationComp \"create 2\";\n      let text = Composition.toString comp1#representation in\n        self#drawTree self#getCy comp1#representation text;\n        HtmlPageClient.defineRE text side\n\n    method checkWord2 word = \n      self#operationComp \"accept\";\n      let res = comp1#accept (str2word word) in\n      (if res then JS.alertStr \"true\" else JS.alertStr \"false\");\n\n    method checkWord word =\n      self#operationComp \"checkWord\";\n      let w = str2word word in\n      comp1#staticAccept w;\n      let (accepted, configs, exact, time) = comp1#returnStats in\n      HtmlPageClient.displayAcceptStats accepted configs exact time;\n\n\n      (* Lwt.return_false *)\n      (*let w = str2word word in\n        wordAsList <- w;\n        CtrlUtil.twoBoxes self#getCy_opt;\n        comp1#startAllTrees w;\n        resultTree <- comp1#accept w;\n        Ctrl.changeCtrlR ((new textController true) :> controller );\n        Cytoscape.resetStyle !Ctrl.ctrlR#getCy Cytoscape.reStyle;\n        if (resultTree) then\n          (!ListenersRE.resultCountListener ();\n          let right = comp1#getRightTrees in \n          ignore (comp1#printTree right (!Ctrl.ctrlR#getCy));\n            !ListenersRE.defineNumberTreesListener ();\n            HtmlPageClient.defineTreeButtons ();\n            Lwt.return_true)\n        else \n          (!ListenersRE.resultCountListener();\n          let wrong = comp1#getWrongTrees in \n          ignore(comp1#printTree wrong (!Ctrl.ctrlR#getCy));\n            !ListenersRE.defineNumberTreesListener ();\n            HtmlPageClient.defineTreeButtons ();\n            Lwt.return_false)*)\n\n\n    method convertToRegExp = \n      let open RegularExpressionView in\n      let re = comp1#evalRE in\n        new RegularExpressionView.model (Representation re)\n\n    method convertToFA =\n      let open FiniteAutomatonView in\n      let fa = comp1#evalFA in\n        new FiniteAutomatonView.model (Representation fa)\n\n    method convertToPDA =\n      let open PushdownAutomatonView in\n      let pda = comp1#evalPDA in\n          new PushdownAutomatonView.model (Representation pda)\n\n    method convertToCFG = \n      let open ContextFreeGrammarView in\n      let cfg = comp1#evalCFG in\n          new ContextFreeGrammarView.model (Representation cfg)\n\n    method convertToTM = \n      let open TuringMachineView in\n      let tm = comp1#evalTM in\n          new TuringMachineView.model (Representation tm)\n\n    method convertToGR = \n      let open GrammarView in\n      let gr = comp1#evalGR in\n          new GrammarView.model (Representation gr)\n\n    method updateButtons =\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyAutomataButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyExpressionButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listOnlyTM2TapesConvertButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyPDAButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyCFGConvertButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyGRConvertButtons;\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyTMConvertButtons; (* carolina *)\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOnlyCFGButtons; (*necessário ???*)\n      List.iter (fun el -> HtmlPageClient.enableButton el) listOtherButtons;\n      List.iter (fun el -> HtmlPageClient.disableButton el) listDisCompButtons\n      \n    \n    method getWords v = \n      self#operationComp \"accepted words\";\n        let var = comp1#generate v in \n          HtmlPageClient.putWords var\n\n    method editModel =\n      let open Js.Unsafe in\n      let createModelPrep titleTxt otherTxt textAreaString okAction =\n        let modelContent = HtmlPageClient.editModelContent titleTxt otherTxt textAreaString okAction in\n        HtmlPageClient.setModal (Js.Unsafe.coerce modelContent);\n        HtmlPageClient.showModalWindow () in\n\n      let createModelPrepComp textAreaString okAction =\n        createModelPrep (Lang.i18nMainTitleComp()) \"\" textAreaString okAction in\n      \n      createModelPrepComp (Composition.toString !Ctrl.ctrlL#getComp#representation) (fun () -> !ListenersComp.createModelListener())\n\n     (* !ListenersRE.editModelListener(); ()*)\n\n    method replicateOnLeft =\n      let c = new compController self#getComp false in\n        Ctrl.ctrlL := (c :> controller)\n\n    method printErrors =\n      let errors = comp1#errors in\n        if errors = [] then \n          ()\n        else \n          JS.alertStr (String.concat \"\\n\" errors)\nend\n","open OCamlFlat\nopen BasicTypes\nopen Js_of_ocaml\nopen JS\nopen ViewUtil\nopen FiniteAutomatonView\nopen PushdownAutomatonView\nopen RegularExpressionView\nopen ContextFreeGrammarBasicView\nopen ContextFreeGrammarView\nopen ContextFreeGrammarLL1View\nopen GrammarView\nopen TuringMachineView\nopen CompositionView\nopen Lang\nopen Listeners\nopen HtmlPageClient\nopen StateVariables\nopen String\nopen Random\nopen AutomatonView\nopen Controller\nopen FiniteAutomatonController\nopen PushdownAutomatonController\nopen RegularExpressionController\nopen ContextFreeGrammarController\nopen TuringMachineController\nopen CompositionController\nopen ExerciseController\nopen GrammarController\n\n(* PEDRO CARLOS VER! 80 linhas. Fazem o que?  o put abaixo?... *)\nlet cfgStr2Model str = (*TODO put in controller*)\n  let open ContextFreeGrammarBasic in\n  let splitStr = String.split_on_char '\\n' str in\n  let initialRule = Set.make [List.hd splitStr] in\n  let otherRules = Set.make (List.tl splitStr) in\n  let initialParsedRule = ContextFreeGrammarBasic.parse initialRule in\n  let initial = (Set.nth initialParsedRule 0).head in\n  let parsedRules = ContextFreeGrammarBasic.parse (Set.union initialRule otherRules) in\n  let variables = Set.add initial (Set.map (fun {head = h; _} -> h) parsedRules) in\n  let alphabet = Set.flatMap (fun {head = h; body = b} -> Set.make (List.filter (fun s -> not (Set.belongs s variables)) b) ) parsedRules in\n  new ContextFreeGrammarBasic.model (Arg.Representation {\n    alphabet = alphabet;\n    variables = variables;\n    initial = initial;\n    rules = parsedRules\n  } )\n\n\nlet grStr2Model str = (*TODO put in controller*)\n  let isTerminalSymbol (symbol: symbol) : bool =\n    let str = symb2str symbol in\n    not ((\"A\" <= str && str <= \"Z\") || String.get str 0 = '<' && String.get str (String.length str - 1) = '>')\n  in\n  (* Extract all symbols between < and > *)\n  let extractInitVars str =\n    let rec extract acc i =\n      try\n        let start = String.index_from str i '<' in\n        let stop = String.index_from str (start + 1) '>' in\n        let symbol = String.sub str start (stop - start + 1) in\n        extract (Set.add (str2symb symbol) acc) (stop + 1)\n      with Not_found -> acc\n    in\n    extract Set.empty 0\n  in\n  let open Grammar in\n  let splitStr = String.split_on_char '\\n' str in\n  let initialRule = Set.make [List.hd splitStr] in\n  let otherRules = Set.make (List.tl splitStr) in\n  let initialParsedRule = Grammar.parse initialRule in\n  let initial = List.hd (Set.nth initialParsedRule 0).head in\n  let parsedRules = Grammar.parse (Set.union initialRule otherRules) in\n  let initiVars = extractInitVars str in\n  let variables =\n    Set.fold_left \n      (fun acc rule -> \n        let headVariables = Set.make (List.filter (fun s -> not (isTerminalSymbol s)) rule.head) in\n        let bodyVariables = Set.make (List.filter (fun s -> not (isTerminalSymbol s)) rule.body) in\n        Set.union acc (Set.union headVariables bodyVariables)\n      )\n      initiVars\n      parsedRules\n  in\n\n  (* Extract alphabet using map *)\n  let alphabet =\n    Set.fold_left\n      (fun acc rule ->\n        let headTerminals = Set.make (List.filter (fun s -> isTerminalSymbol s && s <> epsilon) rule.head) in\n        let bodyTerminals = Set.make (List.filter (fun s -> isTerminalSymbol s && s <> epsilon) rule.body) in\n        Set.union acc (Set.union headTerminals bodyTerminals)\n      )\n      Set.empty\n      parsedRules\n  in\n\n  let model = new Grammar.model (Arg.Representation {\n    alphabet = alphabet;\n    variables = variables;\n    initial = initial;\n    rules = parsedRules\n  }) in\n\n  (* Convert model to JSON string and alert *)\n  (* let model_json = model#toJSon in\n  let model_str = Js_of_ocaml.Json.output model_json in\n  Js_of_ocaml.Dom_html.window##alert (Js_of_ocaml.Js.string (Js_of_ocaml.Js.to_string model_str));\n    *)\n  model\n\nmodule ControllerListeners = struct\n  let listColors = [|\"Red\"; \"Yellow\"; \"Cyan\"; \"Green\"; \"Indigo\"; \"Blue\"; \"Magenta\"; \"Sienna\"; \"Violet\"; \"Orange\"; \"Lime\"; \"Teal\"; \"SteelBlue\"; \"Silver\"; \"Olive\"; \"Salmon\"; \"Crimson\"; \"Purple\"; \"DarkKhaki\"; \"PowderBlue\"|]\n  let listColorsBig: string array ref = ref [||];;\n\n  let setTitle () =\n    if !Ctrl.ctrlR#locked then\n      !Ctrl.ctrlR#setTitle\n    else \n      !Ctrl.ctrlL#setTitle\n  \n  let createController c lr = \n    if lr then begin \n      Ctrl.ctrlR := (c :> controller);\n    end\n    else begin \n      Ctrl.ctrlL := (c :> controller);\n    end\n\n  let createFAController fa lr =\n    if not lr then !Ctrl.ctrlL#finish else ();\n    let c = new faController fa lr in\n      createController c lr\n  \n  let createPDAController pda lr =\n    if not lr then !Ctrl.ctrlL#finish else ();\n    let c = new pdaController pda lr in\n      createController c lr\n  \n  let createREController re lr =\n    if not lr then !Ctrl.ctrlL#finish else ();\n    let c = new reController re lr in\n      createController c lr\n\n  let createCFGController (cfg: ContextFreeGrammarView.model) lr =\n    if not lr then !Ctrl.ctrlL#finish else ();\n    let c = new cfgController cfg lr in\n      createController c lr\n      \n  let createCFGController2 (cfg: ContextFreeGrammarBasic.model) lr =\n      if not lr then !Ctrl.ctrlL#finish else ();\n    let cfg = ContextFreeGrammarView.adjust cfg in\n    createCFGController cfg lr\n\n\n  let createGRController (gr: GrammarView.model) lr =\n    if not lr then !Ctrl.ctrlL#finish else ();\n    let c = new grController gr lr in\n      createController c lr\n      \n  let createGRController2 (gr: Grammar.model) lr =\n      if not lr then !Ctrl.ctrlL#finish else ();\n    let gr = GrammarView.adjust gr in\n    createGRController gr lr \n  \n\n  let createTMController (tm: TuringMachineView.model) lr =\n    if not lr then !Ctrl.ctrlL#finish else ();\n    let c = new tmController tm lr in\n       createController c lr   \n      \n  let createCompController (comp: CompositionView.model) lr =\n    if not lr then !Ctrl.ctrlL#finish else ();\n    let c = new compController comp lr in\n      createController c lr\n \n  let createExerController ex lr title =\n    if not lr then !Ctrl.ctrlL#finish else (); (*pode se apagar eventualmente?*)\n    let c = new exerController ex lr title in\n      createController c lr \n\n  let closeLeftAction () =\n    (match !Ctrl.ctrlR#locked with\n    | false -> \n      HtmlPageClient.clearBox1 ();\n      !Ctrl.ctrlR#replicateOnLeft;\n      !Ctrl.ctrlL#defineExample;\n      CtrlUtil.oneBox !Ctrl.ctrlL#getCy_opt\n    | true -> (*apagar apenas esquerda*)\n      HtmlPageClient.clearBox1 ();\n      !CtrlUtil.changeToControllerCtrlLeft ());\n    !Ctrl.ctrlL#updateButtons;\n    setTitle()\n    \n  let conversionTo n =\n    CtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n    try\n      match n with\n      | 1 ->  \n              let re = !Ctrl.ctrlL#convertToRegExp in \n              CtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n              createREController re true;\n              !Ctrl.ctrlR#defineExample2\n      | 2 -> \n              let fa = !Ctrl.ctrlL#convertToFA in\n              createFAController fa true;\n              !Ctrl.ctrlR#defineExample2;\n              Cytoscape.fit !Ctrl.ctrlR#getCy_opt\n      | 3 -> \n              let cfg = !Ctrl.ctrlL#convertToCFG in\n              createCFGController cfg true;\n              !Ctrl.ctrlR#defineExample2;\n              Cytoscape.fit !Ctrl.ctrlR#getCy_opt\n      | 4 -> \n              let gr = !Ctrl.ctrlL#convertToGR in\n              createGRController gr true;\n              !Ctrl.ctrlR#defineExample2;\n              Cytoscape.fit !Ctrl.ctrlR#getCy_opt\n      | 5 -> \n              let pda = !Ctrl.ctrlL#convertToPDA in\n              createPDAController pda true;\n              !Ctrl.ctrlR#defineExample2;\n              Cytoscape.fit !Ctrl.ctrlR#getCy_opt\n      | 6 -> \n              let tm = !Ctrl.ctrlL#convertToTM_SingleTape in\n              createTMController tm true;\n              !Ctrl.ctrlR#defineExample2;\n              Cytoscape.fit !Ctrl.ctrlR#getCy_opt\n      | 7 -> \n              let tm = !Ctrl.ctrlL#convertToTM_DualTape in\n              createTMController tm true;\n              !Ctrl.ctrlR#defineExample2;\n              Cytoscape.fit !Ctrl.ctrlR#getCy_opt\n    with\n    | Failure _ -> JS.alertStr (Lang.i18nErrorConversion ())\n    ;;\n\n  Listeners.openEntityListener :=\n    fun (txt) -> (\n      let j = JSon.parse txt in\n        let kind = JSon.fieldString j \"kind\" in\n        (match kind with\n        | k when k = FiniteAutomaton.kind -> \n              HtmlPageClient.clearBox1 ();\n              let fa = new FiniteAutomatonView.model (JSon j) in \n              createFAController fa false;\n              !Ctrl.ctrlL#defineExample\n        | k when k = RegularExpression.kind -> \n              HtmlPageClient.clearBox1 ();\n              let re = new RegularExpressionView.model (JSon j) in \n              createREController re false;\n              !Ctrl.ctrlL#defineExample\n        | k when k = PushdownAutomaton.kind -> \n              HtmlPageClient.clearBox1 ();\n              let pda = new PushdownAutomatonView.model (JSon j) in \n              createPDAController pda false;\n              !Ctrl.ctrlL#defineExample\n        | k when k = ContextFreeGrammar.kind ->\n              HtmlPageClient.clearBox1 ();\n              let cfg = new ContextFreeGrammarView.model (JSon j) in\n              createCFGController cfg false;\n              !Ctrl.ctrlL#defineExample\n\n        | k when k = Grammar.kind ->\n              HtmlPageClient.clearBox1 ();\n              let gr = new GrammarView.model (JSon j) in\n              createGRController gr false;\n              !Ctrl.ctrlL#defineExample\n\n        | k when k = TuringMachine.kind ->\n              HtmlPageClient.clearBox1 ();\n              let tm = new TuringMachineView.model (JSon j) in \n              createTMController tm false;\n              !Ctrl.ctrlL#defineExample\n        | k when k = Composition.kind ->\n              HtmlPageClient.clearBox1 ();\n              let tm = new CompositionView.model (JSon j) in \n              createCompController tm false;\n              !Ctrl.ctrlL#defineExample\n        | _ -> HtmlPageClient.clearBox2 ();\n              let enu = new Exercise.exercise (JSon j) in \n              createExerController enu true \"exercise\";\n              !Ctrl.ctrlR#defineExample2);\n        setTitle();\n        !Ctrl.ctrlL#printErrors);;\n\n  Listeners.closeRightListener := \n    fun () -> !Ctrl.ctrlR#closeRightAction;\n              !Ctrl.ctrlL#resetStyle;\n              CtrlUtil.oneBox (!Ctrl.ctrlL#getCy_opt);\n              setTitle();;\n\n  Listeners.defineInformationBoxListener :=\n    fun () -> !Ctrl.ctrlL#defineInformationBox;;\n\n  ListenersAutomaton.paintAllUsefulListener :=\n    fun () -> !Ctrl.ctrlL#resetStyle;\n    (!Ctrl.ctrlL#getAutomaton)#usefulPainting !Ctrl.ctrlL#getCy;;\n\n  ListenersAutomaton.paintAllProductivesListener :=\n    fun () -> (!Ctrl.ctrlL#resetStyle;\n    (!Ctrl.ctrlL#getAutomaton)#productivePainting !Ctrl.ctrlL#getCy);;\n\n  ListenersAutomaton.paintAllReachableListener := \n    fun () -> !Ctrl.ctrlL#resetStyle;\n    (!Ctrl.ctrlL#getAutomaton)#reachablePainting !Ctrl.ctrlL#getCy;;\n(* ML *)\n\n  ListenersAutomaton.addNode := fun x y -> !Ctrl.ctrlL#addNode x y false false;;\n\n  ListenersAutomaton.addInitialNode := fun x y -> !Ctrl.ctrlL#addNode x y true false;;\n\n  ListenersAutomaton.addFinalNode := fun x y -> !Ctrl.ctrlL#addNode x y false true;;\n\n  ListenersAutomaton.removeNode := fun node -> !Ctrl.ctrlL#eliminateNode node;;\n\n  ListenersAutomaton.turnFinal := fun node -> !Ctrl.ctrlL#turnFinalNode node;;\n\n(*\n  ListenersAutomaton.addNode := fun x y -> \n    let promptResult = (JS.prompt (Lang.i18nTextEnterState ()) \"A\") in\n    match Js.Opt.to_option promptResult with\n    | None -> ()\n    | Some v -> !Ctrl.ctrlL#addNode x y (Js.to_string v)\n    ;;\n    \n  ListenersAutomaton.addInitialNode := fun x y ->\n    let promptResult = (JS.prompt (Lang.i18nTextEnterState ()) \"A\") in\n    match Js.Opt.to_option promptResult with\n    | None -> ()\n    | Some v -> !Ctrl.ctrlL#addInitialNode (Js.to_string v)\n    ;;\n\n  ListenersAutomaton.addFinalNode := fun x y ->\n    let promptResult = (JS.prompt (Lang.i18nTextEnterState ()) \"A\") in\n    match Js.Opt.to_option promptResult with\n    | None -> ()\n    | Some v -> !Ctrl.ctrlL#addFinalNode x y (Js.to_string v)\n    ;;\n*)\n\n  ListenersAutomaton.removeTypeFinal := fun node -> !Ctrl.ctrlL#removeFinalNode node;;\n\n  ListenersAutomaton.turnNodeInitial := fun node -> !Ctrl.ctrlL#addInitialNode node;;\n\n    \n  ListenersAutomaton.addTransition := fun src trg -> !Ctrl.ctrlL#createTransition src trg ;;\n\n  ListenersAutomaton.removeTransition := fun srcId trgId symbol -> \n    let open Re in\n    (if List.length (Str.split (Str.regexp \",\") symbol) > 1 then\n      (let text = JS.prompt (Lang.i18nWhichTransition ()) symbol in \n      match Js.Opt.to_option text with\n      | None -> ()\n      | Some v -> !Ctrl.ctrlL#eliminateTransition (srcId, (Js.to_string v), trgId)\n      )\n    else \n        !Ctrl.ctrlL#eliminateTransition (srcId, symbol, trgId));;\n\n  ListenersAutomaton.renameNodeListener :=\n    fun (state) -> !Ctrl.ctrlL#renameState state;;\n\n  ListenersAutomaton.showTable :=\n    fun () -> \n              !Ctrl.ctrlL#changeTab;\n              let flag = !Ctrl.ctrlL#getTab in\n              HtmlPageClient.toggleTab flag;\n              Cytoscape.fit !Ctrl.ctrlL#getCy_opt;;\n              \n\n\n  ListenersFA.cleanUselessListener :=\n    fun () -> if ((!Ctrl.ctrlL#getFA)#areAllStatesUseful) then \n                JS.alertStr (Lang.i18nAlertClean ())\n              else \n                (let auto = (!Ctrl.ctrlL#getFA)#cleanUselessStates1 !Ctrl.ctrlL#getCy in \n                CtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n                createFAController auto true;\n                !Ctrl.ctrlR#defineExample2;\n                Cytoscape.fit !Ctrl.ctrlR#getCy_opt;);;\n\n  ListenersFA.getDeterministicListener :=\n    fun () -> if ((!Ctrl.ctrlL#getFA)#isDeterministic) then \n                JS.alertStr (Lang.i18nAlertDeterministic ())\n              else \n                (let auto = (!Ctrl.ctrlL#getFA)#toDeterministic1 in \n                CtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n                createFAController auto true;\n                !Ctrl.ctrlR#defineExample2;\n                Cytoscape.fit !Ctrl.ctrlR#getCy_opt);;\n  \n  let getRandom() = \n    let test = Random.int 16777215 in\n    Printf.sprintf \"#%06x\" test\n    \n  let setColor number =\n    if (number <= 20) then \n      listColorsBig := listColors\n    else \n      (for i=0 to 19 do \n        Array.set !listColorsBig i (Array.get listColors i)\n        done;\n      for i=20 to number-1 do\n        let newColor = getRandom () in \n          Array.set !listColorsBig i newColor\n      done);;\n\n  ListenersFA.defineMinimizedListener :=\n  fun () -> if ((!Ctrl.ctrlL#getFA)#isDeterministic) then\n              if ((!Ctrl.ctrlL#getFA)#isMinimized) then \n                JS.alertStr (Lang.i18nAlertMinimum ())\n              else \n                (let auto = (!Ctrl.ctrlL#getFA)#minimize1 in \n                CtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n                createFAController auto true;\n                let number = (!Ctrl.ctrlL#getFA)#getColors in\n                setColor number;\n                !Ctrl.ctrlR#defineMinimize !listColorsBig number;)\n            else \n              JS.alertStr (Lang.i18nAlertNeedsDeterministic ());;\n\n  ListenersPDA.cleanUselessListener :=\n  fun () -> if ((!Ctrl.ctrlL#getPDA)#areAllStatesUseful) then \n              JS.alertStr (Lang.i18nAlertClean ())\n            else \n              (let automaton = (!Ctrl.ctrlL#getPDA)#cleanUselessStates1 !Ctrl.ctrlL#getCy in \n              CtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n              createPDAController automaton true;\n              !Ctrl.ctrlR#defineExample2;\n              Cytoscape.fit !Ctrl.ctrlR#getCy_opt;);;\n\n  Listeners.closeLeftListener := \n  fun () -> \n    (closeLeftAction ();\n    setTitle () );;\n          \n  Listeners.showModelListener := \n    fun () -> CtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n              !CtrlUtil.changeToControllerCtrlRight();\n              !Ctrl.ctrlR#setUpdateType \"specification\";\n              let getInfo = JSon.toString ((!Ctrl.ctrlL#model)#toJSon) in\n              HtmlPageClient.showModelInfo getInfo;;\n\n  ListenersRE.resultCountListener := \n    fun () -> \n      if (!Ctrl.ctrlL#getResultTree)  then \n        HtmlPageClient.putTreeResult (Lang.i18nWordAccepted ())\n      else \n        (HtmlPageClient.putTreeResult (Lang.i18nWordNotAccepted ()));\n        let blah = !Ctrl.ctrlL#getRE in \n        let blah2 = !Ctrl.ctrlL#getWordAsList() in \n        let (right, wrong) = blah#countRightTrees blah2 in \n          let textt = (Lang.i18nExists ()) ^ (string_of_int (right)) ^ (Lang.i18nGoodDerivations ()) in\n            HtmlPageClient.putTreeGoodDerivations textt;\n          let textt1 = (Lang.i18nExists ()) ^ (string_of_int (wrong)) ^ (Lang.i18nBadDerivations ()) in\n            HtmlPageClient.putTreeBadDerivations textt1;;\n      \n  ListenersRE.defineNumberTreesListener :=\n    fun () -> \n      let pos = (!Ctrl.ctrlL#getRE)#position in \n      let leng = (!Ctrl.ctrlL#getRE)#length in \n      let textt = (string_of_int (pos)) ^ (Lang.i18nBy ()) ^ (string_of_int (leng)) in \n        HtmlPageClient.putTreeNumbers textt;;\n  \n  ListenersRE.previousTreeListener :=\n    fun () -> \n      let back = (!Ctrl.ctrlL#getRE)#back in\n      let cy = !Ctrl.ctrlR#getCy in\n      Cytoscape.removeAllElements cy;\n      ignore ((!Ctrl.ctrlL#getRE)#printTree back cy);\n        !ListenersRE.defineNumberTreesListener ();;\n  \n  ListenersRE.nextTreeListener := \n    fun () ->\n      let next = (!Ctrl.ctrlL#getRE)#next in\n      let cy = !Ctrl.ctrlR#getCy in\n      Cytoscape.removeAllElements cy;\n      ignore ((!Ctrl.ctrlL#getRE)#printTree next cy); \n        !ListenersRE.defineNumberTreesListener ();;\n              \n  ListenersEXER.checkExerciseListener :=\n    fun () -> (\n        let model = !Ctrl.ctrlL#model in \n        let result = model#checkExercise (!Ctrl.ctrlR#getExercise) in\n        let (insideErrors, outsideErrors, properties) = model#checkExerciseFailures (!Ctrl.ctrlR#getExercise) in \n          !Ctrl.ctrlR#checkHelper result (insideErrors, outsideErrors, properties);\n    );;\n      \n  ListenersEXER.clearExerciseListener :=\n    fun () -> (\n      HtmlPageClient.oneBox ();\n      let element = Dom_html.getElementById \"cy2\" in\n        element##.innerHTML := Js.string \"\";\n      !CtrlUtil.changeToControllerCtrlRight();\n      setTitle ();\n      );;\n\n  ListenersRE.changeDirectionListener :=  fun () -> \n    let newDir = (Cytoscape.changeDirection !Ctrl.ctrlL#getCy !Ctrl.ctrlL#getLayoutDir) in\n\t\t!Ctrl.ctrlL#changeLayoutDir newDir;;\n\n  ListenersCFG.cleanCFGListener :=\n    fun () -> let cfg = !Ctrl.ctrlL#getCFG in\n              if not cfg#isClean then\n\t\t\t\tlet newCfg = cfg#clean1 in\n\t\t\t\t\tcreateCFGController2 newCfg.grammar true;\n\t\t\t\t\t!Ctrl.ctrlL#box2CFGShow newCfg\n              else\n\t\t\t\tJS.alertStr (Lang.i18nAlertIsClean());;\n \n  ListenersCFG.previousNewCFGListener :=\n    fun () -> let newCFG = (!Ctrl.ctrlL#getCFG)#getPreviousTransformed in\n              createCFGController2 newCFG.grammar true;\n              !Ctrl.ctrlL#box2CFGShow newCFG;;\n\n  ListenersCFG.nextNewCFGListener :=\n    fun () -> let newCFG = (!Ctrl.ctrlL#getCFG)#getNextTransformed in\n              createCFGController2 newCFG.grammar true;\n              !Ctrl.ctrlL#box2CFGShow newCFG;;\n\n  ListenersCFG.removeLeftRecursionListener :=\n    fun () -> let cfg = !Ctrl.ctrlL#getCFG in\n              if cfg#isLeftRecursive\n              then ( let newCfg = cfg#removeLeftRecursion1 in\n                createCFGController2 newCfg.grammar true;\n                !Ctrl.ctrlL#box2CFGShow newCfg)\n              else JS.alertStr (Lang.i18nAlertNotLeftRecursive());;\n    \n  ListenersCFG.leftFactoringListener :=\n    fun () -> let cfg = !Ctrl.ctrlL#getCFG in\n              if cfg#isLeftFactoring\n              then ( let newCfg = cfg#leftFactoring1 in\n                createCFGController2 newCfg.grammar true;\n                !Ctrl.ctrlL#box2CFGShow newCfg)\n              else JS.alertStr (Lang.i18nAlertNotLeftFactoring());;\n  \n  ListenersCFG.removeEpsilonListener :=\n    fun () -> let cfg = !Ctrl.ctrlL#getCFG in\n              if cfg#hasEmptyProductions\n              then ( let newCfg = cfg#removeEmptyProductions1 in\n                createCFGController2 newCfg.grammar true;\n                !Ctrl.ctrlL#box2CFGShow newCfg)\n              else JS.alertStr (Lang.i18nAlertNoEmptyProductions());;\n\n  ListenersCFG.removeUnitListener :=\n    fun () -> let cfg = !Ctrl.ctrlL#getCFG in\n              if cfg#hasUnitProductions\n              then ( let newCfg = cfg#removeUnitProductions1 in\n                createCFGController2 newCfg.grammar true;\n                !Ctrl.ctrlL#box2CFGShow newCfg)\n              else JS.alertStr (Lang.i18nAlertNoUnitProductions());;\n\n  ListenersCFG.transformLL1Listener :=\n    fun () -> let cfg = !Ctrl.ctrlL#getCFG in\n              if not cfg#isLL1\n              then ( let newCfg = cfg#transformToLL1X in\n                createCFGController2 newCfg.grammar true;\n                !Ctrl.ctrlL#box2CFGShow newCfg)\n              else JS.alertStr (Lang.i18nAlertIsLL1());;\n\n  ListenersCFG.tablesListener :=\n    fun () -> let cfg = !Ctrl.ctrlL#getCFG in\n              CtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n              HtmlPageClient.prepareCFG2Tables ();\n              cfg#createFirstAndFollowTableHtml;\n              cfg#createParsingTableHtml;;\n  \n  ListenersCFG.recursiveDescedentParserListener :=\n    fun () -> let cfg = !Ctrl.ctrlL#getCFG in\n              if not cfg#isLL1\n              then JS.alertStr (Lang.i18nIsNotLL1())\n              else  (\n                CtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n                let optsList = cfg#rdparserOpts in\n                HtmlPageClient.prepareCFG2RecursiveDescedentParser optsList (!Ctrl.ctrlL#getCFG#generateRecursiveDescendentParser));;\n\n\n  (*GR *)\n  ListenersGR.grOps :=\n    fun (op: string) -> !Ctrl.ctrlL#handleOp op; \n  ;;\n\n\n    \n\n  ListenersGR.createModelListener := fun () -> \n    try \n      let str = ViewUtil.extractStringFromTextArea() in\n      let grModel = grStr2Model str in\n      HtmlPageClient.hideModalWindow();\n      CtrlUtil.oneBox !Ctrl.ctrlL#getCy_opt;\n      HtmlPageClient.clearBox1();\n      createGRController2 grModel false;\n      !Ctrl.ctrlL#defineExample;\n      setTitle()\n    with\n      _ -> JS.alert (Lang.i18nErrorParsing());;\n\n                \nopen ContextFreeGrammarLL1View;;\n  \n  ListenersCFG.simpleToggleListener :=\n    fun () -> let cfg = !Ctrl.ctrlL#getCFG in\n              cfg#toggleSimplified;\n              let elem = Dom_html.getElementById_opt (ContextFreeGrammarLL1View.firstFollowTableId()) in\n              match elem with\n              | None -> ()\n              | Some e -> let otherE = Dom_html.getElementById (ContextFreeGrammarLL1View.parsingTableId()) in\n                          e##.innerHTML := Js.string \"\";\n                          otherE##.innerHTML := Js.string \"\";\n                          cfg#createFirstAndFollowTableHtml;\n                          cfg#createParsingTableHtml;;\n\n    \n    let createModelPrep titleTxt otherTxt textAreaString okAction =\n      let modelContent = HtmlPageClient.editModelContent titleTxt otherTxt textAreaString okAction in\n      HtmlPageClient.setModal (Js.Unsafe.coerce modelContent);\n      HtmlPageClient.showModalWindow ()\n  \n      \n    let createModel modelType ?(customString=\"\") () =\n      let getDefault default = if customString = \"\" then default else customString in\n      match modelType with\n      | \"FA\" -> !ListenersFA.createModelListener()\n      | \"PDA\" -> !ListenersPDA.createModelListener()\n      | \"TM\" -> !ListenersTM.createModelListener()\n      | \"RE\" -> createModelPrep (Lang.i18nMainTitle2()) \"\" (getDefault \"ab\") (fun () -> !ListenersRE.createModelListener())\n      | \"Comp\" -> createModelPrep (Lang.i18nMainTitleComp()) \"\" (getDefault \"[dfa_1]+[dfa_1]\") (fun () -> !ListenersComp.createModelListener())\n      | \"CFG\" -> createModelPrep (Lang.i18nMainTitle4()) (Lang.i18nInstructionsCFG()) (getDefault \"S -> [ S ] | A\\nA -> a\") (fun () -> !ListenersCFG.createModelListener())\n      | \"GR\" -> createModelPrep (Lang.i18nMainTitle5()) (Lang.i18nInstructionsGR()) (getDefault \"S -> aBC | aSBC\\nCB -> CZ\\nCZ -> WZ\\nWZ -> WC\\nWC -> BC\\naB -> ab\\nbB -> bb\\nbC -> bc\\ncC -> cc\") (fun () -> !ListenersGR.createModelListener())\n      | _ -> ();;\n  \n    \n    Listeners.createModelListener :=\n      fun () -> \n        HtmlPageClient.putInnerHtml \"selectConv\" (Lang.i18nSelectConv ());\n        match Dom_html.getElementById_coerce \"selectNewModel\" Dom_html.CoerceTo.select with\n        | None -> ()\n        | Some select -> \n            let value = Js.to_string select##.value in\n            if value = \"optionNewAutomatonFA\" then createModel \"FA\" () else\n            if value = \"optionNewAutomatonPDA\" then createModel \"PDA\" () else\n            if value = \"optionNewRegularExpression\" then createModel \"RE\" () else\n            if value = \"optionNewContextFreeGrammar\" then createModel \"CFG\" () else\n            if value = \"optionNewGrammar\" then createModel \"GR\" () else\n            if value = \"optionNewTuringMachine\" then createModel \"TM\" () else\n            if value = \"optionNewComposition\" then createModel \"Comp\" ();\n            select##.selectedIndex := 0;;\n\n    ListenersAutomaton.editModelListener :=\n    fun () -> \n      JS.alert (Lang.i18nModelEditFA());\n      !Ctrl.ctrlL#changeToEditModelMode;;\n  \n    ListenersRE.editModelListener :=\n      fun () -> createModel \"RE\" ~customString:(!Ctrl.ctrlL#model2Str) ();;  \n  \n    ListenersCFG.editModelListener :=\n      fun () -> createModel \"CFG\" ~customString:(!Ctrl.ctrlL#model2Str) ();;\n  \n    ListenersGR.editModelListener :=\n      fun () -> createModel \"GR\" ~customString:(!Ctrl.ctrlL#model2Str) ();;\n\n    Listeners.editModelListener :=\n      fun () -> \n        HtmlPageClient.putInnerHtml \"selectConv\" (Lang.i18nSelectConv ());\n        let model = !Ctrl.ctrlL#returnType in\n        if model = RegularExpression.kind then\n            createModel \"RE\" ~customString:(!Ctrl.ctrlL#model2Str) ()\n        else if model = ContextFreeGrammar.kind then\n            createModel \"CFG\" ~customString:(!Ctrl.ctrlL#model2Str) ()\n        else if model = Grammar.kind then\n            createModel \"GR\" ~customString:(!Ctrl.ctrlL#model2Str) ()\n        else if model = FiniteAutomaton.kind then\n            JS.alert (Lang.i18nModelEditFA())\n        else if model = PushdownAutomaton.kind then\n            JS.alert (Lang.i18nModelEditFA())\n        else if model = TuringMachine.kind then\n            JS.alert (Lang.i18nModelEditFA())\n        else ();\n        match Dom_html.getElementById_coerce \"selectNewModel\" Dom_html.CoerceTo.select with\n        | None -> ()\n        | Some select -> select##.selectedIndex := 0;;\n\n(*\n  let createComp () =\n    createModelPrepComp \"[dfa_1]+[dfa_1]\" (fun () -> !ListenersComp.createModelListener())\n\n  let createCFG () =\n    createModelPrepCFG \"S -> [ S ] | A\\nA -> a\" (fun () -> !ListenersCFG.createModelListener())\n\n  let createTM () =\n    !ListenersTM.createModelListener()\n  \n  let extractStringFromTextArea () =\n    match Dom_html.getElementById_coerce \"modelStringContainer\" Dom_html.CoerceTo.textarea with\n              | None -> \"\"\n              | Some textarea -> Js.to_string textarea##.value;;\n\n  Listeners.createModelListener :=\n    fun () -> match Dom_html.getElementById_coerce \"selectNewModel\" Dom_html.CoerceTo.select with\n              | None -> ()\n              | Some select -> let value = Js.to_string select##.value in\n                                if value = \"optionNewAutomatonFA\" then createFA () else\n                                if value = \"optionNewAutomatonPDA\" then createPDA () else\n                                if value = \"optionNewRegularExpression\" then createRE () else\n                                if value = \"optionNewContextFreeGrammar\" then createCFG ();\n                                if value = \"optionNewTuringMachine\" then createTM ();\n                                if value = \"optionNewComposition\" then createComp ();\n                               select##.selectedIndex := 0;;\n\n  let cfgStr2Model str = (*TODO Where to put this?*)\n    let open ContextFreeGrammarBasic in\n    let splitStr = String.split_on_char '\\n' str in\n    let initialRule = Set.make [List.hd splitStr] in\n    let otherRules = Set.make (List.tl splitStr) in\n    let initialParsedRule = ContextFreeGrammarBasic.parse initialRule in\n    let initial = (Set.nth initialParsedRule 0).head in\n    let parsedRules = ContextFreeGrammarBasic.parse (Set.union initialRule otherRules) in\n    let variables = Set.add initial (Set.map (fun {head = h; _} -> h) parsedRules) in\n    let alphabet = Set.flatMap (fun {head = h; body = b} -> Set.make (List.filter (fun s -> not (Set.belongs s variables)) b) ) parsedRules in\n    new ContextFreeGrammarBasic.model (Arg.Representation {\n      alphabet = alphabet;\n      variables = variables;\n      initial = initial;\n      rules = parsedRules\n    } );;\n\n  let grammar2Str (rep:ContextFreeGrammarView.t) = (*TODO Where to put this?*)\n    let open ContextFreeGrammarBasic in\n    let initialRules = Set.filter (fun {head = h; _} -> h = rep.initial) rep.rules in\n    let nonInitialRules = Set.filter (fun {head = h; _} -> h <> rep.initial) rep.rules in\n    let initialRulesStrLst = ContextFreeGrammarBasic.toStringList initialRules in\n    let nonInitialRulesStrLst = ContextFreeGrammarBasic.toStringList nonInitialRules in\n    let rulesList = initialRulesStrLst @ nonInitialRulesStrLst in\n    let rec toString l =\n      match l with\n      | [] -> \"\"\n      | x::xs -> x ^ \"\\n\" ^ (toString xs)\n    in\n      toString rulesList;;\n*)\n  ListenersFA.createModelListener := fun () -> \n    let defaultFA = new FiniteAutomatonView.model (Representation {\n      alphabet = Set.empty;\n      states = Set.make [\"START\"]; \n      initialState = \"START\";\n      transitions = Set.empty;\n      acceptStates = Set.empty\n    }) in\n      CtrlUtil.oneBox !Ctrl.ctrlL#getCy_opt;\n      HtmlPageClient.clearBox1();\n      createFAController defaultFA false;\n      !Ctrl.ctrlL#defineExample;\n      setTitle();;\n\n  ListenersPDA.createModelListener := fun () -> \n    let defaultPDA = new PushdownAutomatonView.model (Representation {\n        inputAlphabet = Set.empty;\n        stackAlphabet = Set.make [PushdownAutomaton.stackSpecialSymb];\n        states = Set.make [\"START\"];\n        initialState = \"START\";\n        initialStackSymbol = PushdownAutomaton.stackSpecialSymb;\n        transitions = Set.empty;\n        acceptStates = Set.empty;\n        criteria = true\n    }) in\n      CtrlUtil.oneBox !Ctrl.ctrlL#getCy_opt;\n      HtmlPageClient.clearBox1();\n      createPDAController defaultPDA false;\n      !Ctrl.ctrlL#defineExample;\n      setTitle();;\n\n    ListenersTM.createModelListener := fun () -> \n       let defaultTM =\n\t\tnew TuringMachineView.model (\n\t\t\tRepresentation\n\t\t\t\t{ TuringMachine.tm_zero with\n\t\t\t\t\tstates = Set.make [\"START\"];\n\t\t\t\t\tinitialState = \"START\"; }\n\t\t) in\n  \n      CtrlUtil.oneBox !Ctrl.ctrlL#getCy_opt;\n      HtmlPageClient.clearBox1();\n      createTMController defaultTM false;\n      !Ctrl.ctrlL#defineExample;\n      setTitle();;\n  \n  ListenersRE.createModelListener := fun () ->\n    try\n      let str = ViewUtil.extractStringFromTextArea() in\n      let reStr = new RegularExpressionView.model (Representation (RegularExpression.parse str)) in\n      HtmlPageClient.hideModalWindow();\n      CtrlUtil.oneBox !Ctrl.ctrlL#getCy_opt;\n      HtmlPageClient.clearBox1();\n      createREController reStr false;\n      !Ctrl.ctrlL#defineExample;\n      setTitle()\n    with\n      _ -> JS.alert (Lang.i18nErrorParsing());;\n\n(* carolina *)\n  ListenersComp.createModelListener := fun () ->\n    try\n      let str = ViewUtil.extractStringFromTextArea() in\n      let compStr = new CompositionView.model (Representation (Composition.parse str)) in\n     HtmlPageClient.hideModalWindow();\n      CtrlUtil.oneBox !Ctrl.ctrlL#getCy_opt;\n      HtmlPageClient.clearBox1();\n      createCompController compStr false;\n     !Ctrl.ctrlL#defineExample;\n     setTitle()\n    with\n      _ -> JS.alert (Lang.i18nErrorParsing());;\n  \n\n  ListenersCFG.createModelListener := fun () -> \n    try \n      let str = ViewUtil.extractStringFromTextArea() in\n      let cfgModel = cfgStr2Model str in\n      HtmlPageClient.hideModalWindow();\n      CtrlUtil.oneBox !Ctrl.ctrlL#getCy_opt;\n      HtmlPageClient.clearBox1();\n      createCFGController2 cfgModel false;\n      !Ctrl.ctrlL#defineExample;\n      setTitle()\n    with\n      _ -> JS.alert (Lang.i18nErrorParsing());;\n(*\n  Listeners.editModelListener :=\n    fun () -> !Ctrl.ctrlL#editModel;;\n\n  ListenersAutomaton.editModelListener :=\n    fun () -> \n      JS.alert (Lang.i18nModelEditFA());\n      !Ctrl.ctrlL#changeToEditModelMode;;\n*)\n(* carolina *)\n  Listeners.save :=\n  fun () ->     \n  let open Js.Unsafe in\n  let open Repository in\n  let createModelPrep titleTxt otherTxt textAreaString okAction =\n    let modelContent = HtmlPageClient.editModelContent titleTxt otherTxt textAreaString okAction in\n    HtmlPageClient.setModal (Js.Unsafe.coerce modelContent);\n    HtmlPageClient.showModalWindow () in\n\n(* carolina *)\n  let createModelPrepSave textAreaString okAction =\n    createModelPrep (Lang.i18nSaveText()) \"\" textAreaString okAction in\n\n  \n(* carolina *)\n  createModelPrepSave (\"Example\") (fun () -> !Listeners.saveModel() );; (*carolina*)\n    (*Ctrl.ctrlL#getModel*)  \n    \n(* carolina *)\n  Listeners.saveModel :=\n    fun () ->\n      let str = ViewUtil.extractStringFromTextArea() in\n      (let m = !Ctrl.ctrlL#model in\n      (*JS.alertStr str;*)\n      JS.log (m));\n      Repository.updateModel str !Ctrl.ctrlL#model;\n      HtmlPageClient.hideModalWindow();\n      HtmlPageClient.putButton2 str;;\n\n\n\n\n  ListenersPDA.toggleAcceptanceCriteria :=\n    fun () ->\n      !Ctrl.ctrlL#toggleAcceptanceCriteria;;\n\n  ListenersPDA.changeInitialStackSymbol :=\n    fun () ->\n      !Ctrl.ctrlL#changeInitialStackSymbol;;\n\n  let showPdaCtrlR pda =\n    CtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n    createPDAController pda true;\n    !Ctrl.ctrlR#defineExample2;\n    Cytoscape.fit !Ctrl.ctrlR#getCy_opt;;\n\n  ListenersPDA.convertAcceptStates :=\n    fun () ->\n      (match !Ctrl.ctrlL#convertAcceptStates with\n      | None -> JS.alertStr (Lang.i18nAlreadyInAcceptanceModeByStates ())\n      | Some pdaConverted -> showPdaCtrlR pdaConverted);;\n          \n  ListenersPDA.convertEmptyStackAccept :=\n    fun () ->\n      (match !Ctrl.ctrlL#convertEmptyStackAccept with\n      | None -> JS.alertStr (Lang.i18nAlreadyInAcceptanceModeByEmptyStack ())\n      | Some pdaConverted -> showPdaCtrlR pdaConverted);;\n(*\n  ListenersRE.editModelListener :=\n    fun () -> createModelPrepRE (RegularExpression.toString !Ctrl.ctrlL#getRE#representation) (fun () -> !ListenersRE.createModelListener());;\n  \n  ListenersCFG.editModelListener :=\n    fun () -> createModelPrepCFG (grammar2Str !Ctrl.ctrlL#getCFG#representation) (fun () -> !ListenersCFG.createModelListener());;\n    *)\n  ListenersAutomaton.clearAutoListener :=\n    fun () -> Cytoscape.resetStyle !Ctrl.ctrlL#getCy Cytoscape.faStyle;;\n    \n  Listeners.updateRightListener :=\n    fun () -> !Ctrl.ctrlL#updateRight\n;;\n\n\n    ListenersLR.buildLR0DiagramListener :=\n\t\tfun () -> try\n\t\t\t\t\tCtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n\t\t\t\t\tlet cfg = !Ctrl.ctrlL#getCFG in\n\t\t\t\t\t\t\t\n\t\t\t\t\t!CtrlUtil.changeToControllerCtrlRight();\n\t\t\t\t\tlet cy = !Ctrl.ctrlR#getCy in\n\n\t\t\t\t\t\n\t\t\t\t\tHtmlPageClient.defineCFG();\n\t\t\t\t\tHtmlPageClient.cfgBoxRegex();\n\t\t\t\t\t(* HtmlPageClient.cfgCyClose(); *)\n\t\t\t\t\tcfg#buildCyLR0Diagram cy;\t \n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tcy##resize; \n\t\t\t\t\tcy##fit;\n\t\t\t\t\t\n\t\t\t\twith\n                  _ -> JS.alert (Lang.i18nErrorParsing());;\n\t\t\n\tListenersLR.buildSLR1DiagramListener :=\n\t\tfun () -> try\n\t\t\t\t\tCtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n\t\t\t\t\tlet cfg = !Ctrl.ctrlL#getCFG in\n\t\t\t\t\t\n\t\t\t\t\t!CtrlUtil.changeToControllerCtrlRight();\n\t\t\t\t\tlet cy = !Ctrl.ctrlR#getCy in\n\n\t\t\t\t\t\n\t\t\t\t\tHtmlPageClient.defineCFG();\n\t\t\t\t\tHtmlPageClient.cfgBoxRegex();\n\t\t\t\t\t(* HtmlPageClient.cfgCyClose(); *)\n\t\t\t\t\tcfg#buildCySLR1Diagram cy;\t \n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tcy##resize; \n\t\t\t\t\tcy##fit;\n\n\t\t\t\twith\n                  _ -> JS.alert (Lang.i18nErrorParsing());;\n\t\t\n\tListenersLR.buildLR1DiagramListener :=\n\t\tfun () -> try\n\t\t\t\t\tCtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n\t\t\t\t\tlet cfg = !Ctrl.ctrlL#getCFG in\n\t\t\t\n\t\t\t\t\t!CtrlUtil.changeToControllerCtrlRight();\n\t\t\t\t\tlet cy = !Ctrl.ctrlR#getCy in\n\t\t\t\t\t\n\t\t\t\t\tHtmlPageClient.defineCFG();\n\t\t\t\t\tHtmlPageClient.cfgBoxRegex();\n\t\t\t\t\t(* HtmlPageClient.cfgCyClose(); *)\n\t\t\t\t\tcfg#buildCyLR1Diagram cy;\t \n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tcy##resize; \n\t\t\t\t\tcy##fit;\n\t\t\t\t\t\n\t\t\t\twith\n                  _ -> JS.alert (Lang.i18nErrorParsing());;\n\t\t\n\tListenersLR.buildLALR1DiagramListener :=\n\t\tfun () -> try\n\t\t\t\t\tCtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n\t\t\t\t\tlet cfg = !Ctrl.ctrlL#getCFG in\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t!CtrlUtil.changeToControllerCtrlRight();\n\t\t\t\t\tlet cy = !Ctrl.ctrlR#getCy in\n\t\t\t\t\t\n\t\t\t\t\tHtmlPageClient.defineCFG();\n\t\t\t\t\tHtmlPageClient.cfgBoxRegex();\n\t\t\t\t\t(* HtmlPageClient.cfgCyClose(); *)\n\t\t\t\t\tcfg#buildCyLALR1Diagram cy;\t \n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tcy##resize; \n\t\t\t\t\tcy##fit;\n\n\t\t\t\twith\n                  _ -> JS.alert (Lang.i18nErrorParsing());;\n\t\t\n\t ListenersLR.buildLR0TableListener :=\n\t\tfun () ->   \n\t\t\t\tlet cfg = !Ctrl.ctrlL#getCFG in\n                CtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n                HtmlPageClient.prepareCFG2Tables ();\n                cfg#createFirstAndFollowTableHtml;\n                cfg#createLR0ParsingTableHtml;; \n\t\t\n\tListenersLR.buildSLR1TableListener :=\n\t\tfun () -> let cfg = !Ctrl.ctrlL#getCFG in\n                CtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n                HtmlPageClient.prepareCFG2Tables ();\n                cfg#createFirstAndFollowTableHtml;\n                cfg#createSLR1ParsingTableHtml;;    \n\t\t\n\tListenersLR.buildLR1TableListener :=\n\t\tfun () -> let cfg = !Ctrl.ctrlL#getCFG in\n                CtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n                HtmlPageClient.prepareCFG2Tables ();\n                cfg#createFirstAndFollowTableHtml;\n                cfg#createLR1ParsingTableHtml;;    \n\t\t\n\tListenersLR.buildLALR1TableListener :=\n\t\tfun () -> let cfg = !Ctrl.ctrlL#getCFG in\n                CtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n                HtmlPageClient.prepareCFG2Tables ();\n                cfg#createFirstAndFollowTableHtml;\n                cfg#createLALR1ParsingTableHtml;;  \n                \n    ListenersLR.acceptLR0Listener :=\n\t\tfun () -> let text = JS.prompt (Lang.i18nPromptTextTestWord ()) \"ababab$\" in \n                \n                 match Js.Opt.to_option text with\n                | None -> ()\n\t\t\t\t| Some v -> let cfg = !Ctrl.ctrlL#getCFG in\n\t\t\t\t\t\t\tCtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n\t\t\t\t\t\t\tHtmlPageClient.prepareAcceptTable ();\n\t\t\t\t\t\t\tcfg#createLR0AcceptTableHtmlV2 (Js.to_string v);;\n\t\t\t\t\n\t\t\t\t\n\tListenersLR.acceptSLR1Listener :=\n\t\tfun () -> let text = JS.prompt (Lang.i18nPromptTextTestWord ()) \"azc$\" in \n                match Js.Opt.to_option text with\n                | None -> ()\n\t\t\t\t| Some v -> let cfg = !Ctrl.ctrlL#getCFG in\n\t\t\t\t\t\t\tCtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n\t\t\t\t\t\t\tHtmlPageClient.prepareAcceptTable ();\n\t\t\t\t\t\t\tcfg#createSLR1AcceptTableHtmlV2 (Js.to_string v);;\n\t\t\t\t\n\tListenersLR.acceptLR1Listener :=\n\t\tfun () -> let text = JS.prompt (Lang.i18nPromptTextTestWord ()) \"azc$\" in \n                 match Js.Opt.to_option text with\n                | None -> ()\n\t\t\t\t| Some v -> let cfg = !Ctrl.ctrlL#getCFG in\n\t\t\t\t\t\t\tCtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n\t\t\t\t\t\t\tHtmlPageClient.prepareAcceptTable ();\n\t\t\t\t\t\t\tcfg#createLR1AcceptTableHtmlV2 (Js.to_string v);;\n\t\t\t\t\n\tListenersLR.acceptLALR1Listener :=\n\t\tfun () -> let text = JS.prompt (Lang.i18nPromptTextTestWord ()) \"cccccccdcccccccccd$\" in \n                 match Js.Opt.to_option text with\n                | None -> ()\n\t\t\t\t| Some v -> let cfg = !Ctrl.ctrlL#getCFG in\n\t\t\t\t\t\t\tCtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n\t\t\t\t\t\t\tHtmlPageClient.prepareAcceptTable ();\n\t\t\t\t\t\t\tcfg#createLALR1AcceptTableHtmlV2 (Js.to_string v);;\n\t\t\t\t\n\n  ListenersComp.showTreeNode := (*carolina*)\n      fun (label) -> (\n      let open Examples in\n      let open Error in\n      let open Repository in\n      let j = getJSon label in\n        let kind = JSon.fieldString j \"kind\" in\n        CtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n        (*HtmlPageClient.twoBoxes();\n        JS.alert j;*)\n        (match kind with\n        | k when k = FiniteAutomaton.kind -> \n              HtmlPageClient.clearBox2 ();\n              let fa = new FiniteAutomatonView.model (JSon j) in\n              createFAController fa true;\n(*JS.alertStr \"XX\";  FAZ DUAS VEZES AMD *)\n              !Ctrl.ctrlR#defineExample2;\n(*JS.alertStr \"YY\"; *)\n              Cytoscape.fit !Ctrl.ctrlR#getCy_opt\n        | k when k = RegularExpression.kind -> \n              HtmlPageClient.clearBox2 ();\n              let re = new RegularExpressionView.model (JSon j) in \n              createREController re true;\n              !Ctrl.ctrlR#defineExample2;\n              Cytoscape.fit !Ctrl.ctrlR#getCy_opt\n        | k when k = PushdownAutomaton.kind -> \n              HtmlPageClient.clearBox2 ();\n              let pda = new PushdownAutomatonView.model (JSon j) in \n              createPDAController pda true;\n              !Ctrl.ctrlR#defineExample2;\n              Cytoscape.fit !Ctrl.ctrlR#getCy_opt\n        | k when k = ContextFreeGrammar.kind ->\n              HtmlPageClient.clearBox2 ();\n              let cfg = new ContextFreeGrammarView.model (JSon j) in\n              createCFGController cfg true;\n              !Ctrl.ctrlR#defineExample2;\n              Cytoscape.fit !Ctrl.ctrlR#getCy_opt\n\n        | k when k = Grammar.kind ->\n              HtmlPageClient.clearBox2 ();\n              let gr = new GrammarView.model (JSon j) in\n              createGRController gr true;\n              !Ctrl.ctrlR#defineExample;\n              Cytoscape.fit !Ctrl.ctrlR#getCy_opt\n\n        | k when k = TuringMachine.kind ->\n              HtmlPageClient.clearBox2 ();\n              let tm = new TuringMachineView.model (JSon j) in\n              createTMController tm true;\n              !Ctrl.ctrlR#defineExample2;\n              Cytoscape.fit !Ctrl.ctrlR#getCy_opt\n        | k when k = Composition.kind ->\n              HtmlPageClient.clearBox2 ();\n              let comp = new CompositionView.model (JSon j) in\n              createCompController comp true;\n              !Ctrl.ctrlR#defineExample2;\n              Cytoscape.fit !Ctrl.ctrlR#getCy_opt        \n        | _ -> Error.fatal \"showTreeNode\");\n      )\n        (*setTitle();\n        !Ctrl.ctrlL#printErrors);;*)\n  \n   (*carolina*)\n    \n\t\t\n\n\n\n\n\nend\n","(*\n * Calling.ml\n *\n * This file is part of the OFLAT app\n *\n * LEAFS project (partially supported by the OCaml Software Foundation) [2020/21]\n * FACTOR project (partially supported by the Tezos Foundation) [2019/20]\n *\n * NOVA LINCS - NOVA Laboratory for Computer Science and Informatics\n * Dept. de Informatica, FCT, Universidade Nova de Lisboa.\n *\n * This software is distributed under the terms of the GPLv3 license.\n * See the included LICENSE file for details.\n *\n *  Written by Rita Macedo\n *)\n\n(* Description: This a component of the controller that is used for the\n * JavaScript to call OCaml functions in the Controller.\n *)\n\nopen OCamlFlat\nopen BasicTypes\nopen Js_of_ocaml\nopen ViewUtil\nopen Controller\nopen HtmlPageClient\nopen Lang\nopen Listeners\nopen RegularExpressionView\nopen JS\nopen FiniteAutomatonView\nopen ContextFreeGrammarView\nopen Lang\nopen ControllerListeners\n\nmodule ExamplesView =\nstruct\n\tlet examplesDiv () =\n\t\tDom_html.getElementById \"examplesServer\"\n\t\n\tlet createDivForTitle i title = \n\t\tlet titleDiv = HtmlPageClient.div (\"title\" ^ string_of_int i) in\n\t\ttitleDiv##.innerHTML := Js.string title;\n\t\ttitleDiv##.style##.cssText := Js.string \"color: white; font-size: 11px; font-weight: bold; padding-left: 20px\";\n\t\tDom.appendChild (examplesDiv ()) titleDiv |> ignore\n\n\tlet createDivForButtons i examples = \n\t\tlet buttonsDiv = HtmlPageClient.div (\"button\" ^ string_of_int i) in\n\t\tbuttonsDiv##.style##.cssText := Js.string \"padding-top: 2px; padding-bottom: 20px;\";\n\t\tList.iter (fun (name, model) -> \n\t\t\tlet button = HtmlPageClient.createServerExampleButton name in\n\t\t\tDom.appendChild buttonsDiv button |> ignore; \n\t\t) examples;\n\t\tDom.appendChild (examplesDiv ()) buttonsDiv |> ignore\n\t\n\tlet handleKind i (title, examples) =\n\t\tcreateDivForTitle i title;\n\t\tcreateDivForButtons i examples\n\n\tlet examplesView () =\n\t\tList.iteri handleKind Examples.examplesTable\nend\n\nmodule JSCallingOCaml =\nstruct\n\n\tlet errorViewer mesg =\n\t\tJS.alertStr mesg\n\n\tlet start () =\n\t\tError.setViewer errorViewer;\n\t\tif (!Lang.lang <> \"en\" && !Lang.lang <> \"pt\" && !Lang.lang <> \"fr\") then\n\t\t\tLang.lang := \"en\";\n\t\tHtmlPageClient.changeLang();\n\t\tExamplesView.examplesView ()\n\t;;\n(*\n\t\tlet start _ =\n\t\t\tError.setViewer errorViewer;\n\t\t\tif (!Lang.lang <> \"en\" && !Lang.lang <> \"pt\" && !Lang.lang <> \"fr\") then\n\t\t\t\tLang.lang := \"en\";\n\t\t\tHtmlPageClient.changeLang();\n\t\t\t\n\t\t\tlet examples = Dom_html.getElementById \"examplesServer\" in\n\t\t\t(* examples##.innerHTML := Js.string \"\"; *)\n\t\t\tlet lis = Examples.examplesTable in\n\t\t\tlet titles = [| \"Finite Automaton\"; \"Regular Expressions\";\n\t\t\t\t\t\t\t\t\t\t\t\"Context Free Grammars\"; \"Pushdown Automaton\";\n\t\t\t\t\t\t\t\t\t\t\t\"Turing Machine\"; \"Composition\";\n\t\t(* PEDRO CARLOS  VER! *)\t\t\t\t\t\t\t\t\"Grammars\"; \"Exercises\" |] in\n\t\t\tList.iteri (fun i el ->\n\t\t\t\t(* Create a div for the title *)\n\t\t\t\tlet titleDiv = HtmlPageClient.div (\"title\" ^ string_of_int i) in\n\t\t\t\ttitleDiv##.innerHTML := Js.string titles.(i);\n\t\t\t\ttitleDiv##.style##.cssText := Js.string \"color: white; font-size: 11px; font-weight: bold; padding-left: 20px\";\n\t\t\t\tDom.appendChild examples titleDiv |> ignore; \n\t\t\n\t\t\t\t(* Create a div for the buttons in this category *)\n\t\t\t\tlet buttonsDiv = HtmlPageClient.div (\"button\" ^ string_of_int i) in\n\t\t\t\tbuttonsDiv##.style##.cssText := Js.string \"padding-top: 2px; padding-bottom: 20px;\";\n\t\t\t\tList.iter (fun ex -> \n\t\t\t\t\tlet button = HtmlPageClient.createServerExampleButton (fst ex) in\n\t\t\t\t\tDom.appendChild buttonsDiv button |> ignore; \n\t\t\t\t) el;\n\t\t\t\tDom.appendChild examples buttonsDiv |> ignore; \n\t\t\t) lis;\n\t\t\t()\n\t\t;;\n*)\n\n\tJs.Unsafe.global##.jscode :=\n\t\tobject%js\n\t\t\n\t\t  method newModel =\n\t\t\t!Listeners.createModelListener()\n\t\t  \n\t\t  method editModel =\n\t\t\t!Listeners.editModelListener()\n\t\t\t\t\t  \t(* !Ctrl.ctrlL#editModel *)\n\n\t\t\t\n\t\t  method getModel =\n\t\t\tlet automaton = !Ctrl.ctrlL#getModel in\n\t\t\tViewUtil.bcSend automaton\n\n\t\t  method fitGraph =\n\t\t\tCytoscape.fit !Ctrl.ctrlL#getCy_opt\n\t\t  \n\t\t  method generateWords =\n\t\t\tlet text = JS.prompt (i18nTextMaximumSize ()) \"4\" in \n\t\t\tCtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n\t\t\t!CtrlUtil.changeToControllerCtrlRight();\n\t\t\tmatch Js.Opt.to_option text with\n\t\t\t| None -> ()\n\t\t\t| Some v -> \n\t\t\t\tlet size = int_of_string (Js.to_string v) in \n\t\t\t\t  !Ctrl.ctrlL#getWords size\n\n              method auto =\n                !Ctrl.ctrlL#autoAccept\n\t\t  \n\t\t  method test =\n\t\t\tCtrlUtil.oneBox !Ctrl.ctrlL#getCy_opt;\n\t\t\tlet text = JS.prompt (Lang.i18nPromptTextTestWord ()) \"ab\" in \n\t\t\tmatch Js.Opt.to_option text with\n                | None -> ()\n                | Some v -> !Ctrl.ctrlL#checkWord (Js.to_string v)\n\n              method trace =\n                CtrlUtil.twoBoxes !Ctrl.ctrlL#getCy_opt;\n                let text = JS.prompt (Lang.i18nPromptTextTestWord ()) \"ab\" in \n                match Js.Opt.to_option text with\n                | None -> ()\n                | Some v -> !Ctrl.ctrlL#showTrace (Js.to_string v)\n\t\t\t\n\t\t  method stepbystep =\n\t\t\tlet text = JS.prompt (Lang.i18nPromptTextTestWord ()) \"ab\" in \n\t\t\tmatch Js.Opt.to_option text with\n\t\t\t| None -> JS.log \"No input provided\"\n\t\t\t| Some v -> \n\t\t\t\t\tJS.log (\"Input provided: \" ^ (Js.to_string v));\n\t\t\t\t\t!Ctrl.ctrlL#startStep (Js.to_string v)\n\n\t\t  method backwards =\n\t\t\tJS.log \"backwards\";\n\t\t\t!Ctrl.ctrlL#backStep\n\t\t  \n\t\t  method forward =\n\t\t\tJS.log \"forward\";\n\t\t\t!Ctrl.ctrlL#nextStep\n\n\t\t  method selectConversions n =\n\t\t\tControllerListeners.conversionTo n\n\n\t\t  method readFromFile n =\n\t\t\tlet str = Js.to_string n in \n\t\t\t!Listeners.openEntityListener str\n\n\t\t  method exportToFile =\n\t\t\tlet json = JSon.toString ((!Ctrl.ctrlL#model)#toJSon) in\n\t\t\tlet json = Js.to_string ((Js.encodeURIComponent (Js.string json))) in\n\t\t\tlet element = Dom_html.document##createElement (Js.string \"a\") in\n\t\t\tlet modelName = \n\t\t\t  begin match !Ctrl.ctrlL#model#id.name with\n\t\t\t  | \"_\" | \"\" -> \"oflatModel\"\n\t\t\t  | a -> a\n\t\t\t  end ^ \".json\"\n\t\t\tin\n\t\t\telement##setAttribute (Js.string \"href\") (Js.string (\"data:application/json,\" ^ json));\n\t\t\telement##setAttribute (Js.string \"download\") (Js.string modelName);\n\t\t\telement##.style##.display := Js.string \"none\";\n\t\t\tlet node = Dom_html.document##.body##appendChild (Js.Unsafe.coerce element) in\n\t\t\telement##click;\n\t\t\tDom_html.document##.body##removeChild node\n\n\t\t  method feedback =\n\t\t\tHtmlPageClient.clearBox1 ();\n\t\t\t!CtrlUtil.changeToControllerCtrlLeft();\n\t\t\t!Ctrl.ctrlL#feedback\n\t\t  \n\t\t  method about  =\n\t\t\tHtmlPageClient.clearBox1 ();\n\t\t\t!CtrlUtil.changeToControllerCtrlLeft();\n\t\t\t!Ctrl.ctrlL#about\n\n              method settings =\n              HtmlPageClient.settings()\n\n              method tooltipSettings =\n                let textBox = Dom_html.getElementById \"tooltipSettings\" in\n                textBox##.innerHTML := Js.string \"Change Settings\" (*TODO: LANG*)\n\n\t\t  method tooltipNewModel =\n\t\t\tlet textBox = Dom_html.getElementById \"tooltipNewModel\" in\n\t\t\ttextBox##.innerHTML := Js.string (Lang.i18nTooltipNewModel ())\n\n\t\t  method tooltipEditModel =\n\t\t\tlet textBox = Dom_html.getElementById \"tooltipEditModel\" in\n\t\t\ttextBox##.innerHTML := Js.string (Lang.i18nTooltipEditModel ())\n\t\t  \n\t\t  method tooltipFitGraph =\n\t\t\tlet textBox = Dom_html.getElementById \"tooltipFitGraph\" in\n\t\t\ttextBox##.innerHTML := Js.string (Lang.i18nTooltipFitGraph ())\n\n\t\t  method tooltipGenerate =\n\t\t\tlet textBox = Dom_html.getElementById \"tooltipGenerate\" in\n\t\t\ttextBox##.innerHTML := Js.string (Lang.i18nTooltipGenerate ())\n\t\t  \n\t\t  method tooltipTest =\n\t\t\tlet textBox = Dom_html.getElementById \"tooltipTest\" in\n\t\t\ttextBox##.innerHTML := Js.string (Lang.i18nTooltipTest ())\n\n              method tooltipTrace =\n                let textBox = Dom_html.getElementById \"tooltipTrace\" in\n                textBox##.innerHTML := Js.string (\"Show Acceptance Path\")\n\t\t  \n\t\t  method tooltipStep =\n\t\t\tlet textBox = Dom_html.getElementById \"tooltipStep\" in\n\t\t\ttextBox##.innerHTML := Js.string (Lang.i18nTooltipStep ())\n\n\t\t  method tooltipClear =\n\t\t\tlet textBox = Dom_html.getElementById \"tooltipClear\" in\n\t\t\ttextBox##.innerHTML := Js.string (Lang.i18nTooltipClear ())\n\n\t\t  method tooltipConvert = \n\t\t\tlet textBox = Dom_html.getElementById \"tooltipConvert\" in\n\t\t\ttextBox##.innerHTML := Js.string (Lang.i18nTooltipConvert ())\n\n\t\t  method tooltipFile = \n\t\t\tlet textBox = Dom_html.getElementById \"tooltipFile\" in\n\t\t\ttextBox##.innerHTML := Js.string (Lang.i18nTooltipFile ())\n\t\t\t\n\t\t  method tooltipExportModel =\n\t\t\tlet textBox = Dom_html.getElementById \"tooltipExportModel\" in\n\t\t\ttextBox##.innerHTML := Js.string (Lang.i18nTooltipExportModel ())\n\n\t\t  method tooltipAbout =\n\t\t\tlet textBox = Dom_html.getElementById \"tooltipAbout\" in\n\t\t\ttextBox##.innerHTML := Js.string (Lang.i18nTooltipAbout ())\n\n\t\t  method tooltipFeedback =\n\t\t\tlet textBox = Dom_html.getElementById \"tooltipFeedback\" in\n\t\t\ttextBox##.innerHTML := Js.string (Lang.i18nTooltipFeedback ())\n\n\t\t  method start =\n\t\t\tstart ()\n\tend\nend\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Ensure that [at_exit] functions are called at the end of every program *)\n\nlet _ = do_at_exit()\n"],"names":["cst","cst_A_cabe_a_da_regra_da_prime","cst_Automate_Pile","cst_A_o","cst_L_en_t_te_de_la_r_gle_de_l","cst_M_quina_de_Turing","cst_Simbolo_Inv_lido","cst_kernelAdvanceItem_Este_cas","cst_type_rule_string_type_cont","cst_type_symbol","cst_type_symbol_s_type_variabl","cst_type_variable","cst_include_stdio_h_include_st","cst_s_s","cst_s_alphabet_s_variables_s_i","cst_let","cst_let_handleAnswer_Learnocam","cst_static_void","cst_type_state_string_type_fin","cst_type_symbol_s_type_state_s","cst_void","cst_LEAFs","cst_and","cst_e","cst_et","cst_kind_grammar_description_a","cst_9dbaea","cst_6f","cst_Li","cst_d","cst_i","cst_li","cst_ni","cst_s","cst_u","cst_amp","cst_gt","cst_lt","cst_or_STRING","cst_if","cst_Program_not_linked_with_g_","cst_char_t_if","cst_dummy_method","cst_11","cst_12","cst_21","cst_22","cst_3","cst_c","cst_characters","cst_SUCCESS","cst_0","cst_01","cst_0vh","cst_10","cst_110100","cst_2","cst_4","cst_40px","cst_40vh","cst_49_5","cst_5","cst_50","cst_60vh","cst_7px","cst_acceptStates","cst_initial","cst_initialState","cst_rules","cst_states","cst_transitions","cst_variables","cst_V","cst_V_s_s_s","cst_V_s_s","cst_br","cst_A","cst_A_0","cst_A_01","cst_A_1","cst_A_aXb","cst_A_ab","cst_A_z","cst_A_B","cst_A_BC","cst_A_a","cst_A_aBb","cst_A_b","cst_A_bBa","cst_About","cst_Ac","cst_Accept","cst_Accepted_word","cst_Aceite","cst_Action","cst_Assert_failure","cst_B","cst_B_z","cst_B_b","cst_Bad_neck","cst_Bascule_entre_les_modes_si","cst_Box1","cst_Box2","cst_C","cst_C_a","cst_C_aC","cst_C_c","cst_C_cC","cst_CFG","cst_Clean_grammar_test_1","cst_Clean_inaccessible_symbols","cst_Clean_unproductive_symbols","cst_Comp","cst_Composition","cst_Composition_with_invalid_r","cst_CompositionSyntax","cst_Conflict","cst_Conflito","cst_Context_Free_Grammars","cst_ContextFreeGrammarSyntax","cst_Current_State","cst_Current_Symbols","cst_D","cst_D_E","cst_D_d","cst_DarkBlue","cst_Did_not_accept_word","cst_Direct_recursion_test_1","cst_Direct_recursion_test_2","cst_Dissertation_test","cst_Division_by_zero","cst_E","cst_E_Da","cst_E_T","cst_E_aE","cst_Empty_production_removal_t","cst_End_of_file","cst_Enter_the_name_of_the_mode","cst_Epsilon_productions_remova","cst_Error","cst_Error_none_node_selected","cst_Example1_test","cst_Example2_test","cst_Example3_test","cst_Example4_test","cst_Example5_test","cst_Example6_test","cst_Exercice","cst_Exercise","cst_Exercises","cst_Expected_string","cst_Expected_symbol","cst_F","cst_F_E","cst_F_I","cst_FA","cst_Factor","cst_Fail","cst_Failure","cst_Fatal_error_exception","cst_Fatal_error_exception_s","cst_Feedback","cst_FeedbackDiv","cst_Finite_Automata","cst_FiniteAutomaton","cst_GR","cst_Grammar","cst_GrammarSyntax","cst_Grammars","cst_HOME","cst_I","cst_I_Ia","cst_I_Ib","cst_I_a","cst_I_b","cst_INRIA_Foundation","cst_Indirect_recursion_test_1","cst_Indirect_recursion_test_2","cst_Indirect_recursion_test_3","cst_Indirect_recursion_test_4","cst_Indirect_recursion_test_5","cst_Instructions","cst_Invalid_use_of_wildcard","cst_Invalid_argument","cst_JSon","cst_L","cst_L_d_N_d_W_s_T_s","cst_L_d_N_d_W_s_TNORMAL","cst_LR","cst_LR0","cst_LR1","cst_Left_factoring","cst_Left_factoring_test_1","cst_Left_factoring_test_2","cst_Left_factoring_test_3","cst_Left_factoring_test_4","cst_Left_factoring_test_5","cst_Left_factoring_test_6","cst_Lwt","cst_Lwt_s","cst_METI_OS_STEPS","cst_Machine_de_Turing","cst_Map_bal","cst_Match_failure","cst_Missing_field","cst_N","cst_NORMAL","cst_NOT","cst_NOVA_LINCS","cst_Non_deterministic_grammar_","cst_Not_found","cst_OFLAT","cst_Ongoing","cst_Out_of_memory","cst_PDA","cst_Palavra","cst_Palavra_Restante","cst_Path","cst_Pilha","cst_Pilha_Estados","cst_Pilha_Simbolos","cst_Premature_end_of_expressio","cst_Prods","cst_Production","cst_Pushdown_Automata","cst_PushdownAutomaton","cst_R","cst_RE","cst_Re_repn","cst_Regular_Expressions","cst_RegularExpression","cst_Rejeitada","cst_Remove_inaccessible_symbol","cst_Remove_left_recursion","cst_Remove_unproductive_symbol","cst_Right_parenthesis_expected","cst_Running_test_find_applied_","cst_S","cst_S_111111","cst_S_X","cst_S_A","cst_S_AB","cst_S_B","cst_S_a","cst_SA","cst_SLR1","cst_START","cst_STARTZ","cst_SUPER","cst_SXA","cst_SXAB","cst_Set_bal","cst_Settings","cst_Sf","cst_Shift","cst_Show_Table_View","cst_Si","cst_Sobre","cst_Some_accept_states_do_not_","cst_Some_transitions_are_inval","cst_Stack","cst_Stack_overflow","cst_Starting_nextConfigs_for","cst_Step","cst_Sys_blocked_io","cst_Sys_error","cst_T","cst_T_aSb","cst_T_F","cst_TB","cst_TM","cst_The_alphabet_contains_epsi","cst_The_head_of_the_rule_of_th","cst_The_initial_state_does_not","cst_The_initial_symbol_is_not_","cst_The_intersection_between_t","cst_The_variables_contain_epsi","cst_Title","cst_Trace","cst_Trail","cst_Transducer","cst_Turing_Machine","cst_Undefined_recursive_module","cst_Unit_production_removal_te","cst_Unit_productions_removal","cst_Valida","cst_Version_4_1","cst_WWW","cst_Word","cst_Word_To_Consume","cst_Word_To_Match","cst_X","cst_X_A","cst_X_XA","cst_X_aBd","cst_Z","cst_a","cst_n","cst_TNORMAL","cst_W","cst_none","cst_aa","cst_aaa","cst_aaabbbccc","cst_aabbcc","cst_aabcc","cst_ab","cst_abc","cst_about","cst_aboutBox","cst_aboutSubtitle","cst_aboutSubtitle2","cst_aboutText1","cst_aboutText10","cst_aboutText11","cst_aboutText12","cst_aboutText13","cst_aboutText14","cst_aboutText15","cst_aboutText16","cst_aboutText2","cst_aboutText4","cst_aboutText5","cst_aboutText6","cst_aboutText7","cst_aboutText8","cst_aboutText9","cst_accept","cst_accept_back","cst_accept_next","cst_accept_start","cst_accept1","cst_accept3","cst_acceptBreadthFirst","cst_acceptCFGLL1","cst_acceptFull","cst_acceptFullLB","cst_acceptLB","cst_acceptList","cst_acceptList2","cst_acceptTable","cst_acceptTime","cst_acceptWithTracing","cst_acceptXXX","cst_acceptZ","cst_accepted","cst_accepted_words","cst_accessible","cst_accessibleRewrite","cst_accessibleSymbols","cst_acdz","cst_activeProm","cst_add_Node","cst_add_final_node","cst_add_transition","cst_addAcceptState","cst_addFinalNode","cst_addFinalState","cst_addInitialNode","cst_addInitialState","cst_addNode","cst_addState","cst_addTransition","cst_alertError","cst_allRulesAccessible","cst_allRulesProductive","cst_allTrees","cst_alphabet","cst_areAllStatesUseful","cst_areuseful","cst_arrayVar","cst_auto","cst_autoAccept","cst_automata_is_deterministic","cst_automata_is_equivalent_to_","cst_automata_is_non_determinis","cst_automata_is_not_equivalent","cst_automataTable","cst_azc","cst_b","cst_back","cst_backStep","cst_backgroundClip","cst_backgroundColor","cst_backgroundImage","cst_backwards","cst_bb","cst_bbb","cst_bestPath","cst_bezier","cst_bgRuleColor","cst_bgRuleColorFail","cst_bgSymbolColor","cst_black","cst_blue","cst_borderColor","cst_borderOpacity","cst_borderStyle","cst_borderWidth","cst_bottom","cst_box2CFGShow","cst_box2GRShow","cst_buffer_ml","cst_build","cst_buildCyLALR1Diagram","cst_buildCyLR0Diagram","cst_buildCyLR1Diagram","cst_buildCySLR1Diagram","cst_buildPoppersConfigsCounter","cst_buildTable","cst_buildTree","cst_button","cst_buttonBox","cst_buttonBox1","cst_buttonInitialStackSymbol","cst_camlinternalFormat_ml","cst_canConnect","cst_cancelProm","cst_center","cst_cfg","cst_cfgAcceptTable","cst_cfgAcceptWord","cst_cfgFirstFollowTable","cst_cfgGrammar2","cst_cfgGuideTable","cst_cfgParsingTable","cst_cfgProductionsTable","cst_cfg_balanced","cst_changeAutomata","cst_changeCFG","cst_changeDirection","cst_changeGR","cst_changeInitialStackSymbol","cst_changeLayoutDir","cst_changeProm","cst_changeSentence","cst_changeStateFromFinal","cst_changeStateToFinal","cst_changeStateToInitial","cst_changeTab","cst_changeTheTestingSentence","cst_changeToEditMode","cst_changeToEditModelMode","cst_changeToFinal","cst_checkExercise","cst_checkExerciseFailures","cst_checkHelper","cst_checkProperty","cst_checkWord","cst_checkWord2","cst_childrenSelected","cst_clean","cst_clean1","cst_cleanUselessStates","cst_cleanUselessStates1","cst_cleanUselessStatesCy","cst_clearAuto","cst_clearCy","cst_clearExerciseAction","cst_click","cst_close","cst_closeRightAction","cst_closing","cst_color","cst_commands","cst_comp","cst_comp2PDAcomp","cst_composition","cst_configDisplay","cst_configMenu","cst_configsCounter","cst_content","cst_context_free_grammar","cst_contextFreeGrammar","cst_convert_to_CFG","cst_convert_to_FA","cst_convert_to_GR","cst_convert_to_PDA","cst_convert_to_RE","cst_convert_to_TM_dual_tape","cst_convert_to_TM_single_tape","cst_convertAcceptStates","cst_convertEmptyStackAccept","cst_convertToCFG","cst_convertToFA","cst_convertToGR","cst_convertToPDA","cst_convertToRegExp","cst_convertToStopCriteria","cst_convertToTM","cst_convertToTM_DualTape","cst_convertToTM_SingleTape","cst_copyClipboardBtn","cst_correct","cst_countRightTrees","cst_countTree","cst_create","cst_create_2","cst_create_example","cst_create_example2","cst_createFirstAndFollowTableH","cst_createFun","cst_createFunCalls","cst_createGrammarTableHtml","cst_createIf","cst_createIfConds","cst_createLALR1AcceptTableHtml","cst_createLALR1ParsingTableHtm","cst_createLR0AcceptTableHtml","cst_createLR0AcceptTableHtmlV2","cst_createLR0ParsingTableHtml","cst_createLR1AcceptTableHtmlV2","cst_createLR1ParsingTableHtml","cst_createParsingTable","cst_createParsingTableGuideHtm","cst_createParsingTableHtml","cst_createSLR1AcceptTableHtmlV","cst_createSLR1ParsingTableHtml","cst_createTransition","cst_crimson","cst_criteria","cst_currPos","cst_currentCharVar","cst_currentIndexVar","cst_currentProds","cst_currentRow","cst_curveStyle","cst_cy","cst_cy2","cst_cy3","cst_dagre","cst_data_label","cst_defineExample","cst_defineExample2","cst_defineInformationBox","cst_defineMinimize","cst_description","cst_destroyAllPoppers","cst_destroyPopperDivs","cst_deterministic","cst_dfa_astar","cst_disableBrowserGestures","cst_disabled","cst_display_config","cst_display_flex_flex_wrap_wra","cst_displayTrace","cst_dissectTransitionInput","cst_div","cst_double","cst_downgradeModelToFiniteAuto","cst_drawExample","cst_drawMinimize","cst_drawTree","cst_edge","cst_edgeParams","cst_edge_label","cst_editModel","cst_eliminate_node","cst_eliminateNode","cst_eliminateTransition","cst_else","cst_else_if","cst_empty","cst_en","cst_entryAlphabet","cst_enum","cst_enumVerify","cst_equality","cst_equivalencePartition","cst_erase_transition","cst_error","cst_errorFunction","cst_errors","cst_evalCFG","cst_evalFA","cst_evalGR","cst_evalPDA","cst_evalRE","cst_evalTM","cst_evtType","cst_exactResult","cst_example","cst_examplesServer","cst_exer_astar_fa","cst_exer_astar_re","cst_exer_balanced_cfg","cst_exercise","cst_exportModel","cst_exportToFile","cst_expressionTermination","cst_fa_abc","cst_false","cst_feedback","cst_feedbackText","cst_feedbackText1","cst_feedbackText2","cst_feedbackThankYou","cst_find_applied_rules","cst_finish","cst_finite_automaton","cst_finite_enumeration","cst_finiteAutomaton","cst_first","cst_first1","cst_fitGraph","cst_follow","cst_follow1","cst_fontFamily","cst_formatting","cst_forward","cst_fr","cst_functionArgsClose","cst_functionArgsOpen","cst_functionDeclarations","cst_generate","cst_generateRecursiveDescenden","cst_generateUntil","cst_generateWords","cst_get_RE","cst_getAcceptStates","cst_getAutomaton","cst_getBestPath","cst_getCFG","cst_getCharFun","cst_getCharFunction","cst_getColors","cst_getComp","cst_getConfigsPathBySymbolCons","cst_getCriteria","cst_getCurrConfigFromBestPath","cst_getCy","cst_getCy_opt","cst_getExercise","cst_getFA","cst_getGR","cst_getInitialState","cst_getLALR1DiagramId","cst_getLALR1Table","cst_getLR0DiagramId","cst_getLR0Table","cst_getLR0TableExt","cst_getLR1DiagramId","cst_getLR1Table","cst_getLayoutDir","cst_getLenghtLeftAccept","cst_getModel","cst_getNewSentence","cst_getNextTransformed","cst_getPDA","cst_getPreviousTransformed","cst_getRE","cst_getResultTree","cst_getRightTrees","cst_getSLR1Table","cst_getSearchTree","cst_getStates","cst_getTM","cst_getTab","cst_getTrees","cst_getUpdateType","cst_getUsefulStates","cst_getUselessStates","cst_getWordAsList","cst_getWordFromConfig","cst_getWords","cst_getWrongTrees","cst_gr","cst_grAcceptTable","cst_grGrammar2","cst_grProductionsTable","cst_grammar","cst_grammarBox","cst_grammarToAcceptBr","cst_green","cst_handleOp","cst_hasEmptyProductions","cst_hasParsingTableConflict","cst_hasState","cst_hasTransition","cst_hasUnitProductions","cst_height","cst_hidden","cst_hoverDelay","cst_href","cst_i18nX","cst_id","cst_ifClose","cst_ifElseGuardClose","cst_ifElseGuardOpen","cst_ifOpen","cst_inAlphabet","cst_info","cst_infoBox","cst_infoBox2","cst_infoBoxBr","cst_inherited","cst_initAllMenusAndFeatures","cst_initialStackSymbol","cst_inputAlphabet","cst_inputEdges","cst_inputNodes","cst_inputNodesPainting","cst_inria","cst_inside","cst_isClean","cst_isComposition","cst_isContextFreeGrammar","cst_isContextGrammar","cst_isContextSensitiveGrammar","cst_isDeterministic","cst_isExercise","cst_isFinal","cst_isFiniteAutomaton","cst_isFullyAccessible","cst_isFullyProductive","cst_isGrammar","cst_isInitial","cst_isLALR1","cst_isLB","cst_isLL1","cst_isLR0","cst_isLR1","cst_isLeftFactoring","cst_isLeftLinearGrammar","cst_isLeftRecursive","cst_isLinearGrammar","cst_isMinimized","cst_isMonotonicGrammar","cst_isOver","cst_isPushdownAutomaton","cst_isRegular","cst_isRegularExpression","cst_isRegulartExpression","cst_isRightLinearGrammar","cst_isSLR1","cst_isSimplified","cst_isSimulating","cst_isTransducer","cst_isTuringMachine","cst_isUnrestrictedGrammar","cst_islinearbounded","cst_kind","cst_kuroda","cst_label","cst_layoutDir","cst_leaf","cst_leftCorner","cst_leftFactoring","cst_leftFactoring1","cst_length","cst_lightblue","cst_lightgreen","cst_lightyellow","cst_lineColor","cst_listDisCompButtons","cst_listOnlyAutomataButtons","cst_listOnlyCFGButtons","cst_listOnlyCFGConvertButtons","cst_listOnlyExpressionButtons","cst_listOnlyGRButtons","cst_listOnlyGRConvertButtons","cst_listOnlyPDAButtons","cst_listOnlyTM2TapesConvertBut","cst_listOnlyTMButtons","cst_listOnlyTMConvertButtons","cst_listOtherButtons","cst_loadButtons","cst_locked","cst_lookahead","cst_lookahead1","cst_mainFunction","cst_mainTitle","cst_make_node_final","cst_make_node_initial","cst_make_node_not_final","cst_makeLabel","cst_makeTree","cst_markers","cst_matchCharFun","cst_matchFunction","cst_maxPos","cst_mediumseagreen","cst_menuItems","cst_min","cst_minimize","cst_minimize1","cst_model","cst_model2Str","cst_modelStringContainer","cst_moduleName","cst_monospace","cst_monospaceClass","cst_mouseover","cst_myCFG","cst_myModal","cst_nSteps","cst_name","cst_never_happens","cst_newEpsylonTransition","cst_newGrammarTitle","cst_newModel","cst_newSentence","cst_newSentence1","cst_newTransformation","cst_newTransition","cst_next","cst_nextStep","cst_noEdgeEventsInDraw","cst_node","cst_node_childrenSelected","cst_node_epsilon","cst_node_selected","cst_nodeConfigDisplay","cst_node_label","cst_node_nodeType_leaf","cst_node_nodeType_root","cst_nodes","cst_nonContractingToCSG","cst_nonContractingToCSGGRGR","cst_nope","cst_notAccept","cst_nothing","cst_null","cst_numberStates","cst_numberTransitions","cst_onClickFunction","cst_opacity","cst_operation","cst_operationAutomaton","cst_operationCFG","cst_operationComp","cst_operationEXER","cst_operationGR","cst_operationRE","cst_operationTM","cst_optionNewAutomatonFA","cst_optionNewAutomatonPDA","cst_optionNewComposition","cst_optionNewContextFreeGramma","cst_optionNewGrammar","cst_optionNewRegularExpression","cst_optionNewTuringMachine","cst_orOp","cst_orange","cst_outAlphabet","cst_outside","cst_overlayOpacity","cst_paint","cst_paintBestCurrentStep","cst_paintCurrentStates","cst_paintGrammarTable","cst_paintMinimization","cst_paintParsingTableHtml","cst_paintStates","cst_paintWord","cst_pan_zoom_resize","cst_parseErrorFun","cst_partialDerivative","cst_pathTable","cst_pdaSpecificationButtons","cst_penttonen","cst_placement","cst_popper","cst_popper_div","cst_position","cst_printErrors","cst_printFunctions","cst_printTree","cst_prob","cst_problem","cst_productive","cst_productivePainting","cst_productiveRewrite","cst_productiveSymbols","cst_promState","cst_properties","cst_pt","cst_purple","cst_pushdown_automaton","cst_px","cst_q","cst_quasiLanguage","cst_rankDir","cst_rdParserCode","cst_rdparserOpts","cst_re","cst_re_astar","cst_reachable","cst_reachableFromInitialState","cst_reachablePainting","cst_readFromFile","cst_red","cst_regExp","cst_regular_expression","cst_removeAcceptState","cst_removeDirectLeftRecursion","cst_removeEmptyProductions","cst_removeEmptyProductions1","cst_removeFinal","cst_removeFinalNode","cst_removeLeftRecursion","cst_removeLeftRecursion1","cst_removeState","cst_removeTransition","cst_removeUnitProductions","cst_removeUnitProductions1","cst_rename_node","cst_renameNode","cst_renameState","cst_renderedPosition","cst_replicateOnLeft","cst_representation","cst_representationx","cst_resetConfigMenu","cst_resetStyle","cst_resetToEditModel","cst_resultBox","cst_resultTree","cst_return","cst_returnPath","cst_returnProm","cst_returnStats","cst_returnType","cst_right","cst_right_end","cst_root","cst_row1","cst_save","cst_select","cst_selectCFG","cst_selectConv","cst_selectConversions","cst_selectFA","cst_selectGR","cst_selectNewModel","cst_selectPDA","cst_selectRegex","cst_selectStep","cst_selectTM","cst_selectTM2Tapes","cst_selectedNodeConfigMenu","cst_selector","cst_sentence","cst_set_initial_step","cst_setBackStep","cst_setComp","cst_setConfigsAndBestPath","cst_setConfigsAndBestPath2","cst_setInitialStep","cst_setNextStep","cst_setRe","cst_setStep","cst_setTitle","cst_setTreeStruct","cst_setUpdateType","cst_settings","cst_settingsText","cst_setupIncludes","cst_setupVariables","cst_shape","cst_show","cst_show2","cst_showConfigurationMenu","cst_showTable","cst_showTrace","cst_side","cst_simplified","cst_simplify","cst_snap","cst_snapFrequency","cst_snapThreshold","cst_solution","cst_sourceArrowColor","cst_specification","cst_specsMenu","cst_src_GrammarTests_ml","cst_src_PushdownAutomatonTests","cst_stackAlphabet","cst_stackConfigDisplay","cst_start","cst_startAccept","cst_startAllTrees","cst_startGraph","cst_startStep","cst_staticAccept","cst_staticAcceptFull","cst_staticGenerate","cst_statsBox","cst_step","cst_stepbystep","cst_steps","cst_stringAsList1","cst_stringSymbolAdd","cst_stringSymbolRemove","cst_style","cst_subscribeConfigEventMenu","cst_subscribeNodesPositionUpda","cst_symbolFunction","cst_synthesized","cst_tab","cst_table","cst_tapdragover","cst_tapeAlphabet","cst_targetArrowColor","cst_targetArrowShape","cst_td","cst_test","cst_test0","cst_test1","cst_testing","cst_textBox","cst_textHalign","cst_textMarginY","cst_textValign","cst_textarea","cst_tezos","cst_th","cst_title","cst_toDeterministic","cst_toDeterministic1","cst_toDisplayString","cst_toJSon","cst_toJSon2","cst_todo","cst_toggleAcceptanceCriteria","cst_toggleSimplified","cst_tooltip1","cst_tooltip3","cst_tooltipAbout","cst_tooltipAccessible","cst_tooltipClean","cst_tooltipClear","cst_tooltipClearAuto","cst_tooltipCloseLeft","cst_tooltipCloseRight","cst_tooltipConvert","cst_tooltipDeterministic","cst_tooltipDirection","cst_tooltipEditModel","cst_tooltipExportModel","cst_tooltipFeedback","cst_tooltipFile","cst_tooltipFitGraph","cst_tooltipGenerate","cst_tooltipMinimize","cst_tooltipNewModel","cst_tooltipProductive","cst_tooltipRDParserCFG","cst_tooltipSettings","cst_tooltipSpecification","cst_tooltipStep","cst_tooltipTest","cst_tooltipTrace","cst_tooltipUseful","cst_tooltiptext1","cst_tooltiptext2","cst_tooltiptext3","cst_tr","cst_trace","cst_transducer","cst_transformGrammar","cst_transformPdaToAcceptEmptyS","cst_transformPdaToAcceptStates","cst_transformToLL1","cst_transformToLL1X","cst_transformationIndex","cst_transformations","cst_transparent","cst_treeButtons","cst_treeDiv","cst_treeNumbers","cst_tree_rules","cst_triangle","cst_true","cst_turing_machine","cst_turnFinalNode","cst_turnNodeFinal","cst_turnNodeInitial","cst_unset","cst_updateAllMenusAndFeatures","cst_updateAllPoppers","cst_updateButtons","cst_updateConfigMenu","cst_updateElements","cst_updateInitialState","cst_updateRight","cst_updateScreenSentence","cst_updateType","cst_useful","cst_usefulPainting","cst_visibility","cst_visitedConfigs","cst_white","cst_width","cst_wordAsList","cst_words","cst_wrong","cst_x","cst_xTypeDeclString","cst_xTypeName","cst_y","cst_yellow","cst_z","cst_work_OCamlFlat","caml_call1","f","a0","caml_call2","a1","caml_call3","a2","caml_call4","a3","caml_call5","a4","caml_call6","a5","caml_call7","a6","caml_call8","a7","dummy","Out_of_memory","Sys_error","Failure","Invalid_argument","End_of_file","Division_by_zero","Not_found","Match_failure","Stack_overflow","Sys_blocked_io","Assert_failure","Undefined_recursive_module","partial","locfmt","cany","empty_alternative","first","lookahead","follow","word","signature","wordsToAccept1","wordsToAccept2","mesg","revStack","valid","stateRevStack","shared","symbolTypeName","symbDisplayQuote","dfa_1","dfa_2","dfa_astar","fa_abc","nfa_1","nfa_2","re_abc","re_complex","re_convoluted","re_simple","re_astar","cfg_simple","cfg_balanced","cfg_ll_thesis_g1","cfg_ll_thesis_g2","cfg_ll_1","cfg_ll_2","cfg_ll_3","cfg_ll_4","cfg_ll_5","cfg_ll_6","cfg_slr1","cfg_lr0_thesis","cfg_slr1_thesis","cfg_lr1_thesis","cfg_lalr1_thesis","cfg_onlylr1","cfg_notlr1","ug_simple","pda_WW_1","pda_AABB","pda_Explode","tm_astar1","tm_astar2","tm_astar3","tm_astar4","tm_astar5","tm_astar6","tm_astar7","tm_astar8","tm_astar9","tm_astar10","tm_astar11","comp_abc","exer_balanced_cfg","exer_anbncn_csg","exer_monotonic_simple","exer_monotonic_strict_simple","exer_noncontracting_anbn","exer_linear_palindromes","exer_right_linear_abstar","exer_left_linear_astarbc","csg","non_contracting","exer_astar_fa","exer_astar_re","exer_abcd","exer_ab","exer_re2fa","exer_readwrite","kind","prelude","moduleName","xTypeName","unGrammar","unGrammar2","cfg","gram_example","gram_example3","lg","rlgrammar","llgrammar","g_unproductive","g_inaccessible","cleang","knf_test_grammar","leftRecursionRemovalTransform","leftFactoringTransform","cleanProductiveTransform","cleanAccessibleTransform","unitRemovalTransform","epsilonRemovalTransform","ag","fileName","oonSample2","fe_colors","exer_colors","re_more","fstIdentity","gram_example4","example1","example2","example3","example4","example5","example6","cfg_dissertation","non_deterministic_grammar","accessible_symbols1","accessible_symbols2","productive_symbols1","productive_symbols2","clean_grammar1","direct_left_recursion_grammar1","direct_left_recursion_grammar2","indirect_left_recursion_gramma","left_factoring_example","left_factoring_example2","left_factoring_example3","left_factoring_example4","left_factoring_example5","left_factoring_example6","unit_removal_example1","unit_removal_example2","unit_removal_example3","unit_removal_example4","unit_removal_example5","epsilon_removal_example1","epsilon_removal_example2","epsilon_removal_example3","colorRed","colorGreen","colorOff","pda_astar","pdaReach","pdaProductive","pdaEmptyStackCriteria","pdaEmptyAcceptStatesCriteria","pdaNonDeterministic","pdaDeterministic","pdaAccept","pdaAccept2","pdaAccept3","i18nKey","prefix","text","finish","productiveColor","reachableColor","usefulColor","stepState","acceptState","wrongFinalState","headers","htmlDelta","none","bestStateColor","htmlArrow","htmlDollar","monospaceClass","nodeString","symbInputRegex","displayConfig","stackConfigDisplayID","nodeConfigDisplayID","uncertainState","nodeLabel","languageOptions","findIndex","emptyOptions","findIndex2","listOnlyAutomataButtons","listOnlyExpressionButtons","listOnlyPDAButtons","listOnlyCFGConvertButtons","listOnlyGRConvertButtons","listOnlyCFGButtons","listOnlyGRButtons","listOtherButtons","cache_id","erase_rel","param","rest","ty","ty1","concat_fmtty","fmtty1","fmtty2","ty2","concat_fmt","fmt1","fmt2","pad","prec","iconv","fconv","str","chr","fmtty","fmting_lit","fmting_gen","char_set","width_opt","counter","ign","arity","make","v","get","r","set","compare_and_set","seen","cur","failwith","s","invalid_arg","Exit","max","x","y","abs","lnot","symbol_concat","char_of_int","n","string_of_bool","b","string_of_int","valid_float_lexem","l","loop","i","match","string_of_float","symbol","l1","l2","tl","hd","stdout","stderr","open_out_gen","mode","perm","name","c","open_out","flush_all","iter","a","exn","tag","output_string","oc","output_substring","ofs","len","close_out","open_in_gen","open_in","unsafe_really_input","ic","really_input","print_string","print_endline","print_newline","prerr_char","prerr_string","prerr_endline","exit_function","at_exit","f_yet_to_run","old_exit","new_exit","success","do_at_exit","exit","retcode","some","map","o","is_none","equal","eq","o0","o1","v1","v0","to_string","escaped","lowercase_ascii","uppercase_ascii","compare","c1","c2","max_array_length","max_string_length","length_aux","length","nth","nth_aux","rev_append","rev","init_tailrec_aux","acc","init_aux","init","flatten","mapi","iteri","fold_left","accu","fold_right","map2","iter2","for_all","p","exists","belongs","assoc","assoc_opt","assq","remove_assoc","pair","remove_assq","find","find_opt","find_all","partition","part","yes","no","combine","stable_sort","cmp","rev_merge","t2","h2","t1","h1","rev_merge_rev","sort","x2","x1","x3","n1","n2","s1","s2","rev_sort","compare_lengths","equal_c","min","empty","copy","sub","sub_string","fill","blit","ofs1","ofs2","blit_string","is_space","trim","j","apply1","capitalize_ascii","bos","bts","ensure_ge","sum_lengths","seplen","unsafe_blits","dst","pos","sep","concat","escape_if_needed","index_rec","lim","index","index_from","contains_from","contains","split_on_char","is_block","res","make_matrix","sx","sy","to_list","tolist","list_length","t","of_list","Make","Ord","height","h","create","hl","hr","bal","lr","lv","ll","lrr","lrv","lrl","rr","rv","rl","rlr","rlv","rll","add","cons_enum","e","compare_aux","e1","e2","r2","v2","r1","d","ld","lrd","rd","rld","data","m","fold","clear","push","pop_opt","top_opt","Empty","q","cell","peek_opt","content","take","next","take_opt","is_empty","Undefined","raise_undefined","force_lazy_block","blk","closure","result","contents","resize","more","old_pos","old_len","new_len","new_buffer","add_char","add_substring","offset","new_position","add_string","default_float_precision","buffer_create","init_size","buffer_check_size","buf","overhead","min_len","new_str","buffer_add_char","buffer_add_string","str_len","buffer_contents","char_of_fconv","opt","sth","cF","bprint_fconv_flag","string_of_formatting_lit","formatting_lit","bprint_fmtty","sub_fmtty","symm","fmtty_rel_det","de","af","jd","ga","trans","rest1","rest2","ty12","ty11","ty22","ty21","f4","f2","Type_mismatch","type_padding","w","padty","type_padprec","type_format","fmt","type_format_gen","fmtty_rest","fmt_rest","pad_opt","sub_fmtty1","formatting_gen","type_formatting_gen","fmt0","fmtty0","fmtty3","fmt3","type_ignored_param","type_ignored_param_one","type_ignored_format_substituti","sub_fmtty_rest","sub2_fmtty","sub1_fmtty","recast","fix_padding","width","fix_int_precision","string_to_caml_string","format_of_iconv","format_of_iconvL","format_of_iconvl","format_of_iconvn","format_of_fconv","symb","transform_int_alt","digits","put","left","convert_int","convert_int32","convert_nativeint","convert_int64","convert_float","hex","sign","add_dot_if_needed","is_valid","caml_special_val","format_caml_char","string_of_fmtty","make_printf","k","kacc","new_acc","make_ignored_param","make_from_fmtty","make_invalid_arg","make_padding","make_int_padding_precision","make_float_padding_precision","make_custom","output_acc","msg","strput_acc","kfprintf","fprintf","printf","eprintf","ksprintf","sprintf","printers","field","other_fields","fields","use_printers","conv","val","to_string_default","char","line","file","constructor","convert_raw_backtrace","bt","format_backtrace_slot","slot","info","is_raise","print_exception_backtrace","outchan","backtrace","print_raw_backtrace","raw_backtrace","print_backtrace","register_printer","fn","old_printers","new_printers","errors","default_uncaught_exception_han","status","empty_backtrace","try_get_raw_backtrace","handle_uncaught_exception","debugger_in_use","string","new_state","full_init","seed","extract","make_self_init","bits","curval","newval","newval30","intaux","int","bound","default$","ongoing_traversal","max_int","params","randomized_default","prng","power_2_above","initial_size","random","insert_all_buckets","indexfun","inplace","odata","ndata","nsize","ndata_tail","insert_bucket","key","nidx","osize","MakeSeeded","H","key_index","bucket","find_rec","k1","d1","next1","k2","d2","next2","k3","d3","next3","hash","include","sz","find_rec_opt","replace_bucket","replace","id","zero","unknown","is_known","String_tag","pp_enqueue","state","token","pp_clear_queue","pp_infinity","pp_output_string","pp_output_newline","pp_output_spaces","pp_output_indent","format_pp_text","size","format_string","break_new_line","after","before","indent","real_indent","break_line","break_same_line","pp_force_break_line","box_type","pp_skip_token","format_pp_token","tabs","add_tab","ls","tag_name","marker","breaks","fits","off","insertion_point","tail","head","tab","tbox","advance_left","pending_count","enqueue_advance","tok","enqueue_string_as","enqueue_string","initialize_scan_stack","stack","queue_elem","set_size","left_total","scan_push","elem","pp_open_box_gen","br_ty","pp_open_sys_box","pp_close_box","pp_close_stag","pp_close_tag","pp_rinit","clear_tag_stack","pp_flush_queue","pp_print_flush","display_newline","blank_line","display_blanks","default_pp_mark_open_tag","default_pp_mark_close_tag","default_pp_print_open_tag","default_pp_print_close_tag","pp_make_formatter","g","pp_queue","sys_tok","scan_stack","pp_margin","make_formatter","output","flush","ppf","formatter_of_out_channel","formatter_of_buffer","pp_buffer_size","pp_make_buffer","stdbuf","std_formatter","err_formatter","flush_standard_formatters","register_exception","public_method_label","Vars","Meths","Labs","table_count","dummy_met","initial_object_size","fit_size","new_table","pub_labels","methods","array","new_size","old_size","new_buck","label","element","method_count","new_method","table","get_method_label","get_method_labels","names","set_method","get_method","arr","narrow","vars","virt_meths","concr_meths","virt_meth_labs","concr_meth_labs","lab","tvars","by_name","by_label","met","hm","widen","saved_vars","saved_hidden_meths","new_slot","new_variable","to_array","new_methods_variables","meths","vals","nmeths","nvals","get_variable","create_table","public_methods","tags","init_class","inherits","cla","top","env","super$","nm","make_class","pub_meths","class_init","env_init","create_object_opt","obj_0","obj","iter_f","run_initializers_opt","inits","get_const","get_var","get_env","get_meth","set_var","app_const","app_var","app_env","app_meth","app_const_const","app_const_var","app_const_meth","app_var_const","app_meth_const","app_const_env","app_env_const","meth_app_const","meth_app_var","meth_app_env","meth_app_meth","send_const","send_var","send_env","send_meth","new_cache","method_impl","clo","set_methods","Error","global","no_handler","undefined$","case$","to_option","true$","t0","array_constructor","t5","array_get","t8","t9","error_constr","t10","t14","t15","encodeURI","t18","encodeURIComponent","t19","appendChild","t3","t4","removeChild","t6","insertBefore","t11","t12","handler","t17","document","getElementById","pnode","getElementById_opt","t7","getElementById_coerce","coerce","opt_iter","createElement","doc","unsafeCreateElement","createElementSyntax","unsafeCreateElementEx","type","elt","el","t34","t35","t37","t36","t38","t16","t20","t21","t22","t23","t24","t25","t26","t27","t28","t29","t32","t33","t30","t31","t13","createOption","createSelect","createTextarea","createButton","createDiv","createP","createH2","createPre","createBr","createA","createTable","createSpan","t40","unsafeCoerce","t42","t41","select","textarea","overflow_limit","setTimeout","callback","remain","step","cb","t108","t109","t110","clearTimeout","t111","t112","console","remove","node","seq","Storage_map","to_public_promise","to_public_resolver","to_internal_promise","to_internal_resolver","state_of_result","identical","p1","p2","underlying","set_promise_state","may_now_be_proxy","handle_all","run","current_storage","concat_regular_callbacks","concat_cancel_callbacks","clean_up_callback_cells","callbacks","merge_callbacks","from","into","regular_callbacks","cleanups_deferred","cancel_callbacks","add_regular_callback_list_node","existing","add_implicitly_removed_callbac","add_cancel_callback","async_exception_hook","handle_with_async_exception_ho","Canceled","run_callbacks","run_cancel_callbacks","fs","iter_callback_list","storage","iter_list","run_regular_callbacks","is_canceled","current_callback_nesting_depth","deferred_callbacks","default_maximum_callback_nesti","enter_resolution_loop","storage_snapshot","leave_resolution_loop","run_in_resolution_loop","run_callbacks_or_defer_them","allow_deferring","maximum_callback_nesting_depth","should_defer","resolve","run_callback_or_defer_it","if_deferred","run_immediately_and_ensure_tai","deferred_result","deferred_callback","immediate_result","deferred_record","wakeup_general","api_function_name","wakeup","cancel","canceled_result","propagate_cancel","cancel_and_collect_callbacks","callbacks_accumulator","ps","return$","fail","return_true","return_false","new_pending","how_to_cancel","task","make_into_proxy","outer_promise","user_provided_promise","p_callbacks","outer_callbacks","symbol_bind","create_result_promise_and_call","saved_storage","p_result","on_cancel","sleep","byte","set_byte","unsafe_set","mask","unsafe_get","reset_zero","create_zero","to_int","intersect","inexistant","letter","not_letter","newline","lastnewline","search_boundary","from_char","cache","of_int","of_char","null_char","compare_pair","equal_pair","union","inter","diff","single","csingle","union_all","ts","intersect_all","mem","rem","hash_rec","xs","one_char","u","CSetMap","cseq","upper","clower","cdigit","cadd","calpha","calnum","case_insens","cword","notnl","nl","lower","alpha","alnum","make_absent","should_grow","slots","absent","index_of_offset","inserting","idx","old_table","found","marks","ma","start_i","stop_i","start","stop","Set","hash_combine","prev","group_count","outside_range","start_inclusive","stop_inclusive","used","eps_expr","mk","ids","def","eps","rep","sem","mark","pmark","erase","alt","is_eps","expr","rename","z","pmarks","hash_marks_offset","marks_set_idx","filter","set_mark","set_pmark","equal_list","marks1","marks2","hash_list","tseq","iter_marks","first_match","remove_matches","split_at_match_rec","split_at_match","set_idx","initial","add_match","add_eps","add_expr","remove_duplicates","cat","desc","category","status_no_mutex","st","Table","index_count","mark_used_indices","tbl","find_free","free_index","delta_expr","ctx","rep_kind","delta_rep","delta_alt","delta_seq","delta_e","delta_desc","delta","tbl_ref","next_cat","prev_cat","repr","color","get_char","translate_colors","cm","cset","color_repr","split","equal_ast","j2","i2","j1","i1","m2","m1","handle_case_cset","ign_case","handle_case","any","as_set_elems","elems","epsilon","repn","rep1","bow","eow","make_set","preserve_set","shortest","group","as_set_or_error","compl","no_case","merge_sequences","colorize","color_map","regexp","lnl","anchored_ast","als","anchored","gcount","gpos","offset_opt","or_not_found","get_ofs","nb_groups","of_idx","is_idx","is_break","is_unknown","make_break","break_idx","get_info","set_info","follow_transition","set_transition","is_unknown_transition","unknown_state","ncol","all","groups","re","find_state","break_state","validate","colors","positions","last","st0","loop_no_mark","final","find_initial_state","get_color","slen","handle_last_newline","real_c","scan_str","initial_state","final_boundary_check","state_info","final_cat","make_match_str","initial_cat","match_str_no_bounds","no_match_starts_before","match_str","mk_re","ncolor","group_names","enforce_kind","cr","trans_set","make_repeater","greedy","translate","ast","ign_group","merged_sequences","trans_seq","compile_1","need_lnl","compile","rg","exec_internal","exec","substr","new_key","eos","test","test2","accept","accept_s","Parse_error","Not_supported","bol","eol","not_boundary","by_code","parse","emacs_only","branch","piece","atom","bracket","re_no_emacs","compile_regexp","string_match","search_forward","valid_group","offset_group","group_len","repl_length","repl","orig","replacement_text","string_before","string_after","group_end","match_end","substitute_first","repl_fun","global_substitute","last_was_empty","startpos","end_pos","repl_text","global_replace","replace_first","search_forward_progress","bounded_split","num","diagnosticsOn","errorViewer","setViewer","adjust","view","fatal","warning","gouping","startGroup","makeMesg","culprit","error","endGroup","expectedKind","delX","singleton","fe_zero","toList","isEmpty","cons","cut","ss","flatMap","subset","equals","unionUnsafe","product","starOne","sel","fixedPoint","star","hasDuplicates","acumFixedPoint","historicalFixedPoint","historicalFixedPointX","acum","newAcum","historicalFixedPointTracing","trace","newTrace","char2symb","str2symb","symb2str","symbI","symbX","dollar","symbX2str","symbolsX","listD","symbXD","symbolsXD","draftVar","strD","stringsD","word2wordX","str2word","word2str","strs","symbols","wordsX","ws","state2str","str2state","draftState","stateXD","statesXD","allDirections","string2direction","dirX","dir","current","gen","genVar","timeStart","exactResult","runconfigs","runtime","update","giveUp","stats","stripHead","skip","distrib2","loadFile","filename","print","println","header","printStates","printWord","printWords","printString","printStrings","show","handleHomeDir","benchmark","testing","active","regularActive","test0","test1","isBlank","isAlpha","isDigit","isId","asStr","strQuoted","asStrQuoted","parserName","inputString","inputStringLength","inputStringPosition","expecting","exp","got","invalid","isInside","slice","skipWhile","good","skipBlanks","peek","getToken","getId","getUntil","ch","getChar","getAlpha","getInt","getCharInt","getDelim","checkStr","getStr","expecting0","rubbish","parseString","delim","tk","parseWord","parseLabel","checkEOF","parsePair","parseAssocCont","parseAssoc","parseListCont","parseList","parseJSon","parseTupleCont","parseTuple","parseOon","fromFile","txt","isComplex","textual","tab1","tab2","toStringN","toString","isNull","hasField","getField","dummySymb","dummyState","dummyDirection","fieldSymbol","asSymbol","fieldSymbolList","fieldSymbolSet","fieldString","asString","fieldStringList","fieldStringSet","asState","fieldState","fieldStateList","fieldStateSet","fieldBool","asStateSymbolState","fieldTriplesList","fieldTriplesSet","asStateSymbolSymbolState","fieldQuadsList","fieldQuadsSet","asWord","asStateSymbolSymbolStateWord","fieldQuintupletsList","fieldQuintupletsSet","append","makeSymbol","makeSymbolList","makeSymbolSet","makeString","makeStringSet","makeState","makeStateSet","makeBool","makeTriplesSet","makeQuadsSet","makeQuintupletsSet","makeAssoc","examplesTable","examplesAll","examples","example","jsonExample","fromAlternatives","dummyId","fromJSon","toJSon","startCreation","createId","arg","endCreation","make2","entity","self_1","self","exer_zero","externalize","toJSon2","show2","showRes","props","outs","ins","exercise","self_2","checkProperty","prop","checkExercise","ex","checkExerciseFailures","ac","cp","checkWord","alphabet","ok","isAccepting","acceptX","configs","newConfigs","newSeen","nextConfigs","initialConfigs","acceptFull","base","accepting","generate","getWord","strict","lenWord","isNew","isExpanding","finalSelection","generateX","toExpand","collected","selected","generateDumb","addAll","combinations","combinations2","comb","model","self_3","strings","words","fe","displayHeader","solution","repx","self_4","fa_zero","toJSon0","transitions3X","trans3X","fa","transs3XD","t2d","isAcceptingConfig","nonEmpty","st1","res1","st2","res2","nextConfigs2","isAcceptingConfig2","transitionGet1","trns","transitionGet2","transitionGet3","fuseStates","sts","hasTrans","nextEpsilon1","nextStates","closeEmpty","ns","validAlphabet","validInitSt","validAccSts","fromSt","toSt","validTrns","acceptBreadthFirst","acceptWithTracing","transition","nsts","nextSts","printRes","generateUntil","addSyToRWords","hasAcceptState","accSts","nxtNonEmptyTrns","transitions","clsEmpty","trnsSet","genX","lenOneOrMore","lenZero","reachable","neighbourSts","reach","visited","productive","reachsAccSt","getUsefulStates","getUselessStates","cleanUselessStates","usfSts","usfTrs","alf","usfAlf","newAccSts","areAllStatesUseful","toDeterministic","move","newR","oneR","nxtSts","clsempty","rToTs","nxtTrans","rsToTs","stsD","rD","trnsD","alph","nxtTs","stSet","nxtRs","newRs","tds","newInitialState","stSet1","stSet2","isAccepState","hasAnAccepSt","newAccStsSet","newAllSts","isDeterministic","trnsFromSt","isStDeter","allSts","allTs","sys","hasNondeterSt","equivalencePartition","notF","inF","distI1","hasTransMulti","distI2","distI","stsXSts","reachingSts","findAR","distA","aped","dist","halfCombs","halfTriang","dicti","eq2","eq1","equiv","equivList","hasAny","sta","stb","agroup","part2","part1","gRemain","minimize","newSts","newInitSt","newTrans","isMinimized","self_5","re_zero","parseExp","parseTerm","parseFactor","parseAtom","parseParentised","hasEmpty","rightConcat","partialDerivative","seqConcat","aset","bset","quasiLanguage","partX","pword","fwp","allTrees","wps","wpl","wp2","wp1","tr","isNotFail","printTreeX","printTree","simplify","simpX","der","nextConfigs3","sym","self_6","fst_zero","transitions4X","trans4X","fst","transs4XD","isComplete","isMooreMachine","isMeelyMachine","self_7","gr_zero","parseHead","parseNeck","parseBody","parseLine","bs","rs","rule2str","toStringList","grammar","rules","gram","isValidAlphabet","isValidVariables","isIntersectionValid","isInitialValid","allHeadSymbols","allValidSymbs","areRuleHeadsValid","allBodySymbols","areRuleBodiesValid","isUnrestrictedGrammar","isEpsilonRule","lengthMonotonicCheck","isNoncontractingGrammar","isMonotonicStrictGrammar","isContextSensitiveGrammar","isContextRule","rule","findContextsHelper","body","match_found","findContexts","isSingleNonterminal","isContextFreeGrammar","isLeftLinearGrammar","var$","var_belongs","rest_belongs","belongs_to_vars","belongs_to_alphabet","isRightLinearGrammar","isLinearGrammar","var_count","count","rechableSymbs","allRulesAccessible","accessSymbols","allVars","terminalSymbs","terminalSymbsCFG","allRulesProductive","prodVars","isClean","cleanUnproductive","prodSymbols","filteredRules","epsilonRuleHeads","unprodictiveEpsilonRules","newFilteredRules","cleanInaccessible","accessibleVars","filteredAlphabet","clean","cleanUnproductiveGram","starts_with","lst","ltail","lhd","stail","shd","removeN","replace_subsequence","original","subseq","replacement","subseq_lenght","rechableSymbsCFG","hasEpsilonRules","generatesEmpty","accessVars","removeEpsilonRules","nullableVars","nullable","newNullable","generateCombinations","tlCombinations","newBodies","newRules","initialConfig","containsSubSequence","subSequence","list","sShd","expand2","sf","newSfs","newSf","filtered","partOneX","ys","partOne","heads","tryMatch","reallyMatch","processHRest","xRules","xBodies","ySet","fs1","fs2","expand","alternativesX","useX","ignoreX","restoreX","genW","simplifyGrammar","processed_gram","accept2","replace_subsequence_with_index","subseq_length","aux","found_index","replaced","find_applied_rules","path","index_rule","curr_i","applicable_rule","level2","level1","expandGenerate","nextConfigsGenerate","isAcceptingConfigGenerate","isTerminalSymbol","generateNewVariable","variables","auxGenerateNewVariable","newVar","introduceTerminalVariables","term_map","current_vars","new_terminal_rules","original_rules","terminal","new_var_symb","final_other_rules","replace_terminal","new_var","new_head","new_body","final_rules","transformGrammar","rule_with_long_head","newVariable","updated_vars","remaining_rules","rest_head","newRuleHead","modifiedRule","updated_rules","updated_gram","rule_with_long_body","rest_body_all","b1","newRuleBody","kurodaNormalForm","makeContextRules","processRules","rulesToCheck","gramAux","new_variables","new_rules","nonContractingToCSG","kuroda_gram","removeUnitProductions","unitProductions","unitProduction","symbolToReplace","replacementSymbol","replace_symbol","newVariables","newInitial","penttonenNormalForm","switch$","self_8","testWord","make_grammar","json","assert_accepts","assert_rejects","test_grammar_types","unrestricted","unrestricted2","linear","test_acceptance","test_generation","expected_words","actual_words","testNew","g_cfg","test_kuroda_normalization","kuroda","test_kuroda_full","test_penttonen_normalization","example_grammar","penttonen","test_nonContrating_to_CSG","g_non_contracting","testAcceptImplementations","g_csg","input_strings","accept_times","accept2_times","test_word","duration1","duration2","channel","test_cleaning","g_cleang","cleaned_inaccessible","cleaned_unproductive","cleaned_cleang","testRemoveEpislon","test_find_applied_rules","trail","syms","config_set","rule_map","rule_opt","cfg_zero","showRules","removeRule","randVar","forbiddenSymbols","usedSymbols","directDeriv","numberOfProdVar","getRule","bdy","rulesWithSameBdy","containsSInRHS","addRule","sSymb","delSFromRHS","newS","isVariable","prodWord","direct","varProdWord","prodEpsilon","epsilonProdsCombs","addNewRules","leftSide","bodies","nCfg","isStartSymbol","delEpsilonRules","cfgRules","epsilonProd","cfgWithRules","cleanEpsilonRules","isAnUnitProduction","addRules","unitFor1","nW","processUnitProduction","sdnCfg","delUnitProductions","isNonSolitaryTerminalsRule","terminals","addRulesFromNonSolitary","processRulesWithNonSolitaryTer","hasMoreThan2NonTerminalsInRHS","nonTerminalsInRHS","splitBodyByVariables","binFor1","processRHSwithMoreThan2NonTerm","cfgWithoutHd","sdCfg","chomsky","term","bin","del","unit","cykAccept","matrix","lhs","bodiesOfHead","rls","concatWords","lws","rws","pairs","exceedsMaxLen","cleanWord","subX","subVar","vs","removeEpsi","cleanNonWords","hasVar","removeEpsilonFromWord","removeDollarFromWord","doWordGenerateEmptyX","doGenerateEmpty","doWordGenerateEmpty","firstX","simple","first2","getFollowRules","testSymbol","getFollowInfo2","getFollowInfo","followX","follow2","hs","isTerminalSymbol2","expandsEmpty","verifyLength","lengthSf","lengthBody","sfVars","bodyVars","main","t_main","h_main","t_sub","h_sub","is_sublist","config","sf_next","var_positions","all_rules","all_positions","var_rules","self_9","alp","isRightLinear","isRightLinearX","isLeftLinear","isLeftLinearX","getPrefix","wa","getSuffix","getSuffixX","sfx","auxSfx","firstNElements","lastNElements","keepByPrefix","testW","pgw","ptw","keepBySufix","sgw","stw","toKeep","tw","nextGeneration","subsWs","trimRes","printWset","tabCreator","tabLevel","parser","self_10","funs","conditions","ifList","createIf2","createExpr","exprList","getNextTerminals","funCalls","lookaheads","mergedMap","self_12","self_13","printDecl","self_14","printFunctionsX","self_15","initialVar","self_16","self_17","newStep","rBody","acceptedString","input","production","recog","accepted","nodes","sameHeadRules","behindSymbol","leftRecursionTest","ruleBodies","leftRecursionTest2","wordBehind","behindGenerateEmpty","isLeftRecursive","isLL1Deterministic","pairsSet","lookaheadInterSet","isLL1","lookahead2Tuple","createParsingTable","lookaheadSet","hasParsingTableConflict","parsingTable","repeatsTbl","getRepeatNum","repeat","boolResults","word2tree","word2tree2","entry","currPerm","xs2","entryChar","stackChar","parsingTableList","substitution","newStack","newCurrPerm","acceptZ","isRuleProductive","isSymbolProductive","productiveSymbolsFP","varP","productiveSymbols","productiveGrammarRewrite","prodSyms","unprodSyms","ruleAccessibleSymbols","aSymbols","rulesAccessibleSymbols","accessibleSymbolsX","accessibleSymbols","accessibleGrammarRewrite","accessSymbs","accessTerms","prodRewrite","accessRewrite","isCFGFullyProductive","isCFGFullyAccessible","getNewVar","chars","symbs","acceptableVars","leftCorner2","leftCorner","sortLeftCorner","sortFun","addToMap","varL","addToMap2","value","removeDirectLeftRecursion","hasRuleDirectLeftRecursion","recursiveRuleRewrite","nV","nRecursiveRuleRewrite","removeDLRFromVar","drs","ndrs","recursiveRs","nRecursiveRs","recRulesRewriteTmp","recRulesRewrite","nRecRulesRewrite","leftRecursiveRules","leftRecursiveVars","nonLeftRecursiveRules","nonLeftRecursiveRulesClean","newVars","removeIndirectLeftRecursion","perVarIndirectRemoval","perVarProdIndirectRemoval","prodHead","iVal","prodBody","rhsValues","results","rhsBody","jVal","rhsVar","rhsVarBodies","replaceRules","varRules","newProds","newGrammar","removeLeftRecursion","leftCornerTest","sortedLeftCornerTest","sortedVars","lcp","xs1","perVarLCP","combos","lcpList","sameRuleFactoring","rb","newRuleFactoring","ruleHasPrefix","getSmallestLCP","currSmallest","getBiggestList","currBiggest","createLargeList","perVarFactoring","prefixedRules","nonPrefixedRules","newSameHeadRulesSet","newHeadRulesSet","getPerVarLCPResult","perVarLCPResult","isLeftFactoring","leftFactoring","variablesToFactorize","unchangedVariables","unchangedRules","hasEmptyProductions","removeEmptyProductions2","combi","changeProds","prod","prodBodiesSet","toChangeProds","unchangedProds","removeEmptyProductions","isUnitProd","isUnitProd2","cS","cB","isUnitProdAux","hasUnitProductions","findUnitPair2","findUnitPairAux","findUnitPairX","origVar","findUnitPair","getNonUnitProductions","prods","perVarPair","nUnitProds","perVar","unitPairs","generateRecursiveDescendentPar","lang","transformToLL1","transform1","transform2","cleanResult","transform3","transform4","transform5","transform6","self_18","pLang","nats","pop","getTail","rule2Item","kernelAdvanceItem","b2","getDirector","getDirectors","getRulesWithThisHead","director","diagramsJoin2","s0","diagramsJoinList","ds","isNextSymbolNotAVariable","isCompleteItem","isStateInConflict","lr0State","completeItems","itemsProneToConflict","it","makeLR0DiagramId","diagram","states","dictionary","statesId","transitionsId","makeLR0TableEntry","stateTransitions","nextShifts","cId","makeLR0Table","labeledDiagram","startRules","lr0StateClosureStep","currentItems","directors","varDirectors","newItems","lr0StateClosure","makeSingularNextLR0Diagram","prevState","items4Kernel","kernel","makeNextLR0Diagram","dirs","diagrams","makeNextLR0DiagramAll","makeFirstLR0Diagram","makeLR0DiagramX","transitions2","states2","makeLR0Diagram","acceptWordLR0Init","lr0Table","initStep","parseStepLR0Operation","symbolStack","stateStack","currentState","action","shifts","popNumber","nextStateStack","nextSymbolStack","wordWithAddedHead","nextStep","targetShifts","nextState","nextSymbol","acceptWordLR0Step","acceptWordLR0InitV2","parseStepLR0OperationV2","nextRevStack","acceptWordLR0StepV2","isLR0","conflictItemStates","getLR0DiagramId","getLR0Table","isCompleteLR0Item","countCompleteLR0Items","buildLR0ReductionActionsForOne","item","buildLR0ReductionActions","buildLR0MixedActionsForOne","buildLR0MixedActions","items","makeLR0TableEntryExt","lr0Actions","makeLR0TableExt","getLR0TableExt","getNextSymbolForLR0Item","followSetForSLR1Item","buildSLR1ReductionActionsForOn","reductionItems","buildSLR1ReductionActions","buildSLR1ShiftActionsForOne","shiftItems","buildSLR1ShiftActions","buildSLR1MixedActionsForOne","fixedreductionItems","acceptItems","reductionEntries","buildSLR1MixedActions","makeSLR1TableEntry","slr1Actions","completeAlphabet","makeSLR1Table","acceptWordSLR1InitV2","slr1Table","parseStepSLR1OperationV2","actionSet","topSymbol","peekedSymbol","peekedsymbolAndActions","nEntries","actions","acceptWordSLR1StepV2","entryHasConflict","slr1TableEntry","entryConflicts","isSLR1","conflicts","getSLR1Table","isCompleteLR1Item","countCompleteLR1Items","lr1State","getNextSymbolForLR1Item","getDirectorLR1","getDirectorWithLookaheadLR1","getDirectorsLR1","kernelAdvanceLR1Item","getDirectorsWithLookaheadLR1","hasSameCore","b22","b21","mergeTwoItemsWithSameCore","combinedLookahead","mergeOneItem","mergeItems","rule2ItemLR1","generateItemsForVarDirectorWit","itemRules","diagramsJoin2LR1","diagramsJoinListLR1","makeLR1DiagramId","buildLR1ReductionActionsForOne","buildLR1ReductionActions","buildLR1ShiftActionsForOne","buildLR1ShiftActions","buildLR1MixedActionsForOne","cfgInitial","buildLR1MixedActions","makeLR1TableEntry","lr1Actions","makeLR1Table","lr1StateClosureStep","directorsWithLookahead","varDirectorsWithLookahead","mergedItems","lr1StateClosure","makeSingularNextLR1Diagram","makeNextLR1Diagram","makeNextLR1DiagramAll","makeLR1DiagramX","makeFirstLR1Diagram","makeLR1Diagram","acceptWordLR1InitV2","lr1Table","parseStepLR1OperationV2","acceptWordLR1StepV2","lr1TableEntry","isLR1","getLR1DiagramId","getLR1Table","itemsSameCores","it1","it2","itemsJoinLookahead","getStateCore","haveSameCores","lr1state1","lr1state2","state1Core","state2Core","mergeLR1States","state1","state2","fit","lr1StateFusion","fstates","lr1TransFusion","makeLALR1FromLR1","ftrans","lalr1Diagram","acceptWordLALR1InitV2","parseStepLALR1OperationV2","acceptWordLALR1StepV2","isLALR1","lalr1Table","getLALR1DiagramId","getLALR1Table","self_19","ag_zero","parseApply","attr","parseExp3","parseExp2","parseExp1","parseExp0","switcher","parseExpression","expression2str","op","parseEquation","parseEquationsX","parseEquations","equation2str","parseCondition","parseConditionsX","parseConditions","condition2str","parseSymbol","parseFinish","conds","eqs","ag2cfg","validateAG","pda_zero","stackSpecialSymb","stackConverterSymb","TooManyTries","maxTries","transitionGet4","transitionGet345","transitionGet45","transitionGet5","transitionGet5Flat","getStackSymbols","stackSymbtoPutInStack","symbList","configurationGet1","configurationGet2","configuration_Get1","pda","validInitStackSymbol","syfromStack","sysToStack","fixedPointN","moves","fixedPointMaxTries","getValidNonEmptyTransitions","topStackSymb","mapStepsToConfigurationAndSymb","steps","toPutInStack","restStack","nextSteps","getNextConfigurationsWithSymbo","configurations","addSymbToWords","mapStepsToConfiguration","getValidTransitions","getNextConfigurationsFromConfi","getNextConfigurations","addNextConfigurations","exploreEmptyTransitions","isInAcceptState","acceptStates","criteria","configuration","newConfigsAndSymbols","printConfig","printSearchTree","configIsInAcceptState","configsAreInAcceptState","advanceOneTransition","getNextConfig","wordLeft","buildNewTransitions","restWord","getNextConfigs","inputSymbol","topStack","validTransitions","ww","nextConfigConsumed","nextConfigNotConsumed","acceptRec","getInitialConfig","configHasNoSymbolToConsume","buildEndNode","foundAcceptConfig","searchTreeSet","filterSearchNode","ShouldNotHappen","getNodeElements","setNodes","getNextConfigsPair","tree","buildTree","pairTreesAndNextConfigs","newNodes","buildSearchTree","forest","nextNodes","searchTree","isBestNode","hasBestPath","mapBestPath","treeSet","nextLayer","getSearchTree","transformConfig","getWordFromNode","getBestNodeAndWord","buildBestPath","nextWord","nextBestNode","getBestPath","getConfigsAndNextNodes","getAllConfigsAndFilterNextNode","treeSetAcc","configsAcc","nextTreeSet","getNextEpsilonNodes","getConfigsBySymbolConsumedStep","closureNodes","getConfigsPathBySymbolConsumed","bestPath","configsBySymbolConsumedStep","transformPdaToAcceptStates","si","initialTrsn","buildTrasitionToFinalState","buildTransitions","convertedPda","transformPdaToAcceptEmptyStack","newStackAlphabet","buildFinalTransitionsToConsume","stackAlphabet","symbStack","buildTrasitionsFromAcceptState","symbsStack","pda2fa","transitionsFa","pdaTransformed","getEquivalentTransitions","getCleanedTransitions","faCleanedTransitions","faClean","trnsFromStateAndSymbs","stackSymb","inputSymb","stackS","isnotDeterministicForStateAndS","isStateNonDeterministic","isFiniteAutomaton","validateTransition","sa","stackLeft","stackTop","sa1","sa2","self_21","usefullStates","tm_zero","nTapes","tm","multi","lbLeft","lbRight","calcNTapes","getTransSymbolMs","trns2","trns4","getTransSymbols","getTransDirectionMs","getTransDirections","asDirection","asOptionalDirectionList","dummyTransition","asOptionalSymbolList","asTransition","fieldTMTransitionList","fieldTransitions","makeTransitions","emptyTape","firstTape","emptyTapes","conf","getCurr","curr","triggered","stops","fix","updateTape","map3","zs","nextConfig","ps2","isLB","validateLB","lbMarkers","inEntryAlph","validSymbolM","withoutMarker","validSymbolMs","leftM","lM","safeT","isLeftSafe","rightM","rM","isRightSafe","checkLB","acceptLB","acceptFullLB","trns1","trns3","trns5","validEntryAlph","emptyInAlph","emptyIsEmpty","validLengths","validMarkers","validCriteria","downgradeModelToFiniteAutomato","alphaB","transitionsTm2Fa","tapeAlf","entryAlf","convertToStopCriteria","hasState","hasTransition","trs","isFinal","isInitial","addState","addInitialState","addFinalState","removeState","changeStateToInitial","changeStateFromFinal","newAcceptSts","changeStateToFinal","renameState","newStates","newTransitions","newAcceptStates","addTransition","removeTransition","self_22","comp_zero","parseInter","parseParentheses","parseId","comp","makeCompositionRef","test00","genName","fa1","fa2","newStart","newTran1","newTran2","newAlf","ist","asts","newTrns","allNewTrns","newAcc","newTrn","re2fa","plusSet","reSet","pls","calczerok","getRij","prvK","assembleRe","rik","rkk","rkj","calck","rij","rikjs","rikj","rkij","fa2re","allRks","ascii","convertPlsRules","newInit","newRule1","newRule2","convertSeqRules","lcfg","rcfg","rl1","rl2","alp1","newBody","newRule","convertStrRules","r0","cl","cre","var2","re2cfg","fa2cfg","toState","toStates","ssy","accSt","ruleToTrans","rh","vrs","cfg2fa","cfg2re","upgradeTransition","upgradeTransitions","fa2pda","re2pda","pda2re","computeState","makeNewTransition","symbToConsume","topStackSymbol","make_new_transition_for_rule","transitionsRules","transitionsFinalSymb","cfg2pda","checkEmptyStackOnAccept","top_stack","n_state","check_pda_transitions","stack_to_push","newEpsilonRules","epsilonRules","newRulesCombinatory","q_states","acc_q","acc_r","matchingTransitions","stateP","stateQ","stateR","stateS","filtered_transitions","filtered_transitions2","limited","newRules3","acc_s","pda2cfg","last_state","fresh_state","get_current_state","pda2tm_2tapes","new_initial_state","initial_stack_check","transiton_on_push","stack_dir","input_dir","symbol_to_push","stack_top","convert_transition","reversed_alpha","build_transitions","current_state","new_top","is_last","transitions_on_push","make_initial_state","converted","accept_state","accept_transitions","all_transitions","init_state","accept_states","pda2tm","stack_limiter","head_pointer","stack_end","pda_alpha","alphabet_movement","state_collector","go_to_stack","return_from_stack","to_stack","new_state2","put_delimiter","new_state3","put_initial","new_state4","put_stack_end","new_state5","put_initial_2","make_initial_transitions","extract_original_symbol","modified_symbol","bar_pos","original_str","input_empty_alphabet","read_input","special_symb","read_stack_end","new_end","return_stack","specials","move_head","special","empty_top","reversed","new_stack_top","write_state","current_states","transSet","all_states","fa2tm","re2tm","cfg2tm","cfg2tm_2tapes","cfg2gr","re2gr","fa2gr","gr2cfg","gr2pda","gr","tm2gr","ini_symb","t_symb","aSet","bSet","newAB_Vars","acc_inner","newAIB_Vars","acc_innermost","v_empty_empty","firstRules","secondRules","new_var_2","new_rule","new_rule_2","transition_rules","tape_symb","next_state","curr_state","v_pq","v_aic","v_pjq","v_ad","accept_state_rules","handle_terminals_rules","new_rule2","empty_epsilon_rule","second","third","json2model","text2model","gr2model","fa2model","re2model","pda2model","cfg2model","tm2model","model2gr","model2fa","model2re","model2cfg","model2pda","model2tm","model2comp","testPDA2TM","pda2","tm2","delete$","updateModel","getExample","getText","fao","reo","cfgo","pdao","tmo","getJSon","gro","decompositions","lp","p0","concatAllS","rigth","conc","lw","addSufixFA","sufix","angular","addSufixCFG","renameStatesFA","addSufixList","addSufixListCFG","renameVariablesCFG","renameVariablesGR","addSufixIfVariable","renameStatesPDA","q2","q1","renameStatesTM","symb2","symb1","evalPlusFA","fb","qI","ta","tb","createTransitionFA","firstState","secondState","evalSeqFA","makeName2","findTransitions","transA","transB","ab","at","abt","y2","y1","createEmptyTransition","emptyAB","emptyA","emptyB","findTransitions2","emptyt","evalIntersectFA","newAlphabet","newAccept","evalStarFA","ft","calcEvalFA","evalPlusRE","ra","evalSeqRE","evalIntersectRE","faComp","evalStarRE","rt","calcEvalRE","evalPlusCFG","ca","evalSeqCFG","evalStarCFG","ct","calcEvalCFG","evalPlusGR","evalSeqGR","evalStarGR","calcEvalGR","evalPlusPDA","pa","pb","sI","createTransitionPDA","stackSymbol","symbolstackAlphabet","evalSeqPDA","evalStarPDA","pt","calcEvalPDA","evalPlusTM","createTransitionTM","tapeAlphabetTA","evalSeqTM","evalStarTM","tt","direction2direction3","createsTransitionsInter","sb","evalIntersectTM","newEntryAlphabet","acceptS","calcEvalTM","comp2facomp","tmobj","comp2recomp","comp2CFGcomp","comp2GRcomp","comp2PDAcomp","comp2TMcomp","evalMixFA","evalMixRE","evalMixCFG","evalMixPDA","evalMixTM","evalMixGR","fx","nextSymb","isTM2FA","isFAConvertivel","cfgobj","pdaobj","isREConvertivel","isCFGConvertivel","isPDAConvertivel","isTMConvertivel","isGRConvertivel","transformt","evalFA","evalRE","evalCFG","evalGR","evalPDA","evalTM","self_23","oCamlFlatDir","exercicesDir","exerciceName","setOCamlFlatDir","dirname","setExercicesDir","setExerciceName","initialize","libFile","targetDir","targetFile","createTargetDir","createTargetFile","co","getExerciceDirContents","generateFile_Descr","generateFile_Meta","generateFile_Prelude","generateFile_Prepare","cmd","generateFile_Solution","useJSon","contentsJSon","generateFile_Template","exercisePart","handleAnswerPartJSon","handleAnswerPart","exerciseText","handleAnswerText","generateFile_Test","generateFile_Index","generateExerciseDir","oon2","testMore","test3","applied_rules","firstPairConversion","followPairConversion","lookaheadPairConversion","failPrint","okPrint","printResult","compareTheseSets","testFirst","allResults","testFollow","testLookahead","testFunction1","testExample1","lookahead2","testExample2","testExample3","testExample4","testExample5","testExample6","testDissertation","testNFGrammar","testAccessible1","transformed","testAccessible2","testProductive1","testProductive2","fullyTransformed","cleanGrammar1","testDirectRecursion1","testDirectRecursion2","testIndirectRecursion1","testIndirectRecursion2","testIndirectRecursion3","testIndirectRecursion4","testIndirectRecursion5","testLeftFactoring1","transformedM","testLeftFactoring2","testLeftFactoring3","testLeftFactoring4","testLeftFactoring5","testLeftFactoring6","testUnitRemoval1","testUnitRemoval2","testUnitRemoval3","testUnitRemoval4","testUnitRemoval5","testEmptyRemoval1","testEmptyRemoval2","testEmptyRemoval3","grammar5","tt3LR0","testReachable","testProductive","testGetUsefulStates","testGetUselessStates","testTransformToAcceptCriteria","testTransformToEmptyStackCrite","testNotDeterministic","deterministic","testDeterministic","testIsFa","isFa","testIsNotFa","testAccept","testAccept2","testAccept3","testGenerate","testSearchTree","checkWords","prepare","target","default_language","set_language","language","i18n","sl","i18nX","i18nTitle","i18nVersion","i18nNewModel","i18nEditModel","i18nFitGraph","i18nToggleView","i18nGeneralRepresentation","i18nGenerate","i18nTesting","i18nStep","i18nStart","i18nClearAuto","i18nConvertToAcceptFinalState","i18nConvertToAcceptEmptyStack","i18nSelectConv","i18nSelectRegex","i18nselectFA","i18nselectPDA","i18nselectCFG","i18nselectGR","i18nselectTM","i18nselectTM2Tapes","i18nImportModel","i18nExportModel","i18nServer","i18nAbout","i18nFeedback","i18nMainTitle1","i18nMainTitle2","i18nMainTitle3","i18nMainTitle4","i18nMainTitle5","i18nMainTitleTM","i18nMainTitlePDA","i18nMainTitleComp","i18nDeveloped","i18nNovaLincs","i18nProject","i18nFactor","i18nAnd","i18nFinancing","i18nFooter","i18nFooter1","i18nInstructionsCFG","i18nInstructionsGR","i18nFormatting","i18nClean","i18nKuroda","i18nPenttonen","i18monoCSG","i18nDeterministic","i18nMinimize","i18nProductive","i18nAccessible","i18nUseful","i18nTogleAcceptCriteriaState","i18nTogleAcceptCriteriaEmptySt","i18nInitialStackSymbol","i18nIsDeterministic","i18nNotDeterministic","i18nIsMinimal","i18nNotMinimal","i18nNotUseless","i18nisEquivalentFA","i18nisNotEquivalentFA","i18nHas","i18nUselessStates","i18nNumberStates","i18nNumberTransitions","i18nIsLinearBounded","i18nIsNotLinearBounded","i18nNoPathAvailablePDA","i18nAlreadyInAcceptanceModeByS","i18nAlreadyInAcceptanceModeByE","i18nDirection","i18nCFGFirst","i18nCFGFollow","i18nRemoveLeftRecursion","i18nRemoveUnproductive","i18nRemoveInaccessible","i18nLeftFactoring","i18nRemoveEpsilonProductions","i18nRemoveUnitProductions","i18nTransformToLL1","i18nFirstAndFollow","i18nParsingTable","i18nSetTables","i18nRDParser","i18nToggle","i18nRDParserCopyButtonDefault","i18nRDParserCopyButtonClick","i18nIsLL1","i18nIsNotLL1","i18nIsLeftRecursive","i18nIsNotLeftRecursive","i18nIsLeftFactoring","i18nIsNotLeftFactoring","i18nHasParsingTableConflict","i18nHasNotParsingTableConflict","i18nIsCFGClean","i18nIsCFG","i18nIsCSG","i18nIsMO","i18nIsUG","i18nIsLG","i18nIsRLG","i18nIsLLG","i18nIsNotCFGClean","i18nNotProd","i18nNotAccess","i18nNewGrammar","i18nAcceptInput","i18nAcceptRecognized","i18nAcceptStack","i18nAcceptProduction","i18nVerify","i18nNonAccepted","i18nAcceptedWords","i18nProblem","i18nEnumTitle","i18nRight","i18nWrong","i18nGenerateWords","i18nWordAccepted","i18nWordNotAccepted","i18nExists","i18nGoodDerivations","i18nBadDerivations","i18nBy","i18nNext","i18nPrevious","i18nAlertMinimum","i18nAlertNeedsDeterministic","i18nAlertDelete","i18nAlertUnexistentState","i18nAlertTheTransition","i18nAlertDoNotExists","i18nAlertAlreadyFinal","i18nAlertAlreadyInitial","i18nAlertNonFinal","i18nAlertDeterministic","i18nAlertClean","i18nAlertExists","i18nLeaveSimulationToEdit","i18nAlertNoMoreStates","i18nAlertEndTMSim","i18nAlertArrivedInitial","i18nAlertNotLeftRecursive","i18nAlertIsLL1","i18nAlertNotLeftFactoring","i18nAlertIsClean","i18nAlertIsNotMonotonic","i18nAlertNoEmptyProductions","i18nAlertNoUnitProductions","i18nAlertCFGAcceptNoInput","i18nAlertCFGAcceptNoStack","i18nAlertCFGAcceptNoProduction","i18nAlertRETooBig","i18nAlertDirectionWrong","i18nAlertExceededCharacters","i18nAlertTransitionExists","i18nFeedbackText","i18nFeedbackText2","i18nFeedbackThankYou","i18nAboutTitle","i18nAboutSubtitle","i18nAboutSubtitle2","i18nAboutText1","i18nAboutText2","i18nAboutText16","i18nAboutText17","i18nAboutText3","i18nAboutText4","i18nAboutText5","i18nAboutText6","i18nAboutText7","i18nAboutText8","i18nAboutText9","i18nAboutText10","i18nAboutText11","i18nAboutText12","i18nAboutText13","i18nAboutText14","i18nAboutText15","i18nTooltipSave","i18nTooltipNewModel","i18nTooltipEditModel","i18nTooltipFitGraph","i18nTooltipGenerate","i18nTooltipTest","i18nTooltipStep","i18nTooltipClear","i18nTooltipConvert","i18nTooltipFile","i18nTooltipExportModel","i18nTooltipAbout","i18nTooltipFeedback","i18nTooltipCloseLeft","i18nTooltipCloseRight","i18nTooltipDirection","i18nTooltipClean","i18nTooltipDeterministic","i18nTooltipMinimize","i18nTooltipProductive","i18nTooltipAccessible","i18nTooltipUseful","i18nTooltipSpecification","i18nProperties","i18nPromptTextTestWord","i18nWhichTransition","i18nRenameStateQuestion","i18nTextMaximumSize","i18nTextRemove","i18nTextAdd","i18nTextAddInitial","i18nTextAddFinal","i18nTextRenameState","i18nTextAddTransition","i18nTextTurnFinal","i18nTextRemoveFinal","i18nTextTurnInitial","i18nTextEnterState","i18nTextEnterTransition","i18nTextEnterTransitionTM","i18nTextEnterTransitionPda","i18nChangeInitialStackSymbolPd","i18nTooltipCFGClean","i18nTooltipGRKuroda","i18nTooltipGRPenttonen","i18nTooltipnonContractingToCSG","i18nTooltipRemoveLeftRecursion","i18nTooltipLeftFactoring","i18nTooltipRemoveEpsilonProduc","i18nTooltipRemoveUnitProductio","i18nTooltipTransformLL1","i18nTooltipSetTables","i18nTooltipRDParser","i18nTooltipToggleMode","i18nSave","i18nSaveText","i18nConfirm","i18nErrorParsing","i18nModelEditFA","i18nErrorConversion","eval$","log","alert","alertStr","prompt","confirm","parent","parentElement","insertRow","insertCell","row","newCell","modifyCell","tableFilled","tableExists","currTab","toTable","fetchTable","fetchRow","fetchCell","cToCell","tToTable","setWidth","modifyRowId","addEventListener","t39","appendChildtoCell","child","appendChildtoRow","t43","t44","lowLevelApply","process","lowTab","changeDisplay","disp","t49","t48","t47","buildTable","fillTable","nRow","fillRow","cells","nIter","newRow","t52","t51","t50","makeFACell","trans1","sy1","targets","makePDACell","makeFAStateRow","makePDAStateRow","ia","makeFAPath","makePDAPath","makeGRPath","makeREPath","makeTMPath","tapes","right","currChar","tmSpan","paint","rowIndex","cellIndex","t55","t54","t53","extractStringFromTextArea","replace_str","toReplace","changeLang","bcSend","name2","save","saveModel","closeLeftListener","closeRightListener","openEntityListener","defineInformationBoxListener","showModelListener","createModelListener","updateRightListener","editModelListener","runOp","removeNode","turnFinal","addNode","removeTypeFinal","turnNodeInitial","addInitialNode","addFinalNode","src","trg","srcId","trgId","renameNodeListener","paintAllProductivesListener","paintAllReachableListener","paintAllUsefulListener","clearAutoListener","showTable","getDeterministicListener","defineMinimizedListener","cleanUselessListener","toggleAcceptanceCriteria","changeInitialStackSymbol","convertAcceptStates","convertEmptyStackAccept","resultCountListener","previousTreeListener","nextTreeListener","defineNumberTreesListener","changeDirectionListener","cleanCFGListener","removeLeftRecursionListener","leftFactoringListener","tablesListener","recursiveDescedentParserListen","simpleToggleListener","removeEpsilonListener","removeUnitListener","previousNewCFGListener","nextNewCFGListener","transformLL1Listener","undefinedListener","buildLR0DiagramListener","buildSLR1DiagramListener","buildLR1DiagramListener","buildLALR1DiagramListener","buildLR0TableListener","buildSLR1TableListener","buildLR1TableListener","buildLALR1TableListener","acceptLR0Listener","acceptSLR1Listener","acceptLR1Listener","acceptLALR1Listener","showTreeNode","checkExerciseListener","cytoscape_cs","node_style","self_24","selector","style","self_25","default_style","default_layout","rankDir","self_26","position","self_27","nodeType","classes","edge","source","mk_graph","container_id","layout","container","display","add_node","cy","addCompoundNode","t46","t45","t56","addChildNode","parentId","childId","childLabel","t58","t57","t60","t59","t62","t61","t64","t63","t66","t65","t68","t67","t69","t70","add_edge","t71","t72","run_layout","t76","on","event","t81","t82","t83","t84","t77","t78","t79","t80","elementId","t85","t86","getAllNodes","t93","t94","data_fromName","t95","t96","faLayout","t100","t101","self_29","reLayout","t102","t103","self_30","cfglayout","t104","t105","self_31","grlayout","t106","t107","self_32","treeGrlayout","self_33","edgehandlesOptions","t113","t114","t115","t116","t117","sourceNode","targetNode","canConnect","edgeParams","hoverDelay","snap","snapThreshold","snapFrequency","noEdgeEventsInDraw","disableBrowserGestures","self_35","menu","eh","menu1","t118","t119","self_36","menu2","t120","t121","self_37","menu3","t122","t123","self_38","menu4","t124","t125","self_39","menu5","t126","t127","self_40","menu6","t130","t131","t128","t129","self_41","t132","t133","commands","self_42","t138","t139","evt","t137","t136","t135","t134","self_43","t144","t145","t143","t142","t141","t140","self_44","t150","t151","t149","t148","t147","t146","self_45","t152","t153","self_46","t156","t157","t154","t155","self_47","t158","t159","self_48","svg","insertNodeImage","itemString","itemListSize","maxSymbolCount","t179","t180","t181","t182","t183","t184","t185","t186","t187","opacity","backgroundColor","backgroundImage","backgroundClip","borderWidth","borderColor","shape","self_52","t190","t188","t189","t177","t178","t176","tspan","stringItems","increment","maxLR0SymbolCount","itemList","buildStyleImage","textSpan","buildLR0NodeStyle","stringItemList","styleImage","encodeStyle","node_name_style","t197","t198","t191","t192","t193","t194","t195","t196","textHalign","textValign","textMarginY","self_53","self_54","edge_symbol_style","t200","t201","t199","self_55","self_56","edge_style","t204","t205","t202","t203","curveStyle","targetArrowShape","self_57","self_58","node_transparent_style","t207","t208","t206","visibility","self_59","self_60","node_style_success","t213","t214","t209","t210","t211","t212","borderStyle","self_61","self_62","eh_handle_style","t222","t223","t215","t216","t217","t218","t219","t220","t221","overlayOpacity","borderOpacity","self_63","self_64","eh_hover_style","t225","t226","t224","self_65","self_66","eh_source_style","t229","t230","t227","t228","self_67","self_68","eh_target_style","t233","t234","t231","t232","self_69","self_70","eh_preview_style","t239","t240","t235","t236","t237","t238","lineColor","targetArrowColor","sourceArrowColor","self_71","self_72","eh_ghost_edge_style","t245","t246","t241","t242","t243","t244","self_73","self_74","eh_ghost_edge_preview_style","t248","t249","t247","self_75","self_76","faStyle","t255","t256","t250","t251","t252","t253","t254","self_77","self_78","t258","t259","t257","self_79","self_80","t262","t263","t260","t261","self_81","self_82","t265","t266","t264","self_83","self_84","t270","t271","t267","t268","t269","self_85","self_86","t277","t278","t272","t273","t274","t275","t276","self_87","self_88","t280","t281","t279","self_89","self_90","t287","t288","t282","t283","t284","t285","t286","self_91","self_92","node_fail_style","t290","t291","t289","self_93","self_94","reStyle","t297","t298","t292","t293","t294","t295","t296","fontFamily","self_95","self_96","node_selected_style","t300","t301","t299","self_97","self_98","node_child_selected_style","t303","t304","t302","self_99","self_100","node_child_epsilon_syle","t306","t307","t305","self_101","self_102","node_style_root","t309","t310","t308","self_103","self_104","node_style_leaf","t312","t313","t311","self_105","self_106","cfgStyle","t319","t320","t314","t315","t316","t317","t318","self_107","self_108","t322","t323","t321","self_109","self_110","t325","t326","t324","self_111","self_112","t328","t329","t327","self_113","self_114","t331","t332","t330","self_115","self_116","t334","t335","t333","self_117","self_118","node_style_compound","t339","t340","t336","t337","t338","self_119","self_120","child_node_style","t342","t343","t341","self_121","self_122","grStyle","resetStyle","styles","t356","t355","t361","t358","t362","t363","t359","t360","t357","t365","t364","removeAllElements","t366","t367","resetFaElems","paintNode","t371","self_123","t374","t372","t373","t369","t370","t368","initCy","initFaCy","cyContainer","t375","t376","addedEles","ele","getElement","t377","t378","t379","t380","t381","t382","t383","t384","t385","t386","startTree","t387","t388","initLL1Cy","t389","t390","initGRCy","t391","t392","initGRCy3","t393","t394","generateEdgeID","addEdge","edgeLabel","nId","getEdge","t395","t397","t396","t398","t399","newSymbol","addEdgeGeneral","t400","t402","t401","t403","t404","isStart","verify","t405","t406","t407","addNode2","t408","t409","t410","nn","t411","t412","removeFinal","t413","t414","removeEdge","t415","t416","labelEdge","t418","t417","labelEscSpecialChars","newLabel","t419","t420","t423","t424","centerGraph","t425","t426","makeTreeNode","t427","t428","makeTreeNode2","t429","t430","t434","t435","t436","t437","t431","t433","t432","makeTreeEdge","idNode1","idNode2","t438","t439","changeDirection","cy2","layoutDir","t442","t443","t440","t441","self_124","t446","t447","t444","t445","self_125","intersection","stringAsList","iterateList","meth","paintProductive","paintReachable","paintUseful","self_126","list1","intre","wordToConsume","bar","paintMinimization","paintMinimized","getMinStates","delay","nextEpsilon2","nextEpsilons","currsts","nst","optionsPopper","placement","self_127","buildPopper","nConfigs","countConfigsDiv","popper","self_128","getConfigCountForNode","buildConfigsCount","updateAllPoppers","poppers","destroyAllPoppers","getConfigsWithState","buildInfoString","buildConfigMenu","menuID","infoDisplay","disabled","onClickFunction","self_129","buildIdFromState","suffix","processNodeConfig","configsOfState","processConfigMenus","menuConfigFA","evtType","menuItems","self_130","buildIdsStateAndApplyF","idSuffix","hideMenu","showMenu","hideMenus","showMenus","hideAllConfigMenus","getStatesFromConfigs","self_131","number","listStates","newState","mapToCytoscapeEdge","accept2X","nextTrans","firstNode","isFinish","listEquivalence","deter","uss","time","configVisited","exact","makeFATable","makePath","lastRowIndex","currBestState","bestPathAutomaton","cyDiv","for$","selectedNode","nGetName","self_132","fl","fr","sr","rootName","regex","text1","reFind","rightTrees","paintCells","cyType","changeEmpty","returnEmpty","returnEnum","changeCy1ToText","getCy1Type","getAutomatonType","getRegexType","getEnumerationType","getInfoType","getFeedbackType","getVerifyType","getCy2Type","firstFollowTableId","parsingTableId","parsingGuideTableId","productionsTableId","productionsTableId2","setToHtmlString","insideBracesString","cs","setString","firstSet","followSet","createGrammarTableHtml","fillRule","span","orSpan","escapedHeadStr","nonInitialRules","createParsingTableGuideHtml","tableHeader","createFirstAndFollowTableHtml","firstF","followF","createParsingTableHtml","cPTF","prods2span","varSpan","arrowSpan","ruleSpan","ruleStr","fillTable2","pTable","assocVar","dollarCell","dollarAssoc","varString","paintGrammarTable","rowElements","prodString","currentProds","paintWord","toAccept","paintParsingTableHtmlGuide","currPos","splitWord","splitRule","splitRecognize","rowsWithClass","t73","t74","t75","spans","currentRow","t87","t88","recogCell","t90","t91","t89","inputCell","t92","stackCell","t97","prodCell","t99","t98","s4","s3","s1Span","s2Span","s3Span","s4Span","s5Span","s6Span","s6","s5","t161","t160","t163","t164","t162","t166","t167","t165","t169","t170","t168","t172","t173","t171","t175","t174","paintParsingTableHtml","paintSpans","paintSpan","spanNode","spanClass","varStr","spanNodeList","rowProcess","rows","newNode","addNodeToTree","toAdd","addNodeToTree2","treeList","stepsList","treeRoot","buildTree2","addNodesToParent","addNodesAux","nClass","addNodes","paintNodes","baseElems","acceptListNoRepeats","acceptList","recognized","acceptTable","syntaxTable","sliceTree","sliceList","insertStep","evtMethod","checkAcceptError","alertError","self_134","listWithIds","guide","insert","toView","newModel","newGrammars","writeLR0StateItems","lr0state","writeLR1StateItems","lr1state","inputLR0NodesV2","lr0Diagram","inputLR0Edges","id2","id1","inputLR1NodesV2","lr1Diagram","inputLR1Edges","actionToString","slr1actionToString","lr1actionToString","concActionsLR0","fillLR0RowExt","symbSet","stateName","newCell1","actionList","newCell3","newCell4","createLR0ParsingTableHtmlExt","numberOfCells","concActions","concActionsLR1","fillSLR1Row","symbActions","newCell2","createSLR1ParsingTableHtml","fillLR1Row","createLR1ParsingTableHtml","createLALR1ParsingTableHtml","stringFromBool","stringListToString","parserPredictLR0Action","parserPredictSLR1Action","parserPredictLR1Action","buildLR0Steps","word2","firstStep","stepList","valid2","createLR0AcceptTableHtml","symbolRevStack","buildLR0StepsV2","createLR0AcceptTableHtmlV2","actionString","numberOfSymbols","buildSLR1StepsV2","createSLR1AcceptTableHtmlV2","buildLR1StepsV2","createLR1AcceptTableHtmlV2","buildLALR1StepsV2","createLALR1AcceptTableHtmlV2","self_135","slr1Diagram","self_136","button","cy3","treeDiv","tableStyle","cy3_cy","fitToBoxButton","node_counter","generate_node_id","add_cy_node","node_label","node_id","add_cy_edge","parent_id","child_id","edge_id","epsilon_str","root_sf","root_label_str","root_id","frontier","num_rules","nodes_to_expand_this_step","current_frontier_copy","rest_rules","current_rule","expansion_results","new_children_for_this_parent","symbol_str","is_epsilon","child_label","is_non_terminal","next_frontier","new_children_list","treeLayout","self_137","bestPathCFG","transitionPda2CytoscapeEdge","symbInput","topStackString","isStateNameValid","isInputValid","processToPutInStackInput","toPutInStackString","processedString","parseUserInput","trimmedStr","splittedInput","genNX","genN","makeIndex","filteriX","filteri","buildStackDisplayString","wasRestricted","restrictedStack","stringStack","stackDisplay","self_138","menuConfigPDA","self_139","self_140","self_141","finalStates","buildStackForTable","stackStr","buildTableConfigDisplay","tHead","trHead","thNode","thStack","tBody","trBody","tdNode","tdStack","buildPopperConfigDisplay","self_142","renderedPosition","self_143","updateconfigDisplay","nodeDisplay","stackString","self_144","addEdgesCytoscape","uselessStates","putInStack","fromState","stackAlphabetTrns","oldState","renameStates","renameTransition","renameTransitions","configDisplayElem","makeStateContents","stckAlp","inpAlp","stateRows","stateStackRow","makePDATable","inputAlphabet","sentence","newSentence","direction2string","direction","getCurrConfigFromBestPath","makeLabel","rsymbs","wsymbs","directions","r_str","w_str","d_str","transformTransitions","nstate","rstate","inputEdges","inputNodes","drawExample","numberStates","numberTransitions","productivePainting","reachablePainting","initSt","usefulPainting","changeTheTestingSentence","changeSentence","revLeft","notEmptyRight","best","finished","isOver","isFinalState","paintStates","acceptSts","paintBestCurrentStep","paintCurrentStates","filterTransitionInput","rdSymb","wrtSymb","filterTransitionInputWithInv","dissectTransitionInput","tape","self_145","buildTape","rightSide","self_146","self_147","self_148","getInitConfig","self_149","currConfig","rsymb","wsymb","self_150","headStr","split_around_rule_head","start_index","head_len","symbols_len","find_subsequence","sub_t","split_at","try_positions","after_head_temp","before_match","after_match","self_151","cleanedGrammar","kurodaGrammar","penttonenGrammar","csgGrammar","edges","fill_epsilon","current_level","nodeId","addNodeAux","level","path_len","addCompoundNodeForRule","labelParent","self_152","sym_idx","self_153","levels","index_in_path","path_elem","len_before","index_next_after_rule","len_head","lengths","max_index_in_path","getEdges","edges_to_delete","w_to","i_to","l_to","t_from","w_from","getEdgesToDelete","filtered_edges","t_to","i_from","l_from","to_id","bestPathGR","button_type","idtxt","button1","classtxt","div","div1","div2","div3","cols","br","ref1","pre","code","table2","elementsList","option","putInnerHtml","putInnerHtmlButtons","idtool","classTool","txt1","tool","defineMainTitle","type1","title","disableButton","buttonName","buttonTo","enableButton","disableButtons","createSpanList","acceptance","string_of_word","space","createPropertiesList","createBox1","box1","buttonBox","regExp","infoBox","createBox2","box2","buttonBox1","textBox","infoBox2","clearBox1","clearBox2","closeButton","putLRButtons","lr0","slr1","lr1","lalr1","lr0table","slr1table","lr1table","lalr1table","acceptLR0","acceptSLR1","acceptLR1","acceptLALR1","putCyButtons","divButtons2","di","tool1","putCy2Buttons","oneBox","twoBoxes","fitBoxRegex","closeBoxRegex","cfgBoxRegex","grBoxRegex","cfgCyClose","cfgCyOpen","cfgCy2Close","grCyClose","grCyOpen","grCy2Close","toggleTab","flag","automataTable","editModelContent","titleTxt","otherTxt","textAreaContent","okAction","other","buttonOk","setModal","modalC","break$","hideModalWindow","modal","showModalWindow","showModelInfo","putCyAutomataButtons","divButtons1","divButtons","divButtons3","clearAuto","tableView","putCyAutomataPDAButtons","divPdaButtonBox","divMenuSpecificationPda","initialStackSymbolInputBox","divButtonsCommands","putCyREButtons","row1","putCyCFGButtons","rLRec","lf","removeEpsilon","removeUnit","transformLL1","rdParser","simpleToggle","putCyGRButtons","defineCFG","cfgString","acceptDiv","acceptWordDiv","acceptTableDiv","defineGR","grString","putCyTMButtons","addBr","addTo","getTransformLang","transformType","printCFG2Grammar","tableId","newGrammarElem","prevButton","transformLabel","grammarDiv","printGR2Grammar","printGR2GrammarComp","grammarTable","printCFG2GrammarComp","prepareAcceptTable","title1","prepareCFG2Tables","firstFollowTable","title2","printCFG2RecursiveDescedentPar","codeString","rdParserCode","prepareCFG2RecursiveDescedentP","optsList","changeFun","copyClipboardBtn","clipboard","rdParserPre","getIsLL1","ll1","getIsLR0","bool","getIsSLR1","getIsLR1","getIsLALR1","getIsLeftRecursive","getIsLeftFactoring","getHasParsingTableConflict","pConf","getIsCFGClean","access","getIsCFG","getIsCSG","getIsMO","getIsUG","getIsLG","getIsRLG","getIsLLG","getIsGRClean","putTreeResult","en","getDeterminim","getMinimism","minimal","getHasUselessStates","use","uStates","useful","useless","getIsEquivalentFA","isEquivalentFA","isFA","getNumberStates","nStates","sentence1","getNumberTransitions","nTransitions","getIsLinearBounded","is","lb","defineInformationBox","elementStr","createServerExampleButton","putButton2","defineRE","putWords","listWords","string_of_words","zz","addEnumTitle","defineEnumProblem","prob","resultBox","addAcceptedTitle","tac","addNonAcceptTitle","twr","wr","addPropertiesBox","addEnumCheckButton","checkButton","defineResult","defineTreeButtons","previous","putTreeGoodDerivations","putTreeBadDerivations","en1","putTreeNumbers","treeNumbers","about","aboutBox","subtitle","aboutTex","text2","text3","text5","text6","text7","text8","aboutTex1","text9","text10","text11","text12","text13","text14","text15","text16","text17","text18","text19","text20","text21","text22","feedback","spanBox","spanBox1","span1","link","span2","putGenText","statsDiv","visitedConfigs","textConfigs","textExact","textTime","putAcceptText","textAccepted","displayGenStats","prevStatsBox","displayAcceptStats","changeButtonColor","but","prob1","settings","settingsDiv","spanL","selectLanguage","langString","selectEmpty","index2","changeToControllerCtrlRight","changeToControllerCtrlLeft","controller","self_154","listColors","newLayout","opName","modelKind","prom","operation","textController","self_155","cyString","cyElement","textCtrl","ctrlL","ctrlR","changeCtrlL","nc","changeCtrlR","automatonController","self_156","tic","faController","self_157","promptResult","stateExists","c3","eliminateNodeTransitions","newName","reg","reController","self_158","newRe","makeTree2","rootL","rootR","root","wrong","auto","maton","grammar2Str","initialRules","initialRulesStrLst","nonInitialRulesStrLst","rulesList","cfgBasicController","self_159","cfgLL1Controller","self_160","gr_representation","cfgLRController","self_161","cfgController","pdaController","self_163","toggleButton","initStackSymbolString","initStackSymbol","convertedPDA","removeNodeTransitions","toNode","fromNode","tmController","self_164","charIsDirection","dirC","char2direction","wrtSymbol","rdSymbol","newTrs","exerController","self_165","properties","outsideErrors","insideErrors","exer","grController","self_166","mo","ug","llg","lrg","newGr","compController","self_167","newComp","createModelPrep","textAreaString","modelContent","createModelPrepComp","cfgStr2Model","splitStr","initialRule","otherRules","initialParsedRule","parsedRules","grStr2Model","extractInitVars","initiVars","headVariables","bodyVariables","headTerminals","bodyTerminals","listColorsBig","setTitle","createController","createFAController","createPDAController","createREController","createCFGController","createCFGController2","createGRController","createGRController2","createTMController","createCompController","createExerController","closeLeftAction","conversionTo","enu","getRandom","setColor","newColor","automaton","getInfo","blah","blah2","textt","textt1","leng","back","newDir","newCfg","newCFG","grModel","otherE","createModel","modelType","customString","getDefault","defaultFA","defaultPDA","defaultTM","reStr","compStr","cfgModel","createModelPrepSave","showPdaCtrlR","pdaConverted","examplesDiv","createDivForTitle","titleDiv","createDivForButtons","buttonsDiv","handleKind","examplesView","modelName","editModel","getModel","fitGraph","generateWords","stepbystep","backwards","forward","selectConversions","readFromFile","exportToFile","tooltipSettings","tooltipNewModel","tooltipEditModel","tooltipFitGraph","tooltipGenerate","tooltipTest","tooltipTrace","tooltipStep","tooltipClear","tooltipConvert","tooltipFile","tooltipExportModel","tooltipAbout","tooltipFeedback","self_168"],"mappings":"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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAe;AAAAA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAC,iBAAA;AAAA,IAAAC,mBAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC,kBAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC,OAAA;AAAA,IAAAA,SAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAD,SAAA;AAAA,IAAAE,eAAA;AAAA,IAAAC,cAAA;AAAA,IAAAH,SAAA;AAAA,IAAAE,eAAA;AAAA,IAAAC,cAAA;AAAA,IAAAF,YAAA;AAAA,IAAAD,SAAA;AAAA,IAAAE,eAAA;AAAA,IAAAC,cAAA;AAAA,IAAAH,SAAA;AAAA,IAAAE,eAAA;AAAA,IAAAC,cAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAd;AAAAA,MAAA;AAAA,IAAAC,oBAAA;AAAA,IAAAc;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAA3D;AAAAA,MAAA;AAAA,IAAA4D;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAf,SAAA;AAAA,IAAAE,eAAA;AAAA,IAAAC,cAAA;AAAA,IAAAa,gCAAA;AAAA,IAAAC,yBAAA;AAAA,IAAAC,2BAAA;AAAA,IAAAC,2BAAA;AAAA,IAAAC,uBAAA;AAAA,IAAAC,0BAAA;AAAA,IAAArB,SAAA;AAAA,IAAAsB;AAAAA,MAAA;AAAA,IAAAtB,SAAA;AAAA,IAAAE,eAAA;AAAA,IAAAC,cAAA;AAAA,IAAAF,YAAA;AAAA,IAAAD,SAAA;AAAA,IAAAA,SAAA;AAAA,IAAA9B;AAAAA,MAAA;AAAA,IAAAD;AAAAA,MAAA;AAAA,IAAAsD,WAAA;AAAA,IAAAA,aAAA;AAAA,IAAAC,aAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAA;AAAAA,MAAA;AAAA,IAAAA;AAAAA,MAAA;AAAA,IAAAA;AAAAA,MAAA;AAAA,IAAAA;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC,WAAA;AAAA,IAAAC,aAAA;AAAA,IAAAC,WAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAzF;AAAAA,MAAA;AAAA,IAAA0F,UAAA;AAAA,IAAAC,SAAA;AAAA,IAAAC,OAAA;AAAA,IAAAC,SAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAA3I;AAAAA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAA;AAAAA,MAAA;AAAA,IAAA4I,kBAAA;AAAA,IAAAC,iBAAA;AAAA,IAAAC,cAAA;AAAA,IAAAC,YAAA;AAAA,IAAAC,cAAA;AAAA,IAAAC,kBAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA;AAAA;AAAA,IAAAlJ;AAAAA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAmJ,YAAA;AAAA,IAAAC,OAAA;AAAA,IAAAC,iBAAA;AAAA,IAAAH;AAAAA,MAAA;AAAA,IAAAT,WAAA;AAAA,IAAAzI;AAAAA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAA;AAAAA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAA;AAAAA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAsJ,YAAA;AAAA,IAAAC,aAAA;AAAA,IAAAC,iBAAA;AAAA,IAAAxJ;AAAAA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAkJ;AAAAA,MAAA;AAAA,IAAAlJ,WAAA;AAAA,IAAAkJ;AAAAA,MAAA;AAAA;AAAA;AAAA,IAAAO,aAAA;AAAA;AAAA;AAAA,IAAAzJ;AAAAA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAA0J,iBAAA;AAAA,IAAAP,cAAA;AAAA,IAAAC,SAAA;AAAA,IAAAO,gBAAA;AAAA,IAAAC,uBAAA;AAAA,IAAAC,sBAAA;AAAA,IAAAR,mBAAA;AAAA,IAAAH,YAAA;AAAA;AAAA;AAAA,IAAAlJ;AAAAA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAA4I,oBAAA;AAAA,IAAAC,mBAAA;AAAA,IAAAC,gBAAA;AAAA,IAAAC,cAAA;AAAA,IAAAC,gBAAA;AAAA,IAAAC,oBAAA;AAAA,IAAAa,iBAAA;AAAA,IAAAT,mBAAA;AAAA,IAAAD,SAAA;AAAA,IAAApJ,YAAA;AAAA,IAAAkJ;AAAAA,MAAA;AAAA,IAAAa,cAAA;AAAA,IAAAA,YAAA;AAAA;AAAA,IAAA/J,YAAA;AAAA,IAAAsJ,cAAA;AAAA,IAAAU,kBAAA;AAAA,IAAAC,YAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA,IAAAC,aAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA;AAAA;AAAA,IAAAC,4BAAA;AAAA,IAAAC,qBAAA;AAAA,IAAAC,4BAAA;AAAA,IAAAC,2BAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAC,oBAAA;AAAA,IAAAC;AAAAA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAA3K;AAAAA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAA;AAAAA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAA;AAAAA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAyI,WAAA;AAAA,IAAAzI;AAAAA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAA,YAAA;AAAA,IAAAA,YAAA;AAAA,IAAAA;AAAAA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAA,YAAA;AAAA,IAAAA,YAAA;AAAA,IAAAyI,WAAA;AAAA,IAAAzI;AAAAA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAA;AAAAA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAA4K,WAAA;AAAA,IAAAA,aAAA;AAAA,IAAAA,aAAA;AAAA,IAAAA,aAAA;AAAA,IAAAA,aAAA;AAAA,IAAAA,aAAA;AAAA,IAAAA,aAAA;AAAA,IAAAA,aAAA;AAAA,IAAAA,aAAA;AAAA,IAAAA,aAAA;AAAA,IAAAA,aAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,cAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,eAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,gBAAA;AAAA,IAAAA,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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAAAF,MAAAC;AAAAA,IEvKb,qDAAuB;AAAA;AAAA,YAAAE,kBAAA7N;AAAAA;AAAAA,KAAA,IC/JrC;AAAA;AAAA;AAAA,GACqB;AAAA;AAAA,SHqUM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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yI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA,sBAAAyyI;AAAAA,kBAAAzyI,M5GhHF;AAAA,c4GgHE;AAAA;AAAA;AAAA;AAAA;AAAA,oB5GhHF;AAAA;AAAA;AAAA;AAAA;AAAA,S4GgHE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6BA2JE;AAAA;AAAA,eAAA3kB;AAAAA,OA5JH;AAAA,wEAAyB;AAAA;AAAA,GC9FlB;AAAA,GAAY;AAAA,E7GjBpB","ignoreList":[0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]}}]}
